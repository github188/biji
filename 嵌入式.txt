//================
//==嵌入式学习顺序
//================
1、Windows的c语言程序
2、Linux系统管理
3、Linux应用程序开发
4、嵌入式处理器51
5、ARM板的配置与下载，与ARM的裸机程序的开发(包括Linux平台下，和Windows平台下)
6、ucosII系统
7、ARM应用程序的开发，Android开发
8、Linux内核开发基础,UBoot移植,Linux移植
9、ARM驱动程序的开发
10、深入学习Linux内核

//====================
//==Windows的c语言程序
//====================

//****************
//hello world形式：
//****************
#include <stdio.h>           //标准输入\输出库
main()
{
  clrscr(); //清屏
  printf(" Hello Worldppt! \n");  //"字符串"， \n换行
  system("pause");
}
1、编译F9，执行Ctrl+F9，查看结果Alt+F5
1、每个程序都从main函数的起点开始执行，这意味着每个程序都必须在某个位置包含一个main函数
2、每个程序可以由一个或多个源文件组成，每个源文件可以由多个函数组成，但是此程序只能有一个main函数
3、注意，它是大小写敏感的
4、每个语句都要以‘；’结尾，但是预处理命令除外


//***************
//C语言模块化编程
//***************
*在TurboC中，头文件是放在include文件夹中，里面包含了函数的声明。而这些函数的具体实现，则是放在文件夹Lib中，里面存放的是obj文件的集合,存放的是这些函数实现后的目标代码，这样子别人只能用，不能看里面的源码了

*基本编写方法
1、写一个头文件delay.h，用于声明这个函数文件里的文件

#ifndef __DELAY_H__
#define __DELAY_H__ 

#define uchar unsigned char
#define uint unsigned int
//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t);
//如果要延时50ms毫秒
void Delay_50ms(uint t);

#endif

2、写一个函数文件的定义以及实现delay.c
#include"delay.h"//将头文件包含进来了，用于函数声明和宏定义

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

3、写一个头文件smg.h，用于声明数码管文件
#ifndef __SMG_H__
#define __SMG_H__ 

#include"delay.h"//为了使用uchar宏
void display_table(uchar *p);
void display(uchar num0,uchar num1,uchar num2,uchar num3);

#endif

4、写一个函数文件的定义以及实现smg.c
#include<reg52.h>
#include"smg.h"
#include"delay.h"


unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选
void display_table(uchar *p)
{
  uchar i;
  for(i=0;i<4;i++)
  {
    P0=smg_du[*p];
	p++;
	P2=smg_wei[i];
	Delay_50us(20);
  }
}

void display(uchar num0,uchar num1,uchar num2,uchar num3)
{
  P0=smg_du[num0];
  P2=smg_wei[0];
  Delay_50us(20);
  P0=smg_du[num1];
  P2=smg_wei[1];
  Delay_50us(20);
  P0=smg_du[num2];
  P2=smg_wei[2];
  Delay_50us(20);
  P0=smg_du[num3];
  P2=smg_wei[3];
  Delay_50us(20);
}

5、写一个测试文件test.c，用于测试函数
注意：<  >编译器在头文件目录里查找头文件"  "编译器现在当前目录查找头文件，没有再去头文件目录查找

/*
   若不写delay.h，则要写上extern void display_table(uchar *p);等相关的声明函数
   表示这个函数在程序的其它文件中已经定义了
*/
#include"smg.h"

uchar table[]={1,2,3,4};
void main()
{
  while(1)
  {
    display_table(table);
    display(5,6,7,8);
  }
}
6、把smg.c,delay.c添加到工程中，只需要编译这个test.c函数即可

*步骤一、头文件的使用方法：
1.简单的说是.c中放定义，.h中放声明:头文件中只有函数声明，变量声明，结构体声明，不宜在头文件中定义变量。宏定义  和结构尽量放在一个头文件里，划分比较好看
2..c文件需要高内聚：一个.c文件，一般只有内部调用，与其它文件之间的交互接口要尽量少，而且简单
3.一个.c文件，它的.h文件要同名，文件名最好要体现代码功能
4.防止重复包含处理
具体实例：
1)基础的"bas****.h"，尽量做到模块化。不交叉
#ifndef __BAS****_H__  （bas****.h里面的代码）
#define __BAS****_H__  (注意，需要有一个空格)
.................
#endif  

2)基础的"bas****2.h"
#ifndef __BAS****2_H__  
#define __BAS****2_H__  
.................
#endif  

3)共用的"pub****.h"，将基础的包括在一起
#ifndef __PUB****_H__  
#define __PUB****_H__  
  include "bas****.h"
  include "bas***2.h"
  .....
#endif  


4)主程序
#include <xxxx.h>
#include "pub****.h"
#include "other****.h"

int main( 。。。)
{
   
}

5、.h 被.c引用和 .h 互相引用，重复定义的问题
A.h
int a();
 
B.h
#include "A.h"
 
C.h
#include "A.h"
 
D.h
#include "A.h"
#include "B.h"
上面的D.h文件中就会重复出现两个int a();的声明阿，这样就有点重复了，这时条件编译宏就派上了用场

完善的写法是：
A.h
#ifndef __A_H__
#define __A_H__ (注意，需要有一个空格)
int a();
#endif

这样，D.h文件就会类似于定义成这样的语句
#ifndef __A_H__（A.h里面的代码）        //如果原先没有定义A_H这个常量，注意常量的编写方式，因此不能写成A.H
#define __A_H__ (注意，需要有一个空格)  //定义这个常量A_H
int a();                            //声明这个函数
#endif

#ifndef __A_H__（B.h里面的代码）        //检测到上面已经定义了常量A_H了
#define __A_H__ (注意，需要有一个空格)  //不重复执行这些代码了
int a();
#endif

例：
上述文件myFuc.h可以改为
#ifndef __MYFUC_H__
#define __MYFUC_H__ 
extern int function(int a);
#endif

6.工程中经常要包含很多库文件，建议在一个基础头文件里将这些库文件全部包含，源文件只要包含该基础文件即可，可以保证不会漏掉。这是由于其实头文件放的顺序和编译速度也是有关系的，所以尽量不要随便乱放头文件的顺序。当项目大到一定程度的时候，头文件的组织就非常重要了。所以建议采取下面的方法：将一组相对固定的头文件放到一个.h中，即一个.h中包含多个.h，然后在需要的地方直接include那个总的.h，这样能大大加快编译速度。


7、大家都知道C语言中没有C＋＋中类的机制，可以将几个函数设为private，另外几个设为public，对外公布为类接口。但是C语言中static定义(静态局部变量)，在函数前加上static定义如
static int get(int x);//不能被外部文件访问，相当于被隐藏了

这样这个函数就只能在被c文件中的函数访问，外部文件是不能访问的。这个特性可以让我们用一个c和h文件来代表一个类或者模块。c文件中包括所有的函数定义，h文件中不书写所有的函数声明，只写想留出的接口，当然这些接口没有static属性。
test.h
int ok_get();/* 接口 */

*步骤二、代码封装
1.将.c文件中，需要模块化的代码封装成函数，或者带参或无参的宏定义；
2.将只有内部使用的函数声明在.c文件中；当需要被外部其它文件调用的函数，声明在.h文件中
3.尽量少用，或者不用全局变量。如果必须要用的全局变量，可以放在这个.c文件中。如果需要使用其它文件的全局变量，
  需要放在.h文件中，使用extern声明
4.这些.c文件，如果有需要其它文件中的函数，只需要添加这些文件的.h文件即可。最后，将这些.h文件添加到工程文件中    去

*头文件工作原理
说来编译器会做以下几个过程： 
1.预处理阶段 
2.词法与语法分析阶段 
3.编译阶段，首先编译成纯汇编语句，再将之汇编成跟CPU相关的二进制码，生成各个目标文件 
4.连接阶段，将各个目标文件中的各段代码进行绝对地址定位，生成跟特定平台相关的可执行文件，当然，最后还可以用objcopy生成纯二进制 
码，也就是去掉了文件格式信息 

编译器在编译时是以C文件为单位进行的，也就是说如果你的项目中一个C文件都没有，那么你的项目将无法编译，连接器是以目标文件为单位

，它将一个或多个目标文件进行函数与变量的重定位，生成最终的可执行文件，在PC上的程序开发，一般都有一个main函数，这是各个编译器

的约定，当然，你如果自己写连接器脚本的话，可以不用main函数作为程序入口！！！！ 

有了这些基础知识，再言归正传，为了生成一个最终的可执行文件，就需要一些目标文件，也就是需要C文件，而这些C文件中又需要一个main

函数作为可执行程序的入口，那么我们就从一个C文件入手，假定这个C文件内容如下： 
#include <stdio.h> 
#include "mytest.h" 

int main(int argc,char **argv) 
{ 
 test = 25; 
 printf("test.................%d\n",test); 
} 

头文件内容如下： 
int test; 

现在以这个例子来讲解编译器的工作： 
1.预处理阶段：编译器以C文件作为一个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个

文件，找到之后，就会将相应头文件中再去处理宏，变量，函数声明，嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义

与声明的情况发生，最后将那些文件中所有的东东全部扫描进这个当前的C文件中，形成一个中间“C文件” 
2.编译阶段，在上一步中相当于将那个头文件中的test变量扫描进了一个中间C文件，那么test变量就变成了这个文件中的一个全局变量，此时

就将所有这个中间C文件的所有变量，函数分配空间，将各个函数编译成二进制码，按照特定目标文件格式生成目标文件，在这种格式的目标文

件中进行各个全局变量，函数的符号描述，将这些二进制码按照一定的标准组织成一个目标文件 
3.连接阶段，将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件，主要的工作就是重定位各个目标文件的函数，变量

等，相当于将个目标文件中的二进制码按一定的规范合到一个文件中 

再回到C文件与头文件各写什么内容的话题上： 
理论上来说C文件与头文件里的内容，只要是C语言所支持的，无论写什么都可以的，比如你在头文件中写函数体，只要在任何一个C文件包含此

头文件就可以将这个函数编译成目标文件的一部分，你可以在C文件中进行函数声明，变量声明，结构体声明，这也不成问题！！！那为何一定要分成头文件与C文件呢？又为何一般都在头件

中进行函数，变量声明，宏声明，结构体声明呢？而在C文件中去进行变量定义，函数实现呢？？原因如下： 
1.如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件

，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发

现多个相同的函数，就会报错 
2.如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被

赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，

也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入BSS段，连接器会对BSS段的多个

同名变量仅分配一个存储空间 
3.如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C

文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成了你不可想象的了，如果把这些公共的东东放

在一个头文件中，想用它的C文件就只需要引用一个就OK了！！！这样岂不方便，要改某个声明的时候，只需要动一下头文件就行了 
4.在头文件中声明结构体，函数等，当你需要将你的代码封装成一个库lib，让别人来用你的代码，你又不想公布源码，那么人家如何利用你的库

呢？也就是如何利用你的库中的各个函数呢？？一种方法是公布源码，别人想怎么用就怎么用，另一种是提供头文件，别人从头文件中看你的

函数原型，这样人家才知道如何调用你写的函数，就如同你调用printf函数一样，里面的参数是怎样的？？你是怎么知道的？？还不是看人家

的头文件中的相关声明啊！！！当然这些东东都成了C标准，就算不看人家的头文件，你一样可以知道怎么使用 

*头文件使用经验进阶
1、对于全局变量，自然要尽可能少用。如果系统实在需要使用全局变量，就应该遵循一般的用法：在逻辑相关的源文件中定义全局变量，在头文件中进行声明，而不要将定义放到源文件中。

    下面这个办法是我为了处理某个老项目而采用的，正常情况下最好不要使用。如果你想将全局变量统一进行管理，可以用一个单独的文件存放全局变量的定义。例如MyVariable.h，其内容如下：            

#ifndef MY_VARIABLE_H
#define MY_VARIABLE_H

int     gMyInt;
short   gMyShort;   

#endif // MY_VARIABLE_H

　　但是这样的定义可能会导致严重的问题，它不允许在多个源文件中include MyVariable.h。我们只能也只需要在一个源文件中include MyVariable.h，而在其他源文件中只能采用extern int gMyInt这样的形式来声明，这可以另外定义一个和MyVariable.h对应的头文件XMyVariable.h来定义这些extern int gMyInt。可是这种方法需要将变量在声明一遍，麻烦不说，还容易产生不一致。其实可以简单地解决这个问题： 

#ifndef MY_VARIABLE_H
#define MY_VARIABLE_H
        
#ifndef MY_NO_EXTERN
#define MY_EXTERN extern
#else
#define MY_EXTERN
#endif // MY_NO_EXTERN

MY_EXTERN int      gMyInt;
MY_EXTERN short    gMyShort; 

#endif // MY_VARIABLE_H

     这下子可以在所有的源文件中include MyVariable.h了，不过需要在其中一个文件中先定义MY_NO_EXTERN，然后再include，以保证变量被定义过一次：                    

#define MY_NO_EXTERN
＃include MyVariable.h

2、函数的声明需要考虑C和C++混用的情况。我经常用C写一些底层的代码，然后用C++（多半是VC++）来做界面，并调用底层的C函数。例如： 

#ifndef MY_FUNCTION_H
#define MY_FUNCTION_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

int MyFunc(int, char *);

#ifdef __cplusplus
  }
#endif // __cplusplus 

#endif // MY_FUNCTION_H

//*************************
嵌入式C语言不可不用的关键字
//*************************
1.static关键字
这个关键字前面也有提到，它的作用是强大的。
要对static关键字深入了解，首先需要掌握标准C程序的组成。
标准C程序一直由下列部分组成：
       1）正文段――CPU执行的机器指令部分，也就是你的程序。一个程序只有一个副本；只读，这是为了防止程序由于意外事故而修改自身指令；
       2）初始化数据段（数据段）――在程序中所有赋了初值的全局变量，存放在这里。
       3）非初始化数据段（bss段）――在程序中没有初始化的全局变量；内核将此段初始化为0。
注意：只有全局变量被分配到数据段中。
       4）栈――增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。这句很关键，常常有笔试题会问到什么东西放到栈里面就足以说明。
       5）堆――动态存储分配。
 
在嵌入式C语言当中，它有三个作用：
作用一：在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
这样定义的变量称为局部静态变量：在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。也就是上面的作用一中提到的在函数体内定义的变量。除了类型符外，若不加其它关键字修饰，默认都是局部变量。比如以下代码：
void test1（void）
{
   unsigned char a；
   static unsigned char b；
   …
   a++；
   b++；
}
在这个例子中，变量a是局部变量，变量b为局部静态变量。作用一说明了局部静态变量b的特性：在函数体，一个被声明为静态的变量（也就是局部静态变量）在这一函数被调用过程中维持其值不变。这句话什么意思呢？若是连续两次调用上面的函数test1：
   void main（void）
   {
      …
      test1（）；
      test1（）；
      …
   }
然后使程序暂停下来，读取a和b的值，你会发现，a=1，b=2。怎么回事呢，每次调用test1函数，局部变量a都会重新初始化为0x00；然后执行a++；而局部静态变量在调用过程中却能维持其值不变。
通常利用这个特性可以统计一个函数被调用的次数。
声明函数的一个局部变量，并设为static类型，作为一个计数器，这样函数每次被调用的时候就可以进行计数。这是统计函数被调用次数的最好的办法，因为这个变量是和函数息息相关的，而函数可能在多个不同的地方被调用，所以从调用者的角度来统计比较困难。代码如下：

void count();
int main()
{
    int i;
    for (i = 1; i <= 3; i++)
   {
       count();
   {
    return 0;
}
void count()
{
    static num = 0;
    num++;
    printf(" I have been called %d",num,"times/n");
}
输出结果为：
I have been called 1 times.
I have been called 2 times.
I have been called 3 times.
 
看一下局部静态变量的详细特性，注意它的作用域。
 1）内存中的位置：静态存储区
   2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
   3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
  注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。
 
作用二：在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
这样定义的变量也称为全局静态变量：在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。也就是上述作用二中提到的在模块内（但在函数体外）声明的静态变量。
定义全局静态变量的好处：
<1>不会被其他文件所访问，修改，是一个本地的局部变量。
<2>其他文件中可以使用相同名字的变量，不会发生冲突。
全局变量的详细特性，注意作用域，可以和局部静态变量相比较：
1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
    2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
    3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。
当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。
 
作用三：在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
 
这样定义的函数也成为静态函数：在函数的返回类型前加上关键字static，函数就被定义成为静态函数。函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
定义静态函数的好处：
<1>其他文件中可以定义相同名字的函数，不会发生冲突
<2>静态函数不能被其他文件所用。它定义一个本地的函数。
这里我一直强调数据和函数的本地化，这对于程序的结构甚至优化都有巨大的好处，更大的作用是，本地化的数据和函数能给人传递很多有用的信息，能约束数据和函数的作用范围。在C++的对象和类中非常注重的私有和公共数据/函数其实就是本地和全局数据/函数的扩展，这也从侧面反应了本地化数据/函数的优势。
 
最后说一下存储说明符，在标准C语言中，存储说明符有以下几类：
auto、register、extern和static
对应两种存储期：自动存储期和静态存储期。
auto和register对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出该程序块时撤销。
关键字extern和static用来说明具有静态存储期的变量和函数。用static声明的局部变量具有静态存储持续期（static storage duration），或静态范围（static extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。
2. const关键字
const关键字也是一个优秀程序中经常用到的关键字。关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
深入理解const关键字，你必须知道：
a. const关键字修饰的变量可以认为有只读属性，但它绝不与常量划等号。如下代码：
const int i=5;
      int j=0;
      ...
      i=j;   //非法，导致编译错误，因为只能被读
      j=i;   //合法
b. const关键字修饰的变量在声明时必须进行初始化。如下代码：
const int i=5;    //合法
    const int j;      //非法，导致编译错误
c.用const声明的变量虽然增加了分配空间，但是可以保证类型安全。const最初是从C++变化得来的，它可以替代define来定义常量。在旧版本(标准前)的c中，如果想建立一个常量，必须使用预处理器：
               #define PI 3.14159
此后无论在何处使用PI，都会被预处理器以3.14159替代。编译器不对PI进行类型检查，也就是说可以不受限制的建立宏并用它来替代值，如果使用不慎，很可能由预处理引入错误，这些错误往往很难发现。而且，我们也不能得到PI的地址（即不能向PI传递指针和引用）。const的出现，比较好的解决了上述问题。
d. C标准中，const定义的常量是全局的。
e.必须明白下面语句的含义，我自己是反复记忆了许久才记住，方法是：若是想定义一个只读属性的指针，那么关键字const要放到‘*’后面。
char *const cp; //指针不可改变，但指向的内容可以改变
char const *pc1; //指针可以改变，但指向的内容不能改变
const char *pc2; //同上（后两个声明是等同的）
      f. 将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。
      参数const通常用于参数为指针或引用的情况，且只能修饰输入参数;若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。例子：
void fun0(const int * a );
void fun1(const int & a);
调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，如形参为const int * a，则不能对传递进来的指针所指向的内容进行改变，保护了原指针所指向的内容；如形参为const int & a，则不能对传递进来的引用对象进行改变，保护了原对象的属性。
      g. 修饰函数返回值，可以阻止用户修改返回值。（在嵌入式C中一般不用，主要用于C++）
      h. const消除了预处理器的值替代的不良影响，并且提供了良好的类型检查形式和安全性，在可能的地方尽可能的使用const对我们的编程有很大的帮助，前提是：你对const有了足够的理解。
      最后，举两个常用的标准C库函数声明，它们都是使用const的典范。
      1.字符串拷贝函数：char *strcpy（char *strDest，const char *strSrc）；
      2.返回字符串长度函数：int strlen（const char *str）；
 
3.volatile关键字
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如： 
static int i=0; 

int main(void) 
{ 
    ... 
    while (1) 
    { 
        if (i) 
            dosomething(); 
    } 
} 

/* Interrupt service routine. */ 
void ISR_2(void) 
{ 
     i=1; 
} 

       程序的本意是希望ISR_2中断产生时，在main当中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。 

如果将将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。 

一般说来，volatile用在如下的几个地方： 

1、中断服务程序中修改的供其它程序检测的变量需要加volatile； 

2、多任务环境下各任务间共享的标志应该加volatile； 

3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；
不懂得volatile的内容将会带来灾难，这也是区分C语言和嵌入式C语言程序员的一个关键因素。为强调volatile的重要性,再次举例分析:
代码一:                               
int a,b,c;                             
//读取I/O空间0x100端口的内容    
a= inword(0x100);                                                 
b=a;                               
a=inword(0x100)                           
c=a; 
代码二:   
 volatile int a;   
 int a,b,c;                             
//读取I/O空间0x100端口的内容    
a= inword(0x100);                                              
b=a;                               
a=inword(0x100)                       
c=a; 
在上述例子中,代码一会被绝大多数编译器优化为如下代码:
      a=inword(0x100)
      b=a;
      c=a;
这显然与编写者的目的不相符,会出现I/O空间0x100端口漏读现象,若是增加volatile,像代码二所示的那样,优化器将不会优化掉任何代码.
      从上面来看,volatile关键字是会降低编译器优化力度的,但它保证了程序的正确性,所以在适合的地方使用关键字volatile是件考验编程功底的事情.
 
4.struct与typedef关键字
面对一个人的大型C/C++程序时，只看其对struct的使用情况我们就可以对其编写者的编程经验进行评估。因为一个大型的C/C++程序，势必要涉及一些(甚至大量)进行数据组合的结构体，这些结构体可以将原本意义属于一个整体的数据组合在一起。从某种程度上来说，会不会用struct，怎样用struct是区别一个开发人员是否具备丰富开发经历的标志。
　　在网络协议、通信控制、嵌入式系统的C/C++编程中，我们经常要传送的不是简单的字节流（char型数组），而是多种数据组合起来的一个整体，其表现形式是一个结构体。
经验不足的开发人员往往将所有需要传送的内容依顺序保存在char型数组中，通过指针偏移的方法传送网络报文等信息。这样做编程复杂，易出错，而且一旦控制方式及通信协议有所变化，程序就要进行非常细致的修改。
用法:
在C中定义一个结构体类型要用typedef:
typedef struct Student
{
       int a;
}Stu;
于是在声明变量的时候就可：Stu stu1;
如果没有typedef就必须用struct Student stu1;来声明
这里的Stu实际上就是struct Student的别名。
另外这里也可以不写Student（于是也不能struct Student stu1;了）
typedef struct
{
       int a;
}Stu;
struct关键字的一个总要作用是它可以实现对数据的封装,有一点点类似与C++的对象,可以将一些分散的特性对象化,这在编写某些复杂程序时提供很大的方便性.
比如编写一个菜单程序,你要知道本级菜单的菜单索引号、焦点在屏上是第几项、显示第一项对应的菜单条目索引、菜单文本内容、子菜单索引、当前菜单执行的功能操作。若是对上述条目单独操作，那么程序的复杂程度将会大到不可想象，若是菜单层数少些还容易实现，一旦菜单层数超出四层，呃~我就没法形容了。若是有编写过菜单程序的朋友或许理解很深。这时候结构体struct就开始显现它的威力了：
//结构体定义
typedef struct
{
unsigned char CurrentPanel;//本级菜单的菜单索引号
unsigned char ItemStartDisplay; //显示第一项对应的菜单条目索引
unsigned char FocusLine; //焦点在屏上是第几项
}Menu_Statestruct;
 
typedef struct
{
unsigned char *MenuTxt; //菜单文本内容
unsigned char MenuChildID;//子菜单索引
void   (*CurrentOperate)();//当前菜单执行的功能操作
}MenuItemStruct;
 
typedef struct
{
MenuItemStruct *MenuPanelItem;
unsigned char   MenuItemCount;
}MenuPanelStruct;
 
      这里引用我巩师兄所写的菜单程序中的结构体定义，这个菜单程序最大可以到256级菜单。我当初要写一个菜单程序之前，并没有对结构体了解多少，也没有想到使用结构体。只是一层层菜单的单独处理：如果按键按下，判断是哪个按键，调用对应按键的子程序，刷屏显示。这样处理起来每一层都要判断当前的光标所在行，计算是不是在显示屏的顶层，是不是在显示层的底层，是不是需要翻页等等，非常的繁琐。后来在网上找资料，就找到了我师兄编写的这个程序，开始并不知道是他写的，在看源程序的时候看到了作者署名：中国传惠 TranSmart，才知道是他。花了一天的时间阅读代码和移植，才知道结构体原来有这么个妙用，当定义了上述三个结构体之后，菜单程序结构立刻变的简单很多，思路也无比的清晰起来。


//***************************
//*ARM中的RO、RW和ZI DATA说明 .
//***************************
RO段、RW段和ZI段


            要了解RO，RW和ZI需要首先了解以下知识：
ARM程序的组成
            此处所说的“ARM程序”是指在ARM系统中正在执行的程序，而非保存在ROM中的bin映像（image）文件，这一点清注意区别。
            一个ARM程序包含3部分：RO，RW和ZI。RO是程序中的指令和常量；RW是程序中的已初始化变量;ZI是程序中的未初始化的变量.
            由以上3点说明可以理解为：RO就是readonly，RW就是read/write，ZI就是zero

 

 ARM映像文件的组成
            所谓ARM映像文件就是指烧录到ROM中的bin文件，也称为image文件。以下用Image文件来称呼它。
            Image文件包含了RO和RW数据。之所以Image文件不包含ZI数据，是因为ZI数据都是0，没必要包含，只要程序运行之前将ZI数据所在的区域一律清零即可。包含进去反而浪费存储空间。
            Q：为什么Image中必须包含RO和RW？
            A：因为RO中的指令和常量以及RW中初始化过的变量是不能像ZI那样“无中生有”的。

 

ARM程序的执行过程
            从以上两点可以知道，烧录到ROM中的image文件与实际运行时的ARM程序之间并不是完全一样的。因此就有必要了解ARM程序是如何从ROM中的image到达实际运行状态的。
            实际上，RO中的指令至少应该有这样的功能：
            1. 将RW从ROM中搬到RAM中，因为RW是变量，变量不能存在ROM中。
            2. 将ZI所在的RAM区域全部清零，因为ZI区域并不在Image中，所以需要程序根据编译器给出的ZI地址及大小来将相应得RAM区域清零。ZI中也是变量，同理：变量不能存在ROM中
            在程序运行的最初阶段，RO中的指令完成了这两项工作后C程序才能正常访问变量。否则只能运行不含变量的代码。


            说了上面的可能还是有些迷糊，RO，RW和ZI到底是什么，下面我将给出几个例子，最直观的来说明RO，RW，ZI在C中是什么意思。
1、RO
            看下面两段程序，他们之间差了一条语句，这条语句就是声明一个字符常量。因此按照我们之前说的，他们之间应该只会在RO数据中相差一个字节（字符常量为1字节）。
            Prog1：
            #include <stdio.h>
            void main(void)
            {
            ;
            }
            Prog2：
            #include <stdio.h>
            const char a = 5；
            void main(void)
            {
            ;
            }
            Prog1编译出来后的信息如下：
            =================================================
            Code RO Data RW Data ZI Data Debug
            948 60 0 96 0 Grand Totals
            =================================================
            Total RO Size(Code + RO Data) 1008 ( 0.98kB)
            Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)
            Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)
            =================================================
            Prog2编译出来后的信息如下：
            =================================================
            Code RO Data RW Data ZI Data Debug
            948 61 0 96 0 Grand Totals
            =================================================
            Total RO Size(Code + RO Data) 1009 ( 0.99kB)
            Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)
            Total ROM Size(Code + RO Data + RW Data) 1009 ( 0.99kB)
            =================================================
            以上两个程序编译出来后的信息可以看出：
            Prog1和Prog2的RO包含了Code和RO Data两类数据。他们的唯一区别就是Prog2的RO Data比Prog1多了1个字节。这正和之前的推测一致。
            如果增加的是一条指令而不是一个常量，则结果应该是Code数据大小有差别。


2、RW
            同样再看两个程序，他们之间只相差一个“已初始化的变量”，按照之前所讲的，已初始化的变量应该是算在RW中的，所以两个程序之间应该是RW大小有区别。
            Prog3：
            #include <stdio.h>
            void main(void)
            {
            ;
            }
            Prog4：
            #include <stdio.h>
            char a = 5；
            void main(void)
            {
            ;
            }
            Prog3编译出来后的信息如下：
            ==================================================
            Code RO Data RW Data ZI Data Debug
            948 60 0 96 0 Grand Totals
            ==================================================
            Total RO Size(Code + RO Data) 1008 ( 0.98kB)
            Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)
            Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)
            ==================================================
            Prog4编译出来后的信息如下： 

	    ==================================================
            Code RO Data RW Data ZI Data Debug
            948 60 1 96 0 Grand Totals
            ==================================================
            Total RO Size(Code + RO Data) 1008 ( 0.98kB)
            Total RW Size(RW Data + ZI Data) 97 ( 0.09kB)
            Total ROM Size(Code + RO Data + RW Data) 1009 ( 0.99kB)
            ==================================================
            可以看出Prog3和Prog4之间确实只有RW Data之间相差了1个字节，这个字节正是被初始化过的一个字符型变量“a”所引起的。

 

3、ZI
            再看两个程序，他们之间的差别是一个未初始化的变量“a”，从之前的了解中，应该可以推测，这两个程序之间应该只有ZI大小有差别。
            Prog3：
            #include <stdio.h>
            void main(void)
            {
            ;
            }
            Prog4：
            #include <stdio.h>
            char a；
            void main(void)
            {
            ;
            }
            Prog3编译出来后的信息如下：
            ====================================================
            Code RO Data RW Data ZI Data Debug
            948 60 0 96 0 Grand Totals
            ====================================================
            Total RO Size(Code + RO Data) 1008 ( 0.98kB)
            Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)
            Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)
            ====================================================
            Prog4编译出来后的信息如下：
            ====================================================
            Code RO Data RW Data ZI Data Debug
            948 60 0 97 0 Grand Totals
            ====================================================
            Total RO Size(Code + RO Data) 1008 ( 0.98kB)
            Total RW Size(RW Data + ZI Data) 97 ( 0.09kB)
            Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)
            ====================================================
            编译的结果完全符合推测，只有ZI数据相差了1个字节。这个字节正是未初始化的一个字符型变量“a”所引起的。
            注意：如果一个变量被初始化为0，则该变量的处理方法与未初始化华变量一样放在ZI区域。
            即：ARM C程序中，所有的未初始化变量都会被自动初始化为0。

总结：
            1、 C中的指令以及常量被编译后是RO类型数据。
            2、 C中的未被初始化或初始化为0的变量编译后是ZI类型数据。
            3、 C中的已被初始化成非0值的变量编译后市RW类型数据。
            附：
            程序的编译命令（假定C程序名为tst.c）：
            armcc -c -o tst.o tst.c
            armlink -noremove -elf -nodebug -info totals -info sizes -map -list aa.map -o tst.elf tst.o
            编译后的信息就在aa.map文件中。
            ROM主要指：NAND Flash，Nor Flash
            RAM主要指：PSRAM，SDRAM，SRAM，DDRAM

 

 

------------------------------------------

 

 

Image$$??$$Limit 的含义

对于刚学习ARM的人来说，如果分析它的启动代码，往往不明白下面几个变量的含义：|Image$$RO$$Limit|、|Image$$RW$$Base|、|Image$$ZI$$Base|。

首先申明我使用的调试软件为ADS1.2，当我们把程序编写好以后，就要进行编译和链接了，在ADS1.2中选择MAKE按钮，会出现一个Errors and Warnings 的对话框，在该栏中显示编译和链接的结果，如果没有错误，在文件的最后应该能看到Image component sizes，后面紧跟的依次是Code，RO Data ，RW Data ，ZI Data ，Debug 各个项目的字节数，最后会有他们的一个统计数据：

Code 163632 ，RO Data 20939 ，RW Data 53 ，ZI Data 17028
Tatal RO size (Code+ RO Data)             184571 (180.25kB)
Tatal RW size(RW Data+ ZI Data)           17081(16.68 kB)
Tatal ROM size(Code+ RO Data+ RW Data)   184624(180.30 kB)

后面的字节数是根据用户不同的程序而来的，下面就以上面的数据为例来介绍那几个变量的计算。

在ADS的Debug Settings中有一栏是Linker/ARM Linker，在output选项中有一个RO base选项，下面应该有一个地址，我这里是0x0c100000，后面的RW base 地址是0x0c200000，然后在Options选项中有Image entry point ，是一个初始程序的入口地址，我这里是0x0c100000 。

有了上面这些信息我们就可以完全知道这几个变量是怎么来的了：
|Image$$RO$$Base| = Image entry point = 0x0c100000 ;表示程序代码存放的起始地址


|Image$$RO$$Limit|=程序代码起始地址+代码长度+1=0x0c100000+Tatal RO size+1
= 0x0c100000 + 184571 + 1 = 0x0c100000 +0x2D0FB + 1
= 0x0c12d0fc

|Image$$RW$$Base| = 0x0c200000 ;由RW base 地址指定

|Image$$RW$$Limit| =|Image$$RW$$Base|+ RW Data 53 = 0x0c200000+0x37（4的倍数,0到55，共56个单元）=0x0c200037

|Image$$ZI$$Base| = |Image$$RW$$Limit| + 1 =0x0c200038

|Image$$ZI$$Limit| = |Image$$ZI$$Base| + ZI Data 17028
                            =0x0c200038 + 0x4284
                            =0x0c2042bc

也可以由此计算：
|Image$$ZI$$Limit| = |Image$$RW$$Base| +TatalRWsize(RWData+ZIData) 17081
                            =0x0c200000+0x42b9+3（要满足4的倍数）
                            =0x0c2042bc

 


加点自己的补充：

RO 是code + RO Data ，RO data应该是const声明的常量

下载到固件中的代码包括RO和RW，ZI主要被malloc 函数用到，还有这些概念和堆栈的联系，malloc声明的变量在heap（堆）中，stack（栈）是用来存放临时变量的。

 

 

-----------------------------------------------------

 

 

一般而言，一个程序包括只读的代码段和可读写的数据段。在ARM的集成开发环境中，只读的代码段和常量被称作RO段(ReadOnly)；可读写的全局变量和静态变量被称作RW段(ReadWrite)；RW段中要被初始化为零的变量被称为ZI段(ZeroInit)。对于嵌入式系统而言，程序映象都是存储在Flash存储器等一些非易失性器件中的，而在运行时，程序中的RW段必须重新装载到可读写的RAM中。这就涉及到程序的加载时域和运行时域。简单来说，程序的加载时域就是指程序烧入Flash中的状态，运行时域是指程序执行时的状态。对于比较简单的情况，可以在ADS集成开发环境的ARM LINKER选项中指定RO BASE和RW BASE，告知连接器RO和RW的连接基地址。对于复杂情况，如RO段被分成几部分并映射到存储空间的多个地方时，需要创建一个称为“分布装载描述文件”的文本文件，通知连接器把程序的某一部分连接在存储器的某个地址空间。需要指出的是，分布装载描述文件中的定义要按照系统重定向后的存储器分布情况进行。在引导程序完成初始化的任务后，应该把主程序转移到RAM中去运行，以加快系统的运行速度。


            什么是arm的映像文件，arm映像文件其实就是可执行文件，包括bin或hex两种格式，可以直接烧到rom里执行。在axd调试过程中，我们调试的是axf文件，其实这也是一种映像文件，它只是在bin文件中加了一个文件头和一些调试信息。映像文件一般由域组成，域最多由三个输出段组成(RO,RW,ZI)组成，输出段又由输入段组成。所谓域，指的就是整个bin映像文件所处在的区域，它又分为加载域和运行域。加载域就是映像文件被静态存放的工作区域，一般来说flash里的 整个bin文件所在的地址空间就是加载域，当然在程序一般都不会放在 flash里执行，一般都会搬到sdram里运行工作，它们在被搬到sdram里工作所处的地址空间就是运行域。

	我们输入的代码，一般有代码部分和数据部分，这就是所谓的输入段，经过编译后就变成了bin文件中ro段和rw段，还有所谓的zi段，这就是输出段。对于加载域中的输出段，一般来说ro段后面紧跟着rw段，rw段后面紧跟着zi段。在运行域中这些输出段并不连续，但rw和zi一定是连着的。zi段和rw段中的数据其实可以是rw属性。 


                | Image$$RO$$Base| |Image$$RO$$Limit| |Image$$RW$$Base| |Image$$ZI$$Base| |Image$$ZI$$Limit|这几个变量是编译器通知的，我们在 makefile文件中可以看到它们的值。它们指示了在运行域中各个输出段所处的地址空间。| Image$$RO$$Base| 就是ro段在运行域中的起始地址，|Image$$RO$$Limit| 是ro段在运行域中的截止地址。其它依次类推。我们可以在linker的output中指定，在 simple模式中，ro base对应的就是| Image$$RO$$Base|，rw base 对应的是|Image$$RW$$Base|，由于rw和zi相连，|Image$$ZI$$Base| 就等于|Image$$ZI$$limit| .其它的值都是编译器自动计算出来的。


            下面是2410启动代码的搬运部分，我给出注释
            BaseOfROM DCD |Image$$RO$$Base|
            TopOfROM DCD |Image$$RO$$Limit|
            BaseOfBSS DCD |Image$$RW$$Base|
            BaseOfZero DCD |Image$$ZI$$Base|
            EndOfBSS DCD |Image$$ZI$$Limit|
            adr r0, ResetEntry;    ResetEntry是复位运行时域的起始地址，在boot nand中一般是0
            ldr r2, BaseOfROM;
            cmp r0, r2
            ldreq r0, TopOfROM;TopOfROM=0x30001de0，代码段地址的结束
            beq InitRam 
            ldr r3, TopOfROM
            ；part 1，通过比较，将ro搬到sdram里，搬到的目的地址从 | Image$$RO$$Base| 开始，到|Image$$RO$$Limit|结束
            
            0 
            ldmia r0!, {r4-r7}
            stmia r2!, {r4-r7}
            cmp r2, r3
            bcc %B0;
            
            ；part 2，搬rw段到sdram，目的地址从|Image$$RW$$Base| 开始，到|Image$$ZI$$Base|结束
            sub r2, r2, r3;r2=0
            sub r0, r0, r2    
            InitRam ;carry rw to baseofBSS
            ldr r2, BaseOfBSS ;TopOfROM=0x30001de0,baseofrw
            ldr r3, BaseOfZero ;BaseOfZero=0x30001de0
            0
            cmp r2, r3
            ldrcc r1, [r0], #4
            strcc r1, [r2], #4
            bcc %B0 
            ；part 3，将sdram zi初始化为0，地址从|Image$$ZI$$Base|到|Image$$ZI$$Limit|
            mov r0, #0;init 0
            ldr r3, EndOfBSS;EndOfBSS=30001e40
            1 
            cmp r2, r3
            strcc r0, [r2], #4
            bcc %B1


 

 

------------------------------------------------------------

 

一 概述

Scatter file (分散加载描述文件)用于armlink的输入参数，他指定映像文件内部各区域的download与运行时位置。Armlink将会根据scatter file生成一些区域相关的符号，他们是全局的供用户建立运行时环境时使用。（注意：当使用了scatter file 时将不会生成以下符号 Image$$RW$$Base, Image$$RW$$Limit, Image$$RO$$Base, Image$$RO$$Limit, Image$$ZI$$Base, and Image$$ZI$$Limit）

二 什么时候使用scatter file

       当然首要的条件是你在利用ADS进行项目开发，下面我们看看更具体的一些情况。
1 存在复杂的地址映射：例如代码和数据需要分开放在在多个区域。
2 存在多种存储器类型：例如包含 Flash,ROM,SDRAM,快速SRAM。我们根据代码与数据的特性把他们放在不同的存储器中，比如中断处理部分放在快速SRAM内部来提高响应速度，而把不常用到的代码放到速度比较慢的Flash内。
3 函数的地址固定定位：可以利用Scatter file实现把某个函数放在固定地址，而不管其应用程序是否已经改变或重新编译。
4 利用符号确定堆与堆栈：
5 内存映射的IO：采用scatter file可以实现把某个数据段放在精确的地指处。
因此对于嵌入式系统来说scatter file是必不可少的，因为嵌入式系统采用了ROM，RAM，和内存映射的IO。

三 scatter file 实例

。。。。。。。。。。。。。（省略


Code,RO-data
RW-data,ZI-data

Code为程序代码部分
Ro-data表示程序定义的常量const
RW-data表示 已经初始化的全局变量
ZI-data表示 未初始化的全局变量
Total RO  Size (Code + RO Data)
Total RW  Size (RW Data + ZI Data) 
Total ROM Size (Code + RO Data + RW Data)
初始化时，RW-data从flash拷贝到RAM


本程序中
Project->Options->Target
IROM1:0x0-0x40000
IRAM1:0x10000000-0x8000
说明RAM分配的空间是0x8000，即32k大小

Project->Options->Linker
R/O Base:0x00000000
R/W Base:0x10000000说明分配空间起始位置
点击Edit,打开InChip.sct文件，也可以看到分配的情况
ROM_LOAD 0x00000000
{
    VECTOR 0x00000000
    {
        vector_table.o (+RO)
    }
    ROM_EXEC +0
    {
        *.o (+RO)
    }

    SRAM 0x10000000
    {
        * (+RW,+ZI)
    }

    HEAP +0 UNINIT
    {
        rt_sys_s.o (Heap)
    }
}




选择右边的工程DebugInFlash->右击->Open xx.Map
打开xx.Map文件，查看最后一行
    Total RO  Size (Code + RO Data)               287700 ( 280.96kB)
    Total RW  Size (RW Data + ZI Data)             32756 (  31.99kB)
    Total ROM Size (Code + RO Data + RW Data)     294128 ( 287.23kB)

可知现在的RW已经用到31.99kB,即将满了。

Project->Options->Device
256kB on-chip Flash ROM，
64kB RAM
可知本芯片可能是64kb,但是由两块32kb来组成的，可知一块已经满了，但是还有一块RAM可以分配



解决方法如下：
具体请看http://blog.csdn.net/ropai/article/details/7492922

RealView MDK在链接时提示空间不够的解决方案总结 .
RealView MDK具有强大的编译、链接功能。嵌入式设备拥有的资源往往有限，如果一个程序编译、链接之后的可执行文件大小略大于存储大小时，则不能生成可执行文件进行调试或固化到Flash中。在这种情况下我们一般不去从硬件上调整存储空间的大小(有些存储空间在片内，实在无法调整)，而是去修改程序，试图将程序简化、将缓存减小、减少全局变量、少用大数组多用指针等等人工方法，有些时候这些方法很有效。但如果使用的开发工具是RealView MDK，则有一系列方法，可以达到这一目的，比起手动方法只有过之而无不及。这些方法仅仅需要在编译、链接之前对某些配置做一些修改即可，使用非常简单。当然，如果将这些方法和人工修改程序的方法结合起来，效果更佳。有时单独使用以下三种方法中的一种即可解决问题，有时需要结合其中两种，甚至三种才能解决问题。下面以开发板Embest ATEB9200（采用的SOC 为AT91RM9200）的例程USARTPDC_test为例，由于片内SRAM空间比较小(大小为16KB，起始地址为0x200000)，本例程在片内SRAM中进行调试时需要使用一些技巧，下面介绍如何使用这些方法。

在默认设置下，将例程USARTPDC_test选择在片上SRAM中调试时，编译通过、在链接时会提示以下错误信息提示空间不够：

compiling init.c...

compiling interrupt_Usart.c...

compiling main.c...

linking...

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(_scanf_int.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(_scanf_longlong.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(aeabi_sdiv.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(init.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section CL$$btod_mult_common(btod.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(__printf.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section CL$$btod_div_common(btod.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(main.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(_scanf.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(interrupt_usart.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(scanf_fp.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(scanf_hexfp.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6407W: Sections of aggregate size 0x23f8 bytes could not fit into .ANY selector(s).

Target not created

一、使用微库

使用微库时，将以更精简短小的C库替代标准C库，减小代码大小，使用微库的方法如下：

打开Project->Options->Target，将Use MicroLIB前面的复选框勾上。如下图：







图一  使用微库


点击确定之后，重新编译、链接。发现还是会提示空间不够的错误信息，但错误信息明显比以前少了：

Build target 'USARTPDC_test Int RAM'

assembling RM9200.s...

compiling init.c...

compiling interrupt_Usart.c...

compiling main.c...

linking...

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section .text(interrupt_usart.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6406W: No space in execution regions with .ANY selector matching Section i._printf_core(printf8.o).

.\Int_RAM\USARTPDC_test.axf: Error: L6407W: Sections of aggregate size 0x86c bytes could not fit into .ANY selector(s).

Target not created

二、修改链接脚本

修改链接脚本的方法有两种一种是直接修改分散加载文件，另一种是使用默认分散加载文件，这时仅需修改Project->Options->Target中的存储空间起始和大小。为了简单直观，本例中使用后者。在使用后者时，需要在Project->Options->Linker中将Use Memory Layout from Target Dialog前面的复选框勾上。如下图：







图二 使用默认的分散加载文件


然后在Project->Options->Target中修改存储空间中只读部分和可读写部分的起始和大小，一般来说加大只读部分大小（该部分存放程序中的指令），而减小可读写部分的大小（该部分存放堆栈、局部变量等）。

根据错误提示可知，只读部分空间最少需要加大0x86c bytes，总空间固定16KB，相应地需要减小可读写部分大小。修改之前如图一，修改后如下图：







图三  增大只读部分大小，减小可读写部分大小


点击确定之后，重新编译、链接：

Build target 'USARTPDC_test Int RAM'

assembling RM9200.s...

compiling init.c...

compiling interrupt_Usart.c...

compiling main.c...

linking...

Program Size: Code=9388 RO-data=380 RW-data=4 ZI-data=1244  

".\Int_RAM\USARTPDC_test.axf" - 0 Error(s), 0 Warning(s).

编译链接成功！

三、修改优化级别，着重对空间进行优化

在编译时着重对空间进行优化，让编译器自动减小代码大小。可使用编译选项-Ospace进行编译以达到目的，另外可以选更高的选优化级别D-03如下图：







图四 选较高优化级别针对空间进行优级化以减小代码大小



//*****************
//Turbo C编译器使用
//*****************
按F10开始选择菜单

*File菜单的子菜单共有9项，分别叙述如下：

1.       Load：装入一个文件, 可用类似DOS的通配符(如*.C)来进行列表选择。也可装入其它扩展名的文件, 只要给出文件名(或只给路径)即可。
2.       Pick：将最近装入编辑窗口的8个文件列成一个表让用户选择,  选择后将该程序装入编辑区, 并将光标置在上次修改过的地方
3.       New，Save, Quit：
4.       Write to：即Save to
5.       Directory：显示目录及目录中的文件, 并可由用户选择。
6.       Change dir：显示当前默认目录, 用户可以改变默认目录。
7.       Os shell：暂时退出Turbo C 2.0到DOS提示符下,   此时可以运行DOS 命令,   若想回到 Turbo C 2.0中, 只要在DOS状态下键入EXIT即可。

*Run菜单：
1.       Run：运行
2.       Program reset：中止当前的调试
3.       Go to cursor：调试程序时运行到光标所在
4.       Trace into：单步调试，执行到该子函数内部
5.       Step over：单步调试，执行时跳过函数
6.       User screen：查看结果

*Compile菜单
1.       Compile to OBJ：将一个C源文件编译生成.OBJ目标文件,  同时显示生成的文件名。
2.       Make EXE file：此命令生成一个.EXE的文件, 并显示生成的.EXE文件名。其中.EXE文件名是下面几项之一：

1)        由Project/Project name说明的项目文件名。

2)        若没有项目文件名, 则由Primary C file说明的源文件。

3)        若以上两项都没有文件名, 则为当前窗口的文件名。

3.       Link EXE file：把当前.OBJ文件及库文件连接在一起生成.EXE文件。

4.       Build all：重新编译项目里的所有文件, 并进行装配生成.EXE文件。该命令不作过时检查 (上面的几条命令要作过时检查,  即如果目前项目里源文件的日期和时间与目标文件相同或更早, 则拒绝对源文件进行编译)。

5.       Primary C file：当在该项中指定了主文件后, 在以后的编译中, 如没有项目文件名则编译此项中规定的主C文件, 如果编译中有错误, 则将此文件调入编辑窗口,  不管目前窗口 中是不是主C文件。

6.       Get info：获得有关当前路径、源文件名、源文件字节大小、编译中的错误数目、可用空间等信息，如图：


*Project菜单
1.       Project name：项目名具有.PRJ的扩展名, 其中包括将要编译、连接的文件名。例如有一个程 序由file1.c, file2.c, file3.c组成, 要将这3个文件编译装配成一个file.exe的执行文件, 可以先建立一个file.prj的项目文件, 其内容如下:

     file1.c

     file2.c

     file3.c

此时将file.prj放入Project name项中, 以后进行编译时将自动对项目文件中规定的三个源文件分别进行编译。然后连接成file.exe文件。如果其中有些文件已经编译成.OBJ文件, 而又没有修改过, 可直接写上.OBJ扩 展名。此时将不再编译而只进行连接。

例如:

   file1.obj

file2.c

file3.c

将不对file1.c进行编译, 而直接连接。

说明: 

当项目文件中的每个文件无扩展名时, 均按源文件对待, 另外, 其中的文件也可以是库文件, 但必须写上扩展名.LIB。

2.       Break make on：由用户选择是否在有Warining、Errors、Fatal Errors时或Link之前退出Make编译。

3.       Auto dependencies：当开关置为on, 编译时将检查源文件与对应的.OBJ文件日期和时间, 否则不进 行检查。

4.       Clear project：清除Project/Project name中的项目文件名。

5.       Remove messages：把错误信息从信息窗口中清除掉。

*Options菜单,该菜单对初学者来说要谨慎使用，该菜单有以下几个内容:
请查询第一部分，c基础\谭浩强1.13.8



*Debug菜单, 该菜单主要用于查错:
1.       Evaluate

1)        Expression要计算结果的表达式。

2)        Result显示表达式的计算结果。

3)        New value赋给新值。

2.       Call stack：该项不可接触。而在Turbo C debuger 时用于检查堆栈情况。

3.       Find function在运行Turbo C debugger时用于显示规定的函数。

4.       Refresh display如果编辑窗口偶然被用户窗口重写了可用此恢复编辑窗口的内容。


*Break/watch菜单：
1.       Add watch，Delete watch，Edit watch，Remove all： 向监视窗口插入一监视表达式。
2.       Toggle breakpoint：对光标所在的行设置或清除断点。
3.       Clear all breakpoints：清除所有断点。
4.       View next breakpoint：将光标移动到下一个断点处。


//**********************************************************
//C语言简洁、紧凑，使用方便、灵活。ANSI C一共只有32个关键字:
//**********************************************************
1、
auto break case char const continue default
 
do double else enum extern float for 
 
goto if int long register return short 
 
signed static  sizof  struct  switch typedef  union 
 
unsigned  void  volatile while

asm        _cs         _ds         _es         _ss         cdecl              far

huge       interrupt   near        pascal
2、转义字符
\n换行，\t横向制表，\v纵向指标，\b回退，\r回车，\f换页，\?使用"?",\'使用单引号, \"使用双引号，\\使用"\", \a鸣铃，  \ddd 1～3位八进制数所代表的字符，
 \xhh 1～2位十六进制数所代表的字符 
ddd和hh分别为八进制和十六进制的ASCII代码。如\101表示字母"A" ，\102表示字母"B"，\134表示反斜线，\XOA表示换行等，\0表示空字符，它的数值为0
其它如果没有定义的，比如\c，则显示"c" 

例：printf(“  ab  c\tde\rf\n”);  答案：fab c de
    printf(“  ab  c\tde\rb\n”);  答案：ab c df
    printf(“hijk\tL\bM\n”); 答案：hijk M


3、预编译：把<xx.h>,或者"xx.h"引号指定的文件库包括到本程序中来，成为本程序的一部分
4、标识符：标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线(_)组成的字符串，并且其第一个字符必须是字母或下划线
5、注释：/**/,//

//********
//数据类型
//********
数值：
//********
//进制转换
//********
1、 二进制数转换为十进制数
0110 0100.101
整数：
     0       1       2       3       4       5       6       7
0 * 2 + 0 * 2 + 1 * 2 + 1 * 2 + 0 * 2 + 1 * 2 + 1 * 2 + 0 * 2 = 100 
小数：
     -1        -2        -3
1 * 2   + 0 * 2   + 1 * 2  = 0.625

所得：100.625
2、 十进制数转换为二进制数
25.25
整数：
   2 | 25
     -----
   2  | 12       1
      ----
   2   | 6       0
       ----
   2    | 3      0
        ----
   2     | 1     1
         ----   
   2       0     1
从下往上11001
小数：
    0.25*2=0.5    0
    0.5*2=1       1 
从上往下01 
所得：11001.01
3、八进制数转换为十进制数
1507.51
整数：
     0       1       2       3
7 * 8 + 0 * 8 + 5 * 8 + 1 * 8 = 839
小数：
     -1        -2       
5 * 8   + 1 * 8   = 0.65
所得：839.65
4、十进制数转换为八进制数
25.25
整数：
   8 | 25
     -----
   8  | 3       1
      ----
      | 0       3
       ----  
从下往上31
小数：
    0.25*8=2    2   
从上往下2 
所得：31.2
5、十六进制数转换为十进制数
19.A
方法一：
整数：
     0       1  
9 * 16 + 1 * 16 = 25
小数：
     -1            -1
A * 16  = 即10 * 16 = 0.625
所得：25.625

方法二：
求19的十进制数值
设n=0;
16*n+1=16*0+1=1;
赋值n=1;
16*n+9=16*1+9=25;

求19.A的十进制数值
设n=0;
16*n+1=16*0+1=1;
赋值n=1;
16*n+9=16*1+9=25;

赋值n=25,设power=1.0
通过循环，当所有小数全部计算结束后退出循环
{
16*n+A=400+10=410
赋值n=410；
power*16=1*16=16
赋值power=6；
}
结果：n/power=410/16=25.625

方法三：
int a=0xff,b=0xff,c=0xff;
printf("Hello, world %lu\n",(a*65536+b*256+c));

6、十进制数转换为十六进制数
25.625
整数：
   16 | 25
     -----
   16 | 1       9
      ----
      | 0       1
       ----  
从下往上19
小数：
    0.625*16=10    即A   
从上往下A 
所得：19.A
7、二进制数转换为八进制数
11001.1011
011   001. 101 100
 3     1.   5   4
所得：31.54
8、八进制数转换为二进制数
31.54
 3     1.   5   4
011   001. 101 100
所得：11001.1011
9、二进制数转换为十六进制数
11001.1011
0001   1001. 1011 0000
 1        9.   B   0
所得：19.B
10、十六进制数转换为二进制数
19.B
 1        9.   B 
0001   1001. 1011 
所得：11001.1011

方法二：
int a=564;
aHigh=564/256;
aLow=564%256;

11、负数的转换
先将该负数转换为补码形式，再根据二进制转为其它进制的方法进行
例：-9 转为八进制
9的原码0000 1001(因为它保存在内存中是两个字节的)
补码为它的原码，取反，再加一，即1111 0110 + 1 =1111 0111
011 110 111
 3   6   7
所得：367

11、十六进制转十进制
07DC

07*256+DC=2012

12、十进制转十六进制
2012

2012/256=7
2012%256=DC

//****
//编码
//****
数字系统中的信息可以分为两类：数值，和文字符号。数值可以用二进制符号表示，而文字符号也可用二进制表示，这个称谓代码(即ASCII码)。建立代码与格符号的对应关系称为编码
1、码的基本概念
1)数位与比特：
码的数位叫做数位，例如十进制码叫做十进制数位；
而二进制码叫做二进制数位，二进制数位一般用比特(bit)表示，简写为b。
例如：一个二进制吗是100101，该码有6数位，称为6bit(比特)

2)字，字长，和字节
用一个二进制数来表示数值或者字符，该二进制数称为字。一个字的二进制数长度称为字长。字长应有1位，8位，16位等。字长越长，机器性能越好。
例如：8051单片机是8位机，是指它的字长是8为，即它的内容运算器都是8位的，每次参加运算得二进制位只有8位
字节：字节是由一组二进制位组成的一个存储单位。一个8位二进制数称为一个字节(Byte)，用B表示
一般来说，一个字由两个字节组成，而一个字符是由一个字节组成
            10                20
1MB=1024KB(2  KB)=1024*1024B(2  B)

字内位的名称：MSB,2SB,3SB,4SB,5SB,6SB,7SB,LSB

3)奇偶校验码：是一个检测错误的代码。它分为：信息位和奇偶校验位。有奇数个1称为奇校验，有偶数个1称为偶校验

//************
//基本数据类型
//************
存放于<limits.h>文件
*符号常量的标识符用大写字母，变量标识符用小写字母，以示区别，#define PRICE 30
 这是因为直接使用类似30的"幻数"不好，这样以后别人无法看懂，而且修改程序将相当困难
*整型常量
1)        十进制整常数：十进制整常数没有前缀。其数码为0～9，
正确：237、-568、65535、1627， 错误：023 (不能有前导0)、23D (含有非十进制数码)。

2)        八进制整常数：八进制整常数必须以0开头，即以0作为八进制数的前缀。数码取值为0～7。八进制数通常是无符号数。
正确：015(十进制为13)、0101(十进制为65)、0177777(十进制为65535)；
错误：256(无前缀0)、03A2(包含了非八进制数码)、-0127(出现了负号)。

3)        十六进制整常数：十六进制整常数的前缀为0X或0x。其数码取值为0~9，A~F或a~f。由于计算机数据都以二进制来进行存放，因此将二进制数据用十六进制表示是非常方便地。

正确：0X2A(十进制为42)、0XA0 (十进制为160)、0XFFFF (十进制为65535)；
错误：5A (无前缀0X)、0X3H (含有非十六进制数码)。

4)        整型常数的后缀：
在16位字长的机器上，基本整型的长度也为16位，因此表示的数的范围也是有限定的。十进制无符号整常数的范围为0～65535，有符号数为-32768～+32767。八进制无符号数的表示范围为0～0177777。十六进制无符号数的表示范围为0X0～0XFFFF或0x0～0xFFFF。如果使用的数超过了上述范围，就必须用长整型数来表示。
 16
2   = 65535

158L表示长整形长整数158L和基本整常数158 在数值上并无区别。但对158L，因为是长整型量，Ｃ编译系统将为它分配4个字节存储空间。而对158，因为是基本整型，只分配2 个字节的存储空间。因此在运算和输出格式上要予以注意，避免出错。

整型常数的无符号数的后缀为“U”或“u”。358u,0x38Au,235Lu，0xFUL均为无符号数。

例：
long l=123; 或者long l=123L

printf("signed long %ld\n",l);
或者
printf("signed long %ld\n",23L);
注意：长整形如果使用%d输出，则会产生溢出错误

*整型变量
相关属性定义在<limits.h>,<float.h>中
1.         整型数据在内存中的存放形式，以二进制进行存储，16位数，表示存储16个单元格

如果定义了一个整型变量i：

int i;

i=10;

在内存中的表示方法
0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 

数值是以补码表示的：

n         正数的补码和原码相同；

n         负数的补码：将该数的绝对值的二进制形式按位取反再加1。

例如：

求-10的补码：

10的原码：
0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 
取反：
1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1
再加1，得-10的补码：
1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0
由此可知，左面的第一位是表示符号的。


2.         整型变量的分类

1)        基本型：类型说明符为int，在内存中占2个字节,一个字节为8位。

2)        短整量：类型说明符为short int或short。所占字节和取值范围均与基本型相同,2个字节。

3)        长整型：类型说明符为long int或long，在内存中占4个字节。

4)        无符号型：类型说明符为unsigned。

无符号型又可与上述三种类型匹配而构成：

n         无符号基本型：类型说明符为unsigned int或unsigned。

n         无符号短整型：类型说明符为unsigned short。

n         无符号长整型：类型说明符为unsigned long。

各种无符号类型量所占的内存空间字节数与相应的有符号类型量相同。但由于省去了符号位，故不能表示负数。

有符号整型变量：最大表示32767
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
无符号整型变量：最大表示65535

1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

下表列出了Turbo C中各类整型量所分配的内存字节数及数的表示范围。

类型说明符         数的范围               字节数
                              15    15
int           -32768~32767即-2  ~（2  -1）     2
                                  16
unsigned int      0~65535  即0~（2  -1）       2
short int     -32768~32767                     2
unsigned short int 0~65535                     2
                                       31    31
long int     -2147483648~2147483647即-2  ~（2  -1） 4 
unsigned long   0~4294967295                        4
 

以13为例：

int型：代表符号位
[0] 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1
short int型：
[0] 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1
long int型：
[0] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1
unsigned int型：
0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1
unsigned short int型：
0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1
unsigned long int型：
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1

             10                                           20     30
各内存大小：2   =1024个字节=1k，即1k大小的内存空间用10位表示，同理，2= 1MB,2  =1GB

 
3.整型数据的溢出
int a = 32767; a++; 得到a=-32768

*实型数据
相关属性定义在<limits.h>,<float.h>中
1、实数只采用十进制。它有二种形式：十进制小数形式，指数形式。没有后缀的浮点数默认为double类型，后缀f表示float类型，后缀L表示long double类型，
                            5                       -2
0.3568,    2.1E5 (等于2.1*10 )    3.7E-2 (等于3.7*10  )  356.0f   356.0L

2、
类型说明符    比特数（字节数） 有效数字 
float            32（4）        6~7
double            64(8)         15~16
long double      128(16)        18~19

而且TurboC规定小数后最多保留六位，其余部分四舍五入 
例：
main()

{

   float a;

   double b;

   a=33333.33333;

   b=33333.33333333333333;

   printf("%f\n%f\n",a,b);

 }

答案：33333.332031;   33333.333333;
由于a 是单精度浮点型，有效位数只有七位。而整数已占五位，故小数二位后之后均为无效数字。
b 是双精度型，有效位为十六位。但Turbo C 规定小数后最多保留六位，其余部分四舍五入

注意：例如c-32，最好写成c-32.0，以强调其浮点性质，便于今后阅读

例：编写程序确定signed以及unsigned限定的char,short,int,long类型变量的取值范围
方式一：从头文件中得到
#include<limits.h>
main()
{
  /*long l=123; 或者long l=123L*/  
  clrscr();
  /*signed types*/
  printf("size of char = %d\n", CHAR_BIT); //得到char类型大小是8位
  printf("signed char min = %d\n", SCHAR_MIN);//得到char类型的取值范围
  printf("signed char max = %d\n", SCHAR_MAX);
  printf("signed short min = %d\n,", SHRT_MIN);
  printf("signed short max = %d\n", SHRT_MAX);
  printf("signed int min = %d\n", INT_MIN);
  printf("signed int max = %d\n",INT_MAX);
  printf("signed long min = %ld,%ld\n",LONG_MIN,23L);
  printf("signed long max = %ld\n",LONG_MAX);
  /*unsigned types*/
  printf("unsigned char max = %u\n", UCHAR_MAX);
  printf("unsigned short max = %u\n", USHRT_MAX);
  printf("unsigned int max = %u\n", UINT_MAX);
  printf("unsigned long max = %lu\n", ULONG_MAX);
  system("pause");
}
方式二：通过位运算得到
#include<limits.h>
#include<stdio.h>
main()
{
  clrscr();
  /*signed types*/
  printf("size of char = %d\n",CHAR_BIT);
  printf("signed char min = %d\n", -(char)((unsigned char)~0>>1));
  printf("signed char max = %d\n", (char)((unsigned char)~0>>1));
  printf("signed short min = %d\n,", -(short int)((unsigned short int)~0>>1));
  printf("signed short max = %d\n", (short int)((unsigned short int)~0>>1));
  printf("signed int min = %d\n", -(int)((unsigned int)~0>>1));
  printf("signed int max = %d\n",(int)((unsigned int)~0>>1));
  printf("signed long min = %ld,%ld\n",-(long int)((unsigned long int)~0>>1),23L);
  printf("signed long max = %ld\n",(long int)((unsigned long int)~0>>1));
  /*unsigned types*/
  printf("unsigned char max = %u\n", (unsigned char)~0);
  printf("unsigned short max = %u\n", (unsigned short int)~0);
  printf("unsigned int max = %u\n", (unsigned int)~0);
  printf("unsigned long max = %lu\n", (unsigned long int)~0);

  system("pause");
}

原理：例如char
0：在内存中存放为00000000 00000000
~0:按位取反，为  11111111 11111111 
(unsigned char)~0：将它强制转为无符号字符数值，它的最大值以二进制表示为
                 11111111 11111111
((unsigned char)~0>>1)：因为要转为有符号字符数值，将它右移一位，去掉符号位
                 [0]1111111 11111111
这个既是有符号字符数值的正值最大值，将它强制转为有符号字符数值最大值
(char)((unsigned char)~0>>1)
它的有符号字符数值最小值
-(char)((unsigned char)~0>>1)


*字符型数据
1、每个字符变量被分配一个字节的内存空间，字符值是以ASCII码的形式存放在变量的内存单元之中的。

Ｃ语言允许对整型变量赋以字符值，也允许对字符变量赋以整型值。在输出时，允许把字符变量按整型量输出，也允许把整型量按字符量输出。

整型量为二字节量，字符量为单字节量，当整型量按字符型量处理时，只有低八位字节参与处理。

在ASCII中，'0'=48,'65'=A,'97'=a

2、字符串常量,在<string.h>中声明了字符串函数
 "C program" 在内存中所占的字节为：
C   p r o g r a m \0

*变量的数据类型转换
1、自动转换<ctype.h>
1)        所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
2)       转换规则：char,short->int->unsigned->long->double,  float->double
3)        在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按（四舍五入）向前舍入。
2、强制转换:
1)        实型赋予整型，直接舍去小数部分。前面的例子已经说明了这种情况。

2)        整型赋予实型，数值不变，但将以浮点形式存放，即增加小数部分(小数部分的值为0)。

3)        字符型赋予整型，由于字符型为一个字节，而整型为二个字节，故将字符的ASCII码值放到整型量的低八位中，高八位为0。整型赋予字符型，只把低八位赋予字符量。


float f=5.75;
printf("(int)f=%d,f=%f\n",(int)f,f);,    结果5， 5.75

*常量类型const
1)const p=48,或者 const p='c'
printf("%c",c);
const char msg[]="hello";表示该数组中的所有元素的值都不能被更改
常量初始化：1、const int a=15;2、fun(const int a);被调用时，赋予实参
2)const涉及指针
查看const究竟指定了何种数据类型为常量，要看const之前的数据类型
int const *a; const之前的数据类型为[int ]，因此，即指定了int是常量，而指针a可以改变

int *const a;const之前的数据类型为[int *]，即指向int型的指针。因此，指针a是常量，而指针a指向的int型数据，内容可以改变

*枚举类型enum boolean{NO, YES}a,b;第一个为0，第二个为1等等......
 同一枚举中，不同的变量，可以有相同的值。如a=YES,b=YES

枚举类型是一种基本数据类型，而不是一种构造类型，因为它不能再包含构造类型，比如struct，或enum，里面再分解为各个基本类型。
1声明
1）enum weekday{ sun,mou,tue,wed,thu,fri,sat };
enum weekday a,b,c;
或者为：
2）enum weekday{ sun,mou,tue,wed,thu,fri,sat }a,b,c;
或者为：
3）enum { sun,mou,tue,wed,thu,fri,sat }a,b,c;
2使用
1）可以在程序中用赋值语句再对它赋值。
例如：对枚举weekday的元素再作以下赋值：
enum weekday
{ sun=2,
  mou=3,
  tue,
  wed,
  thu,
  fri,
  sat
}。

2）枚举元素本身由系统定义了一个表示序号的数值，从0开始顺序定义为0，1，2…。如在weekday中，sun值为0，mon值为1，…,sat值为6。
3）枚举变量的使用
enum weekday{ sun,mon,tue,wed,thu,fri,sat } a,b,c;
a=sun;
b=mon;
c=tue;
printf("%d,%d,%d",a,b,c);
说明：
只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量。如：
a=sum;b=mon;是正确的。
而：a=0;b=1;是错误的。如一定要把数值赋予枚举变量，则必须用强制类型转换。a=(enum weekday)2;

4)还应该说明的是枚举元素不是字符常量也不是字符串常量，使用时不要加单、双引号。


*Static：外部变量，和静态变量默认初始化为0，自变量则为一个无效的值

*extern


*Ｃ语言的运算符可分为以下几类：

1.       算术运算符:用于各类数值运算。包括加(+)、减(-)、乘(*)、除(/)(当操作数都是整数时，结果为整数；当有任何一个是浮点数时，结果即是浮点数)、求余(或称模运算，%)、自增(++)、自减(--)共七种。

2.       关系运算符:用于比较运算。包括大于(>)、小于(<)、等于(==)、 大于等于(>=)、小于等于(<=)和不等于(!=)六种。

3.       逻辑运算符:用于逻辑运算。包括与(&&)、或(||)、非(!)三种。

4.       位操作运算符:参与运算的量，按二进制位进行运算。包括位与(&)、位或(|)、位非(~)、位异或(^)、左移(<<)、右移(>>)六种。

5.       赋值运算符:用于赋值运算，分为简单赋值(=)、复合算术赋值(+=,-=,*=,/=,%=)和复合位运算赋值(&=,|=,^=,>>=,<<=)三类共十一种。

6.       条件运算符:这是一个三目运算符，用于条件求值(?:)。

7.       逗号运算符:用于把若干表达式组合成一个表达式(，)。

8.       指针运算符:用于取内容(*)和取地址(&)二种运算。

9.       求字节数运算符:用于计算数据类型所占的字节数(sizeof)。

10.   特殊运算符:有括号()，下标[]，成员(→，.)等几种。

11.   顺口溜：醋坛酸味灌，味落跳福豆
                        运算符                                     结合性
醋(初等)  　() [] -> .                                            left to right 
坛(单目)　　! ~ ++ -- +正 -负 *指针 &取地址 (type) sizeof长度     right to left 　　
酸(算术)    * / %                                                 left to right 　
          　+ -                                                   left to right
味(位移) 　　<< >>                                                left to right 
灌(关系)　　< <= > >=                                             left to right
        　　== !=                                                 left to right 
味(按位)　　&按位与                                               left to right
        　　^按位异或                                             left to right
        　　|按位或                                               left to right
落(逻辑) 　&&                                                     left to right 　　
           ||                                                     left to right 　　
跳(条件)   ?:                                                     right to left
福(赋值) 　= += -= *= /= %= &= ^= |= <<= >>=                      right to left 
豆(逗号)　　,                                                     left to right
编辑本段三个优先级
　　优先级从上到下依次递减，最上面具有最高的优先级，逗号操作符具有最低的优先级。 　　所有的优先级中，只有三个优先级是从右至左结合的，它们是单目运算符、三目运算符、赋值运算符。其它的都是从左至右结合。 
在表达式中，优先级较高的先于优先级较低的进行运算。而在一个运算量两侧的运算符优先级相同时，则按运算符的结合性所规定的结合方向处理。


12、自增、自减运算符
++i    i自增1后再参与其它运算。 i = i + 1; i = i;

--i    i自减1后再参与其它运算。i = i - 1; i = i;

i++    i参与运算后，i的值再自增1。i = i; i = i+ 1;

i--    i参与运算后，i的值再自减1。i = i; i = i - 1;

例：int i = 2;
printf("%d\n",-i++);
答案：
i = i 即 2;
i = -i 即 -2；
printf -2;
i = i + 1 即 3

printf("%d\n",-i--);
答案：
i = i 即 3;
i = -i 即 -3；
printf -3;
i = i - 1 即 2

例：
main(){

  int i=5,j=5,p,q;

  p=(i++)+(i++)+(i++);

  q=(++j)+(++j)+(++j);

  printf("%d,%d,%d,%d",p,q,i,j);

}
  这个程序中，对P=(i++)+(i++)+(i++)应理解为三个i相加，故P值为15。然后i再自增1三次相当于加3故i的最后值为8。而对于q 的值则不然，q=(++j)+(++j)+(++j)应理解为q先自增1，再参与运算，由于q自增1三次后值为8，三个8相加的和为24，j的最后值仍为8。

int j=1;

int b = ++j + ++j + ++j + ++j + ++j + ++j + ++j;

即 int b = (++j + ++j) + ++j + ++j + ++j + ++j + ++j;
b = 3+3+4+5+6+7+8 = 36, j=8



例：
int i =2, j =3, y;
y = i +++--j;  
即y = (i ++)+(--j); 
y的值为4

13、取模运算符%：不能应用于float或double类型的表达式中,必须要求操作数只能是整数

14、三目运算符
　<表达式1>?<表达式2>:<表达式3>; "?"运算符的含义是: 先求表达式1的值, 如果为真, 则求表达式2 的值并把它作为整个表达式1的值; 如果表达式1 的值为假, 则求表达式3 的值并把它作为整个表达式1的值. 　　例： 　　int a=2; 　　int b=(a==2?2:5); 　　输出b; 　　这样的结果是b为2 

例： 　　int a=1,b=2,z; 　　z=a>b?a:a>b?a:b;//去了括号 　　cout<<"z:"<<z<<endl; 　　这样的输出的结果是：2 　　三目运算中执行方向依次为自右向左。


15、逗号运算符，优先级别最低，它将两式联接起来，如：（3+5,6+8）称为逗号表达式，其求解过程先表达式1，后表达式2，整个表达式值是表达式2的值，如：（3＋5，6＋8）的值是14。（a=3*5,a*4）的值是60 
(1) 逗号表达式的运算过程为：从左往右逐个计算表达式。 
(2) 逗号表达式作为一个整体，它的值为最后一个表达式（也即表达式n）的值。
(3) 逗号运算符的优先级别在所有运算符中最低。

//****************
//程序表达式和算法
//****************
*数据的输入输出
1、输出单个字符putchar('A');    putchar(‘\101’); 也是A
2、输入单个字符
char c;
c=getchar();
putchar(c);
1)       getchar函数只能接受单个字符，输入数字也按字符处理。输入多于一个字符时，只接收第一个字符。
2)       程序最后两行可用下面两行的任意一行代替：
putchar(getchar());
printf(“%c”,getchar());

3、   printf("%d %d\n",a,b);  %%表示打印'%'本身

4、回车时，跳出循环
char c;
while((c=getchar())!='\n'){xxxx}

EOF:代表文件结束，需要使用stdio.h库；当文件输入结束时，推出程序
#include <stdio.h>
int c;//为了在声明C时，让它达到足以存放getchar函数返回的EOF常量
while((c=getchar())!=EOF){xxxx}
实际操作时，以Ctrl+z，再回车，即退出程序

在Turbo C中格式字符串的一般形式为：
      [标志][输出最小宽度][.精度][长度]类型
  其中方括号[]中的项为可选项。
各项的意义介绍如下：
1)       类型：类型字符用以表示输出数据的类型，其格式符和意义如下表所示：

格式字符                      意            义
d               以十进制形式输出带符号整数(正数不输出符号)
o               以八进制形式输出无符号整数(不输出前缀0)
x,X             以十六进制形式输出无符号整数(不输出前缀Ox)
u               以十进制形式输出无符号整数
f               以小数形式输出单、双精度实数
e,E             以指数形式输出单、双精度实数
g,G             以%f或%e中较短的输出宽度输出单、双精度实数
c               输出单个字符
s               输出字符串
2)       标志：标志字符为-、+、#、空格四种，其意义下表所示：
标 志                          意         义
-                结果左对齐，右边填空格
+                输出符号(正号或负号)
空格             输出值为正时冠以空格，为负时冠以负号
#                对c,s,d,u类无影响；对o类,在输出时加前缀o；对x类,在输出时加前缀0x；对e,g,f                  类当结果有小数时才给出小数点
3)       输出最小宽度:用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位         数输出，若实际位数少于定义的宽度则补以空格或0。
4)       精度:精度格式符以“.”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数         点后面小数的位数；如果输出的是字符，则表示全部输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。
5).长度:长度格式符为h,l两种，h表示按短整型量输出，l表示按长整型数据(如%ld) 和双精度浮点数(如%lf)输出。
6)*:字符串或者小数的宽度和精度可以用*表示，例如
  printf("%.*s", max, s); 表示这个字符串输出的长度为max个


示例：
int a=15;
float b=123.1234567;
double c=12345678.1234567;
char d='p';
char s[]="abcdefghijklmn";
printf("a=%d,%5d,%o,%x,%-5d,%+5d,% 5d,%#5o,%#5x\n",a,a,a,a,a,a,a,a,a);
结果:a=15， _ _ _15，17，f,15_ _ _, _ _ _+15,_ _ _15,_ _ 017, _ _ 0xf
printf("b=%f,%lf,%5.4lf,%e\n",b,b,b,b);
结果:b=123.123459,123.123459,123.1235,1.23123e+02
printf("c=%lf,%f,%8.4lf\n",c,c,c);
结果:c=12345678.123457,12345678.123457,12345678.1235
printf("d=%c,%8c,%8.3s\n",d,d,s);
结果：d=p,_ _ _ _ _ _ _ p, _ _ _ _ _abc

4、将输出结果存放到字符串中，而不是输出到屏幕中
char *str,*a="hello ",*b="world!",*c="oh";
sprintf(str,"%s%s%s\n",a,b,c);
printf("%s",str);

5、scanf("%d%d%d",&a,&b,&c);
1)格式字符串的一般形式为：
%[*][输入数据宽度][长度]类型
1)       类型：表示输入数据的类型，其格式符和意义如下表所示。
格式             字符意义
d             输入十进制整数
o             输入八进制整数
x             输入十六进制整数
u             输入无符号十进制整数
f或e      输入实型数(用小数形式或指数形式)
c             输入单个字符
s             输入字符串

2)       “*”符:用以表示该输入项,读入后不赋予相应的变量，即跳过该输入值。
如:
 scanf("%d %*d %d",&a,&b);
当输入为：1   2   3时，把1赋予a，2被跳过，3赋予b。
 scanf("result=%c,%*c,%c",&e,&f);
当输入为：result=o,p,q时，把o赋予e，p被跳过，q赋予f。
3)       宽度:用十进制整数指定输入的宽度(即字符数)。

例如：

    scanf("%5d",&a);

输入：12345678

只把12345赋予变量a，其余部分被截去。

又如：

        scanf("%4d%4d",&a,&b);

输入：12345678

将把1234赋予a，而把5678赋予b。

scanf("result=%d %d",&e,&f);
当输入为：result=44 55时，把ee赋予e，55赋予f。

4)       长度:长度格式符为l和h，l表示输入长整型数据(如%ld) 和双精度浮点数(如%lf)。h表示输入短整型数据。

使用scanf函数还必须注意以下几点：

1)       scanf函数中没有精度控制，如：scanf("%5.2f",&a);是非法的。不能企图用此语句输入小数为2位的实数。

2)       scanf中要求给出变量地址，如给出变量名则会出错。如 scanf("%d",a);是非法的，应改为scnaf("%d",&a);才是合法的。

3)       在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用空格，TAB或回车作间隔。C编译在碰到空格，TAB，回车或非法数据(如对“%d”输入“12A”时，A即为非法数据)时即认为该数据结束。

4)       在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。

例如：

              scanf("%c%c%c",&a,&b,&c);

输入为：

                  d   e   f

则把'd'赋予a, ' ' 赋予b,'e'赋予c。

只有当输入为：

                  def

时，才能把'd'赋于a,'e'赋予b,'f'赋予c。

如果在格式控制中加入空格作为间隔，

如:

scanf ("%c %c %c",&a,&b,&c);

则输入时各数据之间可加空格。

5)       如果格式控制串中有非格式字符则输入时也要输入该非格式字符。

       例如：

scanf("%d,%d,%d",&a,&b,&c);

   其中用非格式符“ , ”作间隔符，故输入时应为：

  5,6,7

又如：

    scanf("a=%d,b=%d,c=%d",&a,&b,&c);

则输入应为：

          a=5,b=6,c=7

6、int sscanf(char *string, "%d%d%d", &a, &b, &c)他将字符串变量string中的
字符串结果分别保存到a，b，c中

*关系表达式
关系表达式的值是真”和“假”，用“1”，或者非0和“0”表示
*选择和循环
1、if (..) 逻辑表达式或关系表达式，或赋值表达式，如(a=b)把b值赋予a，如为非0则输出该值，否则输出                               “a=0”字符串。
   xxxx;
else if ...
   {
     xxxx;
     xxxx;
   }
else
   xxxx;

多条件判断语句：if...or"...and..."，或者用if (c==' ' || c== '\n' || c=='\t')

在if语句的嵌套时，else总是与它前面最近的if配对

2、三目运算符：max=(a>b)?a:b;
即 if(a>b)  max=a;     else max=b;
3、switch语句
main(){

    int a;

    printf("input integer number:    ");

    scanf("%d",&a);

    switch (a){

      case 1:printf("Monday\n");break;

      case 2:printf("Tuesday\n"); break;

      case 3:printf("Wednesday\n");break;

      case 4:printf("Thursday\n");break;

      case 5:printf("Friday\n");break;

      case 6:printf("Saturday\n");break;

      case 7:printf("Sunday\n");break;

      case '0': case '1': case '2': ndigit[c - '0']++; break;

      default:printf("error\n");

    }

}

4、goto语句：标号必须与goto语句同处于一个函数中,但可以不在一个循环层中
   goto用于一次跳出两层或者多层循环，但是范围只限于本函数
   for()
      for()
         for()
         {
            if()
              goto found;
         } 
    found:
          xxxxxxxxxxxx
5、while(表达式)(为真时执行循环)           do 
   {XXXXXXXX}                              {语句}
                                           while(表达式)(为真时继续循环)

for(表达式1；表达式2；表达式3) 
{语句xxxxxxxxxx}
1)       先求解表达式1。
2)       求解表达式2，若其值为真（非0），则执行for语句中指定的内嵌语句，然后执行下面第3）步；若其值为假（0），则结束循环，转到第5）步。
3)       求解表达式3。
4)       转回上面第2）步继续执行。
5)       循环结束，执行for语句下面的一个语句。
6)       for循环中的“表达式1（循环变量赋初值）”、“表达式2(循环条件)”和“表达式3(循环变量增量)”都是选择项, 即可以缺省,但“；”不能缺省。
例：for(sum=0,i=1;i<=100;i++,j--)sum=sum+i;

6、break:break用于开关语句switch中时,可使程序跳出switch而执行switch以后的语句；当break语句用于do-while、for、while循环语句中时,可使程序终止循环而执行循环后面的语句

7、continue语句只用在for、while、do-while等循环体中,作用是跳过循环本中剩余的语句而强行执行下一次循环




//************
//构造数据类型
//************
一个构造类型的值可以分解成若干个“成员”或“元素”。每个“成员”都是一个基本数据类型或又是一个构造类型。在C语言中，构造类型有以下几种：

*数组类型
 数组分为数值数组、字符数组、指针数组、结构数组
1、int a[3+2],b[7+FD];合法，但int n; a[n]非法
2、一维数组：
   a[5.4] 既是表示a[5]的值
   初始化：
1)       可以只给部分元素赋初值。

当{ }中值的个数少于元素个数时，只 给前面部分元素赋值。

例如：

    int a[10]={0,1,2,3,4};

表示只给a[0]～a[4]5个元素赋值，而后5个元素自动赋0值。

2)       只能给元素逐个赋值，不能给数组整体赋值。

例如给十个元素全部赋1值，只能写为：

    int a[10]={1,1,1,1,1,1,1,1,1,1};

而不能写为：

    int a[10]=1;

3)       如给全部元素赋值，则在数组说明中，可以不给出数组元素的个数。

例如：

    int a[5]={1,2,3,4,5};

可写为：

    int a[]={1,2,3,4,5};

3、二维数组：a[行][列]
   初始化：int a[5][3]={ {80,75,92},{61,65,71},{59,63,70},{85,87,90},{76,77,85} };
           int a[5][3]={ 80,75,92,61,65,71,59,63,70,85,87,90,76,77,85};

   1)       可以只对部分元素赋初值，未赋初值的元素自动取0值。

        例如：

        int a[3][3]={{1},{2},{3}};

    是对每一行的第一列元素赋值，未赋值的元素取0值。 赋值后各元素的值为：

        1 0 0

2 0 0

3 0 0 

int a [3][3]={{0,1},{0,0,2},{3}};

赋值后的元素值为:

    0 1 0

0 0 2 

3 0 0 

2)       如对全部元素赋初值，则第一维的长度可以不给出。

        例如：

    int a[3][3]={1,2,3,4,5,6,7,8,9};

可以写为：

int a[][3]={1,2,3,4,5,6,7,8,9};

3)       一个二维数组也可以分解为多个一维数组。
如二维数组a[3][4]，可分解为三个一维数组，其数组名分别为：

a[0]

a[1]

a[2]

对这三个一维数组不需另作说明即可使用。这三个一维数组都有4个元素，例如：一维数组a[0]的元素为a[0][0],a[0][1],a[0][2],a[0][3]。

必须强调的是，a[0],a[1],a[2]不能当作下标变量使用，它们是数组名，不是一个单纯的下标变量。
        
3、字符数组：char c[10];也可以定义为int c[10]但这时每个数组元素占2个字节的内存单元
   初始化char c[]="C program"；
   输入输出：
       输出 char c[]="BASIC\ndBASE"; printf("%s\n",c);//数组名就代表了该数组的首地址,因此不用&c
       输入 char st[15];//对一个字符数组，如果不作初始化赋值，则必须说明数组长度
            scanf("%s",st);//本例中由于定义数组长度为15，因此输入的字符串长度必须小于15，以留出一个字节用于存                           //放字符串结束标志`\0`。字符串中不能含有空格，否则将以空格作为串的结束符。

4、字符串处理函数<string.h>:
    1).字符串输出函数 puts: char c[]="BASIC\ndBASE"; puts(c);
    2).字符串输入函数 gets: char st[15]; gets(st);//gets函数并不以空格作为字符串输入结束的标志，而只以回车作为输入结束。这是与scanf函数不同的。
    3).字符串连接函数strcat(字符数组名1，字符数组名2):strcat(st1,st2);//c，并删去字符串1后的串标志“\0”。本函数返回值是字符数组1的首地址。
       strncat(字符数组名1，字符数组名2, n)把字符数组2中的前n个字符连接到字符数组1 中字符串的后面
    4).字符串拷贝函数strcpy:strcpy(字符数组名1，字符数组名2);把字符数组2中的字符串拷贝到字符数组1中.。串结束标志“\0”也一同拷贝。字符数名2，也可以是一个字符串常量。这时相当于把一个字符串赋予一个字符数组。
       strncpy(s, t, n)类似
    5).字符串比较函数strcmp:strcmp(字符数组名1，字符数组名2);
    功能：按照ASCII码顺序比较两个数组中的字符串，并由函数返回值返回比较结果

          字符串1＝字符串2，返回值＝0；

              字符串1〉字符串2，返回值〉0；

              字符串1〈字符串2，返回值〈0。

本函数也可用于比较两个字符串常量，或比较数组和字符串常量。
      strncmp(s, t, n)类似
   6).测字符串长度函数strlen: int k; k=strlen(st);\\测字符串的实际长度(不含字符串结束标志‘\0’)
   7)strchr(s, c);在字符串s中查找c，若找到，则返回指向它第一次出现的位置指针，否则返回NULL
     strrchr(s, c)在字符串s中查找c，若找到，则返回指向它最后一次出现的位置指针，否则返回NULL

5、字符串测试和转换函数<ctype.h>
   1)isalpha(c)若c是字母，返回非0值，否则返回0
   2）isupper(c)若c是大写字母，返回非0值，否则返回0
   3）islower(c)若c是小写字母，返回非0值，否则返回0
   4）isdigit(c)若c是数字，返回非0值，否则返回0
   5）isalnum(c)若c是字母或数字，返回非0值，否则返回0
   6）isspace(c)若c是空格，制表符，换行符，回车符，换页符等，返回非0值，否则返回0
   7）toupper(c)将c转为大写
   8）tolower(c)将c转为小写
7、数学函数<math.h>
   1）sin(x)，cos(x)  x用弧度表示
   2）atan2(y,x)  y/x的反正切函数
                     x 
   3）exp(x)指数函数e
   4) log(x) x的自然对数(以e为底)，x>10
   5)log10(x) x的常用对数（以10为底），x>10
                  y
   6)pow(x,y)计算x 的值
   7）sqrt(x) x的平方根 x>=10
   8）fabs(x) x的绝对值
   9）随机函数<stdlib.h>  (double) rand() 介于0和RAND_MAX之间
    
8、其它函数
   1）ungetc(int c, FILE *fp)将c写回到文件fp中，成功则返回c，失败则返回EOF。每个文件只能接收一个字符。
      它可以和任何输入函数一起使用，比如scanf，getc，getchar等
   2）命令执行函数system(char *s);执行s所代表的命令，然后继续执行当前程序。
   3）

*结构体类型
“结构”是一种构造类型，它是由若干“成员”组成的。每一个成员可以是一个基本数据类型或者又是一个构造类型。
1、结构的定义
   1)
    struct stu
    {
        int num;
        char name[20];
        char sex;
        float score;
    };
    struct stu boy1,boy2;
   2)
     #define STU struct stu
   STU
   {
        int num;
        char name[20];
        char sex;
        float score;
    };
    STU boy1,boy2;
    3)
    struct stu
    {
        int num;
        char name[20];
        char sex;
        float score;
    }boy1,boy2;
    4)
    struct
    {
        int num;
        char name[20];
        char sex;
        float score;
    }boy1,boy2;
    5)结构嵌套
    struct date
   {
        int month;
        int day;
        int year;
    };
    struct
   {
       int num;
       char name[20];
       char sex;
       struct date birthday;
       float score;
    }boy1,boy2;
2、结构的赋值与初始化
   赋值：boy1.num=102;
         boy1.name="Zhang ping";
         boy1.birthday.month如果成员本身又是一个结构则必须逐级找到最低级的成员才能使用。

   初始化：struct stu    /*定义结构*/
          {
              int num;
              char *name;
              char sex;
              float score;
          }boy2,boy1={102,"Zhang ping",'M',78.5};
3、结构优先级
   struct 
   {
       int len;
       char *str;
   } *p;
   运算符：.   ->    ()   []的运算符最高
   ++p->len 即是++(p->len)，它先将len的值加1,再得到len的值
   (++p)->len,它先将p的值加1，再得到len的值
   (p++)->len，它先得到len的值，再将p加1
   *p->str，它得到str的值
   *p->str++ 即是(*p->str)++，它先得到str的值，再将str加1
   *p++->str,它先得到str的值，再将p加1

4、结构数组：数组的元素也可以是结构类型的。结构数组的每一个元素都是具有相同结构类型的下标结构变量。在实际应用中，经常用结构数组来表示具有相同数据结构的一个群体。如一个班的学生档案，一个车间职工的工资表等。
    struct stu
    {
        int num;
        char *name;
        char sex;
        float score;
    }boy[5]={
             {101,"Li ping","M",45},
             {102,"Zhang ping","M",62.5},
             {103,"He fang","F",92.5},
             {104,"Cheng ling","F",87},
             {105,"Wang ming","M",58};
             }
     当对全部元素作初始化赋值时，也可不给出数组长度。
     使用： 
     for(i=0;i<5;i++)
    {
      s+=boy[i].score;
      if(boy[i].score<60) c+=1;
    }

*共用体类型
有时需要使几种不同类型的变量共用同一段内存单元，而且对不同类型的变量进行赋值时，每次只能存放其中一个变量的数据。新的数据会覆盖从前的内存数据。
用体变量所占内存大小取几个不同类型变量所占内存中最大的那一个。
union 
{ 
int i; 
char ch; 
float f; 
}a={12,’c’,12.5};   /*错误,不能初始化共用体变量*/ 
 a=12;                 /*错误,不能对共用体变量赋值*/ 
 m=a;                  /*错误,不能引用共用体变量名以得到一个值*/ 

它的使用方法与结构体类似
不能用共用体变量作为函数参数（共用体成员可以），也不能使函数带回共用体变量，但可以使用指向共用体变量的指针（与结构体变量这种用法相仿）。 

共用体和结构体可以互相嵌套定义。 

例：建立一张表
                         班级/职称
姓名    编号    职业   班级      职称
tea1    001     教师             pr1
stu1    054     学生    3

 #include <stdio.h> 
 #include <stdlib.h>
 struct 
 { 
     int  num; 
     char name[10]; 
     char job; 
     union    
    { 
      int classa; 班级
      char office[10]; 职称
    }category; 
 }person[2]; 
 void main() 
 { 
    int i; 
    char numstr[20]; 
    for(i=0;i<2;i++) 
    { 
       printf("请输入编号："); 
       gets(numstr); 
       person[i].num=atoi(numstr); 
       printf("请输入姓名："); 
       scanf("%s",person[i].name); 
       getchar(); //用来接收输入姓名后的“回车”符，下同。 
       printf("请输入职业(t/s)："); 
       person[i].job=getchar(); 
       if(person[i].job=='s') 
       { 
           printf("请输入班级号："); 
           scanf("%d",&person[i].category.classa); 
           getchar(); 
       } 
       else if(person[i].job=='t') 
       { 
           printf("请输入职称："); 
           scanf("%s",person[i].category.office); 
           getchar(); 
       } 
    for(i=0;i<2;i++) 
    { 
       printf("%-10d%-11s%",person[i].num,person[i].name); 
       if(person[i].job=='s') 
           printf("\t\t学生"); 
       if(person[i].job=='t') 
           printf("\t\t教师"); 
       if(person[i].job=='s') 
           printf("\t\t%d\n",person[i].category.classa); 
       if(person[i].job=='t') 
           printf("\t\t%s\n",person[i].category.office); 
    } 
 }  

//********
//指针类型
//********
指针类型其值用来表示某个变量在内存储器中的地址
1、地址指针的基本概念
1)指针:也称作地址，是一个常量。根据内存单元的地址编号即可准确地找到该内存单元。允许用一个变量来存放指针，这种变量称为指针变量。一个指针变量可以被赋予不同的指针值，是变量。因此，一个指针变量的值就是某个变量在内存单元的地址，或称为某变量的指针。
例如：*i_pointer=3;


2)我们中约定：“指针”是指地址，是常量，“指针变量”是指取值为地址的变量。定义指针的目的是为了通过指针去访问内存单元。

3)一个指针变量中可以存放一个数组或一个函数等其它数据结构的首地址

4)使用：
  char *p4;定义一个指针变量，而且今后P4 只能指向字符变量
  指针变量的引用:指针变量的赋值只能赋予地址，决不能赋予任何其它数据
  两个有关的运算符：
  &:取地址运算符，其结合性为自右至左，其功能是取变量的地址。它不能作用于表达                  式，常量，或者register类型的变量
  *：指针运算符（或称“间接访问” 运算符,或取内容运算符）:其结合性为自右至左    ，用来表示指针变量所指的变量。在*运算符之后跟的变量必须是指针变量。
    比如int a=12; printf("%d",*a);就会出错

  例：(1)  指针变量初始化的方法
  int a;
  int *p=&a;
  (2)  赋值语句的方法
    int a;
    int *p;
    p=&a;
    或者*p=a;也可以
  (3)使用的方法
    printf("%d",*p);
  (4)把一个指针变量的值(即保存的地址)赋予指向相同类型变量的另一个指针变量
    int a,*pa=&a,*pb;
    pb=pa;    /*把pa所保存的a的地址赋予指针变量pb*/   
    例：
    int x,y，*px=&x;
    y=*px+5;  /*表示把x的内容加5并赋给y*/
    y=++*px;  /*px的内容加上1之后赋给y，++*px相当于++(*px)*/
    y=*px++;  /*相当于y=*px; px++    今后*px将指向一个无效值*/ 
    &*px     是指指针的地址
    *&x      是指x的值  

  问题：
  请对下面再的关于“&”和“*”的问题进行考虑：

   1)       (pointer_1)++和pointer_1++的区别？

2指向数组的指针变量
1)把数组的首地址赋予指向数组的指针变量。
    int a[5],*pa;    
    pa=a; (数组名表示数组的首地址，故可赋予指向数组的指针变量pa)
    pa=&a[0];  /*数组第一个元素的地址也是整个数组的首地址，也可赋予pa*/
    int a[5],*pa=a;采取初始化赋值的方法
2)
int a[10], *p=a;
数组a[i]的地址，或者说它们指向a数组的第i个元素:(p+i),或者(a+i)
数组a[i]的值：a[i],或者p[i],*(a+i),*(p+i)。注意：如p++是合法的；而a++是错误的。pa=a是合法的；而a=pa是错误的。因为a是数组名，它是数组的首地址，是常量
例：
int *p,i,a[10];
p=a;
for(i=0;i<10;i++)
*p++=i;
  p=a;
  for(i=0;i<10;i++)
    printf("a[%d]=%d\n",i,*p++);
注意： *p++，由于++和*同优先级，结合方向自右而左，等价于*(p++)。
       *(p++)与*(++p)作用不同。若p的初值为a，则*(p++)等价a[0]，*(++p)等价a[1]
       *(p--)相当于a[i--]；
       *(++p)相当于a[++i]；
       *(--p)相当于a[--i]。
       (*p)++表示p所指向的元素值加1。

3)加减算术运算:指针变量的加减运算只能对数组指针变量进行，对指向其它类型变量的指针变量作加减运算是毫无意义     的。
      int a[5],*pa;
      pa=a;      /*pa指向数组a，也是指向a[0]*/     pa=pa+2;   /*pa指向a[2]，即pa的值为&pa[2]*/

4) 两个指针变量之间的运算：只有指向同一数组的两个指针变量之间才能进行运算，否则运算毫无意义
      两指针变量相减：两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数。而相加则毫无意义
      两指针变量进行关系运算：指向同一数组的两指针变量进行关系运算可表示它们所指数组元素之间的关系
      例如：
      pf1==pf2表示pf1和pf2指向同一数组元素；
      pf1>pf2表示pf1处于高地址位置；
      pf1<pf2表示pf2处于低地址位置。
      指针变量还可以与0比较。
      设p为指针变量，则p==0表明p是空指针，它不指向任何变量；
      p!=0表示p不是空指针。
      对指针变量赋0值和不赋值是不同的。指针变量未赋值时，可以是任意值，是不能使用的。否则将造成意外错误。而指      针变量赋0值后，则可以使用，只是它不指向具体的变量而已。指针也可以与0进行比较。在程序中常以符号常量NULL来表示0，它是在<stddef.h>中进行定义
 
5)二维数组的指针和指针变量
  int a[3][4]={{0,1,2,3},{4,5,6,7},{8,9,10,11}}
  则a，  a[0]，*(a+0)，*a，&a[0][0] 是第0行元素的首地址
    a+i，a[i]，*(a+i)，    &a[i][0], &a[i] 是第i行元素的首地址
        *a[i]，**(a+i)，   a[i][0],        是第i行元素的第一个元素的值

    &a[i][j]即是一维数组a[i]的j号元素首地址，=a[i]+j=*(a+i)+j，第i行j列元素的地址
    a[i][j]即是一维数组a[i]的j号元素值，=*(a[i]+j)=*(*(a+i)+j)，第i行j列元素的值

  指针变量的定义：int (*p)[4] ，4表示二维数组分解为多个一维数组时，一维数组的 
例：                                长度
main()
{
    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
    int(*p)[4];
    int i,j;
    p=a;
    for(i=0;i<3;i++)
    {
      for(j=0;j<4;j++) 
          printf("%2d  ",*(*(p+i)+j));
      printf("\n");
    }
    printf("\n");}
}



6)数组名作函数参数:
方式一：
void inv(int x[],int n)   /*形参x是数组名*/
方式二：
void inv(int *x,int n)   /*形参x为指针变量*/

使用：
main()
{
  int *p,a[10]={3,7,9,11,0,6,7,5,4,2};
  p = a; 
  inv(a,10);
  或者
  inv(p,10);
}

3、指针数组
整个数组的各个元素的值都为指针
int *pa[3]
例：
main()
{
int a[3][3]={1,2,3,4,5,6,7,8,9};
int *pa[3];
pa[0]=a[0];
pa[1]=a[1];
pa[2]=a[2];
int *p=a[0];
  int i;
  for(i=0;i<3;i++)
  {
      printf("%d,%d,%d\n",a[i][0],*a[i],**(a+i));//得到第i行0列的值    
      printf("%d,%d,%d\n",a[i][2-i],*a[i],*(*(a+i)+i));
  }
      //或者使用*++a来指向一个字符串;
      //而指向该字符串的第一个字符是：(*++a)[0],或者**++a 
      //while(c=*++a[0])遍历这个指向的字符串的字符串的每一个字符
  for(i=0;i<3;i++)
      printf("%d,%d,%d\n",*pa[i],p[i],*(p+i));
}

printf(" %#x  %#x %d %d\n",pa[i],*(pa+i),*pa[i],**(pa+i));
pa[i],*(pa+i)是第i行元素的首地址
*pa[i],**(pa+i)是第i行元素的第一个元素的值
*(pa[i]+1),*(pa[i]+2),*(pa[i]+n)是第i行元素的第n个元素的值


指针数组也常用来表示一组字符串，其初始化更为简单
char *name[]={"Illagal day","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"};

printf("%s",name[3]);
指针数组作指针型函数的参数：
char *day_name(char *name[],int n)
{
  char *pp1,*pp2;
  pp1=*name;
  pp2=*(name+n);
  return((n<1||n>7)? pp1:pp2);
}



4、字符串的指针
1)把字符串的首地址赋予指向字符类型的指针变量
    char *pc;    pc="C Language";
C语言中，可以用两种方法访问一个字符串：
    char string[]=”I love China!”;
    char *string=”I love China!”;
         string= string+10； 输出为"a! "。
2)字符串指针变量比字符数组更好的原因
  (1)字符串指针变量本身是一个变量，用于存放字符串的首地址,而字符数组是由于若干个数组元素组成的，它可用来存放整个字符串。
   因此，赋值时char *ps;  ps="C Language";
   而字符数组需要写成char st[20];  st[]={"C Language"};它的内存空间不能灵活分配
   
5、指针变量作为函数参数:函数的参数不仅可以是整型、实型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。
注意：不能企图通过改变指针形参的值而使指针实参的值改变
swap(int *p1,int *p2)
{
 int *p;
 p=p1;
 p1=p2;
 p2=p;
}

main()
{ 
int a,b;
int *pointer_1,*pointer_2;
scanf("%d,%d",&a,&b);
pointer_1=&a;pointer_2=&b;
/*
  其实在函数swap(int *p1,int *p2)中,只是复制了两个指针p1,p2
  而p1,p2发生改变之后，实参的指针pointer_1,pointer_2并不会改变
*/
if(a<b) swap(pointer_1,pointer_2);
printf("\n%d,%d\n",*pointer_1,*pointer_2);
}

结果：是p1,p2指针指向发生了变化，而*pointer_1,*pointer_2指向却没有变化

解决方法：使用指向指针的指针
/* 标准文档模板 */

#include "Stdio.h"
#include "Conio.h"
void swap(int **p1,int **p2)
{
  int *temp;
  temp=*p1;
  *p1=*p2;
  *p2=temp;
  printf("%d,%d\n",**p1,**p2);
}
int main(void)
{
 /* 此处添加你自己的代码 */
  int a=10,b=20,*point_1=&a,*point_2=&b;
  int *temp;
  printf("%d,%d\n",*point_1,*point_2);
  /* 
    p1,p2是传地址过去的，因此在函数swap(int *p1,int *p2)中
    p1,p2发生改变后，实参的指针pointer_1,pointer_2也发生改变
  */
  swap(&point_1,&point_2);  
  printf("%d,%d\n",*point_1,*point_2);

  getch();
  return 0;
}

结果：是p1,p2指针指向发生了变化，而*pointer_1,*pointer_2指向也发生改变


6、指向函数的指针
函数的入口地址赋予指向函数的指针变量。
    int (*pf)(); pf=func;     /*func为函数名*/
一个函数总是占用一段连续的内存区，而函数名就是该函数所占内存区的首地址。我们可以把函数的这个首地址赋予一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以找到并调用这个函数。我们把这种指向函数的指针变量称为“函数指针变量”。
定义：int(*pmax)(), z;
      int (*comp)(void *, void *)comp是一个指向函数的指针，该函数有两个void*类型的参数，其返回值为int
赋值：pmax=max; /*max是一个函数名称，max函数返回最大的一个值*/
使用：z=(*pmax)(x,y);
函数指针变量不能进行算术运算，数组指针变量加减一个整数可使指针移动指向后面或前面的数组元素，而函数指针的移动是毫无意义的。

7、指针型函数：函数的返回值是一个指针(地址)注意，函数返回值需要是地址，而不是值
char *day_name(int n)
{xxxxxxxxxxxxxxxxxxxxx}

main()
{
  int i;
  printf("Day No:%2d-->%s\n",i,day_name(i));
}

8、指向指针的指针，一般用于指针数组的使用中
指向指针的指针变量            指针数组变量       变量
保存指针数组变量地址  -->     保存变量地址  -->   值

main()
{
char *name[]={"Follow me","BASIC","Great Wall","FORTRAN","Computer desighn"};
char **p;
int i;
for(i=0;i<5;i++)
{
  p=name+i;  保存指针数组变量地址
  将该指针数组所保存的变量地址赋予%s，输出该字符串例如“Great Wall”
  printf("%s\n",*(name+i));
  p的值是该指针数组变量地址,*p的值是将该指针数组所保存的值，即一个变量的地址  ；将它赋予%s，输出该字符串例如“Great Wall”；**p是该字符串的第一个字符G
  printf("%s %c\n",*p,**p);

}

}

9、指向结构变量的指针
结构指针变量中的值是所指向的结构变量的首地址，通过结构指针即可访问该结构变量
1)声明与赋值
    struct stu
    {
        int num;
        char name[20];
        char sex;
        float score;
    }boy1,boy2，*pstu2;
    struct stu *pstu;
    
    pstu=&boy1;
    pstu2=&boy2;
    注意： pstu=&stu是错误的,pstu=&boy[1].sex;也是错误的
    注意：结构体变量名不是指向该结构体的地址，这与数组名的含义不同，结构体中          第一个成员的首地址是&[结构体变量名]

    
2）使用其成员：(*pstu).num，或者 pstu->num

3）指向结构数组的指针
指针变量可以指向一个结构数组，这时结构指针变量的值是整个结构数组的首地址。结构指针变量也可指向结构数组的一个元素，这时结构指针变量的值是该结构数组元素的地址。

设ps为指向结构数组的指针变量，则ps也指向该结构数组的0号元素，ps+1指向1号元素，ps+i则指向i号元素。这与普通数组的情况是一致的。

struct stu
{
    int num;
    char *name;
    char sex;
    float score;
}boy[5]={
          {101,"Zhou ping",'M',45},
          {102,"Zhang ping",'M',62.5},
          {103,"Liou fang",'F',92.5},
          {104,"Cheng ling",'F',87},
          {105,"Wang ming",'M',58},
        };
for(ps=boy;ps<boy+5;ps++)//ps=boy是ps被赋予boy的首地址，或者使用ps=&boy[0]；然后循环5次，输出boy数组中各成员值
    printf("%d\t%s\t\t%c\t%f\t\n",ps->num,ps->name,ps->sex,ps->score);//使用它的成员

注意：ps=&boy[1].sex;是错误的

4）结构指针变量作函数参数
struct stu
{
    int num;
    char *name;
    char sex;
    float score;
}boy[5]={
          {101,"Zhou ping",'M',45},
          {102,"Zhang ping",'M',62.5},
          {103,"Liou fang",'F',92.5},
          {104,"Cheng ling",'F',87},
          {105,"Wang ming",'M',58},
        };

void ave(struct stu *ps);//函数声明

struct stu *ps;
ps=boy;

ave(ps);//使用函数

10、 动态分配内存空间，释放内存空间
1)可以在程序运行时，动态用一个变量来分配内存空间
分配一块内存空间：malloc
char *ps;
int n=100;//表示分配100个字节的内存空间
ps=(char *)malloc(n);//表示分配100个字节的内存空间，并强制转换为字符数组类型，即数组有100块的字符内存块，函数的返回值为指向该字符数组的指针，把该指针赋予指针变量ps

2)连续分配三块内存空间：alloc
//sizeof(struct stu)，或者sizeof(stu1对象名)是求stu的结构长度所占内存空间的字节数
//例如数组struct stu keytab={1,2,3,4},则要得到数组keytab的行数
//方法一：sizeof(keytab)/sizeof(struct stu)
//方法二：sizeof(keytab)/sizeof(keytab[0])这种方法更好，因为这样，即使类型改//变了，也不需要改程序
char *ps;
int n=sizeof(struct stu);//表示分配一个stu的长度的内存空间
int m=3;
ps=(struet stu*)alloc(m,n);//按stu的长度分配3块连续区域，强制转换为stu类型，即有3块stu的内存块，并把其首地址赋予指针变量ps。


3)将内存区空间数据清除函数memset
//把内存区p_addr的1024个字节，全部清除，用'\0'来代替
char *p_addr
memset(p_addr,'\0',1024);
//把内存区buf_r的sizeof(buf_r)个字节，全部清除，用数字0来代替
char buf_r[100];
memset(buf_r,0,sizeof(buf_r));

4)释放内存空间函数free
  struct stu
  {
      int num;
      char *name;
      char sex;
      float score;
    }  *ps;
    ps=(struct stu*)malloc(sizeof(struct stu));
    ps->num=102;
    ps->name="Zhang ping";
    ps->sex='M';
    ps->score=62.5;
    printf("Number=%d\nName=%s\n",ps->num,ps->name);
    printf("Sex=%c\nScore=%f\n",ps->sex,ps->score);
    free(ps);

11、链表
比如登记学生花名册，如果用结构数组来进行登记，
则有缺点：预先不能准确把握学生人数，也就无法确定数组大小。
          而且当学生留级、退学之后也不能把该元素占用的空间从数组中释放出来。
          必须占用一块连续的内存区域才可以分配 

好的方法是使用动态分配内存空间，形成一个链表，以保存数据
#define NULL 0
struct stu//定义一个结构体，里面保存一个学生的详细信息
{
  int num;//学生数据信息
  int age;
  struct stu *next;//一个结构体指针，指向下一个学生节点的地址
};
//函数作用是建立一个链表，链表由n个节点组成
struct stu *create(int n)//参数n表示这个链表要建立几个节点
{
  //head为头指针，pf为指向两相邻结点的前一结点的指针变量。pb为后一结点的指针变量。
  struct stu *head,*pf,*pb;
  int i;
  for(i=0;i<n;i++)//创建链表
  {
    //由指针pb申请分配一块内存用于保存一个studen结构的节点
    pb=(struct stu*)malloc(sizeof(struct stu));
    printf("input Number and Age\n");
    //往这个节点内写入需要保存的数据信息
    scanf("%d%d",&pb->num,&pb->age);
    if(i==0)//如果这是第一个节点
      pf=head=pb;//指针pf,head(头指针)同时指向指针pb所指向的第一个节点的地址
    else//如果这是以后几个节点
      pf->next=pb;//为本节点指向下一个学生节点的地址
    pb->next=NULL;
    pf=pb;//指针pf定位到新节点的位置
  }
  return(head);//返回该链表的头结点位置
}
main()
{
  struct stu *now;
  now=create(5);//指针指向该链表的头结点位置
  for(;now->next!=NULL;now=now->next)//指针now遍历该链表的所有节点节点
  {
    //得到节点数据
    printf(" now num=%d,age=%d,adress=%#x\n",now->num,(*now).age,now->next);
    //释放节点
    free(now);
  }
  printf(" now num=%d,age=%d,adress=%#x\n",now->num,(*now).age,now->next);
  free(now);

  system("pause");
}



12、类型定义符typedef
由用户为数据类型取“别名”,这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。其中原类型名中含有定义部分，新类型别名一般用大写表示

概念精讲：typedef用来声明一个别名，typedef后面的语法，是一个声明。本来笔者以为这里不会产生什么误解的，但结果却出乎意料，产生误解的人不在少数。罪魁祸首又是那些害人的教材。在这些教材中介绍typedef的时候通常会写出如下形式： typedef int PARA; 这种形式跟#define int PARA几乎一样，如前面几章所述，这些教材的宗旨是由浅入深，但实际做出来的行为却是以偏盖全。的确，这种形式在所有形式中是最简单的，但却没有对 typedef进一步解释，使得不少人用#define的思维来看待typedef，把int与PARA分开来看，int是一部分，PARA是另一部分，但实际上根本就不是这么一回事。int与PARA是一个整体！就象int i:声明一样是一个整体声明，只不过int i定义了一个变量，而typedef定义了一个别名。这些人由于持有这种错误的观念，就会无法理解如下一些声明： typedef int a[10]; typedef void (*p)(void); 他们会以为a[10]是int的别名，(*p)(void)是void的别名，但这样的别名看起来又似乎不是合法的名字，于是陷入困惑之中。实际上，上面的语句把a声明为具有10个int元素的数组的类型别名，p是一种函数指针的类型别名。 虽然在功能上，typedef可以看作一个跟int PARA分离的动作，但语法上typedef属于存储类声明说明符，因此严格来说，typedef int PARA整个是一个完整的声明。 
定义一个函数指针类型。 
1、比如原函数是 void func(void);
2、定义它的一个指向函数的指针就是void (*f)(void);
3、那么为该定义的函数指针重命名就是typedef void (*Fun)（void);  即用新类型名字Fun 来代表void (*f)(void);
4、然后用这个新类型，定义一个指向函数的指针(类似于定义变量)： Fun func1;即用funcl来代表void (*f)(void);
5、当用func1获取函数地址：赋值语句即是func1=func;
6、可以像调用原函数那样来使用这个函数指针： func1(void);即是fun(void)

在采用多模块程序设计时，如果不同的模块程序员文件中用到同一类型的复杂数据时(像数组，指针，结构，联合),经常用typedef将这些数据重新定义，并放到一个单独的文件中，需要时，再通过include将它们包含进来

1)定义简单类型：
typedef int INTEGER
INTEGER a;即等效于int a

注意：typedef 就像 auto，extern，mutable，static，和 register 一样，是一个存储类关键字。因此定义的时候，不能重复声明
typedef register int FAST_COUNTER; // 错误

2)定义数组：用类型名替代变量名
typedef char NAME[20]表示NAME是字符数组类型，数组长度为20
NAME a1,a2,s1,s2;即等效于 char a1[20],a2[20],s1[20],s2[20]

typedef int INT_ARRAY_10[10];
typedef int INT_ARRAY_20[20];
INT_ARRAY_10 a，b，c，d; 即int a[10], int b[10]，int c[10]， int d[10]
INT_ARRAY_20 e;即 int e[20]


3)typedef和结构结合使用：
typedef struct stu
{ char name[20];
  int age;
  char sex;
} STU;
这语句实际上完成两个操作：
　　(1) 定义一个新的结构类型stu
    (2) typedef为这个新的结构起了一个名字，叫STU,
        即typedef struct stu STU;
定义一个：指向该结构的类型
定义：
STU body1,body2;
使用：
return (struct stu)malloc(sizeof(STU));

再定义一个：指向该结构的指针
typedef struct stu *Sptr;
定义：
Sptr stu_node;
使用：
return (Sptr)malloc(sizeof(STU));

4)为指针定义简洁的名称 :
(1)在有指针的场合,typedef要比#define要好,为数据指针定义新的名称。
因此，编程一般都遵循#define定义“可读”的常量以及一些宏语句的任务，而typedef则常用来定义关键字、冗长的类型的别名。
typedef char * pStr1;
#define pStr2 char *;
pStr1 s1, s2;   即char *s1, char *s2
pStr2 s3, s4;   即 char *s3,s4,出错
int mystrcmp(pstr,pstr);

注意：
typedef char * pstr;
int mystrcmp(const pstr, const pstr); 
这是错误的，按照顺序，‘const pstr’应该被解释为‘char * const’（一个指向 char 的常量指针），而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：
typedef const char * cpstr; 
int mystrcmp(cpstr, cpstr); // 现在是正确的




(2)为函数指针定义新的名称:在传统的变量声明表达式里用类型名替代变量名


(3)typedef & 复杂的变量声明:对复杂变量建立一个类型别名的方法很简单，你只要在传统的变量声明表达式里用类型名替代变量名，然后把关键字typedef加在该语句的开头就行了。 
这样，在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。
理解复杂声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。

例：单个复杂变量声明
 int *(*a[5])(int, char*);
//变量名为a，需要直接用一个新别名pFun替换a

//如果pFun是我们需要建的一个类型别名，则用类型别名替代变量名，然后加上typedef
typedef int *(*pFun)(int, char*); 

//别名的使用：
pFun a[5]; 即等价于int* (*a[5])(int, char*);


typedef int (*PFI)(char *, char *);
PFI strcmp, numcmp; 
即(*strcmp)(char *, char *)； (*numcmp)(char *, char *)

例：多个复杂变量声明
void (*b[10]) (void (*)());
变量名为b,按照“右左法则”：
首先替换右边部分括号里的，为函数参数(void (*)())进行声明替换：
typedef void (*pFunParam)();

再替换左边的变量b：typedef void (*pFun)(pFunParam);
使用：pFun b[10];   即void (*b[10]) (void (*)());

doube(*)() (*pa)[9]; 
变量名为pa，按照“右左法则”,右边无需替换，则替换左边部分，
为部分函数doube(*)()进行声明：typedef double(*pFun)();

最后为整体进行声明：typedef pFun (*pFunParam)[9];
使用：pFunParam pa;   即doube(*)() (*pa)[9];



5)包含链表形式的结构体：
方法一：
struct tagNode
{
　char *pItem;
　struct tagNode *pNext;
};
typedef struct tagNode *pNode;
方法二：
typedef struct tagNode 
{
　char *pItem;
　struct tagNode *pNext;
} *pNode;
错误做法：
typedef struct tagNode
{
　char *pItem;
　pNode pNext;//这个类型的新名字也还不存在，报错
} *pNode; 

13、链表进阶
1)单链表操作
/* 标准文档模板 */

#include "Stdio.h"
#include "Conio.h"

typedef struct STU
{
  char name[20];
  char stuno[10];
  int age;
  int score;
}ElemType;

struct LNODE
{
  ElemType data;
  struct LNODE *next;
};

typedef struct LNODE LNode;
typedef struct LNODE *LinkList;

/*初始化链表*/
/*
L用指针，是因为可以将LinkList类型看作一个普通类型，这样
LinkList Lb只是复制一个数据变量，进行操作而已；
而LinkList *L是传地址，因此可以保存L的值，如果不使用
指针类型LinkList，而是用实体类型LNode的话，则参数就使用
指向指针的指针了LNode **L
这样，在main函数中，La就必须需要传地址了init(&La)
具体，可以看"5、指针变量作为函数参数"
*/
int init(LinkList *L)
{
  *L=(LNode *)malloc(sizeof(LNode)); /*用malloc函数分配节点*/
  if(!L) exit(1);/*若分配失败，返回*/
  (*L)->next=NULL;
  return 1;
}

/*查找第i个节点的值*/
ElemType *GetElem(LinkList L,int i)
{
  LinkList p;
  int j;
  p=L->next;  /*初始化，p指向链表的第一个节点*/
  j=1;
  while(p&&j<i) /*测试i是否过大，来判断p是否为空来确定是否达到链表的尾部*/
  {
    p=p->next;
    ++j;
  }

  if(!p||j>i) return 0;/*若第i个元素不存在，返回*/

  return &(p->data);

}
/*插入第i个节点*/
int ListInsert(LinkList L,int i,ElemType e)
{
  LinkList p,s;
  int j;
  p=L;  /*初始化，p指向链表的头指针，插入元素可能在链表头，j为计数器*/
  j=1;

  while(p&&j<i) /*测试i是否过大，来判断p是否为空来确定是否达到链表的尾部*/
  {
    p=p->next;
    ++j;
  }

  if(!p||j>i) return 0;/*若第i个元素不存在，返回*/

  s=(LNode *)malloc(sizeof(LNode)); /*用malloc函数分配节点*/
  if(!L) exit(1);/*若分配失败，返回*/
  s->data=e;
  s->next=p->next;
  p->next=s;
  p=s;
  return 1;
}

/*注意：删除第i个节点类似，但是删除的这个节点的next指针要置空*/

/*比较两个节点之间，哪个比较大*/
int Less_Equa(ElemType *e1,ElemType *e2)
{
  if(strcmp(e1->name,e2->name)<=0)
    return 1;
  else
    return 0;
}
/*合并两个链表*/
/*
Lc用指针，是因为可以将LinkList类型看作一个普通类型，这样
LinkList Lb只是复制一个数据变量，进行操作而已；
而LinkList *Lc是传地址，因此可以保存Lc的值
*/
void hebingList(LinkList La, LinkList Lb, LinkList *Lc)
{
  LinkList pa,pb,pc;
  pa=La->next;/*指向La的第一个数据节点*/
  pb=Lb->next;/*指向Lb的第一个数据节点*/
  pc=La;
  (*Lc)=pc;
  while(pa&&pb)/*两个节点是否有一个到达末尾*/
  {
    /*将两个链表，按顺序连接到Lc中*/
    if(Less_Equa(&(pa->data),&(pb->data)))
    {
    pc->next=pa;
    pc=pa;
    pa=pa->next;
    }
    else
    {
    pc->next=pb;
    pc=pb;
    pb=pb->next;
    }
  }
  /*将剩余一个链表的余下节点全部存到Lc中*/
  pc->next=pa?pa:pb;
  free(Lb);
}

/*遍历，打印各节点*/
int PrintList(LinkList L)
{
  int i;
  LinkList p;
  p=L;
  while(p->next)
  {
    p=p->next;
    printf("%-10s %s\t%d\t%d\n",p->data.name,p->data.stuno,p->data.age,p->data.score);
  }
}

int main(void)
{
 /* 此处添加你自己的代码 */
  ElemType e,f;
  LinkList La,Lb,Lc;
  clrscr();
  printf("First La is InsertList function\n");
  /*初始化第一个链表指针*/
  init(&La);
  strcpy(e.name,"stu1");
  strcpy(e.stuno,"01");
  e.age=25;
  e.score=133;
  /*在第一个链表中插入第一个节点*/
  ListInsert(La,1,e);
  strcpy(e.name,"stu4");
  strcpy(e.stuno,"04");
  e.age=28;
  e.score=103;
  /*在第一个链表中插入第二个节点*/
  ListInsert(La,2,e);
  strcpy(e.name,"stu6");
  strcpy(e.stuno,"06");
  e.age=21;
  e.score=114;
  /*在第一个链表中插入第三个节点*/
  ListInsert(La,3,e);
  PrintList(La);

  /*查找第一个节点的值*/
  f=*GetElem(La,1);
  printf("第1个节点的值是\n");
  printf("%-10s %s\t%d\t%d\n",f.name,f.stuno,f.age,f.score);

  printf("Second Lb is InsertList function\n");
  /*初始化第二个链表指针*/
  init(&Lb);
  strcpy(e.name,"stu2");
  strcpy(e.stuno,"02");
  e.age=20;
  e.score=122;
  /*在第一个链表中插入第一个节点*/
  ListInsert(Lb,1,e);
  strcpy(e.name,"stu5");
  strcpy(e.stuno,"05");
  e.age=25;
  e.score=153;
  /*在第一个链表中插入第二个节点*/
  ListInsert(Lb,2,e);
  strcpy(e.name,"stu7");
  strcpy(e.stuno,"07");
  e.age=27;
  e.score=174;
  /*在第一个链表中插入第三个节点*/
  ListInsert(Lb,3,e);
  strcpy(e.name,"stu8");
  strcpy(e.stuno,"08");
  e.age=28;
  e.score=183;
  /*在第一个链表中插入第四个节点*/
  ListInsert(Lb,4,e);
  strcpy(e.name,"stu9");
  strcpy(e.stuno,"09");
  e.age=29;
  e.score=189;
  /*在第一个链表中插入第九个节点*/
  ListInsert(Lb,5,e);
  PrintList(Lb);

  printf("Third Lc is InsertList function\n");
  /*合并两条链表La，Lb，到链表Lc中*/
  hebingList(La, Lb, &Lc);
  PrintList(Lc);
  getch();
  return 0;
}
2)单向循环链表：最后一个节点的next指向第一个节点
3)双向链表：每个节点都能指向它的前面，和后面节点，双向循环链表
struct LNODE
{
  ElemType data;
  struct LNODE *next;
  struct LNODE *priv;
};

4)树与二叉树
树是由n个节点组成的，n=0是空树，n=1时，只有一个根。
节点的度：节点的分支数
树的度：树中所有节点度的最大值
终端节点：即叶子，度为0。，非终端节点：即枝，度不为0。
节点的层次：树中根节点的层次为1，其余的以此类推
树的深度：树中所有节点层次的最大值
有序树，无序树：树中每棵子树从左到右的排列有一定顺序称为有序树，否则即无序树
树林：多棵树的集合
节点之间的关系：孩子，双亲，子孙，祖先，兄弟
二叉树的5种形态：
Φ  o   o  o      o
       /    \    / \
      o      o  o   o
满二叉树        完全二叉树
   o                o
  / \              / \
 o   o            o   o
/ \ / \          / \ / \ 
o o o o          o o o

遍历：
先序遍历：根->左子树->右子树
中序遍历：左子树->根->右子树
后序遍历：左子树->右子树->根

二叉树的构建方法
/* 标准文档模板 */

#include "Stdio.h"
#include "Conio.h"
typedef struct TNode
{
  char data;
  struct TNode *lchild;
  struct TNode *rchild;
}Node;

/*初始化链表*/
/*
node用指针，是因为可以将Node类型看作一个普通类型，这样
Node *node只是复制一个数据变量，进行操作而已；
而Node **node是指向指针的指针.它传地址，因此可以保存node的值
这样，在main函数中，root就必须需要传地址了init(&root)
*/
void init(Node **node)
{
  *node=(Node *)malloc(sizeof(Node));
  (*node)->lchild=(*node)->rchild=NULL;
  (*node)->data=0;
}

/*二叉树构建函数，data是节点数据，**node是根节点*/
void construct(char data,Node **node)
{
  int i;
  Node *temp_node=*node;
  while(temp_node)
  {
    /*判断该节点数据值是否为空，若为空，则这个是根节点，进行根节点赋值*/
    if(!temp_node->data)
    {
      temp_node->data=data;
      break;
    }
    /*若要插入的数据小于该节点，则进入循环体*/
    else if(data<=temp_node->data)
    {
      /*若该节点的左孩子为空，则初始化左孩子*/
      if(!temp_node->lchild)
      {
        init(&temp_node->lchild);
        temp_node->lchild->data=data;
        break;
      }
      /*若该节点的左孩子非空，则继续比较*/
      else
      {
        temp_node=temp_node->lchild;
        continue;
      }
    }
    else if(data>temp_node->data)
    {
      /*若该节点的右孩子为空，则初始化右孩子*/
      if(!temp_node->rchild)
      {
        init(&temp_node->rchild);
        temp_node->rchild->data=data;
        break;
      }
      /*若该节点的左孩子非空，则继续比较*/
      else
      {
        temp_node=temp_node->rchild;
        continue;
      }
    }
  }
  return;
}

/*先序遍历*/
int PreOrder(Node *tree_node)
{
  if(tree_node)
  {
    /*遍历根节点*/
    if(printf("%c ",tree_node->data))
       /*遍历左子树*/
       if(PreOrder(tree_node->lchild))
          /*遍历右子树*/
         if(PreOrder(tree_node->rchild))
            return 1;
     return 0;
  }
  else
    return 1;
}

/*中序遍历*/
int InOrder(Node *tree_node)
{
  if(tree_node)
  {
    /*遍历左子树*/
    if(InOrder(tree_node->lchild))
      /*遍历根节点*/
      if(printf("%c ",tree_node->data))
          /*遍历右子树*/
     if(InOrder(tree_node->rchild))
            return 1;
     return 0;
  }
  else
    return 1;
}

/*后序遍历*/
int NextOrder(Node *tree_node)
{
  if(tree_node)
  {
    /*遍历左子树*/
    if(NextOrder(tree_node->lchild))
       /*遍历右子树*/
       if(NextOrder(tree_node->rchild))
         /*遍历根节点*/
         if(printf("%c ",tree_node->data))
            return 1;
     return 0;
  }
  else
    return 1;
}

/*统计该树的叶子节点*/
int leaf_num(Node *tree_node, int *count)
{
  if(tree_node)
  {
    /*遍历根节点*/
    if(!tree_node->lchild&&!tree_node->rchild)
       (*count)++;
    /*遍历左子树*/
    if(leaf_num(tree_node->lchild,count))
       /*遍历右子树*/
       if(leaf_num(tree_node->rchild,count))
          return 1;
     return 0;
  }
  else
    return 1;
}

/*统计该树的高度*/
int tree_high(Node *tree_node)
{
  int h1,h2;
  if(!tree_node)
    return -1;
  else
  {
    /*后序遍历左子树，求出左子树的高度*/
    h1=tree_high(tree_node->lchild);
    /*后序遍历右子树，求出右子树的高度*/
    h2=tree_high(tree_node->rchild);
    return h1>h2?(h1+1):(h2+1);
  }
}

int main(void)
{
 /* 此处添加你自己的代码 */
  int i,count=0;
  Node *root;
  char data[8]={'e','f','h','g','a','c','b','d'};
  init(&root);
  /*二叉树构建糊*/
  for(i=0;i<8;i++)
    construct(data[i],&root);

  clrscr();
  /*树的遍历*/
  printf("PreOrder\n");
  PreOrder(root);/*先序遍历*/
  printf("\nInOrder\n");
  InOrder(root);/*中序遍历*/
  printf("\nNextOrder\n");
  NextOrder(root);/*后序遍历*/

  /*叶子统计*/
  leaf_num(root, &count);
  printf("\n lead num count=%d\n",count);
  /*统计该树的高度*/
  printf("tree high count=%d\n",tree_high(root));
  getch();
  return 0;
}


5)红黑树
6)哈希表
基本概念:在链表和树中，如果要找到一个特定关键字的数据，就需要对各个节点进行比较，效率不高。而为了能迅速找到所需要的记录，最直接的方法是：一个关键字，f(关键字)函数：得到这个关键字所存储的位置。
例：
关键字             1   2   3  
存储位置(在第几条) 87  68  52

哈希表的构造方法：
(1)直接定址法：f(关键字)=关键字，注意，关键字要尽量找不会发生冲突的数字
关键字             1   2   3  
存储位置(在第几条) 1   2   3 
(2)折叠法：将数字分成相同位数的几部分，然后取这几部分的叠加和，而且舍去进位。
例如：关键字为：图书编码04-5240-6025       04-2258-2102
                  04+5240+6025=11269    04+2258+2102=4364
      存储位置(在第几条)：1269(舍去进位)     4364
(3)取模法：f(关键字)=关键字%p, p为一随机的，不大于哈希表表长的数
(4)随机数法:f(关键字)=random(关键字);  

哈希表处理冲突的方法：如果哈希表产生的关键字发生了冲突，用如下方法得到其它位置，如果这个方法又有冲突，则不断选下一个，直到找到为止。
例：
关键字为：                          60 17 29 
存储位置(在第几条)： 0   1  2  3  4  5  6  7  8  9  10

要插入38，而通过哈希函数f(38)=5,产生冲突。
可以看出，表长m=11

(1)开放地址法：Hi=(原存储位置+di)% 表长 
di的值：1，2，3，..m-1称为线性探测再散列
Hi=(5+1)%11=6冲突，Hi=(5+2)%11=7冲突，Hi=(5+8)%11=8可用
关键字为：                          60 17 29 38 
存储位置(在第几条)： 0   1  2  3  4  5  6  7  8  9  10

di的值：1,-1,2,-2,4,-4,9,-9,16,-16,...k*k,-k*k称为二次探测再散列
di的值：随机数数列，称为随机探测再散列

(2)再哈希法：使用第二个，第三个哈希函数计算地址，直到无冲突为止
(3)链地址法：将所有发生冲突的关键字链接在同一位置的线性链表中
位置 链表
 0
 1->14->41->25
 2->50->12->7
..
 5->60->38
 6->17
 7->29
(4)建立公共溢出区：另外设立存储空间来处理哈希冲突 

14、main函数的参数
Ｃ语言规定main函数的参数只能有两个，习惯上这两个参数写为argc和argv。而且argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。加上形参说明后，main函数的函数头应写为：
    main (int argc,char *argv[])
而argc参数表示了命令行中参数的个数(注意：文件名本身也算一个参数)，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的，因此不用输入，需要输入的只是实际参数即可
使用时：
在运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数
例如：
main(int argc,char *argv)
{
  while(argc-->1)
      printf("%s\n",*++argv);
}
输入C:\>a:e24 BASIC foxpro FORTRAN 
则运行结果为：
BASIC
foxpro
FORTRAN




//******
//空类型
//******
1、如果函数没有返回值，那么应声明为void类型：
函数头为：int max(int a,int b);这个返回的函数值是具有一定的数据类型的，应在函数定义及函数说明中给以说明。但是，也有一类函数，调用后并不需要向调用者返回函数值，这种函数可以定义为“空类型”。其类型说明符为void。
无返回值的函数
void xx（xxxx）          main()
{                        {
 ......                    ..........
 return;                   return; 或者return 0; 
}                         }
                          表示main像程序的执行环境返回一个值，0表示正常终止，非0表示异常
2、如果函数无参数,那么应声明其参数为void：
int xx(void)代表不接受任何参数
{};
3、如果函数的参数可以是任意类型指针，那么应声明其参数为void * 
void * memcpy(void *dest, const void *src, size_t len); 因为该指针函数的返回值是一个地址，因此可以设为void*　
void * memset ( void * buffer, int c, size_t num ); 

//****
//函数
//****
*函数之间的值传递可以通过参数，返回值，以及全局变量进行
*如果函数没有参数，则用void表示
例如int copy(void){XXXXXXXXX}
*返回值：如函数返回值为整型，在函数定义时可以省去类型说明
*函数声明：如果被调函数的返回值是整型或字符型时，可以不对被调函数作说明，而直接调用。
声明方式：int max(int a,int b);或者int max(int,int);
*数组作为函数参数:
 1、数组元素作函数实参：数组元素的值传送给形参，实现单向的值传送
  for(i=0;i<5;i++)
      {scanf("%d",&a[i]);
  nzp(a[i]);函数内部值的变化，不影响主调函数
 2、 数组名作为函数参数：void nzp(int a[8]),或者void nzp(int a[])，
     或者void nzp(int a[]，int n)n值动态地表示数组的长度
     或者使用多维数组int MA(int a[3][10])，int MA(int a[][10])。
     nzp(b[2]);是传b[2]的值，为单向传递，形参不影响实参；
     nzp(b);是传该数组的首地址，为双向传递，形参影响实参；
*作用域：
     1、局部变量：复合函数内也可以使用局部变量
main()

{

    int i=2,j=3,k;

    k=i+j;

    {

      int k=8;

      printf("%d\n",k);//k=8

    }

    printf("%d\n",k);//k=5

}
     2、全局变量：全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它的使用范围是整个源程序。它的作用域是从它的定义开始，直到最后一行。外部变量与局部变量同名，则在局部变量的作用范围内，外部变量被“屏蔽”，即它不起作用。
     int a,b/*外部变量*/
     void f1()
     { 
       声明外部变量x,y; 再使用extern x,y;
       直接使用外部变量a,b;
     }
     int x,y /*外部变量*/
     void f1()
     {        
       直接使用外部变量x,y;
     }
*变量的存储类别: 
1、静态存储方式：是指在程序运行期间分配固定的存储空间的方式。
   动态存储方式：是在程序运行期间根据需要进行动态的分配存储空间的方式。

2、存储一个程序的方式：
-------------
程序区；    |
-------------
静态存储区；|全局变量全部存放在静态存储区，在程序开始执行时给全局变量分配存             储区，程序行完毕就释放。在程序执行过程中它们占据固定的存储单元              |，而不动态地进行分配和释放；
-------------
动态存储区；| 动态存储区存放以下数据：
            |  1)        函数形式参数；
            |  2)        自动变量（未加static声明的局部变量）；
            |  3)        函数调用实的现场保护和返回地址；
-------------
在函数开始调用时分配动态存储空间，函数结束时释放这些空间。
在c语言中，每个变量和函数有两个属性：数据类型和数据的存储类别。

3、静态变量和动态变量：
   动态变量(自变量)：放在动态存储区中，用auto int b,c=3;表示，默认情况下不写    auto。自动变量（即动态局部变量）属于动态存储类别，占动态存储空间，函数调   用结束后即释放。
   静态局部变量static：(类似C++里面的private作用)有时希望函数中的局部变量的  值在函数调用结束后不消失而 保留原值，又不希望这个变量，或者函数会被其它 文 件所看到，这时就应该指定局部变量为“静态局部变量 ”，用关键字static进行声  明。
   作用：用于外部变量，或者函数，(类似C++里面的private作用)，本文件内从定义以下可用，而其他文件不可用；    
         用于内部变量，局部变量的值在函数调用结束后不消失
   例：文件f1.c中
        int f();//没有写上static,则说明该函数在其它文件中也可用
       头文件my.h中
        extern int f();//说明，这个文件是存在于别的源文件中
       文件fmain.c中
        include "my.h"
        则，这里就可以使用f1.c文件的f()函数了 

   他们的区别：
1)       静态局部变量属于静态存储类别，在静态存储区内分配存储单元。在程序整         个运行期间都不释放。自动变量（即动态局部变量）属于动态存储类别，占         动态存储空间，函数调用结束后即释放。
2)       静态局部变量在编译时赋初值，即只赋初值一次；而对自动变量赋初值是在         函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语         句。

3)       如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动         赋初值0（对数值型变量）或空字符（对字符变量）。而对自动变量来说，如         果不赋初值则它的值是一个不确定的值。

4、寄存器变量：register
   为了提高效率，C语言允许将在程序中使用频率较高的局部变量得值放在CPU中的寄存器中，这种变量叫“寄   存器变量”，
   1)        只有局部自动变量和形式参数可以作为寄存器变量；局部静态变量不能               定义为寄存器变量。
   2)        一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；

5、外部变量：extern
   外部变量（即全局变量）如果在定义点之前的函数想引用该外部变量，则应该在引用之前用关键字extern对该变量作“外部变量声明”。表示该变量是一个已经定义的外部变量。
声明放在函数内部的开头，表示这个声明在本函数内有效。声明放在函数外部，表示这个声明得作用域从声明处开始，到该文件的末尾有效
main()
{
 extern A,B;
 printf("%d\n",max(A,B));
}
int A=13,B=-8;

对于函数声明：
如果本份文件中定义了函数f(), 则需要这样进行声明int f();
如果在别的文件中定义了函数f(), 则需要这样进行声明extern int f();

2)全局变量和静态全局变量
  当一个程序由多个文件组成时，全局变量的作用域为全部文件。而静态全局变量只在定义了该变量的源文件内有效，在其它文件中不能使用它。

//**********
//预处理命令
//**********
所谓预处理是指在进行编译的第一遍扫描(词法扫描和语法分析)之前所作的工作。当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。

*系统预定义符号<stdio.h>
  _FILE_ 进行编译的源文件 
  _LILE_ 文件当前行的行号
  _DATE_ 文件被编译的日期 
  _TIME_ 文件被编译的时间
  _STDC_ 如果编译器遵循ANSI C，则值为1
*宏定义：在Ｃ语言源程序中允许用一个标识符来表示一个字符串，称为“宏”。在编译预处理时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换。
 1、无参宏定义： #define M (y*y+3*y)
对于宏定义还要说明以下几点：

1)       宏定义预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后           的源程序时发现。
2)       宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起置           换。
3)       宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终         止其作用域可使用# undef命令。
    #define PI 3.14159

    main()

    {

      ……//宏PI有效
      printf("PI");//不是宏，不作替换

    }

    #undef PI

    f1()

   {

      ……//宏PI无效

   }
4)       宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层代换。

例如：

    #define PI 3.1415926

    #define S PI*y*y          /* PI是已定义的宏名*/

对语句：

    printf("%f",S);

在宏代换后变为：

    printf("%f",3.1415926*y*y);
5)       可用宏定义表示数据类型，使书写方便。

例如：

    #define STU struct stu

在程序中可用STU作变量说明：

    STU body[5],*p;

    #define INTEGER int

在程序中即可用INTEGER作整型变量说明：

    INTEGER a,b;

应注意用宏定义表示数据类型和用typedef定义数据说明符的区别。

宏定义只是简单的字符串代换，是在预处理完成的，而typedef是在编译时处理的，它不是作简单的代换，而是对类型说明符重新命名。被命名的标识符具有类型定义说明的功能。

请看下面的例子：

    #define PIN1 int *

    typedef (int *) PIN2;

从形式上看这两者相似， 但在实际使用中却不相同。

下面用PIN1，PIN2说明变量时就可以看出它们的区别：

PIN1 a,b;在宏代换后变成:

    int *a,b;

表示a是指向整型的指针变量，而b是整型变量。

然而：

    PIN2 a,b;

表示a,b都是指向整型的指针变量。因为PIN2是一个类型说明符。

6)       对“输出格式”作宏定义，可以减少书写麻烦。

【例9.3】中就采用了这种方法。

#define P printf

#define D "%d\n"

#define F "%f\n"

main(){

  int a=5, c=8, e=11;

  float b=3.8, d=9.7, f=21.08;

  P(D F,a,b);

  P(D F,c,d);

  P(D F,e,f);

}

 2、带参宏定义：
   #define M(y) y*y+3*y      /*宏定义*/
   k=M(5);                   /*宏调用*/即为5*5+3*5
  1). 带参宏定义中，宏名和形参表之间不能有空格出现。
    #define MAX  (a,b)  (a>b)?a:b /*宏定义*/
    max=MAX(x,y); /*宏调用*/即为max=(a,b)(a>b)?a:b(x,y);
  2). 在带参宏定义中，形式参数不必作类型定义。#define M(y),而不用写成     #define M(int y);在带参宏中，只是符号代换，不存在值传递的问题,这与函数不    同。
  3).在宏定义中的形参是标识符，而宏调用中的实参可以是表达式。
    #define SQ(y) (y)*(y) /*宏定义*/
    a=2;
    sq=SQ(a+1);/*宏调用*/即为sq=(a+1)*(a+1);
    这与函数的调用是不同的，函数调用时要把实参表达式的值求出来再赋予形参。而    宏代换中对实参表达式不作计算直接地照原样代换。
  4).在带参数的宏替换中，它的参数不能加上引号。如果要加上引号，则需要在前面加上#符号
    例：#define dprint(expr)  printf(expr + "a");
        若想通过dprint("dds")  替换成printf("dds"+"a");是错的
        
        正确的做法：#define dprint(expr)  printf(#expr + "a");
        dprint(dds) 替换成printf("dds"+"a")
  5).如果宏替换里面的参数与##相邻，##与前后的空白符会被删除
     #define paste（fr, ba）  fr    ##   ba
     结果paste（as, 1） 就变成as1

*文件包含
#include"stdio.h"

#include<math.h>

但是这两种形式是有区别的：使用尖括号表示在包含文件目录中去查找(包含目录是由用户在设置环境时设置的)，而不在源文件目录去查找；

使用双引号则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找。用户编程时可根据自己文件所在的目录来选择某一种命令形式。

*条件编译
1、
#ifdef  标识符

  程序段1

#else if 标识符2

  程序段2

#else 标识符3

  程序段3

#endif

如果标识符已被 #define命令定义过则对程序段1进行编译；否则对程序段2进行编译。
例：
#define NUM ok

#define NUM//不给出任何字符串也可以

....................
  #ifdef NUM

      printf("Number=%d\nScore=%f\n",ps->num,ps->score);//执行这一条

  #else

      printf("Name=%s\nSex=%c\n",ps->name,ps->sex);

  #endif
一般用途：通常用于调试程序中，如果需要调试时
#ifdef _DEGBUG_
   printf(调试信息咯参数值);
#endif
在调试完后，只要去掉#define _DEGBU_ ，即可发布产品

2、
#ifndef 标识符  

    程序段1  

#else  

    程序段2  

#endif
如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译
3、
#if 常量表达式

    程序段1

#else  

    程序段2

#endif
如常量表达式的值为真(非0)，则对程序段1 进行编译，否则对程序段2进行编译。

 

//******
//位运算
//******
1、&按位与用于屏蔽某些二进制位，即置0；

例如：n = n & 0177;
0177是八进制，转为二进制为001 111 111
n
&
001 111 111 即为将n中，除了7个低二进制位外的所有都置为0

|按位或用于将某些二进制位置为1；^按位异或当两个操作数的该对应位不同时置为1，否则置为0；
                                       n                n                             n
>>,<<移位:在移位操作中，左移n位相当于x2 ,右移n位相当于/2 ，因此可用移位操作来代替乘除2  的操作
例：a=(high+low)/2比较低效，  代替方法是a=(high)+low>>1
注意：此类计算时，需要考虑可以使用0，或者自身，进行辅助计算；
         n
例：表达2 , 即1UL<<n

2、按位取反运算
例如：求-10的按位取反

求-10的补码：

10的原码：
0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 
取反：
1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1
再加1，得-10的补码：
1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0

-10的按位取反
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 = 9
即~(-10)=9

例：
#define PAGE_SHIFT 12
1UL
00000000000000000000000000000001 
1UL<<PAGE_SHIFT
00000000000000000001000000000000 
#define PAGE_SIZE 1UL<<PAGE_SHIFT

PAGE_SIZE-1
00000000000000000000111111111111
,即是十六进制：0x1000

~(PAGE_SIZE-1)
11111111111111111111000000000000
,即是十六进制：0xfffff000

D例2-6
将x中从第p位开始的n个(二进制)位设为y中最右边n位的值，x的其余各位保持不变
原理：
p=4 n=3
x:110110[101]10
y:10110101[110]

*
11111111111    
~0<<n 
11111111000    
~(~0<<n)
00000000111
~(~0<<n)<<(p+1-n)
00000011100
~(~(~0<<n)<<(p+1-n))
11111100011
*
x:110110[101]10
And   
  111111[000]11 
x & ~(~(~0<<n)<<(p+1-n))
*
11111111111
~0<<n
11111111[000]
~(~0<<n)
00000000[111]
*
y:10110101[110]
And
  00000000[111] 
y & ~(~0<<n)  
*
(y & ~(~0<<n))<<(p+1-n) 
y:000000[110]00
*
x:110110[000]10
Or
y:000000[110]00

(x & ~(~(~0<<n)<<(p+1-n)))|((y & ~(~0<<n))<<(p+1-n))
110110[110]10 =1754

代码：
#include<stdio.h>
unsigned setbits(unsigned x,int p,int n,unsigned y);
main()
{
  clrscr();
  printf("%d",setbits(1750,4,3,1454));
  getch();
}
unsigned setbits(unsigned x,int p,int n,unsigned y)
{
  return (x & ~(~(~0<<n)<<(p+1-n)))|((y & ~(~0<<n))<<(p+1-n));
}
D例2-7
将x中从第p位开始的n个(二进制)位求反，x的其余各位保持不变
原理：
p=4 n=3
x:110110[101]10

*
11111111111
~0<<n
11111111000
~(~0<<n)
00000000111
(~(~0<<n))<<(p+1-n)
00000011100
*
x:110110[101]10
XOR
  000000[111]00
=110110[010]10
x^(~(~0<<n))<<(p+1-n)
代码：
unsigned invert(unsigned x,int p,int n)
{
  return x^(~(~0<<n))<<(p+1-n);
}
D例2-8
将x中从最右断的n个(二进制)循环移到左端(跑马灯)
原理：
n=3
x:1101100101010[110]
*
  1111111111111 111
(~0)<<n
  1111111111111 000
~((~0)<<n)
  0000000000000 111
*
x:1101100101010[110]
AND
  0000000000000[111]
= 0000000000000[110]
x & ~((~0)<<n)
*
求x的字长有几位
int i;
unsigned v=(unsigned)~0;
for(i=1;(v>>1)!=0;i++);
return i; 16位
*
(x & ~((~0)<<n))<<(i - n);
[110]0000000000000
*
x>>n
[000]1101100101010
*
[000]1101100101010
|
[110]0000000000000
=[110]1101100101010
(x>>n)|((x & ~((~0)<<n))<<(i - n))
例子:
unsigned rightrot(unsigned x, int n)
{
  return (x>>n)|((x & ~((~0)<<n))<<(getlength() - n));
}
int getlength(void)
{
  int i;
  unsigned v=(unsigned)~0;
  for(i=1;(v=v>>1)>0;i++);
  return i;
}
D2-8跑马灯，一个一个移动
unsigned rightrot(unsigned x, int n)
{
  int rbit;
  while(n-- > 0)
  {
    rbit = (x&1) << (getlength() - 1);
    x = x >> 1;
    x = x | rbit;
  }
  return x;
}

3、位域
有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间，并使处理简便，所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。

*位域的定义和位域变量的说明
struct bs

     {

       int a:8;

       int b:2;

       int c:6;

     }data;

说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。
对于位域的定义尚有以下几点说明：

1)       一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。

例如：

    struct bs

     {

       unsigned a:4;

       unsigned :0;        /*空域*/

       unsigned b:4;       /*从下一单元开始存放*/

       unsigned c:4;

     }

    在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。

2)       由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。

3)       位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：

    struct k

     {

      int a:1;

      int  :2;          /*该2位不能使用*/

      int b:3;

      int c:2;

     };

从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。

*位域的使用
main(){
    //bs共所用位数不一定是几个字节，例如它用了11位，则在内存中就分配两个字节    //，其余没用的位就浪费掉了
    struct bs

    {

      unsigned a:1;//代表所占位数

      unsigned b:3;

      unsigned c:4;

    } bit,*pbit;

    bit.a=1;

    bit.b=7;

    bit.c=15;

    printf("%d,%d,%d\n",bit.a,bit.b,bit.c);

    pbit=&bit;

    pbit->a=0;

    pbit->b&=3;

    pbit->c|=1;

    printf("%d,%d,%d\n",pbit->a,pbit->b,pbit->c);

}

上例程序中定义了位域结构bs，三个位域为a,b,c。说明了bs类型的变量bit和指向bs类型的指针变量pbit。这表示位域也是可以使用指针的。程序的9、10、11三行分别给三个位域赋值(应注意赋值不能超过该位域的允许范围)。程序第12行以整型量格式输出三个域的内容。第13行把位域变量bit的地址送给指针变量pbit。第14行用指针方式给位域a重新赋值，赋为0。第15行使用了复合的位运算符"&="，该行相当于：

    pbit->b=pbit->b&3

位域b中原有值为7，与3作按位与运算的结果为3(111&011=011,十进制值为3)。同样，程序第16行中使用了复合位运算符"|="，相当于：

pbit->c=pbit->c|1

其结果为15。程序第17行用指针方式输出了这三个域的值。

   
//****
//文件
//****
这里的I/O操作都是基于流缓冲的，它的目的是为了尽可能少的使用API函数read和write调用的数量，他有三种缓冲机制
全缓冲：每次只有填满I/O缓存后，才进行实际的I/O操作，例如使用malloc函数，不与终端交互，却
        只对普通文件操作
行缓冲：它允许我们一次输入，或输出一个字符，但是却缓冲保存起来。只有这一行全输入完后，换        行后，才会进行I/O操作，比如fputc,fgetc函数。当流涉及到一个终端时，例如标准输入和
        标准输出，通常使用行缓冲
不带缓冲：例如stderr

flush冲洗：在标准I/O方面，flush是把缓冲区中的数据全部写到磁盘上；在终端驱动程序方面，flush是把缓冲区中的数据全部丢弃

0、流的操作
#include<stdio.h>
更改缓冲类型：成功0，失败非0
void setbuf(FILE *restrict fp,char *restrict buf);
buf:设为BUFSIZE，则默认开为全缓冲，或者行缓冲；设为NULL，则设为无缓冲
int setvbuf(FILE *restrict fp,char *restrict buf,int mode,size_t size);
mode:_IOFBF全缓冲：buf为NULL
_IOLBF行缓冲：buf为NULL
_IONBF不带缓冲：buf为NULL

冲洗流：flush
int fflush(FILE *fp);成功0，失败EOF;
若fp为NULL，则所有输出流被冲洗

1、文件指针
一个指向文件类型的指针FILE *fp；注意，FILE要大些，因为它实际上是由系统定义的一个结构，该结构中含有文件名、文件状态和文件当前位置等信息。

2、文件的打开与关闭
所谓打开文件，实际上是建立文件的各种有关信息，并使文件指针指向该文件，以便进行其它操作。关闭文件则断开指针与文件之间的联系，也就禁止再对该文件进行操作。
FILE *fp；
fp=fopen("c:\\hzk16","r"); 若直接写hzk16则是打开在当前目录下的hzk16文件，只允许进,若打开文件错误则指针返回NULL值

FILE *fdopen(int fd,"r");以文件描述符fd打开文件，已打开的文件指针，出错NUL

FILE *freopen("c:\\hzk16","r",FILE *strem)已打开的文件指针，出错NULL
将一个文件打开，并设为一个指定的刘：标准输入，标准输出或标准出错

fclose(fp);//关闭文件fp,正常完成关闭文件操作时，fclose函数返回值为0。如返回非零值则表示有错误发生。
行“读”操作
1)各参数说明
r(read):        读，原文件必须要存在
w(write):       原文件可以不存在；如果存在，则先把原文件清空，后写
a(append):      追加
t(text):        文本文件，可省略不写
b(banary):      二进制文件
+:              读和写
例：
 “rt”   只读打开一个文本文件，只允许读数据  (使用r则该文件必须已经存在)
 “wt”   只写打开或建立一个文本文件，只允许写数据(使用w则若该文件不存在，则                                         新建；若该文件必须已经存在，则覆盖)
 “at”   追加打开一个文本文件，并在文件末尾写数据(使用a则该文件必须已经存在)
 “rb”   只读打开一个二进制文件，只允许读数据
 “wb”   只写打开或建立一个二进制文件，只允许写数据
 “ab”   追加打开一个二进制文件，并在文件末尾写数据
 “rt+”  读写打开一个文本文件，允许读和写
 “wt+”  读写打开或建立一个文本文件，允许读写
 “at+”  读写打开一个文本文件，允许读，或在文件末追加数据
 “rb+”  读写打开一个二进制文件，允许读和写
 “wb+”  读写打开或建立一个二进制文件，允许读和写
 “ab+”  读写打开一个二进制文件，允许读，或在文件末追加数据
例：
      if((fp=fopen("c:\\hzk16","rb")==NULL)//如果指针返回为空，则没有打开成功
      {
          printf("\nerror on open c:\\hzk16 file!");
          getch();
          exit(1);
      }


3、文件的读写 
1)字符读写函数：成功返回下一个字符，已达到结尾或出错返回EOF

(1)fgetc和fputc:每次可从文件读出或向文件写入一个字符。
(2)getc(FILE *fp),putc(FILE *fp)跟上面一样，但是它只是一个宏
(3)getchar();putchar();对终端进程操作

char ch;
ch=fgetc(fp);//从文件中读一个字符。在文件内部有一个位置指针，它不需在程序中定义说明，而是由系统自动设置的。结束返回EOF
fputc('a',fp);//把字符a写入fp所指向的文件中,函数有一个返回值，如写入成功则返回写入的字符，否则返回一个EOF。可用此来判断写入是否成功。

(4)rewind(fp);把fp所指文件的内部位置指针移到文件头
fp2若是stdout;在显示器上显示文件内容
stdin;指向键盘，stderr指向显示器

(5)ungetc(int c,FILE *fp)将字符压送回流中，不能回送EOF。成功返回c，出错EOF
作用：当进行判断时，我们有时需要先看一看下一个字符，已决定如何处理现在这一个字符。然后，就将下一个字符回送，一遍下一次调用getc时返回该字符。压回是将这个字符写回流缓冲区中

2)字符串读写函数fgets和fputs:每次可从文件读出一个字符串到字符数组中,或向文件写入一个字符串。遇到null字符后终止
(1)fgets(str,n,fp);从fp所指的文件中读出n-1个字符送入字符数组str中,完了后，再在字符数组最后加上串结束标志'\0'(null字符)。
   ①      在读出n-1个字符之前，如遇到了换行符或EOF，则读出结束。
   ②     fgets函数也有返回值，其返回值是字符数组的首地址。如果文件结束，或者错误，则返回NULL
fputs(“abcd“,fp);将一个以'\0'(null字符)终止的字符串写到fp中。发生错误时返回EOF，其它情况返回一个非负值

(2)gets(str)从标准输入中读,puts(str)写到标准输出中。注意，这两个函数有缺陷，因此不要使用

3)数据块读写函数fread和fwtrite:成功返回读写文件的数目number，失败则返回EOF
fread(fa,4,5,fp);其意义是从fp所指的文件中，每次读4个字节(一个实数)送入实数组fa中，连续读5次，即读5个实数到fa中。
fwrite(fa,4,5,fp);其意义是在fp所指的文件中，每次从实数组fa中取4个字节(一个实数)的数据些入fp所指的文件，连续写5次，即写5个实数到fp中。

4) 格式化读写函数fscanf和fprintf
fscanf(fp,"%d%s",&i,s);从文件fp中，读取一个整形到i中，一条字符串到s中
fprintf(fp,"%d%c",j,ch);将一个整形j，一个字符ch，读入到文件fp中

5)文件定位，与随机读写(即是从文件的某一个位置开始读写)
rewind(fp);把文件内部的位置指针移到文件首
fseek(fp,100L,0);返回值成功0，出错非0；从某个起始点开始，移动文件内部位置指针。fseek函数一般用于二进制文件。在文本文件中由于要进行转换，故往往计算的位置会出现错误。
参数中100L是位移量，要求位移量是long型数据，所以加上L后缀
0是起始点：起始点有
文件首   SEEK_SET或者用 0 
当前位置 SEEK_CUR或者用 1
文件末尾 SEEK_END或者用 2
 
例：fseek(fp,100L,0);其意义是把位置指针移到离文件首100个字节处。

6)文件检测函数
feof(fp);判断文件是否处于文件结束位置，如文件结束，则返回值为1，否则为0。
ferror(fp);检查文件在用各种输入输出函数进行读写时是否出错。如ferror返回值为0表示未出错，否则表示有错。
clearerr(fp);清除出错标志和文件结束标志，使它们为0值。

7）路径获取
char *getcwd(char *buffer,int size);,size是buffer的大小，获取的路径信息将保存到buffer中，错误返回-1
例如：获取当前工作路径
char buf[80];
getcwd(buf,sizeof(buf));  

8）创建目录<sys/stat.h>
int mkdir(char *dir,int mode);dir路径名称，mode目录权限，如0755；成功返回0，失败返回-1



//=================
//==Linux的基本操作
//=================
//********
//基本要素
//********
*版本号：主版本号.从版本号.补丁   ，其中，偶数的为稳定版，奇数的为调试版
           2     .    4   . 18      2.4代表稳定版
 2.4版本为目前通用版本，而目前最新版本为2..6版
*支持文件系统：ext2,ext3,NTFS,FAT,网络文件系统NFS
*虚拟内存：SWAP分区，专门用于虚拟内存交换
*Linux的内核体系结构
-----------------------------------------------------------------------------------------
用户--|->应用层---|->Shell层(系统命令)--|->API--|->系统调用--|->Linux内核--|->计算机硬件|
|<-------------------用户态-------------------->|<-------内核态--------->|
-----------------------------------------------------------------------------------------

用户态与内核态：它们再逻辑上是相互隔离的，因此，用户进程不能直接访问内核数据，也无法使用内核函数。   
系统调用与API：用户进程如果需要使用内核的数据，则先连接API函数，而API函数通知系统调用模块。此时，系统调用通过一个软中断向内核提交请求以获取内核服务的接口。  
Shell作用：提供应用层程序，与内核之间进行交互的接口；是一个文本解析程序，类似于批处理
windows api和shell有什么区别和联系：他们之间的与底层的层次关系是 底层--API--SHELL--类库
（1）API、类库编程和shell编程的区别是在API、类库编程结合着某种开发语言（如C++/C#）开发软件，它往往用在各种开发语言对系统的内核的调用上（也就是一个设计用来直接调用跟系统打交道）；
shell编程采用自己独特的语法和命令来操控系统要求系统完成制定的任务(一个专门用来设计给别人调用跟系统打交道）,目前的WINDOWS API中也包含shell提供的接口；
(2)打个比方吧，API是做菜的原料，SHELL是做成的菜，只是这道菜有点特殊，还可以作为其它菜继续加工的原料。
(3)shell仍然是一个非常灵活的工具。Shell不仅仅是命令的收集，而且是一门非常棒的编程语言。您可以通过使用shell使大量的任务自动化，shell特别擅长系统管理任务，尤其适合那些易用性、可维护性和便携性比效率更重要的任务。

//*****
//*安装
//*****
1、硬件代号
在Linux系统中，每个硬件设备都被当成一个文件来对待，/dev呢是我们放置设备文件的目录，
IDE硬盘/dev/hd[a-d]
SCSI硬盘/dev/sd[a-p]
光驱/dev/cdrom
软驱/dev/fd[0-1]
打印机/dev/lp[0-2]
鼠标/dev/mouse
磁盘 /dev/ht0（IDE）或/dev/st0（SCSI界面）
网卡 /dev/ethn（n由0开始）
Linux安装至少要两个分区:Linux native(文件)分区和Linux Swap(交换)分区。主分区用于存放Linux的文件，交换分区为运行Linux提供虚拟内存。
硬盘：“hda1”。其具体含义是:分区名的前头两个字母表明分区所在设备的类型，例如hd指IDE硬盘，sd指SCSI硬盘;第三个字母表示分区在哪个设备，按a,b,c,d的顺序排列，如hda是IDE 1口的主硬盘，则IDE 2口的主硬盘就应该是hdc了；最后的数字表示在该设备上的分区顺序，前四个分区(主分区或扩展分区)用数字1 到4表示， 逻辑分区从5开始。例如: hda3表示第一个IDE硬盘上的第三个主分区或扩展分区。
                   主硬盘  从硬盘   
IDE 1（Primary） /dev/hda /dev/hdb
IDE 2（Secondary） /dev/hdc /dev/hdd

SWAP分区：Linux通常是独立出一个分区，用来进行作虚拟内存

2、推荐的分区方案：一个SWAP交换分区用于虚拟内存；一个根分区"/"用于保存系统文件；一个/home分区，作用类似于“我的文档”
3、Linux的引导程序，安装程序提供了两个引导装载程序：GRUB和LILO，现在一般选择使用GRUB
4、窗体：x-window基础窗体界面，GNOME搭载x-window之上的更漂亮窗体，KDE搭载x-window之上的更漂亮窗体，可以都选择
5、RPM 软件包管理器：类似于Install安装包
   帮助：rpm --help
   文件名称：liubing                 -1.0                                   -1.i386.      rpm（软件安装包）
             软件包名称“liubing”   软件的主版本号和次主本号“1.0”；“i386”是软件所运行硬件平台，即是X86体                                                                   系。如果是写“ARM”，则针对ARM体系的安装包
   安装：rpm Ci  RPM包的全路径文件名 
         如果想安装RPM包并显示安装进度信息可使用如下命令格式：
         	rpm Civh  RPM包的全路径文件名 
         在此命令的参数选项中：
         （1）i：代表安装。
         （2）v：代表verbose，设置在安装过程中将显示详细的信息。
         （3）h：代表hash，设置在安装过程中将显示“# ”来表示安装的进度。
   删除 RPM包：rpm -e  RPM包名称，需要指定要删除的软件包的名称而不是安装命令中的软件包安装文件名。
   升级RPM包 ：rpm -U(大写) RPM包的全路径文件名
   查询RPM包 ：rpm -q RPM包  显示它的名称、版本、和发行号码
6、ubuntu软件安装工具apt-get,它从网络上下载程序并安装
(1)
修改sudo vi /etc/apt/sources.list,
将注释掉的网址如 #deb http://cn...... 去掉

(2)更新当前系统安装的软件信息，看哪些需要安装，哪些需要升级
sudo apt-get update

//******************
//基本操作与文件目录
//******************
*登陆：管理员账号是root，
登陆后显示[root@test root]:#  即[当前账号@主机名称 当前目录]
进入/etc/passwd文件即可看到root的两个ID号都是0，基本上，只要建立一个账号，并将其UID设为0，那么它就有root身份了，一般用户账号ID号都是500以后，1-499由系统使用

*退出系统：[root@test root]# exit：退出系统并不是关机。Linux有很多作业，您的登入也仅是其中
的一个作业而已，所以当您退出时，该作业就停止了，但此时Linux中的其他作业还在进行。

*关机：shutdown [-t 秒 ] [-arkhncfF] 时间 ] [ 警告信息]
-t sec： -t后面跟秒数，亦即“过几秒后关机”的意思
-k： 不要真的关机，只是发送警告信息
-r： 重新开机
-h： 立即关机
-c： 取消已经在进行的shutdown指令内容
例如：
shutdown -h now 立刻关机，其中now相当于时间为0
shutdown -h 20:25 系统在今天的20:25分关机
shutdown -h +10 系统再过十分钟后自动关机
shutdown -r now 系统立刻重新开机
shutdown -r +30 'The system will reboot'
再过三十分钟系统会重新开机，并显示后面的信息。
shutdown -k 'This system will reboot'
仅发出引号内的警告信息，系统不会关机

*sudo reboot重启

*图形模式与文字模式的切换：Linux提供了6个文字界面终端tty1-tty6。
・ Ctrl + Alt + [F1] ~ [F6] ：文字界面tty1 ~ tty6终端
・ Ctrl + Alt + [F7] ：图形界面,或者输入[root@test root]# startx

*基本指令：[root@test root]:#command [-options] parameter1 parameter2 ...指令与参数区分字母大小写；
退出运行程序：ctrl+z，ctrl+c,输入quit,或者按下q
1、显示时间：date；显示日历cal [month] [year]，不输参数，则列出当前月份的月历
2、计算器：bc
   ^ 指数,% 余数,退出quit
   bc默认仅输出整数，如果要输出小数点后的位数，就必须执行scale=number，例如scale=3保留3位小数
3、在线求助：man , 例如：要查询date的使用方法，输入man date  同时，如果您知道某些关键词，那么可以在任何时候
   输入/word，来主动搜寻关键词。
4、切换用户：切换成root: su root  输入密码
   在当前账户下，临时使用root账户运行某些指令sudo service vsftpd restart 
   对于ubuntu，默认不采用root管理 如果需要这个权限的话，需要重新创建sudo passwd root 
5、系统帮助：可以查询相关API函数，或者相关命令
6、清屏：clear
7、查看前台，与后台的所有进程ps -ef，或ps aux

*Linux网络操作：
1、netstat -nl显示系统的各ftp协议，udp协议开放了哪些端口
2、得到用户信息：finger,或者who
3、ifconfig：得到用户IP地址信息，类似windows下的ipconfig
   关闭网卡：ifconfig eth0 down   打开网卡：ifconfig eth0 up
   显示所有网卡设备，包括打开和关闭的：ifconfig -a
   改本机IP地址：ifconfig eth0 192.168.23.223 netmask 255.255.255.0(如果要把子网掩码一起改，要这样写)
   如果权限不够，就要直接提升权限来修改IP地址：sudo ifconfig eth0 192.168.23.223 netmask 255.255.255.0(如果要把子                 网掩码一起改，要这样写)  输入密码
   注意：一旦修改ip地址后，一定要重启系统
4、ping命令：ping 192.168.23.45
5、telnet远程登录：telnet 192.168.23.45
   telnet help：列出所有命令。
    close：断开连接。
    display：列出当前的操作参数。
    open：建立一个新的连接。
    quit：直接退出telnet程序。
    set：设置操作参数。

*Linux文件操作：
 输入ls -al  参数-al则表示列出所有的文件（包含隐藏文档)
 列出的文件详细信息，包括

   文件属性  连接数   文件拥有者   文件所属群组   文件大小    最后修改时间     文件名    目录    隐藏文件
 -rwxrwxrwx    1      root          root          293         Oct 19 21:24     test   ，而tmp/， .tes
  隐藏目录
   .as/
1、个文件的属性
                                             可读 可写 可执行   可读 不可写 可执行   
  -                                            r   w      x       r     -     x         ---
                                            文件拥有者的属性   文件所属组的属性    其它组对本文件的属性
第一个属性代表这个文件是目录、文件或链接文件：
・ 若为[ d ]，则是目录，例如上面的tmp/行；
・ 若为[ - ]，则是文件，例如上面的.bashrc行；包括纯文本文件，二进制文件即执行程序
・ 若是[ l ]，则表示为链接文件（link file）；类似Windows下的快捷方式
              在Windows系统的快捷方式中，您将无法修改主程序，但是在Linux中，链接文件可以直接链接到主程序，因                此只要修改了这个链接文件，主程序也被相应改变。
              它的文件名会显示例如module->mould-info,说明module是文件名，它所指向的文件是mould-info

   设备文件（device）：与系统外设相关的文件，通常都集中在/dev目录下。
・ 若是[ b ]，块（block）设备文件，则表示为设备文件中可供储存的接口设备；就是硬盘
              注意：它的显示方式不一样，brw-rw----, 1 root disk 8(主设备号，统一用来代表是那一类设备，如8是用   来代表scsi接口的硬盘), 0(从设备号，用来代表这个是这类设备的第几个) 11月 14 20:58 sda
・ 若是[ c ]，字符（character）设备文件，则表示为设备文件中的串行端口设备，例如键盘、鼠标。

如果不具备某个属性，则相应字母会被删掉。例如，如果仅有读写能力，没有执行能力，那么x会被删掉，而成为[rw-]。

还要小心的是，在Windows下一个文件是否具有执行能力是藉由后缀名来实现的，例如.exe，.bat，.com等。但是在Linux下，文件是否能执行，则是藉由是否具有x这个属性来决定，跟后缀名没有绝对的关系

2、 第二栏表示链接占用的连接数（i-node）（若为目录，通常与该目录下有多少子目录有关）

3、如何改变文件权限：
   1）改变群组 chgrp 群组名称  文件或目录，注意，改变的目标群组名称必须在/etc/group中存在
           [root@test root]# chgrp users tmp
   2）改变拥有者 注意，文件的拥有者必须已经存在于系统中，也就是说，拥有者名称在/etc/passwd文件中存在才能改变
           chown 账号名称    文件或目录
           chown [ -R ]     账号名称:群组名称    文件或目录
           需要注意的是，这两个指令都只改变了文件或目录的所有权，要同时改变这个目录下的东西，使用-R参数。
   例：原文件drwx------ 2 users users 4096 Oct 19 21:24 tmp/
       [root@test root]# chown test tmp
       drwx------ 2 test users 4096 Oct 19 21:24 tmp/
       [root@test root]# chown CR root:root tmp
       drwx------ 2 root root 4096 Oct 19 21:24 tmp/
   3)改变文件权限:：[ -rwxrwxrwx ]这9个属性是三三一组，所以同一组
的rwx可以相加成为一个值。我们可以使用数字代表各个属性，如下：
r: 4
w: 2
x: 1
将同一组数字相加。这样，图5.2的属性[ -rwxrwx--- ]的相加结果为：
owner = rwx = 4+2+1 = 7
group = rwx = 4+2+1 = 7
others = --- = 0+0+0 = 0
所以，三组属性生成的数值就是770。  
    语法为：chmod [-R] xyz 文件或目录 
    例如，如果要将.bashrc文件属性变成“-rwxr-xr--”呢？结果就是[4+2+1][4+0+1][4+0+0]=754
    输入chmod 754 .bashrc

    还有一个改变属性的方法。从前面的介绍可以发现，基本上9个属性分别是user，group和others三组，那么我们可以用u，g和o来代表3个组的属性。此外，a则代表all亦即全部的三组。那么读写属性就可以写成r，w，x。
    chmod u  +（加入） r   文件或目录
          g  -（除去） w
          o  =（设定） x
          a
    例：假如我们要设定一个文件的属性为-rwxr-xr-x，即：
        u： 具有可读、写、执行
        g与o： 具有读与执行
        [root@test root]# chmod u=rwx,og=rx .bashrc
        若是-rwxr-xr--，则可以使用chmod u=rwx,g=rx,o=r filename来设定。
        只想增加.bashrc这个文件的每个人均可写入的权限，[root@test root]# chmod a+w .bashrc
4、文件格式：ext2，ext3
   Linux文件的后缀名：，Linux上的文件名只是让您了解该文件可能的用途，能否执行仍然需要属性的规范要设为x。

   ・ 批处理文档（脚本）：通常以*.sh代表（因为批处理文档使用shell写成，所以后缀名为.sh）；
   ・ 打包或压缩文档：通常后缀名为*.Z，*.tar，*.tar.gz，*.zip，*.tgz等，这是因为压缩软件分别为gunzip，tar等，      其后缀名因不同的压缩软件而不同。
   ・ 网页文件：通常使用*.html与*.php等后缀名，分别代表HTML语法与PHP语法的网页文件。这种文件可以使用网页浏览      器打开。

5、Linux目录：
   Linux的树状目录
        /bin，/usr/bin:存放诸如ls，mv，rm，mkdir，rmdir，gzip，tar，telnet和ftp等常用执行命令的程序
        /boot：存放启动程序grub，vmlinuz-xxx就是Linux的内核文件的镜像
        /dev：存放设备，Linux系统均把设备当成文件，例如/dev/fd0代表软驱，而/dev/cdrom则代表光驱。
             这个目录下的文件通常分为两种，分别是管理硬盘I/O的块文件与外设的字符文件
        /etc：这个目录相当重要，存放系统配置文件，启动与系统数据文件均在这个目录下，因此当这个目录被破坏，您               的系统也就差不多该死掉了
             /etc/rc.d:存放开关机过程中用到的脚本文件
                       /etc/rc.d/init.d:所有服务默认的启动脚本文件都放在这里
                                        例如，要启动与关闭iptables，可以使用：
                                        /etc/rc.d/init.d/iptables start
                                        /etc/rc.d/init.d/iptables stop
                      /etc/rc.d/rc.sysinit:表示系统启动了哪些进程
            /etc/inittab:用于配置当前系统是以什么模式启动，例如图形界面方式启动 
            /etc/xinetd.d:这个路径在较新的Linux版本中才有，存放启动服务
            /etc/X11：与X windows有关的配置文件
       /home：您新增一个一般用户的账号时，默认该用户根目录已在这里设定好
       /lib：系统函数库（library），其中的文件以.so为后缀的，类似于windows的DLL文件
       /lost+found：系统产生异常错误时，会将一些遗失的片段放置在此目录下
       /mnt：通常，软驱挂在/mnt/floppy下，光驱挂在/mnt/cdrom下
             例，挂载光驱：mount -t /dev/cdrom /mnt/cdrom
                 挂载windows硬盘：mount -t vfat(它是Fat分区) /dev/hda2(放在硬盘哪里) /mnt/windows/d(挂载点)
                 查看各硬盘分区信息：fdisk -l
       /opt：存放用户自安装的程序
       /proc：Linux启动后，用于存放内存中的系统核心与执行程序所需的一些信息
             后面的数字对应的是系统进程的ID号，每个进程都是一个目录，里面存放该进程的内存空间，当前状态的映射
             cpuinfo保存处理器信息，devices保存目前使用的设备，filesystems系统目前支持的文件系统，
             interrupts系统目前的几个中断，iomem系统整个内存的放置映射，左边是内存块空间，右边是使用这块空间
             的设备；ioports是io端口映射，保存比如串口，寄存器等的地址；meminfo保存内存信息，如总大小，当前空              闲等；partitions:各基本分区信息，pci:保存总线信息；version:Linux的版本,uptime:整个系统运行了多长             时间
             modules:加载的模块，Linux的设备驱动有两种方式，一种是直接编译到内核中，一种是以module方式加载到                     Linux中，而这个modules保存各设备的驱动模块
/      /root：系统管理员的根目录
       /sbin，/usr/sbin：与/bin不太一样，这个目录下的程序通常是root等系统管理员使用的程序，例如fdisk，mke2fs              ，fsck，mkswap和mount，userconf，netconf，perl，gcc等
       /tftpboot:存放ftp服务器端共享文件存放地方
       /tmp：是让一般用户存放临时文件的地方，例如您在安装Linux下的软件时，可能软件的默认安装目录就是/tmp
       /usr：存放程序与指令。这个目录有点类似Windows下的Program Files目录
             /usr/include：一些套件的头文件，编程时应用程序会搜索这里的头文件。基本上，当我们以Tarball方式                          （*.tar.gz方式）安装某些数据时会用到的函数库都在这个目录下
            /usr/lib：内含许多程序与子程序所需的函数库
            /usr/local：在这里安装升级的软件，，升级后的执行文件通常放在/usr/local/bin目录下
            /usr/local/man：放置一些程序的说明文件的地方，就是您使用man时会查询的路径
            /usr/share/doc：放置一些系统说明文件的地方
            /usr/share/man：放置一些程序的说明文件的地方，就是您使用man时会查询的路径
            /usr/src：是放置核心源代码的默认目录，未来我们要编译核心的时候，就必须到这个目录下
            /usr/X11R6:X Window System存放相关文件的目录
      /var:登入、各类服务发生问题时的记录日志
           /var/lib：存放一些数据库如MySQL
           /var/spool/mail：用户未读邮件的默认存放地点

6、cd变换目录
   .     代表当前层目录        
   ..    代表上层目录，        cd ../home <==相对路径的写法
   ~     代表自己的根目录
   ~user 代表到user这个人的根目录

   pwd  上面最后的目录是/home/test，但提示符仅显示test，若想知道当前所在目录，输入pwd即可
7、mkdir [目录名称] 建立新的目录，不过，请注意，目录需要一层一层地建立
   rmdir [目录名称] 删除旧有的目录，注意，目录需要一层一层地删除，而且被删除的目录中不能有其他的目录或文件。
   用rm -rf [目录名称]删除旧有的目录，可以将所有该目录下的子目录，以及文件都删除
8、环境变量PATH：：“为什么我可以在/root
  下执行/bin/ls这个文件呢？”对呀，为什么直接执行ls就一定可以显示一些信息而不会说找
  不到该文件呢？这就是环境变量PATH的作用所在。当我们执行一个指令时，系统会依照
  PATH的设定到PATH定义的每个路径下搜寻文件，先搜寻到的指令文件先被执行。
  [root@test root]# echo $PATH  会显示当前的PATH
  如果您将ls移到/root下，而且您自己也在/root下，但是执行ls时，却找不到该文件，什么原因呢？
  有两个方法，其一：直接将/root的路径加入PATH中，使用如下指令
  PATH=”$PATH”:/root
  进行添加。另一种方法是使用完整文件名，即直接使用相对或绝对路径，例如：
  /root/ls
  ./ls
9、ls：[root @test /root ]# ls [-ailS]
       参数说明：
       -a :列出所有文件（连同隐藏文档）
       -i :打印inode的值
       -l :详细列出，连同文件大小、属性数据等
       -S :以文件大小排序
  cp： [root @test /root ]# cp [-drsu] [源文件] [目标文件]
       参数说明：
       -d ：进行复制时，如果是复制到链接文件，若不加任何参数，则默认情况下会将链接到的源文件
       复制到目的地，若加-d，则链接文件可原封不动地将链接这个快捷方式复制到目的地。
       -r ：可以进行目录的复制。
       -s ：做成链接文件，与ln指令功能相同。
       -u, --update：如果源文件较新，或者没有目标文件，才会进行复制动作。可用于备份操作。
      范例：
      [root @test /root]# cp .bashrc bashrc
      将.bashrc复制成bashrc文件！
      [root @test /root]# cp -r /bin /tmp/bin
      这个功能用来复制整个目录的参数！
      [root @test /root]# cp -s .bashrc bashrc.cp
      建立一个链接文件，文件名为bashrc.cp
      [root @test /root]# cp -u /root/.bashrc /home/test/.bashrc
      先检查/home/.bashrc与.bashrc是否相同，如果不同就复制一份；如果相同则不做任何动作！
  rm：[root @test /root ]# rm [-fir] [文件名]
      参数说明：
      -i :提供用户确认（这是默认值）。
      -r :循环删除，直到没有东西为止。即表示删除目录
      -f :force，就是强制删除。
      范例：
      [root @test /root]# rm -rf testing
      连续删除该目录下的所有文件与目录
  mv：[root @test /root ]# mv [-u] [源文件] [目标文件]
      -u :同样，为update的简写，当源文件比目标文件还新时才会动作！
10、查看文件内容： [root @test /root ]# less [文件名]
    [root @test /root]# less ~/.bashrc
    od指令用于读取非ASCII数据文件，例如二进制文件。od指令可以将整个数据以数值方式读出来，它可以用来输出十进制    、十六进制等数据格式。但这个指令对工程师可能比较有用，因为用它显示出来的数据都是数字
   或内存中的数据。：[root @test /root ]# od [文件名]
     [root @test /root]# cat ~/.bashrc
11、链接文件：。链接有点类似Windows的“快捷方式”[root @test /root ]# ln -s [源文件] [目标文件]  
12、搜寻文件或目录：
    [root @test /root ]# which [文件名称]  寻找可执行文件。
    [root @test /root ]# whereis [-bmsu] [目录名称]  寻找所有文件。
    参数说明：
    -b :只找二进制文件
    -m :只找在说明文件manual路径下的文件
    -s :只找source源文件
    -u :没有说明文档的文件！

    # find -name a.c 找文件名为a.c的文件
    # grep abc * -nR 找当前目录下所有包含abc字样的文件

13、压缩文件：[root @test /root ]# gzip ab.cfg    得到的压缩文件为ab.cfg.gz     
    解压文件：[root @test /root ]# gzip -d ab.cfg.gz    
    [root @test /root ]# zcat filename.gz <==读取压缩文件内容
    压缩目录：[root @test /root ]# tar [-zxcvfpP] filename
    参数说明：
    -z ：是否同时具有 gzip，即以gzip格式压缩
    -x ：解开一个压缩文件
    -t ：查看 tarfile 里面的文件
    -c ：建立一个压缩文件
    -v ：压缩过程中显示文件
    -f ：使用文件名
    -p ：使用原文件的原有属性（属性不会依据用户而变）
    -P ：可以使用绝对路径
    -N ：比后面接的日期（yyyy/mm/dd）还要新的文件才会被打包进新建的文件中
    --exclude FILE：在压缩过程中，不要将FILE打包
     
    例：[root @test /root]# tar -cvf directory.tar directory只将目录整合打包成一个文件，不压缩
       [root @test /root]# tar -cvf directory.tar(压缩成的文件名) directory(要压缩的目录)
       [root @test /root]# tar -zcvf filename.tar.gz /home/test/*
                    将 /home/test/目录下的文件全部打包并压缩为一个 filename.tar.gz文件
       [root @test /root]# tar -xvf directory.tar
                    解压tar包，请注意，由于没有gzip（.tar而非.tar.gz）的作用，所以只要使用 Cxvf 即可，
                    不需要加上z，否则会有问题
       [root @test /root]# tar -zxvf directory.tar.gz
       这个就是加上gzip的压缩结果！所以需要加上Cz
       [root @test /root]# tar Cztvf directory.tar.gz
       这个 t 可以用来查看 tar 里面的文件信息，而不需要将它解开！
       [root @test /root]# tar -zcvfP home.tar.gz /home
       建立起来的压缩文件内文件为绝对路径
       [root @test /root]# tar -N '2002/06/25' -zcvf home.tar.gz /home
       在/home目录中，比2002/06/25还要新的文件才会被打包进入 home.tar.gz 文件中
//********
//网络服务
//********
*基本服务
 Apache 是HTTP服务器，Sendmail邮件服务器，Vsftp是ftp服务器，MySQL服务器：类似SQLServer
*ssh服务：在windows端上远程控制Linux的pc机，因为在公司上有时候Linux不是在虚拟机上，而是有一台公共的Linux服务器
，使用远程控制连接上之后，就可以在本机上对Linux进行控制了
Linux服务器端：
安装ssh服务器sudo apt-get install openssh-server openssh-client
             不过Ubuntu缺省已经安装了ssh client。 可以通过编辑 /etc/ssh/sshd_config 文件来配置 OpenSSH 
             编辑之前先备份 cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
配置完成后重起：(客户端)sudo /etc/init.d/ssh restart 或者(服务端)sudo service ssh start
Windows客户端：
使用SecureCRT->Protocol:SSH2,填写Hostname,密码即可，连接上之后，就可以使用例如ls,等的指令控制Linux了

*Vsftp服务器，
Linux服务器端：
1、安装ubuntu的ftp server：sudo apt-get install vsftpd
安装之后默认启动，通过sudo /etc/init.d/vsftpd stop或者sudo service vsftpd stop停止。

2、安装之后的配置文件为/etc/vsftpd.conf,,可以通过修改该文件进行ftp配置。
sudo vim /etc/vsftpd.conf，
或者以root账户启动，然后打开这个配置文件，进行修改

发现write_enable=YES这句配置项默认是被注释掉的即#write_enable=YES,好，把前面的注释去掉，
需要注释掉
#local_enable=YES
#write_enable=YES

3、重启ftp
sudo  service vsftpd restart

4、客户端登陆
用本地账户 user xxxxxx
或anonymous  密码：anonymous

5、注意：一旦修改ip地址后，一定要重启系统

*tftp服务器，vsftp.rpm  和tftp.rpm 都是ftp服务器，主要区别是安全性不同，而且在实际使用中，
tftp用于嵌入式板子与服务器之间的交互。因此这两个ftp都要安装
1、Linux安装tftp服务器
(1)
卸载并清除配置 apt-get remove --purge 软件名字

（2）首先我们应保证在linux的虚拟机下已经安装了tftp服务器。这一点可以使用命令来查看：
#netstat -a|grep tftp
如果没有任何信息出现则没有安装tftp。需要自己安装tftp。

(3)ubuntu tftp服务器安装:安装tftpd（tftp服务器）、tftp（tftp客户端）以及xinetd（超级服务器）
sudo apt-get install tftpd     （服务端）
sudo apt-get install tftp     （客户端）  
sudo apt-get install xinetd  


(4) 创建/etc/xinetd.d/tftp文件，并在文件中添加如下内容
service tftp
{
  socket_type = dgram
  protocol = udp
  wait = yes 
  user = root
  server = /usr/sbin/in.tftpd  
  server_args = -s /tftpboot 
  disable = no
  per_source=11
  cps=100 2
  flags=IPV4  
} 

(5) 创建tftp服务器的根目录
# sudo mkdir /tftpboot
# sudo chmod -R 777 /tftpboot
# sudo chown -R nobody /tftpboot 


(6)通过xinetd超级服务器重启tftpd
# sudo /etc/init.d/xinetd restart 
  启动的现象如下
  stopping xinetd: ok
  Sttarting xinetd: ok 
或者关闭后，再启用
root@ubuntu:/etc/init.d# sudo /etc/init.d/xinetd stop 
	Rather than invoking init scripts through /etc/init.d, use the service(8) 
	utility, e.g. service xinetd stop 
	Since the script you are attempting to invoke has been converted to an 
	Upstart job, you may also use the stop(8) utility, e.g. stop xinetd 
	xinetd stop/waiting 
	$ sudo /etc/init.d/xinetd start 
	root@ubuntu:/etc/init.d# sudo /etc/init.d/xinetd start 
	Rather than invoking init scripts through /etc/init.d, use the service(8) 
	utility, e.g. service xinetd start 
	Since the script you are attempting to invoke has been converted to an 
	Upstart job, you may also use the start(8) utility, e.g. start xinetd 

(7)查看安装信息
root@ubuntu:/etc/init.d# ps -e | grep xinetd 
	root@ubuntu:/etc/init.d# chkconfig | grep xinetd 
		tftp                        xinetd 
		xinetd                      off 
	root@ubuntu:/etc/init.d# chkconfig | grep tftp 
		atftpd                      on 
		tftp                        xinetd
   
(8)测试一下，在/tftpboot文件夹下新建立一个文件
sudo touch test
sudo chmod 777 test

(9)
进入其它路径下：
tftp 192.168.0.38 【IP自行修改】(本机测试可以为：tftp localhost)
tftp> get /tftpboot/test

也可以使用
netstat -a|grep tftp
命令来测试系统是否开启了tftp服务
若开启，则返回udp 0 0 *:tftp *:*

(10)关闭linux的防火墙
Redhat使用
service iptables stop 
ubuntu使用
sudo ufw disable

2、windows安装tftp客户端
(1)控制面板->程序->打开或关闭windows功能->勾选tftp客户端

*nfs服务
(1)
sudo apt-get install nfs-kernel-server portmap
(2)
需要修改它的配置文件/etc/exports，增加一行以下内容
/work/nfs_root *(rw,sync,no_root_squash)

然后，就可以通过网络文件系统访问/work/nfs_root目录

其中： /work/nfs_root是要共享的目录，

            *代表允许所有的网络段访问，

            rw是可读写权限,sync是资料同步写入内存和硬盘，

no_root_squash是nfs客户端分享目录使用者的权限，如果客户端使用的是root用户，
那么对于该共享目录而言，该客户端就具有root权限。


(3)重启NFS服务
$sudo /etc/init.d/portmap restart 
sudo /etc/init.d/nfs-kernel-server restart

(4)测试nfs
此时可以运行以下命令来显示一下共享出来的目录： 
$showmount -e 
或者可以使用以下命令把它挂载在本地磁盘上，例如将/rootfs挂载到/mnt下： 
$sudo mount -t nfs localhost:/work/nfs_root /mnt

可以运行df命令查看是否挂载成功。查看后可以使用以下命令卸载： 
$ sudo umount /mnt



*安装C库，g++，编译器等等
sudo apt-get install build-essential
sudo apt-get install bison flex
安装c的man手册，安装后就可以通过man read的命令查看函数的用法
sudo apt-get install manpages-dev

 
*Samba服务:允许Linux与UNIX系统之间进行数据资源共享，也允许Linux与Windows系统之间共享数据资源,即文件共享服务器
1、安装：
rpm Cqa|gerp samba来检查是否安装了samba 软件包，如果没有
输入：yum install samba* -y进行安装
2、启动
＃service smb start （/etc/init.d/smb start ）启动smb服务
＃service nmb start （/etc/init.d/nmb start ）启动nmb服务
#pstree | grep mb测试是否正常启动
＃cp /etc/samba/smb.conf /etc/samba/smb.conf.bak  我们先备份配置文件smb.conf

3、打开文件smb.conf,进行配置
======Global Settings====
..............
--------Logging Options--------
max log size=0
--------Standalone Server Options--------
security=user
============== Share Definitions =========================
[homes]
	
    comment = Home Directories
 
    path = /home/guozhenzhen/ctest
 ← 设置共享文件专用路径
    browseable = no
    guest ok = no
    writable = yes
    valid users = %S
    valid users = MYDOMAIN\%S


4、创建将要通过Fedora Samba 共享给 Windows 网络的专用目录:
[root@sample ~]# mkdir /home/guozhenzhen/ctest
　 ← 建立共享文件专用目录
[root@sample ~]# chown -R nobody. /home/guozhenzhen/ctest　 ← 设置专用目录归属为 nobody 
[root@sample ~]# chmod 777 /home/guozhenzhen/ctest　 ← 将专用目录属性设置为 777  


5、对用于登录Fedora Samba 的用户进行设置：创建用于登录Fedora Samba 的用户数据。这里需要注意的一点：用 smbpasswd 创建用户的前提是，系统用户中存在该用户 -- 在基于系统用户之上，才可以创建该用户在Fedora Samba 用户数据库中的信息。
[root@sample ~]# smbpasswd -a suyang　 ← 将系统用户 guozhenzhen（例）加入到Fedora Samba 用户数据库
New SMB password:　 ← 输入该用户用于登录Fedora Samba 的密码
Retype new SMB password:　 ← 再次确认输入该密码

6、关闭防火墙
iptables -F
/etc/selinux/config文件的selinux：   disabled，或者直接在图形选项上改

7、启动Fedora Samba 服务(含两个守护进程：smb,nmb)。
[root@sample ~]# chkconfig smb on　 ← 设置Fedora Samba 自启动
[root@sample ~]# chkconfig --list smb　 ← 确认Fedora Samba 启动标签，确认 2-5 为 on 的状态
smb 0:off 1:off 2:on 3:on 4:on 5:on 6:off
[root@sample ~]# chkconfig nmb on　 ← 设置 nmb 自启动
[root@sample ~]# chkconfig --list nmb　 ← 确认 nmb 启动标签，确认 2-5 为 on 的状态
nmb 0:off 1:off 2:on 3:on 4:on 5:on 6:off
[root@sample ~]# /etc/rc.d/init.d/smb start　 ← 启动 Fedora Samba 服务，restart重新启动
Starting SMB services: [ OK ]
[root@sample ~]# /etc/rc.d/init.d/nmb start　 ← 启动 nmb 服务
Starting NMB services: [ OK ]







//==================
//==Linux的C语言编程
//==================
*vi编辑器的使用：
用vi打开一个文件:vi test.txt
使用i进入编辑模式，编辑后，按ESC退出编辑模式,注意：tab键与空格键不同
按下：:wq退出，并保存；w保存；q不保存，退出
查找：/xxxx要查找的字符串，按n找下一个
*让程序在后台执行命令:最后加上一个&的符号
*显示行号：set nu,  不显示行号：set nonu
例如：cc m2.c&

*学习Bash:它是Linux默认的shell程序，shell程序的编程类似于windows下的批处理 的*.bat文件，它是指令集,如cd,ls,
pwd,的集合。编写完成后，就可以通过执行以下文件，全部执行里面的命令
注意：如果写入的shell不止一行，就用\间断，在下一行继续写入
例：mv ./home/dev/ctest/a.txt ./home/dev\
   >/ctest/b.txt

1、建立一个简单程序
   1)vi test.sh/*一般以sh为后缀名，命名shell*/
   2)写下
     #！bash
     date
     ps -e
     cp file1 file2
     保存文本
  3)此时，该文件没有执行权限
    方式一：需要解析命令为sh test.sh,则会得到执行结果
    方式二：修改文件执行权限chmod 755 test.sh, 输入./test.sh执行文件
    注意：系统默认是不主动搜寻当前目录下的执行文件，比如当前目录下有一个执行文件test.sh，
          如果想要执行该文件，直接输入test.sh会出错，而必须输入./test.sh
  4)调试脚本
    [test @test test]# sh [-nvx] scripts
    -n ：不执行脚本，查询脚本内的语法，若有错误则列出
    -v ：在执行脚本之前，先将脚本的内容显示在屏幕上；
    -x ：将用到的脚本内容显示在屏幕上，与-v稍微不同
    [test @test test]# sh -n test01-hello.sh

    [test @test test]# sh -v test01-hello.sh
    #!/bin/bash
    hello="Hello! How are you"
    echo $hello
    Hello! How are you

    [test @test test]# sh -x test01-hello.sh
    + hello=Hello! How are you
    + echo 'Hello!' How are you
    Hello! How are you
2、变量
   在命令行输入的变量也好、命令别名也罢，都只是针对该次登入的设定，所以，只要您注销，那么上次的设定值就会不见了。
   1)显示变量
    echo:显示变量的值要用到echo指令,[root @test root]# echo $variable(变量)
    例题：请在屏幕上显示您的环境变量PATH，HOME与MAIL。
    [root @test root]# echo $PATH
    [root @test root]# echo $HOME
    [root @test root]# echo $MAIL
    $HOSTNAME主机名，$LOGNAME当前登陆用户名
    env:可以查到当前系统所有预设的环境变量
    set：会显示系统当前的环境变量，以及您的自定义变量
    2)变量设定
      （1）通常大写字符为系统预设变量，自定义变量可以使用小写字符，变量名称只能是英文字母与数字，其中数字不能           是开头字符；
           [root @test root]# 12name=VBrid <==错误。因为变量开头不能是数字
           [root @test root]# name=VBird <==正确。echo $name显示VBird

      （2）变量赋值：变量与变量内容以等号“=”连结，且等号两边不能直接接空格符，若要有空格符，可以使用双引号或单引号将变量内容结合起来，但要特别留意，双引号仍然可以保留变量的内容，但单引号内仅能是一般字符，而不会有特殊符号
           [root @test root]# name = VBird <==错误。因为等号两边不能直接接空格符
           [test @test test]# name=VBird name <==错误。需要加双引号
           [test @test test]# name="VBird name" <==正确。
           [test @test test]# name=’VBird’s name’ <==错误。因为有3个单引号
           [test @test test]# name="VBird's name" <==正确。
           例：单引号与双引号的区别
           [root @test root]# name=VBird
           [root @test root]# echo $name
           VBird
           [root @test root]# myname="$name its me"
           [root @test root]# echo $myname
           VBird its me
           [root @test root]# myname='$name its me'
           [root @test root]# echo $myname
           $name its me

      （3）必要时以跳转字符“\”将特殊符号（如Enter，$，\，空格符，'等）变成一般符号；
           [test @test test]# name=VBird\$ s\ name <==正确。

      （4）变量添加值：则需以双引号及$变量名称（如"$PATH":/home）继续累加内容； 
           [test @test test]# name="$name"isme <==正确。
           [test @test test]# PATH="$PATH":/home/test <==正确。
      （5）指令中嵌套指令：先执行嵌套内的指令，再执行外部指令
           [test @test test]# cd /lib/modules/'uname Cr'/kernel
           ，在 ' 之内的指令将被首先执行，而其执行结果将作为外部的输入信息。
例如uname Cr会显示当前的核心版本，而我们的核心版本在/lib/modules中，因此，您可以先执行uname Cr找出核心版本，然后用“cd 目录”转到该目录下
      (6)执行自定义变量
          [test @test test]# name=/home
          [test @test test]# cd $name
      (7)export:当您取得一个bash之后，即得到了一个程序，但是若您再次执行bash，那么将进入子程序,由于您已经进入了该子程序，所以父程序中的变量设定将不继续存在。如果想让该变量内容继续在子程序中使用，请执行
         export 变量
在引用他人的文件或其他程序时，export相当重要，尤其在需要两三个文件互相引用时，如果忘记设定export，那么不同文件中的相同变量值将需要一再地重复设定。所以，只要在头一个文件使用export，那么后续的文件引用该变量时，将会自动读取该变量内容。
         例：
           [test @test test]# name="VBird's name" <==设定name变量
           [test @tset test]# echo $name <==显示name变量的指令
           [test @test test]# /bin/bash <==另开一个bash的子程序
           [test @tset test]# echo $name <==此时，无此name变量，因此显示为空
           [test @test test]# exit <==退出子程序bash shell
           [test @test test]# export name <==正确。如此则$name可以用于下一个子程序中 
      (8)取消变量设定：
          [test @test test]# unset name 

3、命令通配符
1)* 通配符，代表任意字符（0到多个）
  [test @test test]# ls test* <==*代表后面不论接几个字符都予以接受(没有字符也接受)

2)? 通配符，代表一个字符
  [test @test test]# ls test* <==*代表后面不论接几个字符都予以接受(没有字符也接受)

3)# 注释，这个最常用在脚本中，视为说明

4)\ 跳转符号，将特殊字符或通配符还原成一般字符

5)| 分隔两个管线命令的界定
  管线命令“|”仅能处理经由前一个指令传来的正确信息，也就是标准输出（Stdout）信息，对于标准错误信息并没有直接处理能力；每个管线部分都是指令，而后一个指令的输入乃是前一个指令的输出。
  常用的管线命令：
  ①cut：截取字符串
  [root @test /root ]# cut -d "分隔字符" [-cf] fields
  参数说明：
  -d ：说明后面接的是分隔字符，默认是空格
  -c ：后面接的是第几个字符
  -f ：后面接的是第几个区块，
  例如111:222:33:44:5:6666，则用“：”作分隔符的话，第一个区块是111，第二个区块是222，第三个区块是33
  [root @test /root]# cat /etc/passwd | cut -d ":" -f 1
  将 passwd文件中每一行里的“:”用作分隔符，列出第一个区块，也就是姓名所在
  [root @test /root]# last | cut -d " " -f1
  以空格符作为分隔，并列出第一个区块
  [root @test /root]# last | cut -c1-20
  将 last 之后的数据，每一行的1~20个字符取出来
  ②sort：对字符进行排序
  [root @test /root ]# sort [-t 分隔符] [(+起始)(-结束)] [-nru]
  参数说明：
  -t 分隔符：使用分隔符隔开不同区块，默认是 tab
  +start -end：由第 start 区块排序到end区块
  -n： 使用纯数字排序（否则会以字母方式排序）
  -r： 反向排序
  -u： 相同出现的一行，只列出一次
  范例：
  [root @test /root]# cat /etc/passwd | sort
  将列出来的个人账号排序！
  [root @test /root]# cat /etc/passwd | sort -t: +2n
  将个人账号以用户ID排序（以 : 作分隔符，第三个为ID，但第一个代号为 0）
  [root @test /root]# cat /etc/passwd | sort -t: +2nr
  反相排序
  ③wc：计算文件内容
  [root @test /root ]# wc [-lmw]
  参数说明：
  -l ：多少行
  -m ：多少字符
  -w ：多少字
  范例：
  [root @test /root]# cat /etc/passwd | wc -l
  这个文件里有多少行
  [root @test /root]# cat /etc/passwd | wc -w
  这个文件里有多少字
  ④uniq：删除重复的行从而只保留一个，无参数
  [root @test /root ]# uniq
  [root @test /root]# last | cut -d" " -f1 | sort | uniq
  ⑤tee：将得到的数据即重定向到文件，又显示到屏幕上
  [root @test /root]# last | tee last.list | cut -d " " -f1
  将得到的数据即重定向到文件last.list，又显示到屏幕上
  ⑥tr：字符串替换
  [root @test /root ]# tr [-ds] SET1
  参数说明：
  -d ：删除 SET1 这个字符串
  -s ：取代重复的字符
  范例：
  [root @test /root]# last | tr '[a-z]' '[A-Z]'
  将小写改成大写
  [root @test /root]# cat /etc/passwd | tr -d :
  “:”这个符号在 /etc/passwd 中不见了！
  [root @test /root]# cat /home/test/dostxt | tr -d '\r' > dostxt-noM
  将 DOS 文件的行尾符号 ^M去除
  ⑦split：切割文件
  [root @test /root ]# split [-bl] 输入文件输出文件前导字符
  参数说明：
  -b ：以文件 size 来分  
  -l ：以行数来分
  范例：
  [root @test /root]# split -l 5 /etc/passwd test
  会产生 testaa, testab, testac等文件
  ⑧grep:筛选出有关键字的数据
   例：ps -e | grep vsftpd 筛选出有vsftpd服务的进程

6)；连续性命令的界定（注意，与管线命令不同）
  连续输入指令的方式：
  command1; command2不论 command1 执行结果为何，command2 都会被执行
  例如：没有/vv这个目录，
  输入ls /vv；ls ./      结果是 无法访问/vv      执行第二条指令ls ./
  输入ls /vv&& ls ./     由于第一条指令失败，所以也不能执行第二条指令
  输入ls /vv|| ls ./     第一条指令失败，执行第二条指令ls ./

7)~ 用户的根目录

8)$ 即变量前需要加的变量值

9)& 将指令变成在背景下工作

10)! 逻辑运算中的“非”（not）

11)/ 路径分隔符号

12)>, >> 输出导向，分别为“取代”与“累加”
   重定向：例
   [test @test test]# ls -al > list.txt
   将显示结果输出到 list.txt 文件中，若该文件没有，则新建；若该文件已存在   则予以覆盖
   [test @test test]# ls -al >> list.txt
   将显示结果累加到list.txt 文件中，该文件为累加的，旧数据保留！
   标准输出：使用方式为1>    错误输出：使用方式为2>
   [test @test test]# ls -al 1> list.txt 2> list.err
   将显示数据正确输出到 list.txt，错误的数据输出到list.err
   [test @test test]# ls -al 1> list.txt 2>&1
   将显示数据不论正确或错误均输出到list.txt中。注意，错误与正确信息输出到同一个文件中，则
   必须以上面的方法来写，不能写成其他格式
   [test @test test]# ls -al 1> list.txt 2> /dev/null
   将显示的数据，正确的输出到list.txt，错误的数据予以丢弃！/dev/null ：可以视为存放垃圾箱。
   < ：由 < 的右边读入参数文件；用最简单的说法，就是将原本需要由键盘输入的数据经由文件读入
   [test @test tset]# mail -s "test" root < /root/.bashrc    将.bashrc内容寄给root

13)' 单引号，不具有变量置换功能

14)" 具有变量置换功能

15)` ` 两个“`”中间为可以先执行的指令
[test @test test]# cd /lib/modules/`uname -r`/kernel/drivers <==被 ` ` 括
起来的内容会先执行

16)( ) 中间为子shell的起始与结束
b=$(ls /home) 把命令的执行结果赋值给变量


17)[ ] 中间为字符组合
[test @test test]# cp test[1-5] /tmp <==test1, test2, test3, test4, test5
若存在，就将其复制到/tmp 下

18){ } 中间为命令区块组合

4、变量的定义
1）declare：在程序中定义变量
[test @test test]# declare [-afirx]
参数说明：
-a ：定义为数组 array
-f ：定义为函数 function
-i ：定义为整数 integer
-r ：定义为只读
-x ：定义为通过环境输出变量
例：
[root @test test]# vi test03-declare.sh

#程序中
declare -i number=2*3+5*13-32+25
echo "Your result is ==> $number"

[root @test test]# sh test03-declare.sh

例：
[test @test test]# declare -i a=3
[test @test test]# declare -i b=5
[test @test test]# declare -i c=$a*$b
[test @test test]# echo $c
15 <==变成数字了。

2）交互式脚本（用于得到用户输入的值）read
echo "Please keyin your name, and press Enter to start."
read name
echo "This is your keyin data ==> $name"

3）得到程序名，以及各参数名
[root @test test]# myscript opt1 opt2 opt3 opt4
                      $0     $1   $2   $3   $4
参数：
    $0 这个程序的执行名字
　　$n 　这个程序的第n个参数值，n=1...9
　　$*　 这个程序的所有参数
　　$# 这个程序的参数个数
　　$$ 这个程序的PID
　　$! 执行上一个背景指令的PID
　　$? 上一个指令的返回值 

例
echo "This script's name => $0"
echo "parameters par1=$1 par2=$2 par3=$3"

输入
[root @test test]# sh readname.sh a1 b2 c3
This script's name => readname.sh
parameters par1=a1 par2=b2 par3=c3

5、逻辑判断式
   1）逻辑判断式
   1. 关于文件与目录的逻辑卷标
   -f 常用！检测文件是否存在          -f filename 如果 filename为常规文件，则为真  [ -f /usr/bin/grep ] 
   -d 常用！检测目录是否存在          -d filename 如果 filename为目录，则为真  [ -d /tmp/mydir ] 
   -b 检测是否为一个block文件
   -c 检测是否为一个character文件
   -S 检测是否为一个socket标签文件
   -L 检测是否为一个符号链接文件            -L filename 如果 filename为符号链接，则为真  [ -L /usr/bin/grep ] 
   -e 检测某个东西是否存在！可以是任何东西    -e filename 如果 filename存在，则为真  [ -e /var/log/syslog ] 
   2. 关于程序的逻辑卷标
   -G 检测是否由GID所执行的程序拥有
   -O 检测是否由UID所执行的程序拥有
   -p 检测是否为程序间传送信息的name pipe或FIFO
   3. 关于文件的属性检测
   -r 检测是否为可读属性        -r filename 如果 filename可读，则为真  [ -r /var/log/syslog ] 
   -w 检测是否为可写入属性      -w filename 如果 filename可写，则为真  [ -w /var/mytmp.txt ] 
   -x 检测是否为可执行属性      -x filename 如果 filename可执行，则为真  [ -L /usr/bin/grep ] 
   -s 检测是否为非空白文件
   -u 检测是否具有SUID属性
   -g 检测是否具有SGID属性
   -k 检测是否具有sticky bit属性
   4. 两个文件之间的判断与比较。例如test file1 -nt file2
   -nt 第一个文件比第二个文件新     filename1-nt filename2 如果 filename1比 filename2新，则为真  [                                                  /tmp/install/etc/services -nt /etc/services ] 
   -ot 第一个文件比第二个文件旧    filename1-ot filename2 如果 filename1比 filename2旧，则为真  [                                                  /boot/bzImage -ot arch/i386/boot/bzImage ] 
   -ef 第一个文件与第二个文件为同一个文件（诸如链接文件）
   5. 逻辑与（and）和或（or）
   && 逻辑与
   || 逻辑或
2）运算符之间的关系
   = 等于       string1= string2 如果 string1与 string2相同，则为真  [ "$myvar" = "one two three" ] 
   != 不等于     string1!= string2 如果 string1与 string2不同，则为真  [ "$myvar" != "one two three" ] 
   < 小于
   > 大于
   -eq 等于     num1-eq num2 等于 [ 3 -eq $mynum ] 
   -ne 不等于   num1-ne num2 不等于 [ 3 -ne $mynum ] 
   -lt 小于     num1-lt num2 小于 [ 3 -lt $mynum ] 
   -gt 大于     num1-gt num2 大于 [ 3 -gt $mynum ] 
   -le 小于或等于  num1-le num2 小于或等于 [ 3 -le $mynum ] 
   -ge 大于或等于  num1-ge num2 大于或等于 [ 3 -ge $mynum ]  
   -a 双方都成立（and）
   -o 单方成立（or）
   -z 空字符串        -z string 如果 string长度为零，则为真  [ -z "$myvar" ] 
   -n 非空字符串      -n string 如果 string长度非零，则为真  [ -n "$myvar" ] 
3）条件判断
   if_[_条件判断一_]_&& (||)_[_条件判断二_]注意：“_”表示加空格，要注意加
   then
      xxxxxxxxxxx
   elif_[ 条件判断三 ]_&& (||)_[ 条件判断四 ]
   then
      xxxxxxxxx
   else
      xxxxxxxxx
   fi
   
   case_xx_in
      __xxx)_xxxxx；；
      __xxx)_xxxxx；；
      *)_echo_"error"；；
   esac
4)循环
  for((i_=_0;_i_<=_100;_i=i+1))
  do
    s=s+i; 
  done
  
  LIST="Tomy Jony Mary Geoge"
  for_i_in_$LIST
  do
    echo_$i
  done 

  while_[_"$a"_!=_"101"_]
  do
     xxxx
  done

  until_[_"$yn"_=_"y"_]_||_[_"$yn"_=_"Y"_]
  do
    xxxx
  done 

//*****************
//基本Linux编程基础
//*****************
*Linux编程风格
1)、函数返回类型说明和函数名分两行放置
例：
int
main
(void)
{
xxxxxxxxx
}
2)请为每个函数书写注释，说明函数是做什么的，需要哪些入口参数，参数可能值的含义和用途。如果用了非常见的、非标准的东西，或者可能导致函数不能工作的任何可能的值，应该进行特殊说明。如果存在重要的返回值，也需要说明
3)不要声明多个变量时跨行，每一行都以一个新的声明开头
  不要这样写：
  int a,b,
      c;
  不要这样写：
  int a,b;
  char c;
  int d;
  要这样写：
  int a,b,d;
  char c;
4)变量的定义和声明要放在开头
  不要这样写：
  int a;
  xxxxxx;
  char b;
  要这样写：
  int a;
  char b;
  xxxxxxxxx
5)命名风格：使用下划线以分割单词，尽量使用小写；把大写字母留给宏和枚举常量，以及根据统一惯例使用的前缀。例如，应该使用类似ignore_space_change_flag的名字；不要使用类似iCantReadThis的名字。
  同时，命名局部变量应该简洁，例如tmp;而命名全局变量应该用比较长的描述性命名方式，例如count_active_users()”

*Linux编译器的使用：
1、在unix系统中如何执行：
   1).预处理阶段 :进行宏替换，替换头文件
   2).词法与语法分析阶段 
   3).编译阶段，将.c文件编译成纯汇编语句
   4）将汇编语句汇编成跟CPU相关的二进制机器码，生成各个目标文件.o文件 
   5).连接阶段，将各个目标文件.o文件中的各段代码进行绝对地址定位，生成跟特定平台相关的可执行文件
2、$ gcc [options][filenames]
  1)基本参数：
   -v:查询该编译器版本号
   -E:只做到预编译，不做其它处理
   -S:只做到编译，生成汇编语句
   -c常用:只做到生成目标文件(.o文件),不链接
   -g常用：添加调试信息
   -o常用 file:把生成的结果(即可执行文件.exe)放到文件file中
   -I dir:头文件搜索路径手动添加dir目录
   -L dir:库文件搜索路径手动添加dir目录
   -static链接静态库
   -library:连接名为library的库文件
例：
   gcc -o test.exe test.c 将test.c文件进行编译，生成可执行文件test
   执行：./test.exe

   gcc -c test.c 将test.c文件进行编译，生成目标文件test.o
  2）优化程序：当用gcc编译C代码时，它会默认产生一个执行文件，这个文件较大，但是易于调试。
     如果需要优化，则他将产生一个更小更快的可执行文件，但是这个文件不能进行调试。
    -O:进行一般级别的优化
    -O2:进行最彻底的优化
    注意：-O可以和-g一同使用，即优化编译，也可以包含调试信息
    例： gcc -O2 -g -o test.exe test.c 将test.c文件进行优化编译，而且可以包含调试信息，生成可执行文件test
  
  3）gdb：调试程序，注意，是调试可执行文件.exe文件

     例：gdb 11003512.exe进入程序调试状态
     参数：
    （1）file命令：装入想要调试的可执行文件。 
    （2）cd命令：改变工作目录。 
    （3）pwd命令：返回当前工作日录。 
    （4）run命令：执行当前被调试的程序。

         (gdb)run 运行当前整个程序
 
    （5）kill命令：停止正在调试的应用程序。 
    （6）list命令：列出正在调试的应用程序的源代码。 
         
         输入(gdb)list 列出该程序源码 

    （7）break命令：设置断点。
   
         输入(gdb)break 3 在第3行设置一个断点             
         输入(gdb)run 运行到第3行后，停止
             显示 3     printf("hello world\n");
   
         输入(gdb)next 单步执行，会进入函数内部；step 单步执行，不会进入函数内部 
 

 
    （8）Tbreak命令；设置临时断点。它的语法与break相同。区别在于用tbreak设置的断点执行一次之后立即消失。 
    （9）watch命令：设置监视点，监视表达式的变化。

         输入(gdb)watch a 设置监视点，变量a  

    （10）awatch命令：设置读写监视点。当要监视的表达式被读或写时将应用程序挂起。它的语法与watch命令相同。 
    （11）rwatch命令：设置读监视点，当监视表达式被读时将程序挂起，等侍调试。此命令的语法与watch相同。 
    （12）next命令：执行下一条源代码，但是不进入函数内部。也就是说，将一条函数调用作为一条语句执行。执行这个          命令的前提是已经run，开始了代码的执行。 
    （13）step命令：执行下一条源代码，进入函数内部。如果调用了某个函数，会跳到函数所在的代码中等候一步步执行         。执行这个命令的前提是已经用run开始执行代码。 
    （14）display命令：在应用程序每次停止运行时显示表达式的值。
    （15）info break命令：显示当前断点列表，包括每个断点到达的次数。 
    （16）info files命令：显示调试文件的信息。 
    （17）info func命令：显示所有的函数名。 
    （18）info local命令：显示当前函数的所有局部变量的信息。 
    （19）info prog命令：显示调试程序的执行状态。 
    （20）print命令；显示表达式的值。 
    （21）delete命令：删除断点。指定一个断点号码，则删除指定断点。不指定参数则删除所有的断点。 
    （22）Shell命令：执行Linux Shell命令。 
    （23）make命令：不退出gdb而重新编译生成可执行文件。 
    （24）quit命令：退出gdb。
   
         输入(gdb)quit 退出gdb

  
  4)makefile：做一个大型的系统里面有很多文件，如果单纯的进行编译和链接会很麻烦。而makefile文件就类似于一个工程管理模块，对这些文件进行管理。在编译的时候，也只会找有进行修改过的文件，进行编译，产生目标文件.o文件。再和所有其它的.o文件一起，进行总体链接，产生一个可执行.exe文件。Makefile是一个文本形式的数据库文件，其中包含一些规则来告诉make处理哪些文件以及如何处理这些文件。
   ①例：一个MakeFile文件内容⑥⑦
# 一个简单的Makefile的例子
# 以#开头的为注释行
  test：prog.o code.o                       #依据目标文件prog.o,code.o生成一个可执行文件test
		gcc Co test prog.o code.o 它的编译方式，注意，不能顶格写，需要用Tab跳格
  prog.o：prog.c prog.h code.h            #依据头文件prog.h，code.h，程序文件prog.c，生成一个目标文件prog.o
		gcc Cc prog.c Co prog.o  它的编译方式，头文件不用写，因为程序中已经include了
  code.o：code.c code.h                   #依据头文件code.h，程序文件code.c，生成一个目标文件code.o
		gcc Cc code.c Co code.o  它的编译方式
  clean：
		rm Cf *.o                #编译完成后，删除所有临时的.o文件
  注意：在Makefile中，可使用续行号（\）将一个单独的命令行延续成几行。但要注意在续行号（\）后面不能跟任何字符（包括空格和键）。

  ②使用：# make test，其中test是：上面定义的test文件中，第一行可执行文件名为test。
        如果只写make,则make就将自动查找，或者新建一个目标。

  ③Makefile中的变量定义：
    作用：保存文件名列表：如OBJS=prog.o code.o
          保存编译器名称：如CC=gcc
          保存编译器的参数：如AS=-o
    例：利用变量把前面的Makefile重写一遍
        OBJS=prog.o code.o        变量定义，一般用大写字母表示
	CC=gcc
        test：${ OBJS }           变量使用
		${ CC } Co test ${ OBJS }
        prog.o：prog.c prog.h code.h
		${ CC } Cc prog.c Co prog.o
        code.o：code.c code.h
		${ CC } Cc code.c Co code.o
        clean：
		rm Cf *.o 
  ④隐含规则:make知道一些默认的动作，即内置的隐含规则，这些规则告诉make当用户没有完整地给出某些命令的时候，应该怎样执行。
   例如：隐含规则会自动的把所有的.c文件，编译成同名的.o文件
         prog.o：prog.c prog.h code.h
	
         code.o：code.c code.h

         不用写出规则，这是因为默认规则会自动生成各.o文件
  ⑤常见的自动变量：
    code.o：code.c code.h
		${ CC } Cc code.c Co code.o
    $<: 第一个依赖文件的名称,即是code.c
    $@:目标文件的名称，即是code.o
    $^:显示所有的依赖文件，以空格相隔。例code.o $^ 即是code.c code.h

6、多文件编译与链接：假设一个程序有三个文件main.c,getline.c,strindex.c
   编译：cc main.c getline.c strindex.c->生成可执行文件main.c,getline.o,
   strindex.o->加载到可执行文件a.out中，进行执行
   如果假设mian.c文件出错，则下一次可以通过
   编译：cc main.c getline.o strindex.o直接编译，并且链接


7、标准出错
   文件<errno.h>定义了各种出错常量，如EACCES表示当前出错是因为没有打开该文件的权限
   errno在普通地方，即使在同一个进程内的多个线程之间也可以使用。
   errno使用规则：一、如果没有出错，则其值不会被一个例程清除。因此，只有当有出错时，才可                  以检查其值；二、errno永远都不会置为0,如errno=0是错误的
   使用函数：void perror(const char *msg); 输出“msg： 具体对应errno值的出错信息\n” 
   出错恢复：
           非致命性错误，只是暂时的，可以恢复，例如资源短缺等：                       EAGAIN,ENFILE,ENOBUFS,ENOLCK,ENOSPC,ENOSR,EWOULDBLOCK,ENOMEM
           致命性错误，只能打印出一条出错消息，或将出错消息写入日志后，终止程序
//********    
//文件编程
//********
文件编程，有两种方法：
Linux系统调用：依赖于Linux操作系统
C语言库函数：是一套标准的系统函数接口，与操作系统平台无关
注意：通常要测试该函数是否出错，需要判断它返回值==-1，，而不是<0

1、输入与输出read和write
头文件<unistd.h>
fd表示文件描述符，它是一个非负整数；同时，0或STDIN_FILENO表示从键盘输入。1或STDOUT_FILENO表示从显示屏输出。2表示标准错误，从显示屏输出。
buf存放读或写的数据的字符数组，n代表要读写的字节数。函数返回实际读写的字节数，
ssize_t n_read = read(int fd, void *buf, size_t n); 返回值是读到的字节数，0表示已读完，-1表示出错
ssize_t:类似int类型，是一个带符号整数
size_t：类似unsigned int类型，是一个不带符号整数

ssize_t n_written = write(int fd, void *buf, size_t n);返回值是写的字节数，==n是写完所有字节，<n写了一部分，-1出错，
例：
  char buf[10];
  int n;
  while((n=read(0,buf,10))>0)
      write(1,buf,n);

例：一个经典的文件复制代码
int from_fd,to_fd; 
int bytes_read,bytes_write; 
char buffer[BUFFER_SIZE]; 
char *ptr; 

  while(bytes_read=read(from_fd,buffer,BUFFER_SIZE))
  {
    ptr=buffer;
    while(bytes_write=write(to_fd,ptr,bytes_read))
    {
      if((bytes_write==-1)&&(errno!=EINTR)) 
         break;
      else if(bytes_write==bytes_read)
         break;
      else if(bytes_write>0)
      {
        ptr+=bytes_write;
        bytes_read-=bytes_write;
      }
    }
    
    if(bytes_write==-1)
      break; 
  }

2、文件操作
   #include <stdio.h>
   #include <stdlib.h>

   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>

  int fd;
  1）文件打开，或创建：fd = open(“文件名”, flags);成功，返回文件描述符。读取失败，返回     -1参数flag：<fcntl.h>，中间可以通过‘|’符号，同时添加几个参数，如O_CREAT|O_WRONLY
   O_RDONLY   只读
   O_WRONLY   只写，光标设在文件开头，而原文件中的内容不变
   O_RDWR   读写，光标设在文件开头，而原文件中的内容不变
   O_APPEND以追加方式打开,光标设在文件末尾
   O_CREAT创建一个文件，并打开fd = open(“文件名”, O_CREAT, 0755文件权限);注意，需要使用三个参数的open
   O_NOBLOCK如果pathname指的是一个FIFO，块特殊文件，或字符特殊文件，则它以非阻塞方式打开            ，这既意味着后续的I/O操作也是非阻塞模式
   O_EXCL用于测试文件是否存在，与O_CREAT合用时，如果文件存在，则返回错误消息
   O_TRUNC如果此文件存在，打开其文件后，再清空后，重头开始
   O_NOCTTY像一些设备操作，打开设备时不是以控制终端方式打开设备。例如串口程序调试时，把串口看作控制终端；而作串口通讯程序时，我们只是接收串口的数据，而不用把它当作控制终端，进行交互。此时，把该串口打开时设置O_NOCTTY了

   附加：
   O_DSYNC每次写数据之前，都等待缓存中的数据全部都要写到相关设备上，并且缓存清空之后。但是写完后，它的文件属性(例如文件修改时间，文件大小)不会同步更新
   O_RSYNC每次读操作，都等待任何对该文件的写操作完成后，再进行
   O_SYNC每次写操作都等待物理I/O操作完成，而且每写完一次，它的文件属性(例如文件修改时间，         文件大小)都会同步更新 

  2）由于早期Linux系统中open函数不能同时创建文件，因此只能使用create函数，它的不足之处是
    它只能以只写方式打开所创建的文件。因此例如：要创建文件，再写文件，再读文件，就需要使    用函数create,close,open
    #include <fcntl.h>
    创建新文件，或覆盖旧文件fd = creat(“文件名”, perms);创建失败，返回-1
    perms:即文件的权限信息，即unix系统中的-rwxrwxrwx,不过由于是使用八进制，因此前面要加0。例如：0755  
          或者S_IRUSR可读，S_IWUSR可写，S_IXUSR可执行，S_IRWXU可读，可写，可执行 
  
  3）<unistd.h>
     <sys/types.h>  
     off_t lseek(int fd, off_t offset, int origin);移动在文件中的位置 
        offset:偏移位置,如123L向后移动123个字节，-5L向前移动5个字节；origin：0或SEEK_SET表示文件开始，1或SEEK_CUR当前位置，2或SEEK_END文件结束；它的返回值是移动后，新位置距离文件头偏移的字节数 ,-1表示出错
     用返回值也可以确定，如果fd是一个管道，FIFO，或socket，则lseek返回-1，并且errno=ESPIPE       文件空洞：设文件偏移量大于当前文件的长度，此时，对该文件的下次写将加长该文件，并在原文               件尾和新开始写位置之间产生文件空洞，并读取为0   
     
  

  4）<unistd.h>   close(fd)关闭文件，并且释放该文件上的所有记录锁
  
  5）unlink(char *name)删除文件
例：
#include <stdio.h>
#include <stdlib.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc ,char *argv[]){
    int fd;
    if(argc<2){
        puts("please input the open file pathname!\n");
        exit(1);
    }
    
    //如果flag参数里有O_CREAT表示,该文件如果不存在,系统则会创建该文件,该文件的权限由第三个参数决定,此处为0755
    //如果flah参数里没有O_CREAT参数,则第三个参数不起作用.此时,如果要打开的文件不存在,则会报错.
    //所以fd=open(argv[1],O_RDWR),仅仅只是打开指定文件
    if((fd=open(argv[1],O_CREAT|O_RDWR,0755))<0){
        perror("open file failure!\n");
        exit(1);
    }else{
        printf("open file %d  success!\n",fd);

    }
    close(fd);
    exit(0);
    
}

3、给多个进程共享的文件
1)内核中，进程调用文件原理
由进程表项指向文件表:其中文件状态标志用于描述读，写，追加，同步和非阻塞的状态。和当前文件偏移量。指向文件表,而不指向实际表是由于可能多个进程都指向同一个文件,但是它们的读文件偏移量 ,文件共享锁是不一样的
文件表指向V节点表:V节点即是用于虚拟文件系统,其中包括该文件的类型(NTFS,或ext2)，和对此文件进行各种操作的函数指针
i节点：包括该文件的所有者，大小，文件所在的设备，文件实际在磁盘的存储位置等


   进程表项1                           
fd文件描述符标志   文件指针                文件表1              V节点表1
fd0               -------------> 文件状态标志    |---→ V节点信息
fd1               ------|        当前文件偏移量  |      i节点信息
                                 指向v节点指针---|      当前文件大小

   进程表项2                        
  fd标志   文件指针                 文件表2             V节点表
fd0               -------------> 文件状态标志    |---→ V节点表1
fd1                              当前文件偏移量  |      i节点信息
                                 指向v节点指针---|      当前文件大小
   进程表项2                                     |  
  fd标志   文件指针                 文件表2      |      V节点表
fd0               -------------> 文件状态标志    |      V节点表1
fd1                              当前文件偏移量  |      i节点信息
                                 指向v节点指针---|      当前文件大小
2)原子操作：如果要为文件fd追加数据时，早期需要使用函数lseek到文件末尾，write函数写数据。但这样子，如果同时有多个进程进行这些操作，则文件的同步性就会被破坏。这时，就需要使用原子操作
#include<unistd.h>
ssize_t pread(int fd,void *buf,size_t nbytes,off_t offset);offset是偏移量，nbytes是读取的字节数
ssize_t pwrite(int fd,void *buf,size_t nbytes,off_t offset);offset是偏移量，nbytes是读取的字节数

现在：直接使用O_APPEND
类似open(pathname,O_CREAT|O_EXCL)也是一个原子操作

3)dup函数，dup2函数：复制原文件描述符，然后新文件共用此文件描述符，类似"进程表项1"所示
#include<unistd.h>
int dup(int fd);正确，返回文件fd的描述符，错误-1
int dup2(int fd1,int fd2);正确，关闭fd2,然后复制fd1的文件描述符给fd2与一同使用，错误-1

4)、文件高速缓存：通常文件的数据没有马上写到文件中，而是先保存到缓冲区中，然后再集中起来一起写出来。这样减少了读写磁盘操作，但是，如果系统故障时，会导致缓存的数据丢失
sync,fsync,fdatasync函数
成功返回0，失败-1
#include<unistd.h>
void sync(void);每次写操作都等待物理I/O操作完成，而且每写完一次，它的文件属性(例如文件修改时间，文件大小)都会同步更新，通常在守护进程中使用，每个一段时间周期地                使用一次
int fsync(int fd);只对文件fd的内容进行写出操作，作用类似sync
int fdatasync(int fd);类似fsync，但是它只更改文件的数据，同步更新文件的属性
与之相对应得文件状态标识是O_SYNC等待写完成(数据和属性),O_DSYNC(仅数据),O_RSYNC(同步读写)

5)为该文件加锁fcntl
返回值：出错返回-1，正确返回其它值
<sys/types.h>
<unistd.h>
<fcntl.h>


int fcntl(int fd,int perms,struct flock *lock)fd是文件描述符，perms是命令参数，lock是设置记录锁的具体状态

perms参数:
F_DUPFD复制文件描述符fd，系统默认为0(在经过exec函数时，不关闭)，设为1(在经过exec函数时，关闭)
F_GETFD获得fd的标志
       例：int fcntl(int fd,F_GETxx,0)获得fd的标志
F_SETFD设置fd的标志
       例：int fcntl(int fd,F_SETxx,val)设置fd的标志为val
F_GETFL获得fd的文件状态标志
       文件状态：[状态val必须先&O_ACCMODE获得访问模式位，再看是否等于下面三种，即是否     (val&O_ACCMODE==O_RDONLY), O_RDONLY,O_WRONLY,O_RDWR],O_APPEND(即看val&O_APPEND是否          ==1),O_NONBLOCK,O_SYNC每次写操作都等待物理I/O操作完成，而且每写完一次，它的文件属性(例如文件修改时间，         文件大小)都会同步更新(即数据和属性),O_DSYNC(仅数据),O_RSYNC(同步读写)，O_ASYNC异步方式，数据发出去后，不管他写完了没有，程序都去做其他的事情

F_SETFL设置fd的文件状态标志
       文件状态：O_APPEND(即看val&O_APPEND是否==1),O_NONBLOCK,O_SYNC等待写完成(数据和属性                 ),O_DSYNC(仅数据),O_RSYNC(同步读写)
       例：set_f1(STDOUT_FILENO,O_SYNC)；set_f1函数在下面例子上定义；打开同步写标识，使得每                                     次write都等待，直至数据已写到磁盘上再返回。
F_SETLK为lock描述的文件信息加锁
F_GETLK测试该锁是否会被另一把锁排斥
F_SETLKW它是F_SETLK的阻塞版本，如果存在其他锁，则调用进程睡眠，如果捕捉到信号则睡眠中断
F_GETOWN检索可以接收SIGIO和SIGURG信号的进程号或进程组号有哪些。返回+arg，或-arg
F_SETOWN设置可以接收SIGIO和SIGURG信号的进程号或进程组号。+arg指定一个进程ID，|-arg|表示arg进程组ID

lock的结构：返回0成功，-1出错
struct flock
{
  short l_type;//取值：F_RDLCK读取锁(共享锁),F_WRLCK写入锁(排斥锁),F_UNLCK解锁
  //要加锁或解锁的区域的起始地址，由l_start和l_whence两者决定
  off_t l_start;//相对位移量(字节)
  short l_whence;//位移的起点，它的返回值是移动后，新位置距离文件头偏移的字节数。SEEK_SET                 文件开头，SEEK_CUR当前位置，SEEK_END文件结尾 
  off_t l_len;//加锁区域的长度
  pid_t l_pid;//l_pid=getpid();
}

关于加锁和解锁区域：
该区域可以在当前文件尾端处开始或越过其尾端处开始，但是不能在文件起始位置之前开始或越过该起始位置。

如若l_len为0，则表示锁的区域从其起点（由l_start和l_whence决定）开始直至最大可能位置为止。也就是不管添写到该文件中多少数据，它都处于锁的范围。为了锁整个文件，通常的方法是将l_start说明为0，l_whence说明为SEEK_SET，l_len说明为0。


(1)例：得到一个文件描述符
#include"gzz.h"
#include<fcntl.h>
//设置文件的状态
void
set_f1(int fd,int flags)
{
  int val;
  if((val=fcntl(fd,F_GETFL,0))<0)//得到fd的原文件状态标志
    perror("fcntl F_GETFL error");
  val|=flags;                    //为fd添加新的文件状态标志
  //fcntl(fd,F_SETFL,0)0代表阻塞状态
  if(fcntl(fd,F_SETFL,val)<0)    //设置fd新的文件状态标志val
    perror("fcntl F_SETFL error");
}
int
main(int argc,char *argv[])
{
  int val;
  if(argc!=2)
    perror("usage:need file");
  if((val=fcntl(atoi(argv[1]),F_GETFL,0))==-1)//得到fd的文件状态标志
    printf("fcntl error for fd %d",atoi(argv[1]));
  switch(val&O_ACCMODE)//该文件是否O_RDONLY,O_WRONLY,O_RDWR
  {
    case O_RDONLY:
        printf("read only");break;
    case O_WRONLY:
	printf("write only");break;
    case O_RDWR:
        printf("read write");break;
    default:
        printf("unknow access mode");break;
  } 
  if(val&O_APPEND)//该文件是否O_APPEND
     printf(",append");
  if(val&O_NONBLOCK)//该文件是否O_NONBLOCK
     printf(",nonblock");
  #if defined(O_SYNC)//该文件是否O_SYNC
     if(val&O_SYNC)
       printf(",synchronous writes");
  #endif
  #if !defined(_POSIX_C_SOURCE)&&defined(O_FSYNC)//该文件是否O_FSYNC
     if(val&O_FSYNC)
       printf(",synchronous writes");
  #endif
  putchar('\n');
  exit(0);
}
执行
./3-4.exe 由于参数只有一个，会返回错误usage:need file

./3-4.exe 0 </dev/tty 
打开一个文件描述符0，将文件/dev/tty打开，并且输入重定向,其文件描述符以0表示，因为这个文件是只读的
read only

./3-4.exe 1 >test.txt
打开一个文件描述符1，它是只写的。将它输出重定向到新建的文件test.txt中
cat test.txt
write only

./3-4.exe 2 2>>test.txt打开一个文件描述符2，它是只写的。将它追加到文件test.txt中
write only,append

./3-4.exe 5 5<>test.txt在文件描述符5上打开文件test.txt以供读写
read write

（2）给文件上锁
当多个用户共同使用、操作一个文件的时候，linux通常采用的方法是给文件上锁，来避免共享资源产生竞争的状态。
文件锁包括建议锁和强制性锁。建议性锁要求上锁文件的进程都要检测是否有锁存在，并尊重已有的锁。强制性锁由内核和系统执行的锁。


4、I/O终端操作函数ioctl函数：是一个I/O操作的集合。所有不能用其它具体的I/O函数操作的I/O操作，都可用ioctl函数执行。主要是用于以后编写设备驱动程序，作比如参数修改，等等其它的除了open,read，write,lseek,close函数之外，所有的I/O操作使用。终端I / O是ioctl 的最大使用方面，主要用于设备的I / O控制，比如串口，网口，USB口等
#include<unistd.h>
#include<sys/ioctl.h>
#include<stropts.h>
#include<termios.h>//I/O终端的设备专用头文件
int ioctl(int fd,int cmd,指向变量或结构的指针);返回值：成功返回其它值，出错-1
通用设备驱动程序操作
类别       常量名        头文件        ioctl数
盘标号     DIOxxx    <sys/disklabel.h>   6
文件I/O    FIOxxx    <sys/filio.h>       9
磁带I/O    MTIOxxx   <sys/mtio.h>        11
套接字I/O  SIOxxx    <sys/sockio.h>      60
终端I/O    TIOxxx    <sys/ttycom.h>      44 

5、select函数：用来检测哪些设备有数据过来
（1）I/O处理的五种模型
①阻塞I/O：例如读串口，或者网络socket的时候，它数据不能及时到达，就需要阻塞了
②非阻塞I/O
③I/O多路转接模型：实现I/O复用，多路数据访问。如果请求的I/O 操作阻塞，但是他不是真正阻塞I/O，而只是针对这个功能进行阻塞。由于它是I/O复用的。因此，在这期间，它还能进行其它的I/O操作。例：select函数，用来检测哪些设备有数据过来。
④信号驱动I/O模型：在这种模型下，通过安装一个信号处理程序，系统可以自动捕获特定信号的到来，从而启动I/O。
⑤异步I/O模型：用法较少

(2)
传向select的参数告诉内核：
①我们所关心的描述符：即我们打开的设备，需要读的有哪些，需要写的有哪些
②当我们进行select操作时，我们会建立三个设备描述符集，读描述符集(包含多个设备读描述符，例如串口读，网络读等),  写描述符集，异常描述符集。例如，select会进行读描述符集的检测，当哪个I/O数据到达，就进行哪个I/O 操作
③希望等待多长时间（可以永远等待，等待一个固定量时间，或完全不等待）。

从select返回时，内核可以告诉我们的基本数据：
①已准备好的描述符的数量：只要有一些设备I/O进行请求了，就会进行登记，这样等下只要对登记的那几个I/O进行处理即可
②哪一个描述符已准备好读、写或异常条件。

(3)
<sys/types.h>
<sys/time.h>
<unistd.h>
返回值：成功即准备就绪的描述符个数，若超时则为0，出错则-1
int select(int numbds,描述符集，表示我们整个的描述符有多少。数量值是需要检查的号码最高的文件描述符再加1 fd_set *readfds,由select监视的读文件描述符集合 fd_set *writefds,由select监视的写文件描述符集合
fd_set *exeptfds,由select监视的异常处理文件描述符集合，表示哪些设备是用于异常处理的
struct timeval *timeout等待的时间，即是超时计时)

timeout结构
struct timeval
{
 long tv_sec;秒
 long tv_unsec;毫秒
}

timeout参数：
NULL     永远等待，直到捕捉到信号，或文件描述符已准备好为止
具体值   一个具体时间，是struct timeval类型的指针，若时间到了还没有准备好，就返回
0        从不等待，测试完了立即返回

select函数对文件描述符进行分类处理：
FD_ZERO(fd_set *set)清除一个文件描述符集
FD_SET(int fd,fd_set *set)将一个文件描述符加入相应文件描述符集中
FD_CLR(int fd,fd_set *set)将一个文件描述符从文件描述符集中清除
FD_ISSET(int fd,fd_set *set)测试该文件描述符集中，文件描述符fd是否产生相关的操作

一般用法：
FD_ZERO清零，初始化一个文件描述符集->FD_SET添加入文件描述符集中->FD_ISSET测试描述符集(在使用select函数时，可循环使用FD_ISSET测试描述符集)->select进行检测，如果有文件描述符变化，则进行相关操作->FD_CLR清除文件描述符集

例：
#include<fcntl.h>
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/time.h>
int
main(void)
{
  int fds[2];
  char buf[7];
  int i,rc,maxfd;
  fd_set inset1,inset2;
  struct timeval tv;

  if((fds[0]=open("hello1",O_RDWR|O_CREAT,0666))<0)
  {
    perror("open hello1 error"); 
  }
  if((fds[1]=open("hello2",O_RDWR|O_CREAT,0666))<0)
  {
    perror("open hello2 error");
  }
  if(rc=write(fds[1],"Hello!\n",7))//写到hello2文件中
    printf("write rc=%d to hello2\n",rc);
  lseek(fds[1],0,SEEK_SET);        //hello2偏移量重设为起始地址  
  maxfd=fds[0]>fds[1]?fds[0]:fds[1];//得到两个文件描述符集中，较大的那一个

  
  FD_ZERO(&inset1);//初始化读文件描述符集inset1
  FD_SET(fds[0],&inset1);//将文件描述符fds[0]添加入inset1
  FD_ZERO(&inset2);//初始化写文件描述符集inset2
  FD_SET(fds[1],&inset2);//将文件描述符fds[1]添加入inset2

  //设超时时间为2s
  tv.tv_sec=2;
  tv.tv_usec=0;

  //循环检测，inset1中fds[0]，inset2中fds[1]，有没有发生改变
  while(FD_ISSET(fds[0],&inset1)||FD_ISSET(fds[1],&inset2))
  {
    if(select(maxfd+1,&inset1,&inset2,NULL,&tv)<0)//等待2s，发现是否有准备就绪的描述符个数
    {
      perror("select error");
    }
    else
    {
      //若在读字符集中hello1文件表示，它的数据已经准备好了，可以读了，产生了一个信号
      if(FD_ISSET(fds[0],&inset1))
      {
        rc=read(fds[0],buf,7);//读文件
        if(rc>0)
        {
          buf[rc]='\0';
          printf("read:%s from hello1\n",buf);
        }
        else
        {
          perror("read error");
        }
      }
      //若在写字符集中hello2文件表示，它现在需要写入数据，产生了一个信号
      if(FD_ISSET(fds[1],&inset2))
      {
        rc=write(fds[1],buf,7);
        if(rc>0)
        {
          buf[rc]='\0';
          printf("rc=%d,write:%s to hello2\n",rc,buf);
        } 
        else
        {
          perror("write error"); 
        }
        sleep(5); 
      }
    }
  }
  exit(0);
}

执行：每隔5s，从hello1文件中读出7个字节数据，写入hello2文件中

6、返回文件信息，属性结构
1）返回值：成功0，出错-1
#include<sys/stat.h>
int stat(const char *restrict 文件路径,struct stat *restrict buf);当所指的文件是一个符号链接时，stat函数返回的是该符号链接引用的文件的信息
int fstat(int fd,struct stat *buf);
int lstat(const char *restrict 文件路径,struct stat *restrict buf);类似stat，但是不同之处
在于，当所指的文件是一个符号链接时，stat函数返回的是该符号链接的有关信息

2）struct stat
{
  mode_t     st_mode;
  ino_t      st_ino;
  dev_t      st_dev;文件系统的设备号
  dev_t      st_rdev;只有字符特殊文件，块特殊文件才有这个值，包含实际设备的设备号
  nlink_t    st_nlink;
  uid_t      st_uid;该文件所有者
  gid_t      st_gid;该文件的组所有者
  off_t      st_size;文件长度多少字节  
  time_t     st_atime;文件最后访问时间
  time_t     st_mtime;文件数据最后更改时间
  time_t     st_ctime;文件状态最后更改时间
  blksize_t  st_blksize;文件I/O较合适的块长度
  blkcnt_t   st_blocks;分配的实际512字节块数量
}

3）st_mode：
文件类型：S_ISREG(st_mode)普通文件，S_ISDIR()目录，S_ISCHR()字符特殊文件,S_ISBLK()块特殊文件, S_ISFIFO()管道或FIFO,S_ISLNK()符号链接,S_ISSOCK()套接字

4）设置用户ID和组ID：

打开一个文件时，会有相关的三组ID：
实际用户ID，实际组ID：当前打开文件的用户ID，当前打开文件的用户所属的组ID
有效用户ID，有效组ID，附加组ID(可以操作文件的其它组的ID)：用于文件访问权限检查
保存设置用户ID和保存设置组ID：包含了实际用户ID，实际组ID的拷贝

本来，文件打开时，它的实际用户ID，实际组ID是当前打开文件的用户ID，所属组ID；而有效用户ID等于实际用户ID，有效组ID等于实际组ID

而函数S_ISUID()是设置用户ID函数，它将该文件的ID改为该文件所属的用户ID，它的值是即是st_uid中的值；
同理，S_ISGID()改为该文件所属组ID，它的值即是st_gid中的值；

5)文件访问权限
S_IRUSR,S_IWUSR,S_IXUSR：本用户读，本用户写，本用户执行
S_IRGRP,S_IWGRP,S_IXGRP：本用户所属组读，本用户所属组写，本用户所属组执行
S_IROTH,S_IWOTH,S_IXOTH：其它组读，其它组写，其它组执行

例如：一个程序passwd(1)作用是任何一个用户可以改变自己的ID口令，而本来这个口令文件是只有root才能更改的，一般ID无法更改，因此，只有通过设置用户ID和组ID，在打开口令文件时，将它临时提升为root的权限，才能让这个ID进行更改自己的口令

例：
#include"gzz.h"
#include<sys/stat.h>
void
main(int argc,char *argv[])
{
  int i;
  struct stat buf;
  char *str;
  if(argc<2)
  {
    perror("need filepath");
  }
  for(i=1;i<argc;i++)
  {
    printf("%s:",argv[i]);
    if(lstat(argv[i],&buf)==-1)
    {
      perror("lstat error");
      continue;
    }
    if(S_ISREG(buf.st_mode)) str="file"; 
    else if(S_ISDIR(buf.st_mode)) str="directory";
    else if(S_ISCHR(buf.st_mode)) str="character special";
    else if(S_ISBLK(buf.st_mode)) str="block special";
    else if(S_ISFIFO(buf.st_mode))str="pipe or fifo";
    else if(S_ISLNK(buf.st_mode)) str="link file";
    else if(S_ISSOCK(buf.st_mode))str="socket file";
    else str="unknow mode";
    printf("%s\n",str); 
  }
  exit(0);
}

执行：\4-10.exe /ho

7、文件访问权限判断：判断该文件是否可以进行读写操作权限，即使目前一个进程可能因为已经"设置了用户ID"以超级用户权限运行，因此Open函数是以有效用户ID为基础进行访问权限测试，而access这个函数还是按它的实际用户ID和实际组ID进行访问权限测试，以验证其实际用户能否访问一个给定的文件
int access("文件名"，mode);
mode:要判断的访问权限，可以取下面参数，或者使用"|"判断他们的组合R_OK可读，W_OK可写，X_OK可执行F_OK文件存在
返回值：成功返回0，若有一个条件不符，则返回-1

8、更改文件属性
1）更改文件权限函数：
返回值：成功0，错误-1
#include<sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd,mode_t mode);

mode：
S_IRUSR,S_IWUSR,S_IXUSR,S_IRWXU：本用户读，本用户写，本用户执行，本用户读写执行
S_IRGRP,S_IWGRP,S_IXGRP,S_IRWXG：本用户所属组读，本用户所属组写，本用户所属组执行，本组读写执行
S_IROTH,S_IWOTH,S_IXOTH,S_IRWXO：其它组读，其它组写，其它组执行
S_ISUID,S_ISGID:执行时设置用户ID，设置组ID
S_ISVTX：保存正文(粘住位)

2）umask:设置文件访问权限
#include<sys/stat.h>
mode_t umask(mode_t cmask);
cmask：添加了任何一个权限，就表示屏蔽了该文件的这个权限，即该权限被禁止了
S_IRUSR,S_IWUSR,S_IXUSR,S_IRGRP,S_IWGRP,S_IXGRP,S_IROTH,S_IWOTH,S_IXOTH


umask(0);即是读写执行的权限所有权限都设为0，即不屏蔽任何权限，即所有权限都打开了


3）更改文件用户ID和组ID：
返回值：成功0，出错-1
如果owner，group任何一个参数值为-1，则对应的ID都不会变
#include<unistd.h>
int chown(const char *pathname,uid_t owner,gid_t group);如果是文件链接，更改符号链接所指向文件的所有者
int fchown(int fd,uid_t owner,gid_t group);
int lchown(const char *pathname,uid_t owner,gid_t group);如果是文件链接，更改符号链接本身的所有者

9、截断文件
返回值：成功0，出错-1
#include<unistd.h>
int truncate(const char *pathname,off_t length);
int ftruncate(int fd,off_t length);
将文件揭短为length字节，如果原文件大于length字节，则超过length字节的就截掉了

10、更改文件
link:为原路径的文件existingpath创建一个新的链接newpath
#include<unistd.h>
int link(const char *existingpath,const char *newpath);成功0，出错-1

unlink:删除文件链接，如果这是最后一个链接，则删除该文件。但是，如果pathname只是一个文件链接，则只会删除该链接，而不会删除文件。
int unlink(const char *pathname);成功0，出错-1

remove：删除文件
int remove(const char *pathname)成功0，出错-1

rename:重命名
int rename(const char *oldname,const char *newname);成功0，出错-1

symlink:创建一个符号链接
int symlink(const char *actualpath,const char *sympath);成功0，出错-1

readlink:打开符号链接
ssize_t readlink(const char *restrict pathname,char *restrict buf,size_t bufsize);成功返回读到的字节数，出错-1

11、文件的时间
st_atime文件数据的最后访问时间
st_mtime文件数据的最后修改时间
st_ctime文件状态的最后更改时间，比如对文件的访问权限，用户ID，链接数的改变等

#include<utime.h>
int utime(const char *pathname,const struct utimbuf *times)成功0，出错-1
struct btimbuf
{
  time_t actime;访问时间
  time_t modtime;修改时间，只是st_mtime，我们不能更改st_ctime
}
它的时间是日历时间，times参数：
NULL：访问时间和修改时间设为当前时间
具体值：一个具体的时间

例：
#include"gzz.h"
#include<fcntl.h>
#include<utime.h>
int
main(int argc,char *argv[])
{
  int i,fd;
  struct stat statbuf;
  struct utimbuf timebuf;
  if(argc!=2)
  {
    perror("need iput filename");
    return 1;
  }
  if(stat(argv[1],&statbuf)<0)
  {
    perror("stat error");
    return 1;
  }
  if((fd=open(argv[1],O_RDWR|O_TRUNC))==-1)
  {
    perror("open file error");
    return 1;
  }
  close(fd);
  timebuf.actime=statbuf.st_atime;
  timebuf.modtime=statbuf.st_mtime;
  if(utime(argv[1],&timebuf)==-1)
  {
    perror("utime file error");
    return 1;
  }
  return;
}

执行：打开原有的文件test.txt后，将这个文件情空
      但是，它的原访问时间，原修改时间却不变

12、目录操作
1)mkdir:创建目录
#include<sys/stat.h>
int mkdir(const char *pathname,mode_t mode);成功0，出错-1

2)rmdir:删除目录，但里面必须是空的
#include<unistd.h>
int rmdir(const char *pathname);成功0，出错-1

3)读目录
#include<sirent.h>

DIR *opendir(const char *pathname)打开目录，成功返回指针，出错返回NULL
struct dirent *readdir(DIR *dp);读目录，成功返回指针，若在目录结尾或出错则返回NULL
struct dirent
{
  ino_t d_ino;            i节点
  char d_name[NAME_MAX+1];目录名字
}

void rewinddir(DIR *dp);
int closedir(DIR *dp);关闭目录,成功0，出错-1
long telldir(DIR *dp);返回dp关联的目录中的当前位置
void seekdir(DIR *dp,long loc);

13、更改当前工作目录
#include<unistd.h>
int chdir(const char *pathname);成功0，出错-1
int fchdri(int fd);成功0，出错-1

注意：这个函数只影响调用它的进程本身，而不影响其它进程，例如在程序中
chdir("/tmp");
执行：./mycd
       pwd,发现其工作目录没有更改，因为是shell创建了一个子进程，而由子进程来执行chdir
函数，因此本进程的工作目录没有更改

char *getcwd(char *buf,size_t size);得到当前工作目录绝对路径值。成功返回buf，出错返回NULL

14、设备特殊文件
写在文件的st_dev,st_rdev字段中。通过宏major,minor来访问主，次设备号
major(st_dev),minor(st_dev),major(st_rdev),minor(st_rdev)


//********    
//时间编程
//********
1、格林尼治时间，本地时间
1）日历时间：从过去一个时间点，即1970年1月1日0点，到现在所经过的秒数
#include<time.h>
（注意：typedef long time_t）
time_t time(time_t *tloc);从过去一个时间点，比如1970年1月1日0点，到现在所经过的秒数,返回值是一个秒数


2）时间转换
struct tm *gmtime(const time_t *timep)timep是日历时间，将日历时间转为格林尼治时间,并保存到tm中
struct tm *localtime(const time_t *timep)timep是日历时间，将日历时间转为本地时间,并保存到tm中

tm结构：
struct tm
{
  int tm_sec;//秒值
  int tm_min;//分钟值
  int tm_hour;//小时值
  int tm_mday;//这个时间是本月第几日
  int tm_mon;//这个时间是本年第几月
  int tm_year;//tm_year的值+1900=这个时间是哪一年
  int tm_wday;//这个时间是本周星期几
  int tm_yday;//这个时间是本年的第几天
  int tm_isdst;//日光节约时间，不用管
};

time_t mktime(struct tm *tmptr);将本地时间转成日历时间

size_t strftime(char *restrict buf,size_t maxsize,const char *restrict format,const struct tm *restrict tmptr);将tm格式的时间tmptr，进行格式化转化。结果存放于长度为maxsize的buf数组中。format是转化格式

3）时间显示
char *asctime(const struct tm *tm)将tm格式的时间转为字符串，进行显示
char *ctime(const time_t *timep)将日历时间转为本地时间的字符串形式

4）获取时间
int gettimeofday(struct timeval *tv,NULL)获取从今日凌晨到现在的时间差，保存到tv中；常用于计算时间耗时

timeval结构：
struct timeval
{
  int tv_sec;//秒数
  int tv_usec;//微秒数
}
例如：有一万零伍佰微秒，则tv_sec:10000,tv_usec：500，其中，1秒=1000毫秒=1000000微秒

例：
#include <sys/time.h> 
#include <stdio.h>
#include <stdlib.h> 
#include <math.h>

/* 算法分析 */
void function() 
{ 
	unsigned int i,j; 
	double y; 
	for(i=0;i<1000;i++) 
		for(j=0;j<1000;j++) 
			y++; 
} 

main() 
{ 
	struct timeval tpstart,tpend; 
	float timeuse; 

	gettimeofday(&tpstart,NULL); // 开始时间
	function(); 
	gettimeofday(&tpend,NULL);   // 结束时间

	/* 计算执行时间 */
	timeuse=1000000*(tpend.tv_sec-tpstart.tv_sec)+ 
		tpend.tv_usec-tpstart.tv_usec; 
	timeuse/=1000000; 

	printf("Used Time:%f\n",timeuse); 
	exit(0); 
} 

5）睡眠
unsigned int sleep(unsigned int seconds);使程序睡眠seconds秒
void usleep(unsigned long usec);使程序睡眠usec微秒

6）CPU时间，用clock_t保存这个时间值。时钟滴答数用来表示CPU的时间，用sysconf函数得到每秒的时钟滴答数。cpu时间=用户CPU时间+系统CPU时间
时钟时间：进程运行的时间总量
用户CPU时间：这条进程执行用户这条指令所用的时间
系统CPU时间：该进程执行这条指令中，其中在内核程序所用的时间

//********    
//进程编程
//********
*进程的基本概念 
1、顺序执行和并发执行
顺序执行：该程序独占整个系统中的所有资源，处理机严格按照程序所规定的顺序进行操作，只有在前一个操作执行完后，才进行后继操作。 即你写的代码一次一行，从头到尾顺序执行下来。它是封闭性的，即不可交互。它的每个操作开始的计算时间，所得的结果即是唯一的。以前的单用户单任务的DOS系统即是如此
多道程序设计：cpu同时运行多个进程，每个进程之间相互独立，它们之间的执行次序是随机的，它们可以引入部分的资源是共享的。
并发执行：在宏观角度看，某个时间段，几个程序是同时执行的。在微观的角度看，几个程序是交替的使用cpu执行。它们的执行过程是间断的，执行一段时间后，sleep一下，cpu交给另外的程序使用。各个进程之间，可以交互式的通讯，互斥访问，以及同步访问。每次重复执行这几个程序时，它们的执行顺序，每个操作开始的计算时间，所得的结果有可能是不一样的。
多个进程同时运行的，即称为多道程序设计

2、进程特征
进程的动态性:它有起始，执行，等待，阻塞，结束几种状态。它在运行时的状态都一直在改变的
进程的并发性，独立性：多个进程之间可以同时执行，并且各进程如果没有交互情况下，是单独运行的。
同步性，异步性：进程之间如果有数据交互，则是同步性。如果没有数据交互，则是交替执行的，即是异步性
3、进程状态转换
就绪：已分配进程已分配到除处理机以外的所有必要的资源（比如已分配PCB，内存，相应设备）后，只要再获得处理机便可立即执行，这时进程的状态称为就绪状态
执行状态：正在执行的状态
阻塞状态：正在执行的进程因发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，这种暂停状态被称为阻塞状态

      进程调度       未申请到相应I/O请求，或资源
就绪<---------->执行------------------>阻塞
 /\   时间片用完                        |
 |______________________________________|

4、进程的结构：由PCB，程序段(程序运行的流程)，数据段（存放全局变量，静态变量），堆段(存放malloc分配的空间)栈段(存放临时变量)组成

内存分配
一个C语言程序所占用的内存分为：
1、栈区：由编译器自动分配和释放，里面存放函数的参数值，局部变量的值等
      1）原理：存储系统中有一个记录空闲内存地址的链表，当系统受到程序的申请时，系统就开始遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序；同时，会将这个节点的首地址出记录本次分配的大小。这样，等下才能正确的释放本内存空间。如果找到的堆节点的大小与申请的大小不相同，则系统会自动的将多余的那部分也重新放入空闲表中
      
      2）申请大小限制：由于系统用链表来存储空闲内存地址，所以地址是不连续的，而链表的遍历方向是由低地址向高地址，所以它是向高地址扩展的数据结构。它的大小比较灵活，只受限于计算机的虚拟内存
      
      3）速度：由系统分配，速度较快
      
      4）内容：先进栈的是调用语句的下一条可执行语句的地址，然后是函数的各个参数，参数是由右往左入栈的，然后是函数中的局部变量。

2、堆区：由程序员分配释放，它的分配方式类似链表。若程序员不释放，程序结束时可能由操作系统回收
     1）原理：只要栈的剩余空间大于所申请的空间，系统就自动为程序提供内存，否则将报溢出异常
     2）申请大小限制：它是由高地址向低地址扩展的数据结构，是一块连续的内存区域。因此，栈顶和栈大小是系统预先规定好的，如果申请超出栈的剩余空间时，会溢出。因此，能从栈获得的空间较小。
     3）速度：一般由malloc等语句分配的内存，速度较慢，而且容易产生内存碎片
     4）内容：先存放堆大小，在存放具体程序员写的内容

全局区，以及静态区static：全局变量和静态变量的存储位置是在一起的，是在数据段中。初始化后的全局变量和      静态变量在同一块区域，而未初始化的全局变量和静态变量在相邻的另一块区域，程序结束      后由系统自动释放
文字常量区：存放常量字符串，程序结束后由系统释放
程序代码区：存放函数体代码的二进制代码
例：
int a=0;//全局初始化区
char *p1;//全局未初始化区
void
main
()
{
  int b,*p2;//栈
  char s[]="abc";//栈
  char *p3="123456"; //123456放在文字常量区，p3放在栈上
  static int c=0;//全局初始化区
  p1=(char *)malloc(10);//分配得到的10字节放在堆区
  p2=(char *)malloc(20);//分配得到的20字节放在堆区 
  strcpy(p1,"123456");//123456放在文字常量区,编译器会将它与p3指向的值123456优化成同一个地方
}

进程控制块PCB：描述了进程的结构特征PCB是进程存在的惟一标志，看这个进程是否在运行，主要是看它的PCB块是否存在。一般把PCB存放在操作系统专门开辟的PCB区内，它是一个链表操作。
1）它包括
进程标识符：每个进程都有惟一的进程标识符，它包括进程的ID号(PID)。
用户名或用户标识号：每个进程都隶属于某个用户(UID)，有利于资源共享与保护。控制同组用户，或不同组用户之间是否进行交                    互
家族关系：相关的家族信息(父进程PPID，子进程等)。Linux启动时，会创建一个init进程（1号进程,它在启动后由内核调用，并且不能终止。但是，要注意的是，它却只是一个普通的用户进程，而不是内核中的系统进程，但它以超级用户特权运行），由它创建(fork)接下来          的子进程。
处理机状态信息：通用寄存器、指令计数器、程序状态字（PSW）、用户栈指针等 
进程调度信息：进程状态。指明进程的当前状态，以作为进程调度和进程对换时的依据。
进程优先级：用于描述进程使用处理机的优先级别的一个整数，优先级别高的进程先获得处理机。对Linux来说，整数越小它            的优先级越高。所用的调度算法。
进程调度所需的其他信息：如进程已等待CPU的时间总和、进程已执行的时间总和等
事件：指进程被阻塞的原因，是I/O请求，内存不够等
程序和数据的地址：指出该进程的程序和数据所在的内存或外存物理地址，以便再调度到该进程执行时，能从中找到其程序                  和数据。
进程同步和通信机制：指实现进程同步和进程通信时所必须的机制，如Linux的同步机制：管道通信，消息队列指针、共享内                  存，信号(或称为软中断)，信号量等。这些数据应全部或部分地存放在PCB中。
资源清单：它是一张列出了除CPU之外的进程所需的全部资源和已经分配给该进程的资源清单
当前状态：当前该进程所占用的空间，正在访问的当前设备
链接指针：它给出了本进程（PCB）所在队列的下一个进程的PCB首地址。即链表的next指针

2）为了对PCB进行有效地管理，系统应把所有的PCB用适当的方式组织起来，目前常用的PCB组织方式有链接方式和索引方式两种：
① 链接方式
执行状态的指针->PCB5
就绪状态队列的指针，指向该链表的头地址：PCB1,next是4->PCB4,next是8->PCB8
阻塞状态队列的指针，指向该链表的头地址：PCB2,next是3->PCB3
空闲状态队列的指针，指向该链表的头地址：PCB6,next是7->PCB7,next是9
② 索引方式
执行状态的指针->PCB5
                                                        就绪索引表(按表顺序，逐条执行)
就绪状态队列的指针，指向就绪状态就绪索引表的头地址：->  PCB1地址   ->PCB1实际数据
                                                        PCB4地址   ->PCB4实际数据
                                                        PCB8地址   ->PCB8实际数据
阻塞状态队列的指针，空闲状态队列的指针一样

*进程的控制
1、操作系统内核：通常将一些与硬件紧密相关的模块，诸如中断处理程序、常用的设备驱动程序以及运行频率较高的模块（如时钟管理、进程调度和公共基本操作模块）都安排在紧靠硬件的软件层次中，并使之常驻内存，以提高操作系统的运行效率，通常把这一部分称为操作系统的内核（Kernel）。

内核将处理机的执行状态分成系统态和用户态两种：它们之间的数据是不能相互访问的。如果用户的应用程序需要访问核心态的数据，则必须先要将这个数据拷贝到用户态下，再访问

系统态：它具有较高特权，能执行一切指令，访问所有寄存器和存储区。比如驱动程序，我们先在用户态下编写。然后就挂        载在核心态下运行
用户态：这是具有较低特权的执行状态，只能执行规定的指令，访问指定的寄存器和存储区。即我们一般编写的应用程序

2、进程控制：创建、撤消进程以及完成进程在各种状态之间的转换，从而提高CPU利用率，尽量让多进程高效率并发执行和协调资源共享的目的。
进程的创建：使用fork函数，继承父进程的所有代码，数据结构，堆栈信息，基本的数据结构。扩展子进程自己的数据信息。然后由exec函数替换该进程空间，执行新的进程
进程的撤消：使用exit函数，全部释放进程的全部资源。一般情况下，都是子进程先撤销，然后让父进程维护。如果是父进            程先撤销，则子进程将会变成一个孤儿进程。过一段时间过后，Linux会将它交给init(1号)进程维护。一般是先把终止的进程设置为僵死状态，它向父进程申请死亡。父进程最终撤销该进程。
进程的阻塞
进程的唤醒：转到就绪状态

3、进程创建和撤销程序
1)获取ID
#include<sys/types.h>
#include<unistd.h>

pid_t getpid(void)获取本进程ID
pid_t getppid(void)获取父进程ID
pid_t getuid(void)获取进程的实际用户ID
pid_t geteuid(void)获取进程的有效用户ID
pid_t getgid(void)获取进程的实际组ID
pid_t getegid(void)获取进程的有效组ID

例：
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
int
main
(void)
{
  printf("PID=%d\n",getpid());
  printf("PPID=%d\n",getppid());
  return 0;
}
运行后，得到这个程序的PID，和他的PPID

2)进程创建
#include<unistd.h>
(1)
pid_t fork(void)
注意：它会返回两个值，相对于父进程，它返回其子进程的PID；相对于子进程，它返回0，如果出现错误，它返回一个负值

创建子进程时：他会复制父进程的地址空间内的数据结构，包括进程上下文，进程堆栈，内存信息，打开的文件描述符，信号控制设置，进程优先级，进程组号，当前工作目录，根目录，资源限制，控制终端等

不同的地方：子进程的运行时间这时会清0，不会继承父进程的时间；子进程不继承父进程对临界资源，文件等加的锁(独占锁，或共享锁)；子进程不继承父进程的告警信息，会清除；进程间通信有一个信号通信方式，父进程有些信号集是未确定，这时，子进程将不会继承，而是设为空集
例：
  pid_t pid;//定义一个变量，存放PID号
  int count=0;
  printf("PID=%d\n",getpid());
  printf("PPID=%d\n",getppid());
  pid=fork();//程序到了这里，本程序仍然只有一个进程，但是，这条语句却创建了一个子进程

  //到这里，本程序有两个进程：父进程，子进程。两个进程将会同时执行下面的代码。即子进程拷贝父进程下面的代码，    而上面的代码子进程却没有拷贝
  count++;
  if(pid<0)
    printf("error in fork!");
  else if(pid==0)
    //子进程执行代码时，只会执行这一个分支，子进程的ID号是getpid()，它创建的pid变量是0
    printf("I am the child process,ID is %d\n",getpid());
  else  
    //父进程执行代码时，只会执行这一个分支，父进程的ID号是getpid()，它创建的子进程ID号是pid变量
    printf("I am the parent prcess,ID is %d\n",getpid());

  printf("count=%d\n",count);
  /*
  注意：运行结果是：count=1
                    count=1
        因为：父进程，子进程它们是相互独立的，子进程只是继承父进程的数据结构，代码，堆栈结构。而具体的资源则        子进程会自己重建一个。因此在子进程中，它的count值原先仍然是0，它count++后，也只是1
  */
(2)pid_t vfork(void)
它与fork的不同点：fork是子进程拷贝父进程的数据段，而vfork是子进程只拷贝父进程最基本的内容，而其它是与父进程共享数据段；fork的父子进程执行次序不一定，而vfork是子进程先运行，父进程后运行
运行结果是：count=1子进程打印
            count=2父进程打印

（3）exec函数：它启动一个新程序，但是不会像fork一样产生一个新的PID，而是用现在的这个进程替换掉原先调用它的进程(包括所有数据，数据结构，堆栈等)，因此它的PID不会改变
一般使用方法：先用fork函数创建一个空间，再用exec函数占用这个空间，进行操作
返回值：出错时，为-1，成功则不返回

int execl(新程序的完整路径，新程序名字，执行参数1，执行参数2，...NULL)必须以NULL来结束

int execle(新程序的完整路径，新程序名字，执行参数1，执行参数2，char *const envp[])
注意：envp[]指定当前进程所使用的环境变量

int execlp(新程序的名字，新程序名字，执行参数1，执行参数2，...NULL)必须以NULL来结束
注意：新程序的名字将不含完整路径了，而是由path环境变量中查找该程序

int execv(新程序的完整路径，char *const argv[]);
它将被执行的程序所需要的命令行参数统一放到指针数组中

int execve(新程序的完整路径，char *const argv[]，char *const envp[]);

int execvp(新程序的名字，char *const argv[])

例：
  pid_t pid;
  char *argv[]={"ls","-al","/etc/passwd",NULL};

  printf("PID=%d\n",getpid());
  printf("PPID=%d\n",getppid());
  
  execl("/bin/ls","ls","-al","/etc/passwd",NULL);
  execlp("ls","ls","-al","/etc/passwd",NULL);
  execv("/bin/ls",argv);

  char *envp[]={"PATH=/tmp","USER=sunq",NULL};//环境变量参数列表,注意，一定要以NULL结尾
  execle("/bin/env","env",NULL,envp);
  execv("/bin/ls",argv,envp);

  printf("now the processID is %d\n",getpid());
注意：因为使用execl函数，用ls程序来代替原程序了，因此原程序最后一行代码
printf("now the processID is %d\n",getpid());
也不会执行了

(4)system
#include <stdlib.h>
int system(const char * string)
调用fork产生一个子进程，由子进程来调用/bin/sh -c string来执行参数string所代表的命令，即利用bash程序，string参数里面写上shell的指令
例：system("ls -al /etc/passwd");

3）进程等待
返回值是这个子进程的PID,出错则为-1
#include<sys/types.h>
#include<sys/wait.h>
pid_t wait(int *status)阻塞该进程，直到某个子进程(Status选项，为空时，代表任何结束的子进程，若不为空，则代表指定状态结束的子进程。)退出；如果没有任何子进程，则直接出错返回

pid_t waitpid(pid_t pid, int * status, int options) ;
wait和waitpid函数的区别：
在一个子进程终止前， wait 使其调用者阻塞，而waitpid 有一选择项，可使调用者不阻塞。
waitpid并不等待第一个终止的子进程，实际上它有若干个选择项，可以控制它所等待的特定进程。

pid的参数：
pid == -1 等待任一子进程。于是在这一功能方面waitpid与wait等效。
pid > 0 等待其进程I D与p i d相等的子进程。
pid == 0 等待其组I D等于调用进程的组I D的任一子进程。
pid < -1 等待其组I D等于p i d的绝对值的任一子进程。

options参数：
不加，则用0表示。或者可以用下面常量的按位或运算得结果
WCONTINUED若pid子进程暂停后又继续运行，则返回其状态
WNOHANG不阻塞,返回值为0
WUNTRACED若pid子进程已暂停，且暂停状态还未向父进程报告过，则返回其状态
WIFSTOPPED确定这个子进程是否暂停

例：pr=waitpid(pid,NULL,WNOHANG);调用waitpid，且父进程不阻塞


例：
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>
int
main
(void)
{
  pid_t pid,pr;  
  printf("PID=%d\n",getpid());
  printf("PPID=%d\n",getppid());
  pid=fork();
  if(pid<0)
    printf("error in fork!");
  else if(pid==0)
  {
    printf("I am the child process,ID is %d\n",getpid());
    sleep(10);//等待10秒
  }
  else
  {
    printf("I am the parent prcess,ID is %d\n",getpid());
    pr=wait(NULL);
    printf("I catched a child process with pid of %d\n",pr);
  }
    
  printf("now the processID is %d\n",getpid());
  return 0;
}
运行过程：
PID=6471//第一个进程列出它的PID
PPID=2222//列出第一个进程的父PID
第一个进程创建了一个子进程
此次是父进程先运行
I am the parent prcess,ID is 6471
父进程被阻塞
子进程开始运行
I am the child process,ID is 6472
子进程沉睡10s
now the processID is 6472
子进程运行结束

父进程开始运行
I catched a child process with pid of 6472
now the processID is 6471

4)中止进程
<stdlib.h>
exit:检查文件打开情况把文件缓冲区的内容写回文件中去->调用退出处理函数->清除I/O缓冲->进程     终止运行,清除其使用的内存空间，并清除其在内核中的数据结构
void exit(int status);参数status：0是正常结束，其它数值是进程出错

例：exit(0);
<unistd.h>
_exit:进程终止运行,清除其使用的内存空间，并清除其在内核中的数据结构
例：_exit(-1);

4、进程互斥和同步 
1）进程互斥：是指当有若干进程都要使用某一共享资源时，任何时刻最多允许一个进程使用，其他要使用该资源的进程必须等待，直到占用该资源者释放了该资源为止。
临界区：一次只允许一个进程访问的资源称为临界资源，把进程中访问临界资源的那段程序代码段称为临界区。
临界区代码：
进入区（Entry Section）；检查临界区正被访问的标志是否为未被访问
  临界区（critical Section）：访问临界资源的代码
退出区（Exit Section）：将临界区正被访问的标志恢复为未被访问的标志

临界区使用准则：空闲让进，忙则等待，让权等待(如果几个进程同时申请一个临界资源，则进行优先级判定。让优先级最高的先进入，其它进程等待)，有限等待（此时，其它等待的进程，随着等待时间的延长，优先级会慢慢提升）

2）进程同步：把异步环境下的一组并发进程因直接制约，使得各进程按一定的速度执行的过程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间互相发送的信号称为消息，信号或事件，这是一种最简单的通讯方式。
例如：需要生产者进程先生产，完了之后，才能由消费者进程进行消费。因此，这是一组先后执行的有一定顺序的进程。

3）进程同步中的信号量机制
（1）．记录型信号量
       struct semaphore
       { 
            int value；临界资源数目
            PCB *L；   指向进程控制块
       }S；
（2）．P、V原语操作
除了给信号量S初始化外，信号量的数值域仅能由P、V原语操作改变
P原语操作：临界资源S.Value减1
入口，A进程需要申请一个临界资源，进行一次P操作
 |
S.value=S.value-1
 |
S.value是否>0?----S.value减1后仍大于或等于零，则A进程使用一个临界资源，继续执行
 |
S.value减1后小于零，则需要该要求的A进程被阻塞(注意，每个临界资源都有各自的阻塞队列)
注意：临界资源可以有多个；
注意：如果有多个进程申请这个临界资源，在进行多次P操作后，若S.value为-n，则即有n个进程处于阻塞队列中

V原语操作：临界资源S.Value加1
入口，A进程对这个临界资源执行完毕之后，需要释放这个资源，进行一次V操作
 |
S.value=S.value+1
 |
S.value是否>0?----S.value加1后大于0，则进程保持不变(表示有临界资源可供使用，而且这个时候没有进程被阻塞在这个                   资源上，也就是说没有进程因为得不到这类资源而阻塞，所以没有被阻塞的进程，自然不需要唤醒)
 |
S.value加1后小于或等于零，则唤醒处于阻塞队列中的进程，比如B进程
注意：当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区进行操作了，并不需要再执行P操作了，因此如上的B进程无需再执行P操作；当执行完了临界区的程序后，就执行V操作

5、进程通信
通信（Communication）
意味着在进程间传送数据(一个进程需要将它的数据发送给另一个进程)；
或多个进程之间共享同样的资源，把进程间大批量数据的交换称为高级通信。；
把进程间控制信息的交换称为低级通信，一个进程需要向另一个或一组进程发送消息，通知他们发生了某种事件。比如控制信号，或软中断；
有些进程希望完全控制另一个进程的执行，此时控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变

1）进程通信的类型
各类型可以通过S ipcs查询各类型通信的状态

（1）管道通信，通信信息量较少
①原理：管道是单向的，先进先出的。它连接一个读进程和一个写进程，以实现它们之间通信的共享文件，。向管道提供输入的发送进程，以字符流方式将大量的数据送入管道，而接收进程从管道中接收数据。  
写进程-->|尾...管道.....头|<--读进程

②无名管道通信pipe：是半双工（每次只是进行读，或写数据），是建立在内存中，只用于亲缘关系的进程之间的通信
  创建： int pipe(int filedis[2]);如果系统调用成功，返回0。如果系统调用失败返回- 1：
	errno = EMFILE (没有空闲的文件描述符)
		    EMFILE (系统文件表已满)
		    EFAULT (fd数组无效)

它是系统自动在内存空间中创建的一个管道，用户不必知道。当一个管道建立时，他会自动创建两个文件描述符，filedis[0]用于读管道(头部)，filedis[1](尾部)用于写管道。即可看做打开了两个文件,他们的文件描述符是filedis[0]，filedis[1]。然后先往文件filedis[1]中写数据，再从文件filedis[0]中读数据；
  管道读写：父进程->创建pipe->通过fork创建子进程，此时子进程会继承父进程的管道->父进程通过管道写数据，子进程           通过管道读数据。
  速记方法：01，读写，头尾
  关闭管道：可以看作将文件filedis[0]，filedis[1]逐个关闭即可，即close(fd)关闭文件，关闭后，会自动卸载管道
例：
#include<unistd.h>
#include<sys/types.h>
#include<errno.h>
#include<stdio.h>
#include<stdlib.h>
int 
main
()
{
  int pipe_fd[2];
  pid_t pid;
  char buf_r[100];
  char *p_wbuf;
  int r_num;

  memset(buf_r,0,sizeof(buf_r));

  if(pipe(pipe_fd)<0)//父进程创建管道
  {
    printf("pipe create errno\n");
    return -1;
  }
  else
  {
    printf("pipe create success\n");
  }

  //父进程创建了子进程，现在，父子进程开始执行
  if((pid=fork())==0)//6、子进程开始运行
  {
    printf("\n");
    close(pipe_fd[1]);//7、子进程关闭写窗口
    sleep(2);//8、睡眠两秒，以便让父进程把数据都写完
    if((r_num=read(pipe_fd[0],buf_r,100))>0)//9、子进程从管道中读取数据
    {
      printf("%d numbers read from the pipe is %s\n",r_num,buf_r);
    }
    close(pipe_fd[0]);//10、子进程关闭读窗口
    exit(0);  //11、子进程撤销
  }
  else if(pid>0)//1、父进程开始执行
  {
    close(pipe_fd[0]);//2、父进程是用于写数据的，因此关闭读窗口
    if(write(pipe_fd[1],"Hello",5)!=-1)//3、写数据Hello World
       printf("parent write1 Hello!\n");
    if(write(pipe_fd[1]," Pipe",5)!=-1)
       printf("parent write2 pipe!\n");
    close(pipe_fd[1]);//4、写完毕，关闭写窗口
    waitpid(pid,NULL,0);//5、阻塞，直到pid所指向的子进程结束后，父进程再运行
    exit(0);//12、父进程撤销
  }
  return 0;
}

③标准流管道：管道的操作也有支持基于文件流的模式，类似fopen() / fclose()
打开：
FILE *popen ( char *command, char *type);如果成功，返回一个新的文件流。如果无法创建进程或者管道，返回NULL。
command：系统的shell命令
type：r读，w写。但不能同时为读和写。管道将会以参数type中第一个字符代表的方式打开。所以，如果你在参数type中写      入rw，管道将会以读的方式打开。
读写：类似文件流读写，比如fgets，fputs等等
关闭：
int pclose( FILE *stream );返回值： 返回系统调用wait4( )的状态。如果stream无效，或者系统调用wait4( )失败，则返回 -1。
注意此库函数等待管道进程运行结束，然后再关闭文件流，并且卸载管道。

例：
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#define BUFSIZE 1024
int main()
{
	FILE *fp;
	char *cmd = "ps -ef";
	char buf[BUFSIZE];
	buf[BUFSIZE] = '\0';	
	if((fp=popen(cmd,"r"))==NULL)//把cmd命令生成的数据的管道，以只读的方式打开
		perror("popen");
	while((fgets(buf,BUFSIZE,fp))!=NULL)
		printf("%s",buf);
	pclose(fp);
	exit(0);
}



④有名管道通信FIFO：是全双工（每次可同时进行读，写数据），是一种借助文件和文件系统。是用于同一系统中的所有进程之间的通信
#include<sys/types.h>
#include<sys/stat.h>
 创建：int mkfifo(const char *pathname,mode_t mode)返回：若成功则为0，若出错则为- 1
       pathname:保存FIFO的文件的路径
       mode:属性，即文件操作那一节的mode。mode:要判断的访问权限，可以取下面参数，或者使用"|"判断他们的组合            O_RDONLY   只读
        O_WRONLY   只写
        O_RDWR   读写
        O_APPEND以追加方式打开
        O_CREAT创建一个文件       
        O_EXCL用于测试文件是否存在，与O_CREAT合用时，如果文件存在，则返回错误消息
      
       FIFO出错相关信息：
            EACCES (无存取权限)
            EEXIST (指定文件不存在)
            ENAMETOOLONG (路径名太长)
            ENOENT (包含的目录不存在)
            ENOSPC (文件系统剩余空间不足)
            ENOTDIR (文件路径无效)
            EROFS (指定的文件存在于只读文件系统中)
       一旦创建了一个FIFO，就可以用open打开它，一般的文件访问函数，如close,read,write等都可用
 打开：没有使用O_NONBLOCK：访问要求无法满足时进程将阻塞，例如试图读取空的FIFO，将导致进程阻塞
       使用O_NONBLOCK：访问要求无法满足时进程不阻塞，例如试图读取空的FIFO，立即出错返回，errno是ENXIO
        O_RDONLY   只读
        O_WRONLY   只写
        O_RDWR   读写
        O_APPEND以追加方式打开
        O_CREAT创建一个文件
        O_NOBLOCK以非阻塞方式打开
        O_EXCL用于测试文件是否存在，与O_CREAT合用时，如果文件存在，则返回错误消息
 读写：读一次管道之后，这个数据就自动从管道中清除掉，这与读文件不同
 关闭：关闭后，文件管道还会存在，需要手动删除 
 



例：有两个程序，因为FIFO适用于两个互相无关的不同的进程
创建管道，并读数据read.c
#include<sys/types.h>
#include<sys/stat.h>
#include<errno.h>
#include<fcntl.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define FIFO "./myfifo.txt"

void
main
()
{
  char buf_r[100];
  int fd;
  int nread;
  //创建管道myfifo.txt，如果文件"./myfifo.txt"已存在，则报错
  if((mkfifo(FIFO,O_EXCL|O_CREAT)<0)&&(errno!=EEXIST))
     printf("cannot create fifo server\n");
  printf("preparing for reading bytes..\n");
  memset(buf_r,0,sizeof(buf_r));
  //打开管道，并且以非阻塞方式，如果读取的数据位空时，报错而不阻塞进程
  fd=open(FIFO,O_RDONLY|O_NONBLOCK,0);
  if(fd==-1)
  {
    perror("open");
    exit(1);
  }
  while(1)
  {
    memset(buf_r,0,sizeof(buf_r));
    //从管道中读数据
    if((nread=read(fd,buf_r,100))==-1)
    {
      if(errno==EAGAIN)
        printf("no data yet\n");
    }   
    printf("read %s from FIFO\n",buf_r);
    //为buf_r添加'\0'
    strcat(buf_r,"");
    printf("now %s\n",buf_r);
    //比较，如果是eixt的话，就退出程序，否则则继续监听管道
    if(strcmp(buf_r,"exit")==0)
    {
      printf("exit program\n");
      //关闭管道
      close(fd);
      //删除管道 
      unlink(FIFO);
      break;
    }
    sleep(2);
  }
  //退出进程
  exit(0);
}

打开管道，并写数据write.c
#include<sys/types.h>
#include<sys/stat.h>
#include<errno.h>
#include<fcntl.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define FIFO "./myfifo.txt"

void
main
(int argc,char *argv[])
{
  int fd;
  char w_buf[100];
  int nwrite;
  //以只读，非阻塞方式打开管道myfifo.txt
  fd=open(FIFO, O_WRONLY|O_NONBLOCK,0);
  if(argc==1)
  {
    printf("please send something\n");
    exit(1);
  }    
  strcpy(w_buf,argv[1]);  
  //向管道中写数据
  if((nwrite=write(fd,w_buf,100))==-1)
  {
    if(errno==EAGAIN)
      printf("the FIFO has not been read yet. please try again\n");
  }  
  else
      printf("write %s to the FIFO\n",w_buf);
  //关闭管道
  close(fd);
  //退出进程
  exit(0);
  //printf("%d\n",nwrite);
}

运行：
先运行read.c，让进程处于不断监听管道的状态
再运行write.c wwd，让进程发送消息wwd到管道中，就可看到read.c进程收到消息wwd

（2）信号signal，通信信息量最少：通知接收进程有某事件发生，这个进程收到该信号，并处理该信号
①原理：
  当用户按下某些按键时产生信号:例如按下DELETE键通常产生中断信号（SIGINT）。
  当硬件检测到的异常产生信号：除数为0，或无效的出错访问(SIGSEGV)等
  一个进程用kill(函数)将一个信号发送给另外一个进程
  一个用户用kill(命令)将一个信号发送给其它进程
  检测到某种软件条件已经发生，并将其通知有关进程时也产生信号。这里并不是指硬件产生条件（如被0除），而是软件条    件控制的。例如SIGURG (在网络连接上传来非规定波特率的数据)、SIGPIPE (在管道的读进程已终止后，读进程写此管道。写进程接收到管道后，就可以停止等待了)，以及  SIGALRM(进程所设置的闹钟时间已经到了)。


常见信号：
  SIGHUP从终端上因为正常或者非正常原因，发出的结束信号
  SIGINT键盘按下Ctrl+c发出的中断信号，程序结束
  SIGKILL发送给另一个进程，结束那个进程
  SIGTERM用户用kill命令发出的结束进程的信号
  SIGCHLD表示子进程停止或结束的信号
  SIGSTOP键盘的Ctrl+z，或调试程序的停止信号，程序结束
  SIGQUIT程序退出,键盘按下Ctrl+\，程序结束
  SIGKILL发送的Kill信号，终止进程
  SIGTTOU程序超时，产生的终止信号
  SIGIO如串口，并口，网络，USB口等开始传数据的时候，产生一个硬件中断，产生一个信号。这时即提醒程序员需要read         ，write进行读写数据操作了
  SIGUSR1,SIGUSR2用户自定义信号
  SIGPIPE管道异常信号
  SIGALRM定时器到期信号
  SIGFPE： 浮点异常信号（例如浮点运算溢出）；
  SIGILL在进程企图执行一条非法指令时(例可执行文件本身出现错误，或者试图执行数据段，堆栈溢        出时)发出，程序结束
  SIGFPE发生致命的算术运算错误时发出，例如浮点运算错误，溢出，除数为0等，程序结束

②发送信号函数
返回值：若成功则为0，若出错则为-1。
kill：即可向自身发送信号，也可向其它进程发送信号
raise：只能向自身进程发送信号
#include<sys/types.h>
#include<signal.h>
int kill(pid_t pid,int signo)
int raise(int signo)
pid参数值：
pid>0 将信号发给进程PID
pid==0将信号发给同组的进程
pid<0将信号发给其进程组ID等于pid绝对值的进程
pid==-1将信号发给所有的进程

例：
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
	pid_t pid;
	int ret;
	if((pid=fork())<0){
		perror("fork");
		exit(1);
	}
	if(pid == 0){
		raise(SIGSTOP);
		exit(0);
	}
	else{
		printf("pid=%d\n",pid);
		if((waitpid(pid,NULL,WNOHANG))==0){//由于父进程这时未阻塞的，因此会先运行父进程函数
			if((ret=kill(pid,SIGKILL))==0)
				printf("kill %d\n",pid);
			else{
				perror("kill");
			}
		}
	}
}

结果：pid=1384
      kill 1384


③信号闹钟alarm：设置一个时间值，即作为闹钟时间。当时间到了时，将产生SIGALRM信号给自己的进程。如果不捕捉此信号，则系统默认是终止该进程
返回值：0或以前设置的闹钟时间的余留秒数
#include<unistd.h>
unsigned int alarm(unsigned int seconds);secongds指定经过了几秒后，将产生信号SIGALRM。如果不忽略或不捕捉此信号，则其默认动作是终止该进程。

每个进程只能有一个闹钟时间。如果在调用alarm时，以前已为该进程设置过闹钟时间，而且它还没有超时，则上次设置的闹钟还剩多少秒将作为本次alarm函数调用的返回值。以前登记的闹钟时间则被新值代换。
如果有以前登记的尚未超过的闹钟时间，而且seconds值是0，则取消以前的闹钟时间，其上次设置的闹钟还剩多少秒还作为本次alarm函数调用的返回值。

例：具有超时限制的read函数
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>

#define MAXLINE 4096

static void sig_alrm(int signo);
{
  printf("in here alarm\n");
}

void 
main()
{
  int n;
  char line[MAXLINE];
  alarm(5);//设置超时时限
  if(signal(SIGALRM,sig_alrm)==SIG_ERR)//注册信号
    perror("signal");
  //等待读数据
  if((n=read(STDIN_FILENO,line,MAXLINE))<0)
    perror("read error");

  alarm(0);//取消超时闹钟
  write(STDOUT_FILENO,line,n);//输出数据
  exit(0);
} 

执行：
如果在5s内有输入数据，则打印出输出信息；如果没有输入数据，就显示
in here alarm

④挂起信号函数pause：使本进程挂起等待，直到收到了一个信号之后，程序才结束
#include<unistd.h>
int pause(void);返回值：-1，errno设置为EINTR
只有执行了一个信号处理程序并从其返回时，pause才返回。

例：
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

int
main
()
{
  int ret;
  ret=alarm(5);
  pause();
  printf("I have been waken up.%d\n",ret);//程序在pause就终止了，因此不执行这一句了
}
执行：只显示Alarm clock这一句

⑤当出现信号时，对信号的三种处理:
忽略信号：有两种信号SIGKILL，SIGSTOP这个不能忽略，只能执行后，去停止相关进程；其余的信号如果不处理的话，默认          忽略
为信号指定，调用一个用户编写的函数
为信号执行系统默认的动作，大多数就是停止该进程

⑥信号处理函数signal来处理信号
#include<signal.h>
void(*signal(int signo,void(*func)(int)))(int)返回：成功则为以前的信号处理配置，若出错则为SIG_ERR


理解：
signal(int signo,void(*func)(int))函数，它的参数(int,指向函数的指针)，它的返回值也是指向函数的指针
由于函数比较难以理解，将它重命名：
1、比如原函数是 void func(int);
2、定义它的一个指向函数的指针就是void (*f)(int);
3、那么为该定义的函数指针重命名就是typedef void(*sighandler_t)(int);  即用新类型名字sighandler_t 来代表void (*f)(int);
4、然后用这个新类型，定义一个指向函数的指针(类似于定义变量)： sighandler_t handler;即用handler来代表void (*f)(int);
5、再看上一层函数，因为这个函数的返回值也是指向函数的指针
sighandler_t signal(int signo,sighandler_t handler)
6、当用handler获取函数地址：赋值语句即是handler=func(int);
7、可以像调用原函数那样来使用这个函数指针signal(SIGINT,my_func);
  SIGINT是信号名字，my_func函数的原型是void my_func(int sign_no)

它的Func的值：
SIG_IGN:忽略此信号（有两个信号SIGKILL和SIGSTOP不能忽略）。
SIG_DFL：按系统默认方式处理
信号处理函数名：用这个函数来处理
例：
#include<signal.h>
#include<stdio.h>
#include<stdlib.h>

void my_func(int sign_no)
{
  if(sign_no==SIGINT)
    printf("I have get SIGINT\n");
  else if(sign_no==SIGQUIT)
    printf("I have get SIGQUIT\n");
}

int main()
{
  printf("Waiting for signal SIGINT or SIGQUIT\n");
  //步骤一，为这个进程注册两个信号，并设定这两个信号的处理方法
  signal(SIGINT,my_func);
  signal(SIGQUIT,my_func);
  //步骤二、将本进程挂起
  pause();
  //步骤三、收到信号时，调用my_func函数，并结束程序
  //步骤四、exit函数，撤销本进程
  exit(0);
}

运行：
ps aux 查找这个程序的进程号是2309,（一般是按时间顺序排列，在最后几行）
kill -s SIGQUIT 2309
或者kill -s SIGINT 2309发送信号
本进程接收到信号后，打印信息，然后执行exit(0)撤销本进程

⑦使用信号集函数组处理信号：一个处理函数可以接收，并处理一组多个信号
㈠原理：我们需要有一个信号集（signal set）的数据类型，它里面包含多个信号。在函数sigprocmask()中使用信号集，登记这个信号集调用的是哪个处理函数。信号集函数组包含几大模块： 创建函数集、登记信号集、检测信号集。

㈡信号操作一般流程：
Sigemptyset函数定义空信号集->Sigaddset函数往信号集中加载信号->Sigprocmask函数对不需要的信号集进行屏蔽->
定义信号处理函数：sa_mask屏蔽字，sa_handler遇到信号集时，调用的信号处理函数，sigaction登记相应的处理函数，并编译进去->Sigpending检测信号是否到达，一到达，就调用信号处理函数

㈢创建函数集
#include <signal.h>
返回值：若成功则为0，若出错则为-1
int sigemptyset(sigset_t * set) ;初始化信号集合为空，即定义一个空信号集；set即信号集
int sigfillset(sigset_t * set) ;初始化信号集合为所有信号的集合，即将目前计算机能处理的所有信号都加载进来
int sigaddset(sigset_t * set,int signo) ;将指定信号添加到现存集中
int sigdelset(sigset_t * set,int signo) ;从信号集中删除指定信号

返回值：若真则为1，若假则为0。	
int sigismember(const sigset_t * set, int signo) ;查询指定信号是否在信号集合中

㈣登记信号集：主要用于决定进程如何处理信号，即接收到一个信号之后，发现这个信号在我们的信号集当中，然后调用注册了的那一个相应的处理函数进行处理。首先使用sigprocmask函数判断检测或更改信号屏蔽字，然后使用sigaction函数处理进程接受到特定信号之后的行为。

信号屏蔽:一个进程的信号屏蔽字可以设定将某个信号阻塞，而不能递送给该进程的信号集。调用函数sigprocmask可以检测或更改(或两者)进程的信号屏蔽字。
返回值：若成功则为0，若出错则为-1
# include <signal.h>
int sigprocmask(int how, const sigset_t * set, sigset_t * oset) ;
	
oset：是非空指针（不是NULL），用于存储进程的当前信号屏蔽字。
set：若set是一个非空指针，则参数how指示如何修改当前信号屏蔽字。如果set是个空指针(NULL)，则不改变该进程的信号屏蔽字，how的值也无意义。
how参数：
SIG_BLOCK指该进程新的信号屏蔽字是其当前信号屏蔽字和set指向信号集的并集。set包含了我们希望阻塞的附加信号。
SIG_UNBLOCK指该进程新的信号屏蔽字是其当前信号屏蔽字和set所指向信号集的交集。set包含了我们希望解除阻塞的信号。
SIG_SETMASK指该进程新的信号屏蔽是set指向的值。

㈤sigaction函数:检查或修改(或两者)与指定信号相关联的处理动作。此函数取代了UNIX早期版本使用的signal函数。
返回值：若成功则为0，若出错则为- 1
#include <signal.h>
int sigaction(int signo, const struct sigaction * act,struct sigaction * oact) ;
	
signo：指定是要检测或修改具体动作的信号，SIGKILL，SIGSTOP除外。
若act指针非空，则指向特定的信号的处理函数。
如果oact指针非空，则存储原来对应的信号处理。
此函数使用下列结构：
struct sigaction 
{
	void (*sa_handler)(int signo); 指定信号signo关联的函数指针(*sa_handler)所指向的函数，可以设置为默认处                                       理SIG_DFL，忽略处理SIG_IGN，用户定义处理函数
	sigset_t sa_mask;是一个信号集，其包含在信号处理程序执行过程中应该被阻塞的信号。因此在调用信号捕捉函数                         之前，需要先将该信号集加入到信号屏蔽字段之中 
        int sa_flags; 对信号进行处理的各种选项
	void (*sa_restore);
} ;
sa_flags：
        SA_NODEFER\SA_NOMASK: 当捕捉到此信号时，在执行其信号捕捉函数时，系统不会自动阻塞此信号。
	SA_NOCLDSTOP: 进程忽略子进程产生的任何SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU信号
	SA_RESTART: 可让重启的系统调用重新起作用，即使系统重启。
	SA_ONESHOT\SA_RESETHAND: 自定义信号只执行一次，在执行完毕后恢复信号的系统默认动作

㈥检测信号集：检测信号是信号处理的后续步骤，但不是必须的。 sigpending函数运行进程检测“未决”信号（进程不清楚这个信号他现在存在的状态是什么），并进一步决定对他们做何处理。
 sigpending返回对于调用进程被阻塞不能递送和当前未决的信号集。
返回值：若成功则为0，若出错则为-1
#include <signal.h>
int sigpending(sigset_t * set) ;
	
例：
#include<sys/types.h>
#include<unistd.h>
#include<signal.h>
#include<stdio.h>
#include<stdlib.h>
void my_func(int signum)
{
  printf("If you want to quit,please try SIGQUIT\n");
}

int
main()
{
  sigset_t set,pendset;
  struct sigaction action1,action2;
  if(sigemptyset(&set)<0)//初始化信号集set
    perror("sigemptyset");
  if(sigaddset(&set,SIGQUIT)<0)//为信号集set添加信号SIGQUIT，SIGINT
    perror("sigaddset SIGQUIT");
  if(sigaddset(&set,SIGINT)<0)
    perror("sigaddset SIGINT");
  
  if(sigprocmask(SIG_BLOCK,&set,NULL)<0)//将信号集set附加到阻塞信号集中,将不会进行信号处理
    perror("sigprocmask");
  else
  {
    printf("blocked\n");
    sleep(5);                          //过5秒钟之后
  }
  if(sigprocmask(SIG_UNBLOCK,&set,NULL)<0)//将信号集set从阻塞信号集中剔除出来
    perror("sigprocmask");
  else
    printf("unblock\n");               //表示，set解除了相应的阻塞状态了

  while(1)                            //循环检测，等待现在是否有信号发送过来了
  {
    if(sigismember(&set,SIGINT))      //如果信号SIGINT在信号集合set中
    {
      sigemptyset(&action1.sa_mask);  //屏蔽信号集action1.sa_mask初始化
      action1.sa_handler=my_func;     //添加处理函数
      sigaction(SIGINT,&action1,NULL);//处理这个信号
    }
    else if(sigismember(&set,SIGQUIT))//如果信号SIGQUIT在信号集合set中
    {
      sigemptyset(&action2.sa_mask);  //屏蔽信号集action2.sa_mask初始化
      action2.sa_handler=SIG_DFL;     //系统默认处理这个信号
      sigaction(SIGTERM,&action2,NULL);//处理这个信号,注意，接收的信号是SIGQUIT，发送的信号是SIGTERM，
                                       //让它终止
    }
  }
}
执行./15001849.exe
blocked 说明SIGINT，SIGQUIT信号被阻塞了，无法使用
等待5秒钟
unblock	说明SIGINT，SIGQUIT信号解除阻塞了，现在可以使用
进入while循环，开始重复检测等待现在是否有信号发送过来了

Ctrl+c发送一个SIGINT信号
If you want to quit,please try SIGQUIT说明信号处理函数被重定义了，目前无法终止程序

Ctrl+\终止程序

（3）共享内存，通信信息量最多,这种方式需要使用到同步机制，如互斥锁和信号量等
①原理
A进程：PCB 程序段 [数据段]->    共享一块内存空间    <-[数据段] 程序段PCB：B进程,C进程,D进程等等多个进程
       1、将自己的数据段与共享内存作地址映射             1、将自己的数据段与共享内存作地址映射
       2、往自己的数据段写数据，即会同步到内存空间中去   2、将内存空间中的数据读到自己的数据段中
       3、释放自己的数据段与共享内存之间的地址映射       3、释放自己的数据段与共享内存之间的地址映射

注意：读完之后，它数据还会保留

#include<unistd.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/shm.h>
②使用shmget函数，创建共享内存：
  int shmget(key_t key,int size,int shmflg)成功，返回标识符，错误返回-1
  size:创建的内存的大小，单位字节，例如开一个1024字节的空间，即size=1024
  key:为IPC_PRIVATE时表示创建一块新的共享内存；为0，而shmflg为IPC_PRIVATE也是创建一块新的共享内存
  shmflg：使用共享内存的模式，一般写作S_IRUSR|S_IWUSR，表示可读可写的

  errno 错误类型： EINVAL (无效的内存段大小)
		   EEXIST (内存段已经存在，无法创建)
		   EIDRM (内存段已经被删除)
		   ENOENT (内存段不存在)
		   EACCES (权限不够)
		   ENOMEM (没有足够的内存来创建内存段)


③使用shmat函数，将创建的这段共享内存映射到具体的进程空间去  
  int shmat(int shmid,char *shmaddr,int flag)成功，返回共享内存映射到该进程中的地址空间，错误返回-1
  shmid:为shmget函数返回的共享存储标识符
  *shmaddr:通常用0，表示让系统自动为它分配一个地址
  flag：0    
  通常：利用返回共享内存映射到该进程中的地址空间，来对共享空间内的数据进行操作

  errno 错误类型： EINVAL(无效的IPC ID 值或者无效的地址)
		   ENOMEM (没有足够的内存)
		   EACCES (存取权限不够)

④用完后，撤销该进程与共享内存的映射
  int shmdt(char *shmaddr)
  errno错误类型： EINVAL (无效的连接地址)

例：
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<errno.h>
#include<unistd.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/shm.h>

#define PERM S_IRUSR|S_IWUSR

int
main
(int argc,char *argv[])
{
  int shmid;
  char *p_addr,*c_addr;
  if(argc!=2)
  {
    fprintf(stderr,"Usage:%s\n\a",argv[0]);
    exit(1);
  }
  //IPC_PRIVATE表示创建一个新进程；S_IRUSR|S_IWUSR，表示可读可写的表示是可读可写的
  if((shmid=shmget(IPC_PRIVATE,1024,PERM))==-1)
  {
    fprintf(stderr,"Create Share Memory Error:%s\n\a",strerror(errno));
    exit(1);
  }
  //创建子进程
  if(fork())//父进程写
  {
    //函数shmat返回共享内存映射到该进程中的地址空间，因此可以用指针p_addr
    //shmaddr:通常用0，表示让系统自动为它分配一个地址
    //通常：利用返回共享内存映射到该进程中的地址空间，来对共享空间内的数据进行操作
    p_addr=shmat(shmid,0,0);
    //把内存区p_addr的1024个字节，全部清除，用'\0'来代替
    memset(p_addr,'\0',1024);
    strncpy(p_addr,argv[1],1024);
    wait(NULL);
    //释放共享内存映射
    shmdt(p_addr);
    exit(0);
  }
  else//子进程读
  {
    sleep(1);//等待1s
    //通常：利用返回共享内存映射到该进程中的地址空间，来对共享空间内的数据进行操作
    c_addr=shmat(shmid,0,0);
    printf("Client get %s\n",c_addr);
    //释放共享内存映射
    shmdt(c_addr);
    exit(0);
  }
}


（4）消息队列，通信信息量较多,而且相比于管道，管道传送的数据字节流是无格式的，如果进程间的交互需要格式，则用消息队列传递。消息队列可以看做一个消息的链表，一条消息节点即是一个记录，需要具有特定的格式。
注意：读完这个消息后，它会自动从消息队列中删除

①直接通信方式原理：数据量较小
                        B进程消息队列
                        .............<-     B进程，接收消息
A进程,发送消息       -> .............

System V消息队列：它是随内核持续存在的，只有在内核重启，或者人工删除时，该消息队列才会被删除。每个消息队列都有一个唯一的键值ID。

②生成键值：
#include<sys/types.h>
#include<sys/ipc.h>
key_t ftok(char *pathname,char proj)创建一个文件，并将它转为一个消息队列，类似命名管道。返回文件名对应的键值
pathname:文件名
proj:随意设置一个数字或字符，只要不为0即可  

③打开/创建：
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
int msgget(key_t key,int msgflg)返回值，是与key相对应得消息队列描述符，错误-1
msgflg:
       IPC_CREAT|0666，如果有文件xx.txt（即key所对应的消息队列），则用此文件打开消息队列。如果没有文件，则创           建这个文件,它的权限是666,再创建新的消息队列；
           
           方法二：key=IPC_PRIVATE,msgflg不填，也可以创建消息队列       
       IPC_CREAT|IPC_EXCL如果要创建的消息队列已经存在，则报错
       IPC_NOWAIT读写消息队列要求无法满足时，不阻塞

④发送消息
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
int msgsnd(int msqid,struct msgbuf *msgp,int msgsz,int msgflg)向消息队列中发送一条消息，正确返回0，错误返回-1
msqid:已打开的消息队列描述符id
*msgp:存放消息的结构
struct msgbuf
{
  long mtype;消息类型>0，例如发送mtype=2的消息
  char mtext[1];消息数据的首地址
}
msgsz:消息大小，注意大小是length=sizeof(struct msgbuf)-sizeof(long)//需要减去消息类型的大小，才是实际数据大小
msgflg:发送标志不写时用0表示，表示调用阻塞直到条件满足为止。IPC_NOWAIT，指明读消息队列时没有足够的空间时，不阻塞等待，而会立即返回

⑤接收消息
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
int msgrcv(int msqid,struct msgbuf *msgp,int msgsz,long msgtyp,int msgflg)从消息队列中读取一个msgtyp类型的消息，并把消息存储在msgp指向的msgbuf结构中。读取成功后，将这条数据从队列中删除。正确返回0，错误返回-1。

msgtyp:>0接收消息队列中第一个类型为msgtyp的消息；<0接收消息队列中第一个类型值不小于msgtyp，且|该类型值|是队列中最小的消息；=0接收队列中的第一个消息

⑥控制消息
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
int msgctl(int msqid,int cmd,struct msqid_ds *buf)。正确返回0，错误返回-1
cmd:
IPC_STAT读取消息队列的数据结构msqid_ds，并将其存储在buf指定的地址中
IPC_SET按由buf指向的结构中的值，设置与此队列相关的结构中的下列四个字段：
	msg_perm.uid、msg_perm.gid、msg_perm;mode模式和msg_qbytes字节数。此命令只能由下列两种进程执行：一种是       其有效用户ID等于msg_perm.cuid或msg_perm.uid;另一种是具有超级用户特权的进程。只有超级用户才能增加      msg_qbytes的值。

IPC_RMID从系统中删除该消息队列以及仍在该队列上的所有数据。这种删除立即生效。仍在使用这一消息队列的其他进程在      它们下一次试图对此队列进行操作时，将出错返回EIDRM。此命令只能由下列两种进程执行：一种是其有效用户ID等于      msg_perm.cuid或msg_perm.uid;另一种是具有超级用户特权的进程。

一般用这种方法来撤销消息队列
例：msgctl(qid,IPC_RMID,NULL);

例：
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
#include<unistd.h>
#include<stdio.h>
#include<string.h>

struct msg_buf
{
  int mtype;//消息类型
  char data[255];//消息实际数据部分
};

int
main
()
{
  key_t key;
  int msgid;
  int ret;
  struct msg_buf msgbuf;

  key=ftok("./message.txt",'a');//利用文件message.txt创建消息队列
  printf("key=[%x]\n",key);
  //如果有文件message.txt，则用此文件打开消息队列。如果没有文件，则创建这个文件,它的权限是666，再创建消息队列
  msgid=msgget(key,IPC_CREAT|0666);

  if(msgid==-1)
  {
    printf("create error\n");
    return -1;
  }
  
  msgbuf.mtype=getpid();
  strcpy(msgbuf.data,"hello test");
  ret=msgsnd(msgid,&msgbuf,sizeof(msgbuf.data),IPC_NOWAIT);//发送消息

  if(ret==-1)
  {
    printf("send message error\n");
    return -1;
  }

  memset(&msgbuf,0,sizeof(msgbuf));

  ret=msgrcv(msgid,&msgbuf,sizeof(msgbuf.data),getpid(),IPC_NOWAIT);//读取消息
  if(ret==-1)
  {
    printf("recv message error\n");
    return -1;
  }
  printf("recv msg=[%s]\n",msgbuf.data);
  //撤销消息队列
  msgctl(msgid,IPC_RMID,NULL);
  //删除文件
  unlink("./message.txt");
  
}

间接通信方式：发送进程将消息发送到指定的信箱中，而接收进程从信箱中取得消息



（5）信号量：作为进程之间，以及同一进程的不同线程之间数据同步的手段；前面几种方法，的目的都是为了进程间数据的传递，而信号量却是为了进程之间的控制，互斥，同步，即主要是为了保护共享临界资源
①分类：
  二值信号量：只能取0(表示该资源不可用)，取1(表示该资源可用)；只能有一个进程可以访问
  计数信号量：信号量的值可以取任意非负的值，可有多个有进程可以访问。表示可以访问该资源的进程数目，0表示不能访                问了
/*
过程：与PV操作不同的是，它是表示这个资源可以同时访问的进程个数，而不是这个资源有几个；而且它必须>=0,因此当这个资源=0时，若此时有一个进程要访问它，看到它=0，就阻塞自己进程，(而PV操作是直接将它0-1=-1)；等到里面的进程使用完毕之后，这个资源=0+1=1(PV操作是-1+1=0)，它再去访问，同时这个资源=1-1=0(PV操作此时不会再操作，它还是0)
*/
 ②创建/打开
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/sem.h>
int semget(key_t key,int nsems,int semflg)返回信号量集合的ID，错误-1
key:key=ftok("./message.txt",'a');//利用文件message.txt创建消息队列
nsems:指定打开，或者创建的信号量集合中包含的信号量数目
semflg:
       IPC_CREAT|0666，如果有文件xx.txt（即key所对应的消息队列），则用此文件打开消息队列。如果没有文件，则创           建这个文件,它的权限是666,再创建新的消息队列；
           
           方法二：key=IPC_PRIVATE,semflg不填，也可以创建消息队列       
       IPC_CREAT|IPC_EXCL如果要创建的消息队列已经存在，则报错
       IPC_NOWAIT读写消息队列要求无法满足时，不阻塞

③操作
int semop(int semid,struct sembuf *sops,unsigned nsops)对信号量进行控制
semid:信号量集合的ID
sops:是一个操作数组，表明要进行什么操作
struct sembuf
{
  unsigned short sem_num;//决定要对集合中的第几个信号量进行获取，或者释放；它从0开始
  //决定对该信号量进行>0是释放信号量；<0是获取信号量，如果|-n|>现有信号量，则操作将会阻塞；直到
  //信号量的值>=|-n|为止，才会重新开始获取；=0则操作将会阻塞，直到信号量的值变为0
  short sem_op;
  //信号的操作标志，IPC_NOWAIT当操作不满足时，将不会阻塞，而是返回一个错误信息，并返回
  //IPC_UNDO不论是正常还是异常，当程序结束时，将一定会释放信号量
  short sem_flg;
}
nsops:sops所指向的数组的元素个数

（6）socket套接字：不同机器之间的进程通信
(1)网络编程的原理
应用层协议：Telnet，（FTP和TFTP）文件传输协议，SMTP简单文件传输协议，DNS域名服务
传输层协议：TCP面向连接的可靠的传输协议，UDP非连接的不可靠的传输协议
网络层协议：IP，ICMP(用于ping命令)，ARP(地址解析协议)

网络层协议中封装了网络层协议，网络层协议中封装了传输层协议，传输层协议封装了应用层协议

(2)网络编程基础
①socket类型：
   流式套接字(SOCK_STREAM)：创建出来的是基于TCP协议的socket
   数据报套接字(SOCK_DGRAM):创建出来的是基于UDP协议的socket
   原始套接字(SOCK_RAW):创建出来的是基于IP协议的socket

②网络地址:
㈠struct sockaddr用于记录网络地址
struct sockaddr
{
  u_short sa_family;指明属于哪一种协议的地址，采用AF_XXX形式，如AF_INT是IP协议
  char sa_data[14];具体的地址值,包含IP地址和端口号
}

㈡实际上，我们用升级版的struct sockaddr_in来记录网络地址
struct sockaddr_in
{
  short int sin_family;指明属于哪一种协议的地址，采用AF_XXX形式，如AF_INT是IP协议
  unsigned short int sin_port;端口号
  struct in_addr sin_addr;具体的地址值
  unsigned char sin_zero[8];填0
}
参数：
typedef struct in_addr
{
  union
  {
      struct
      {
        unsigned char s_b1,s_b2,s_b3,s_b4;
      }S_un_b;

      struct
     {
       unsigned short s_w1,s_w2;
     }S_un_w;

     unsigned long s_addr;//我们通常用这一个，即用32位的无符号长整形来存储一个IP地址

  }S_un;

}IN_ADDR;

㈢地址转换
参数S_addr：用32位的无符号长整形来存储一个IP地址，而一般地址的形式是例如192.168.0.12形式的，这就需要地址
转换

int inet_aton(const char *cp,struct in_addr *inp);
将a.b.c.d形式的IP地址(参数 cp)，转换为32位的IP地址,存储到inp中
inet_addr("192.168.1.1");  作用同上

char *inet_ntoa(struct in_addr in);
将32位的IP地址,转换为a.b.c.d形式

③字节序转换：不同CPU对变量的字节存储顺序可能不同，如果不处理，就会在互相传输中出现错误0x1234,传过去时，就会
被解释为0x3412。因此，在上传到网络时，需要转为网络的字节序；从网络上接收时，需要转为本机的字节序进行处理
bigendian:高位字节在低地址处,低位字节在高地址处；
littleendian:高位字节在高地址处，低位字节在低地址处；
网络使用：bigendian

htons();把unsigned short类型从主机序转为网络序
htonl();把unsigned long类型从主机序转为网络序
ntohs();把unsigned short类型从网络序转为主机序
ntohl();把unsigned long类型从网络序转为主机序

④使用IP地址，或主机名访问主机：在网络中访问一台主机，可以使用IP地址，或主机名。本地的主机可以使用localhost这个主机名进行访问
gethostbyaddr把IP地址转换为主机名
struct hostent *gethostbyname(const char *hostname)把主机名转为IP地址

struct hostent
{
  char *h_name;主机的正式名称
  char *h_aliases;主机的别名
  int h_addrtype;主机的地址类型AF_INET
  char **h_addr_list;主机的IP地址列表
}

#define h_addr h_addr_list[0]主机的第一个IP地址

⑤Socket编程函数
socket创建一个socket
bind把IP地址和端口号绑定到socket
connect与服务器建立连接
listen设置服务器能处理的最大连接要求
accept监听客户端的socket连接请求
send发送数据
recv接收数据
关闭连接

(2)TCP网络编程
#include <netdb.h> 
#include <sys/types.h> 
#include <netinet/in.h> 
#include <sys/socket.h>
返回值：成功0，出错-1

TCP服务器：
int sockfd,new_fd; 
struct sockaddr_in server_addr; 
struct sockaddr_in client_addr; 

sockfd=socket(AF_INET,SOCK_STREAM,0),出错-1，创建一个socket
/* 如果服务器终止后,服务器可以第二次快速启动而不用等待一段时间  */
 setsockopt(listen_fd,SOL_SOCKET,SO_REUSEADDR,&n,sizeof(int));

/* 服务器端填充 sockaddr结构 */ 
bzero(&server_addr,sizeof(struct sockaddr_in)); // 初始化,结构体内部置0
server_addr.sin_family=AF_INET;                 // 使用IP协议
server_addr.sin_port=htons(portnumber);         // (将本机器上的short数据转化为网络上的short数据)添加端口号
//添加地址
server_addr.sin_addr.s_addr=htonl(INADDR_ANY);  // INADDR_ANY绑定到所有的IP，即表明和任何主机通信  
//server_addr.sin_addr.s_addr=inet_addr("192.168.1.1");  //用于绑定到一个固定IP,inet_addr用于把数字加格式的ip                                                转化为整形ip


bind(sockfd,(struct sockaddr *)(&server_addr)本地地址,sizeof(struct sockaddr)地址长度),出错-1，把IP地址和端口号绑定到socket
listen(sockfd,5允许最大的请求数),出错-1，设置服务器能处理的最大连接要求

sin_size=sizeof(struct sockaddr_in); 
new_fd=accept(sockfd,(struct sockaddr *)(&client_addr)客户端地址,&sin_size地址长度)监听客户端的socket连接请求
fprintf(stderr,"Server get connection from %s\n",inet_ntoa(client_addr.sin_addr)); // 将网络地址转换成字符串                                                                 形式

send()，或write()发送数据
recv()，或read()接收数据
if((nbytes=read(new_fd,buffer,1024))==-1) 
{ 
	fprintf(stderr,"Read Error:%s\n",strerror(errno)); 
	exit(1); 
} 		
buffer[nbytes]='\0';
printf("Server received %s\n",buffer);
close(new_fd);//关闭文件


close(sockfd); 关闭连接



TCP客户端：
int sockfd; 
char buffer[1024]; 
struct sockaddr_in server_addr; 
struct hostent *host; 

if((host=gethostbyname(argv[1]))==NULL)  /* 使用hostname查询host 名字 */

sockfd=socket(AF_INET,SOCK_STREAM,0),出错-1，创建一个socket

/* 客户程填充服务端的资料 */ 
bzero(&server_addr,sizeof(struct sockaddr_in)); // 初始化,结构体内部置0
server_addr.sin_family=AF_INET;                 // 使用IP协议
server_addr.sin_port=htons(portnumber);         // (将本机器上的short数据转化为网络上的short数据)添加端口号
//添加地址
/*
1、char **h_addr_list;是主机的IP地址列表,因此h_addr_list指向第一个指针数组h_addr_list[0]的地址
2、h_addr即宏 h_addr_list[0]，表示第一个指针数组h_addr_list[0]的的值，它是指向主机的第一个"IP地址"
3、host是指针变量，从函数gethostbyname中得到
4、所以，host->h_addr即是保存主机的第一个"IP地址"的地址
5、*(host->h_addr)即是得到主机的第一个"IP地址"
6、因为对方是struct in_addr结构的，因此需要强制转换*((struct in_addr *)host->h_addr)
*/
server_addr.sin_addr=*((struct in_addr *)host->h_addr); // IP地址


if(connect(sockfd,(struct sockaddr *)(&server_addr)服务器地址,sizeof(struct sockaddr))==-1)出错-1，连接服务器

send(fd,const void *msg指向要发送数据的指针,int len数据长度,0)
或write()发送数据
/* 发送数据 */
fgets(buffer,1024,stdin); 
write(sockfd,buffer,strlen(buffer));

recv(fd,void *buf存放接收数据的缓冲区,int len数据长度,0)
或read()接收数据

close(sockfd);关闭连接

例：server
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>
#include<string.h>
#include<netdb.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/socket.h>

#define portnumber 3333

int main(int argc,char *argv[])
{
  int sockfd,new_fd;
  struct sockaddr_in server_addr;
  struct sockaddr_in client_addr;
  int sin_size;
  int nbytes;
  char buffer[1024];
  
  /*服务器端开始建立sockfd描述符*/
  if((sockfd=socket(AF_INET,SOCK_STREAM,0))==-1)
  {
    fprintf(stderr,"socket error:%s\n\a",strerror(errno));
    exit(1);
  }
  /*服务器端填充sockaddr结构*/
  bzero(&server_addr, sizeof(struct sockaddr_in));//初始化，结构体内都置0
  server_addr.sin_family=AF_INET;//使用IP协议
  server_addr.sin_port=htons(portnumber);//添加端口号  
  server_addr.sin_addr.s_addr=htonl(INADDR_ANY);//添加地址,INADDR_ANY表明和任何主机通讯
  /*绑定sockfd到IP地址*/
  if(bind(sockfd,(struct sockaddr *)(&server_addr),sizeof(struct sockaddr))==-1)
  {
    fprintf(stderr,"bind error:%s\n\a",strerror(errno));
    exit(1);
  }
  /*设置服务器能处理的最大连接要求*/
  if(listen(sockfd,5)==-1)
  {
    fprintf(stderr,"listen error:%s\n\a",strerror(errno));
    exit(1);
  }
  while(1)
  {
    /*服务器阻塞，监听客户端的socket连接请求*/
   sin_size=sizeof(struct sockaddr_in);
   if((new_fd=accept(sockfd,(struct sockaddr *)(&client_addr),&sin_size))==-1)
   {
     fprintf(stderr,"accept error:%s\n\a",strerror(errno));
     exit(1);
   }

   //将网络地址转成字符串形式
   fprintf(stderr,"server get connection from %s\n",inet_ntoa(client_addr.sin_addr));

   //读数据
   if((nbytes=read(new_fd,buffer,1024))==-1)
   {
     fprintf(stderr,"read error:%s\n",strerror(errno));
     exit(1);
   }
   buffer[nbytes]='\0';
   printf("server received %s\n",buffer);
   //关闭文件
   close(new_fd);
   //循环下一个
 }
  //关闭连接
  close(sockfd);
  exit(0);
}


client：
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>
#include<string.h>
#include<netdb.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/socket.h>

#define portnumber 3333

int main(int argc,char *argv[])
{
  int sockfd;
  struct sockaddr_in server_addr;
  struct hostent *host;
  char buffer[1024];
  
  if(argc!=2)
  {
    fprintf(stderr,"usage:%s hostname \a\n",argv[0]);
    exit(1);
  }
 
  //使用hostname查询host 名字
  if((host=gethostbyname(argv[1]))==NULL)
  {
    fprintf(stderr,"gethostname error\n");
    exit(1);
  }
 
  if((sockfd=socket(AF_INET,SOCK_STREAM,0))==-1)//客户程序开始建立 sockfd描述符 
  {
    fprintf(stderr,"socket error:%s\a\n",strerror(errno));
    exit(1);
  }

  /* 客户程序填充服务端的资料 */ 
  bzero(&server_addr, sizeof(struct sockaddr_in));//初始化，结构体内都置0
  server_addr.sin_family=AF_INET;//使用IP协议
  server_addr.sin_port=htons(portnumber);//添加端口号

//添加地址
/*
1、char **h_addr_list;是主机的IP地址列表,因此h_addr_list指向第一个指针数组h_addr_list[0]的地址
2、h_addr即宏 h_addr_list[0]，表示第一个指针数组h_addr_list[0]的的值，它是指向主机的第一个"IP地址"
3、host是指针变量，从函数gethostbyname中得到
4、所以，host->h_addr即是保存主机的第一个"IP地址"的地址
5、*(host->h_addr)即是得到主机的第一个"IP地址"
6、因为对方是struct in_addr结构的，因此需要强制转换*((struct in_addr *)host->h_addr)
*/
  server_addr.sin_addr=*((struct in_addr *)host->h_addr);// IP地址

  /* 客户程序发起连接请求 */ 
  if(connect(sockfd,(struct sockaddr *)(&server_addr),sizeof(struct sockaddr))==-1)
  {
    fprintf(stderr,"connect error:%s\a\n",strerror(errno));
    exit(1);
  }
  printf("please input char:\n");/* 连接成功了 */ 
  
  /* 发送数据 */
  fgets(buffer,1024,stdin);
  write(sockfd,buffer,strlen(buffer));

  /* 结束通讯 */ 
  close(sockfd);
  exit(0);
}

执行：
server
./03000523.exe
阻塞到accpet函数中,当客户端连接后
server get connection from x.x.x.x
再次阻塞，在read函数中，打算读取客户端发送的数据

client:
./03000523c.exe localhost注意，客户端需要添加服务器的机器名，或者机器IP地址

(2)UDP网络编程
#include <netdb.h> 
#include <sys/types.h> 
#include <netinet/in.h> 
#include <sys/socket.h>
#include <arpa/inet.h>
UDP服务器：
int sockfd; 
struct sockaddr_in addr; 

sockfd=socket(AF_INET,SOCK_DGRAM,0),出错-1，创建一个socket
/* 如果服务器终止后,服务器可以第二次快速启动而不用等待一段时间  */
 setsockopt(listen_fd,SOL_SOCKET,SO_REUSEADDR,&n,sizeof(int));

/* 服务器端填充 sockaddr结构 */ 
bzero(&server_addr,sizeof(struct sockaddr_in)); // 初始化,结构体内部置0
server_addr.sin_family=AF_INET;                 // 使用IP协议
server_addr.sin_port=htons(portnumber);         // (将本机器上的short数据转化为网络上的short数据)添加端口号
//添加地址
server_addr.sin_addr.s_addr=htonl(INADDR_ANY);  // INADDR_ANY绑定到所有的IP，即表明和任何主机通信  
//server_addr.sin_addr.s_addr=inet_addr("192.168.1.1");  //用于绑定到一个固定IP,inet_addr用于把数字加格式的ip                                                转化为整形ip


bind(sockfd,(struct sockaddr *)(&server_addr),sizeof(struct sockaddr)),出错-1，把IP地址和端口号绑定到socket

recvfrom(sockfd,void *buf存放接收数据的缓冲区,MAX_MSG_SIZE数据长度,0,struct sockaddr *fromaddr来自的源机器的IP地址和端口号信息,int *fromlen地址长度)开始等待接收数据

void udps_respon(int sockfd) 
{ 
	struct sockaddr_in addr; 
	int addrlen,n; 
	char msg[MAX_MSG_SIZE]; 

	while(1) 
	{	/* 从网络上读,并写到网络上 */ 
		bzero(msg,sizeof(msg)); // 初始化,清零
		addrlen = sizeof(struct sockaddr); 
		n=recvfrom(sockfd,msg,MAX_MSG_SIZE,0,(struct sockaddr*)&addr,&addrlen); // 从客户端接收消息
		msg[n]=0; 
		/* 显示服务端已经收到了信息 */ 
		fprintf(stdout,"Server have received %s",msg); // 显示消息
	} 
} 




close(sockfd); 关闭连接



UDP客户端：
int sockfd; 
struct sockaddr_in addr; 

sockfd=socket(AF_INET,SOCK_STREAM,0),出错-1，创建一个socket

/* 客户程填充服务端的资料 */ 
bzero(&server_addr,sizeof(struct sockaddr_in)); // 初始化,结构体内部置0
server_addr.sin_family=AF_INET;                 // 使用IP协议
server_addr.sin_port=htons(portnumber);         // (将本机器上的short数据转化为网络上的short数据)添加端口号
//添加地址
if(inet_aton(argv[1],&addr.sin_addr)<0)  /*inet_aton函数用于把字符串型的IP地址转化成网络2进制数字*/ 


bind(sockfd,(struct sockaddr *)(&server_addr),sizeof(struct sockaddr)),出错-1，把IP地址和端口号绑定到socket

sendto(sockfd,const void *buffer指向要发送数据的指针,strlen(buffer)数据长度,0,const struct sockaddr *toaddr指向目的地的IP地址和端口号信息,int tolen地址长度); 发送数据
/* 发送数据 */
void udpc_requ(int sockfd,const struct sockaddr_in *addr,int len) 
{ 
	char buffer[MAX_BUF_SIZE]; 
	int n; 
	while(1) 
	{ 	/* 从键盘读入,写到服务端 */ 
		printf("Please input char:\n");
		fgets(buffer,MAX_BUF_SIZE,stdin); 
		sendto(sockfd,buffer,strlen(buffer),0,addr,len); 
		bzero(buffer,MAX_BUF_SIZE); 
	} 
} 


close(sockfd);关闭连接


例：
server：
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>
#include<string.h>
#include<unistd.h>
#include<netdb.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<sys/types.h>
#include<arpa/inet.h>

#define SERVER_PORT 8888
#define MAX_MSG_SIZE 1024

void udps_respon(int sockfd)
{
  struct sockaddr_in addr;
  int addrlen,n;
  char msg[MAX_MSG_SIZE];

  //从网络上读数据
  while(1)
  {
    bzero(msg,sizeof(msg));
    addrlen=sizeof(struct sockaddr);
    //会阻塞，接收数据
    n=recvfrom(sockfd,msg,MAX_MSG_SIZE,0,(struct sockaddr *)(&addr),&addrlen);
    msg[n]=0;
    fprintf(stdout,"Server have received %s",msg);
  }
}

int main(void)
{
  int sockfd;
  struct sockaddr_in addr;
  
  if((sockfd=socket(AF_INET,SOCK_DGRAM,0))<0)
  {
    fprintf(stderr,"socket eror:%s\n",strerror(errno));
    exit(1);
  }
  
  bzero(&addr,sizeof(struct sockaddr_in));
  addr.sin_family=AF_INET;
  addr.sin_port=htons(SERVER_PORT);
  addr.sin_addr.s_addr=htonl(INADDR_ANY);

  if(bind(sockfd,(struct sockaddr *)(&addr),sizeof(struct sockaddr))<0)
  {
    fprintf(stderr,"bind error:%s\n",strerror(errno));
    exit(1);
  }
  
  udps_respon(sockfd);// 进行读操作

  close(sockfd);
}

client:
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>
#include<string.h>
#include<unistd.h>
#include<netdb.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<sys/types.h>
#include<arpa/inet.h>

#define SERVER_PORT 8888
#define MAX_BUF_SIZE 1024

void udpc_requ(int sockfd,const struct sockaddr_in *addr,int len)
{
  char buffer[MAX_BUF_SIZE];
  int n;
  
  while(1)
  {
    printf("please input char:\n");
    fgets(buffer,MAX_BUF_SIZE,stdin);
    sendto(sockfd,buffer,strlen(buffer),0,(struct sockaddr *)addr,len);
    bzero(buffer,MAX_BUF_SIZE);
  }
}

int main(int argc,char *argv[])
{
  int sockfd;
  struct sockaddr_in addr;

  if(argc!=2)
  {
    fprintf(stderr,"usage:%s server_ip\n",argv[0]);
    exit(1);
  }
  
  if((sockfd=socket(AF_INET,SOCK_DGRAM,0))<0)
  {
    fprintf(stderr,"socket eror:%s\n",strerror(errno));
    exit(1);
  }
  
  bzero(&addr,sizeof(struct sockaddr_in));
  addr.sin_family=AF_INET;
  addr.sin_port=htons(SERVER_PORT);
  if(inet_aton(argv[1],&addr.sin_addr)<0)
  {
    fprintf(stderr,"ip error:%s\n",strerror(errno));
    exit(1);
  }

  udpc_requ(sockfd,&addr,sizeof(struct sockaddr_in));
  
  close(sockfd);  
}

执行：
server
./04000347.exe

client:
./04000347c.exe localhost注意，客户端需要添加服务器的机器名，或者机器IP地址

(3)并发服务器
服务器模型：通常是一个server端，需要对应多个clinet端，这时server端就有几种模型
循环服务器：服务器在同一时刻，只能响应一个client
并发服务器：服务器在同一时刻，可以响应多个client

①UDP循环服务器：每次从socket中读取一个client的请求->处理->返回结果给该client,由于它不需要连接，所以它能同时处理多个client的请求
流程：
socket();
bind();
...
while(1)
{
  recvfrom();
  process();
  sendto();
}
②TCP循环服务器：每次从socket中读取一个client的请求->处理->返回结果给该client->断开连接,它每次只能处理一个client的请求，并且只要这个client不放，server端就一直被占用下去
流程：
socket();
bind();
listen();
...
while(1)
{
  accept();
  process();
  close();
}
③TCP并发服务器：每个client的请求，是由服务器新建一个进程，来进行处理，所以它能同时处理多个client的请求
流程：
socket();
bind();
listen();
...
while(1)
{
  accept();
  if(fork()==0)
  {
    process();
    close();
    exit();
  }
  close();
}



例：
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>
#include<string.h>
#include<netdb.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/socket.h>

#define portnumber 3333

int main(int argc,char *argv[])
{
  int listen_fd,accept_fd;
  struct sockaddr_in client_addr,now_addr;
  int sin_size;
  int n,nbytes;
  
  
  
  if((listen_fd=socket(AF_INET,SOCK_STREAM,0))==-1)
  {
    fprintf(stderr,"socket error:%s\n\a",strerror(errno));
    exit(1);
  }
  
  bzero(&client_addr, sizeof(struct sockaddr_in));
  client_addr.sin_family=AF_INET;
  client_addr.sin_port=htons(portnumber);
  client_addr.sin_addr.s_addr=htonl(INADDR_ANY);
  n=1;
  /* 如果服务器终止后,服务器可以第二次快速启动而不用等待一段时间  */
  setsockopt(listen_fd,SOL_SOCKET,SO_REUSEADDR,&n,sizeof(int));
  
  if(bind(listen_fd,(struct sockaddr *)(&client_addr),sizeof(struct sockaddr))==-1)
  {
    fprintf(stderr,"bind error:%s\n\a",strerror(errno));
    exit(1);
  }
  
  if(listen(listen_fd,5)==-1)
  {
    fprintf(stderr,"listen error:%s\n\a",strerror(errno));
    exit(1);
  }
  while(1)
  {
   sin_size=sizeof(struct sockaddr_in); 
       
   if(((accept_fd=accept(listen_fd,(struct sockaddr *)(&now_addr),&sin_size))==-1)&&(errno==EINTR))
     continue;
   else if(accept_fd<0)    
   {
     fprintf(stderr,"accept error:%s\n\a",strerror(errno));
     exit(1);
   }
     fprintf(stderr,"server get connection from %s\n",inet_ntoa(now_addr.sin_addr));
  
   if((n=fork())==0)
   {
     char buffer[1024];
     
     if((nbytes=read(accept_fd,buffer,1024))==-1)
     {
        fprintf(stderr,"erad error:%s\n",strerror(errno));
        exit(1);
     }
     buffer[nbytes]='\0';
     printf("server received %s\n",buffer);
     close(listen_fd);
     close(accept_fd);
     exit(0);
   }
   else if(n<0)
     printf("fork error:%s\n\a",strerror(errno));

   close(accept_fd); 
  }  
}




2）息缓冲队列通信机制
类似进程消息队列，它们必须满足的条件是：读写消息队列应互斥访问
（1）消息缓冲区
    typedefstruct message buffer
    {
       sender；	//发送者进程标识符
       size；		//消息长度
       text；		//消息正文
       next；	//指向下一个消息缓冲区的指针
    }

（2）PCB中有关进程通信的数据项
    typedefstruct message block
    {
      …
      mq；	//消息队列队首指针
      mutex；//消息队列互斥信号量，初值为1
      sm；	//消息队列资源信号量，用于消息队列中的消息计数，初值为0
      …
    }

6、进程调度
1）进程调度的概念
高级调度：把硬盘上处于后备队列中的哪些作业调入内存
中级调度：中级调度大多针对于分时系统，是按一定的算法在内存和外存之间进行进程对换，目的在于缓和内存的紧张。 
低级调度：低级调度用于将内存中就绪队列中选择一个进程，把处理机分配给它，使其执行。 

2）进程调度的方式：A进程正在使用处理机，这时B进程过来申请了。而B进程的优先级比A进程要高。这时，有两种调度方式：非剥夺方式，剥夺方式(执行状态与就绪状态之间的交互)

3）进程调度算法：执行交互时，就绪队列之间选择哪一个进程去执行
先来先服务调度算法FCFS；
短进程优先调度算法SPF，对执行时间短的进程优先调度的算法；
高优先级优先（HPF）调度算法：处理机总是分配给就绪进程队列中优先级最高的进程，进程的优先级可采用静态优先级和动                    态优先级（随着等待时间的延长，或其它原因而自动提升）两种，优先级可由用户自定或由系统确定。 
时间片轮转法：以时间片为单位，轮流调度当前就绪队列中的第一个进程。一个进程在被调度选中之后用完了系统规定的时              间片，但未完成要求的任务，则它自行释放自己所占有的CPU，而排到就绪队列的末尾，等待下一次调度。

Linux的调度算法：一般把80号以下，是一个实时优先级。而80号以上，是一个非实时优先级。优先数越低的优先级越高。Linux先基于高优先级优先算                 法，再基于时间片轮转，和先来先服务调度算法。实时进程的优先级是固定的，不会改变

6、死锁：多个进程因竞争资源而形成一种僵局，若无外力作用，这些进程都将永远不能再向前推进
产生死锁的原因：竞争资源，进程推进顺序不当
产生死锁的必要条件：只要同时具备4个必要条件，才会发生死锁，但不一定会马上发生死锁
1）互斥条件：一个资源在一段时间内只能被一个进程所使用，具有排它性。
2）请求和保持条件：一个进程保持自己本身的资源不放，又要要求新的资源
3）不剥夺条件：进程已获得的资源，在未使用完之前不能被剥夺，只能在使用完时由自己释放
4）环路等待条件：P1正在等待P2占用的资源，P2正在等待P3占用的资源，…，Pn正在等待P1占用的资源。

处理死锁的方法：
1）预防死锁：在系统设计初期即选择一些限制条件，来破坏产生死锁的4个必要条件之一或其中几个
打破“请求和保持”条件，即把进程运行中所要求的所有资源在进程开始运行之前，一次性地分配给进程，只要有一种资源不能满足，该进程就必须等待。

打破“不剥夺”条件，即强迫那些请求新资源而没有立即得到满足的进程释放它已保持的其他资源。

打破“环路等待”条件，在资源的分配过程中，对资源的请求做出某种限制，使环路不可能出现。比如一个进程已有一个临界资源了，不允许它再申请另外的临界资源，这样子，环路条件也不会存在了。

2）避免死锁：死锁的必要条件的存在未必就一定会马上发生死锁，避免死锁并不严格限制死锁必要条件的存在，而是在资源   的动态分配过程中，使用某种方法去防止系统进入不安全状态，从而避免死锁的最终出现。

3）检测和解除死锁：在这种系统中，专门设置了一个检测机构，可以随时检测出死锁的发生，并能确定与死锁有关的进程和资源，然后采用适当的方法解除系统中的死锁状态。
常用的解除死锁的方法有两种：一是强制性地撤销一些死锁进程，并剥夺它们的资源给其他的进程；另一种是使用一个有效的挂起和解除挂起机构来挂起一些进程，比如自己需要的资源目前没办法获得，就先找一个机构把自己挂起来，先释放掉自己的资源，等下自己再想办法申请临界资源。

7、守护进程
守护进程是在后台运行的，不需要控制终端进行交互的，只提供一些系统服务；在系统引导装入时起动，在系统关闭时终止。例如vsftpd(注意，一般xxxd的即是守护进程)，http服务，samba服务等。
所有守护进程都以超级用户（用户I D为0）的优先权运行。
所有守护进程的父进程都是1号(init)进程
没有一个守护进程具有控制终端，因此终端名称设置为问号（？），(有控制终端的其它非守护进程，是用tty表示)、终端前台进程组I D设置为－1。
除update以外的所有守护进程都是进程组的唯一进程。也是：(一个或多个进程组成一个进程组->一个或多个进程组组成一个会话组)守护进程也是会话组的唯一进程)

1）守护进程编程规则
（1）创建子进程，父进程退出：首先做的是调用fork，然后使父进程exit。这样子，就会将子进程转为孤儿进程，交予init进程管理
（2）调用setsid，以创建一个新的会话组，并成为该会话组的首进程，与原来的会话组脱离。创建一个新的进程组，并成为该进程组的首进程，与原来的进程组脱离。脱离控制终端。要这么做的原因：原先在调用fork函数时，子进程复制了父进程的会话组，进程组，控制终端等。所以需要重新独立出来

返回值：成功时返回该进程组ID, 出错时返回-1
＃include <sys/types.h>
＃include <unistd.h>
Pid_t setsid(void)
（3）改变当前目录为根目录：因为例如使用一个U盘，先把它mount到文件系统中，打开U盘中的程序，如果这里面有守护进程的话，这样这个U盘就在系统关闭之前，都不能unmount卸载了
chdir(“/”);
（4）重设文件权限掩码：比如fork的子进程也继承了父进程对于这个文件的读写权限，但是这个子进程却需要对这份文件有更多的权限，例如子进程是守护进程时，就需要对这份文件更多的权限了。
屏蔽码：文件对应的那一位权限(读,写,执行)如果设置上后，以后这一位的这个权限就禁止了
        umask(0);即是读写执行的权限所有权限都设为0，即不屏蔽任何权限，即所有权限都打开了
(5) 关闭不再需要的文件描述符：用fork函数创建的子程序会从父进程那继承一些已经打开的文件，但是如果是作为守护进程，这些文件就需要关闭
for (i=0;i<MAXFILE;I++)
	close（i）；

例：
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<fcntl.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>
#include<syslog.h>

#define MAXFILE 65536
int
main()
{
  pid_t pc,sid;
  int i,fd,len;
  char *buf="This is a Dameon\n";
  len=strlen(buf);
  pc=fork();                               //（1）创建子进程，父进程退出
  if(pc<0)
  {
    printf("error fork\n");
    exit(1);
  }
  else if(pc>0)
  {
    exit(0);
  }
  openlog("16001843.c",LOG_PID,LOG_DAEMON);//打开系统日志服务
  if((sid=setsid())<0)                     //（2）调用setsid，以创建一个新的会话组
  {
     syslog(LOG_ERR,"%s\n","setsid error"); //出错时，向日志文件中写入消息
     exit(1);
  }
  if((sid=chdir("/")))                    //（3）改变当前目录为根目录 
  {
    syslog(LOG_ERR,"%s\n","chdir error");
    exit(1);
  }
  umask(0);                               //（4）重设文件权限掩码
  for(i=0;i<MAXFILE;i++)                  //(5) 关闭不再需要的文件描述符
    close(i);
  while(1)                                //守护进程循环往文件里面写入字符串
  {
    if((fd=open("/home/guozhenzhen/ctest/test.txt",O_CREAT|O_WRONLY|O_APPEND,0600))<0)
    {
      perror("open error");
      exit(1);
    }
    write(fd,buf,len+1);
    close(fd);
    sleep(5);
  }
  closelog();                             //关闭系统日志服务    
  exit(0);
}

执行：./16001843.exe
通过ps -ef  看到守护进程16001843.exe存在，并且得到它的PID=2223
查看到：test.txt文件没过5s钟，都向文件中写入字符串
kil -s SIGTERM 2223 将进程去掉


2）守护进程出错显示调试函数：代替printf，或perror的方法
通常将出错信息输入到“/var/log/messages”系统日志文件中去

（1）openlog函数：打开系统日志服务
#include <syslog.h>
void openlog(char * ident, int option, 	int facility) ;
Ident：当前运行的程序的名称；

option参数：
LOG_CONS： 若日志消息不能写到message日志文件中，则将该消息在屏幕上输出；
LOG_NDELAY：以非延时向message日志文件写入日志消息。
LOG_PERROR：将日志向message日志文件写入，还将它写至标准出错（stderr）。
LOG_PID：每条消息都包含进程ID，此选择项可供对每个请求都fork一个子进程的守护进程使用。

facility参数：
LOG_AUTH 授权程序: login.su,getty,...
LOG_CRONcron 和 at
LOG_DAEMON 系统守护进程：ftpd,routed,...
LOG_KERN 内核产生的消息
LOG_LOCAL0～7  保留由本地使用
LOG_LPR 行打系统：lpd, lpc,...
LOG_MAIL 邮件系统
LOG_NEWSU senet网络新闻系统
LOG_SYSLOG syslogd守护进程本身
LOG_USER 来自其他用户进程的消息
LOG_UUCP UUCP系统

（2）syslog函数：向日志文件中写入消息，在这里可以规定消息的优先级、消息的输出格式等
＃include <syslog.h>
void syslog(int priority, char *format, ...);
format:具体消息

Priority选项（消息优先级）：从高到低
LOG_EMERG 紧急(系统不可使用) (最高优先级)
LOG_ALERT 必须立即修复的条件，即需要显示报警
LOG_CRIT 临界条件(例如，硬设备出错)
LOG_ERR 出错条件
LOG_WARNING 警告条件
LOG_NOTICE 正常，但重要的条件
LOG_INFO 信息性消息
LOG_DEBUG 调试排错消息(最低优先级)

（3）closelog函数：关闭系统日志服务
#include <syslog.h>
void closelog(void);

例：



*线程Thread
由于进程是一个资源拥有者，所以在进程的创建、撤消和调度切换以及进程的同步与通信中，系统必须付出较大的时空开销。正因为如此，在系统中所设置的进程数目不宜过多，进程切换的频率也不宜过高。
线程是进程中的一个实体，是被系统独立调度和分派的基本单位。它的执行环境很小，除了自身必需的堆栈、寄存器、优先级等私有资源外，共享其所属进程的资源。

1、线程属性
1）拥有自己的控制表(类似于PCB)
2）各进程的基本代码结构，数据空间都是独立的；一个进程内部含有多个线程，而进程内的所有线程，各线程共享所属进程的资源。
3）并发性：进程的并发性范围比较大。而线程是处理机的独立调度单位，多个线程可以并发执行。但是线程只能在进程内进行并发处理，范围比较小
4）调度：进程的调度开销比较大，线程只能在进程内进行互相调度，它们的速率更快
5）线程有动态性，也有状态转换等
6）通信：进程间通信费时，不方便；由于同一进程下各线程间共享数据空间，所以一个线程的数据可以同时为其它线程所用

2、线程的状态及其转换
    被调度                执行完成
备用-------------->运行-------------->终止
  ↑         被抢占/ \阻塞 
  |               /   \
  | 被选中     ↓      ↓
  |--------- 就绪 <--- 等待
  ----------↑↑  唤醒   / 
  |            \        / 资源不可用 
创建   资源可用 \      ↓
并初始            转换
化一个进程

2、线程创建
1）创建线程
#include<pthread.h>
返回值：正确0，错误-1
int pthread_create(pthread_t *tidp,const pthread_attr_t *att,void *(*start_rtn)(void),void *arg)
tidp:线程ID
attr:NULL，(线程属性)
start_rtn:线程要执行的函数，当线程创建起来之后，就要执行该函数，当执行完了之后，线程就卸载掉了。这与子进程创          建方法是不同的 
arg：start_rtn所指向的函数的参数

编译：因为pthread的库不是linux系统的库，因此在编译时，需要这样做
$$gcc -lpthread -o xxx.exe xxx.c

（1）无参数的处理函数，线程创建例子
#include<stdio.h>
#include<pthread.h>
void *myThread1(void)
{
    int i;
    for (i=0; i<2; i++)
    {
        printf("This is the 1st pthread,created by zieckey.\n");
        sleep(1);//Let this thread to sleep 1 second,and then continue to run
    }
}

void *myThread2(void)
{
    int i;
    for (i=0; i<2; i++)
    {
        printf("This is the 2st pthread,created by zieckey.\n");
        sleep(1);
    }
}

int
main()
{
    int i=0, ret=0;
    pthread_t id1,id2;
    
    /*创建线程1*/
    // (void*)myThread1的作用：形参void *(*start_rtn)(void)，实参是 *myThread1(void)，本来赋值的时候是
    //start_run=myThread1,因此只要穿myThread1即可
    //因为要强制转换成指针类型的，因此再加上(void*)myThread1
    ret = pthread_create(&id1, NULL, (void*)myThread1, NULL);
    if (ret)
    {
        printf("Create pthread error!\n");
        return 1;
    }
    
    /*创建线程2*/
    ret = pthread_create(&id2, NULL, (void*)myThread2, NULL);
    if (ret)
    {
        printf("Create pthread error!\n");
        return 1;
    }
    
    
    pthread_join(id1, NULL);
    pthread_join(id2, NULL);
    
    return 0;
}
执行：$gcc -lpthread -o 02000739.exe 02000739.c
this is the 2st pthread
this is the 1st pthread
this is the 2st pthread
this is the 1st pthread

（2）有参数的处理函数，线程创建例子
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>
void
*create(void *arg)
{
  int *num;
  //本来num=arg即可，因为num是int类型的指针，将void *arg进行强制转换(int *)arg
  num=(int *)arg;
  printf("create parameter is %d\n",*num);
  //将0进行强制转换
  return (void*)0;
}

int
main(int argc,char *argv[])
{
  pthread_t tidp;
  int error;
  int test=4;
  int *attr=&test;

  //(void *)attr作用：形参是*arg，实参是*attr，本来赋值是arg=att;
  //因为在处理函数中，*create(void *arg)，它是void *类型的，
  //因此，需要强制转换为void的指针,(void *)attr
  error=pthread_create(&tidp,NULL,create,(void *)attr);
  if(error)
  {
    printf("pthread_create is created not created\n");
    return -1;
  }
  sleep(1);
  printf("pthread_create is created\n");
  return 0;
}
执行：$gcc -lpthread -o 02001331.exe 02001331.c

(3)参数是字符串：
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void *create(void *arg)
{
    char *name;
    name=(char *)arg;
    printf("The parameter passed from main function is %s  \n",name);
    return (void *)0;
}

int main(int argc, char *argv[])
{
    char *a="zieckey";
    int error;
    pthread_t tidp;

    error=pthread_create(&tidp, NULL, create, (void *)a);

    if(error!=0)
    {
        printf("pthread is not created.\n");
        return -1;
    }
    sleep(1);
    printf("pthread is created... \n");
    return 0;
}    

（4）参数是结构：
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

struct menber
{
    int a;
    char *s;
};

void *create(void *arg)
{
    struct menber *temp;
    temp=(struct menber *)arg;
    printf("menber->a = %d  \n",temp->a);
    printf("menber->s = %s  \n",temp->s);
    return (void *)0;
}

int main(int argc,char *argv[])
{
    pthread_t tidp;
    int error;
    struct menber *b;
    b=(struct menber *)malloc( sizeof(struct menber) );
    b->a = 4;
    b->s = "zieckey";

    error = pthread_create(&tidp, NULL, create, (void *)b);

    if( error )
    {
        printf("phread is not created...\n");
        return -1;
    }
    sleep(1);
    printf("pthread is created...\n");
    return 0;
}

（5）例：线程共享数据段
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

//static int a=4;//③若使用这个静态变量a

int a = 1;//①若使用这个全局变量a

void *create(void *arg)
{
    printf("new pthread ... \n");
    printf("now a=%d  \n",a);
    a=a+1;
    return (void *)0;
}

int main(int argc,char *argv[])
{
    pthread_t tidp;
    int error;
    
    int a=5;//②若也打开了这个局部变量a

    printf("in main before a = %d\n",a);
    
    error=pthread_create(&tidp, NULL, create, NULL);

    if(error!=0)
    {
        printf("new thread is not create ... \n");
        return -1;
    }
    
    sleep(3);
    
    printf("new thread is created ... \n");

    printf("in main after a = %d\n",a);
    return 0;
}

若打开了①后,使用这个全局变量a
in main before a = 1
now a=2
in main after a =2


若打开了①和③后,使用这个静态变量a，同时在main中也使用了局部变量a
由于静态变量a是放在数据段里面，而局部变量a是放在栈里面，而线程在共享时，优先是共享数据段，再共享堆栈，
因此，本例子将优先使用数据段里面的a。结果如下所示
in main before a = 5
now a=1
in main after a =5

若打开了①和②后,使用这个全局变量a，同时在main中也使用了局部变量a
由于全局变量a是放在数据段里面，而局部变量a是放在栈里面，而线程在共享时，优先是共享数据段，再共享堆栈，
因此，本例子将优先使用数据段里面的a。结果如下所示
in main before a = 5
now a=1
in main after a =5

2)线程的终止
在进程中如果使用exit或_exit，会终止该进程，并且该进程内的所有线程都会终止。终止里面单独的线程的方法是
(1)处理函数中使用return语句，返回了
(2)本线程所在的进程被另外的进程终止了
(3)线程自己调用pthread_exit函数,即使用这个函数来代替exit(..)函数，来进行线程正常，或异常退出
#include<pthread.h>
voi pthread_exit(void *rval_ptr)，正确0，错误-1

rval_ptr:显示线程退出的返回值，可以通过函数pthread_join函数来得到

例：
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>

void *create(void *arg)
{
  printf("new thread create\n");
  return (void *)8;
}

int main()
{
  pthread_t tid;
  int error;
  void *temp;
  error=pthread_create(&tid,NULL,create,NULL);
  printf("mian thread!\n");
  if(error)
  {
    printf("thread is not create\n");
    return -1;
  }
  error=pthread_join(tid,&temp);
  if(error)
  {
    printf("thread is not exit\n");
    return -2;
  }
  printf("thread is exit code %d\n",(int)temp);
}

执行：程序是使用执行函数的return语句终止的线程，因此返回8

3)线程等待
#include<pthread.h>
int pthread_join(pthread_t tid,void **rval_ptr);正确0，错误-1，阻塞所调用的线程，直到该线程终止

tid：等待退出的线程的id
rval_ptr：该线程退出的返回值

例：
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>

void *thread(void *str)
{
    int i;
    for (i = 0; i < 10; ++i)
    {
        sleep(2);
        printf( "This in the thread : %d\n" , i );
    }
    return NULL;
}

int main()
{
    pthread_t pth;
    int i;
    int ret = pthread_create(&pth, NULL, thread, (void *)(i));
    
    pthread_join(pth, NULL);
    printf("123\n");
    for (i = 0; i < 10; ++i)
    {
        //sleep(1);
        printf( "This in the main : %d\n" , i );
    }
    
    return 0;
}
执行：它先等待，让线程的循环打印都完成后，线程终止，主程序再循环打印
如果pthread_join(pth, NULL);这句话去掉，则
①线程创建了后，该线程处于就绪态
②主进程执行了print 123
③主进程执行，打印了循环0
④线程开始执行态，打印了循环0
⑤线程循环打印和进程循环打印将会交替进行

如果pthread_join(pth, NULL);这句话去掉，而且主进程，线程的sleep都去掉，则
①线程创建了后，该线程处于就绪态
②主进程执行了print 123
③主进程执行，一直打印循环，线程不予启动

4)线程标识
#include<pthread.h>
pthread_t pthread_self(void)得到线程ID

例：线程处理函数中
void *create(void *arg)
{
  int i;
  printf("new thread create\n");  
  //得到线程ID,注意需要将它转为无符号型
  printf("the thread is %u,the process is %d\n",(unsigned int)pthread_self(),getpid());
  return (void *)8;
}

5）线程同步，通常有互斥锁和信号量
(1)mutex互斥锁
①分类
快速互斥锁：一个线程为这个共享资源上锁后，它的下一个线程再要上锁这个资源，则会阻塞，直至            该线程释放锁
递归互斥锁：能增加调用线程在互斥锁上加锁的次数
检错互斥锁：一个线程为这个共享资源上锁后，它的下一个线程再要上锁这个资源，则会报错，并马           上返回

②互斥锁的操作步骤：
#include<pthread.h>
返回值：正确0，错误-1
互斥锁初始化:int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t 
*mutexattr创建互斥锁的方法)
参数mutexattr:
PTHREAD_MUTEX_INITIALIZER 快速互斥锁
PTHREAD_RECURSIVE_MUTEX_ INITIALIZER_NP递归互斥锁
PTHREAD_ERRORCHECK_MUTEX_ INITIALIZER_NP检错互斥锁
   

互斥锁上锁：int pthread_mutex_lock(pthread_mutex_t *mutex)
互斥锁判断是否已上锁：int pthread_mutex_trylock(pthread_mutex_t *mutex)
互斥锁解锁：int pthread_mutex_unlock(pthread_mutex_t *mutex)
撤销互斥锁：int pthread_mutex_destroy(pthread_mutex_t *mutex)

(2)信号量
#include<semaphore.h>
#include<pthread.h>
int sem_init(sem_t *sem,int pshared,unsigned int value)创建，并初始化信号量
sem:信号量
pshared:取0
vlaue:信号量初始值

int sem_wait(sem_t *sem)即P操作，若信号量<0时，该进程会阻塞
int sem_trywait(sem_t *sem)即P操作，若信号量<0时，该进程会报错返回
int sem_post(sem_t *sem)即V操作
int sem_getvalue(sem_t *sem)得到信号量的值
int sem_destroy(sem_t *sem)删除信号量


6）线程清除
在线程的正常终止时，它会自动清除。但是当线程是非正常终止时，这时就需要手动进行清除工作
#include<pthread.h>
void pthread_cleanup_push(void(*rtn)(void *),void *arg)将清除函数压入清除栈
rtn:清除函数
arg:rtn函数的参数

void pthread_cleanup_pop(int execute)将清除函数弹出清除栈
execute:执行到pthread_cleanup_pop(）时，是否在弹出清除函数的同时执行该函数，1：执行；0：不执行

原理：
pthread_cleanup_push(存放一个清除函数,例如A函数)A函数一般放一些释放资源的代码
xxxxxxxxxxx
xxxxxxxxxxx可能存在异常出错的代码
xxxxxxxxxxx----->假设，在这里出现一个异常，则先调用清除函数,例如A函数，再终止线程
xxxxxxxxxxx
pthread_cleanup_pop()//如果保护的这段代码没有出现异常情况，则执行到这里，通过0，或1，来判断是否需要执行A函数

特例：如果被保护函数中有return语句的话，即使出栈函数pthread_cleanup_pop(1)，也不会执行

注意：如果
  //压栈操作
  pthread_cleanup_push((void *)clean,"thread 2 first handler");
  pthread_cleanup_push((void *)clean,"thread 2 second handler");

由于栈的特性，因此出栈时是
先thread 2 second handler
再thread 2 first handler

例：
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>

void *clean(void *arg)
{
  printf("cleanup: %s\n",(char *)arg);
  return (void *)0;
}
void *thr_fn1(void *arg)
{
    printf("thread 1 start  \n");
    //压栈操作
    pthread_cleanup_push( (void*)clean,"thread 1 first handler");
    pthread_cleanup_push( (void*)clean,"thread 1 second hadler");
    //受保护代码，start
    printf("thread 1 push complete  \n");
    if(arg)
    {
        return((void *)1);//函数类型void *表示返回值可以是任意类型指针
    }
    //受保护代码，end
    //出栈操作
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    return (void *)1;
}

void *thr_fn2(void *arg)
{
  printf("thread 2 start\n");
  //压栈操作
  pthread_cleanup_push((void *)clean,"thread 2 first handler");
  pthread_cleanup_push((void *)clean,"thread 2 second handler");
  //受保护代码，start
  printf("thread 2 push complete\n");
  if(arg)
  {
    pthread_exit((void *)2);//结束线程程序，的参数出错，将会启用异常处理函数
  }
  //受保护代码，end
  //出栈操作
  pthread_cleanup_pop(0);
  pthread_cleanup_pop(0);
  pthread_exit((void *)2);
}

int main()
{
  int err;
  pthread_t tid1,tid2;
  void *tret;
  
  err=pthread_create(&tid1,NULL,thr_fn1,(void *)1);
  if(err!=0)
  {
    printf("error create1\n");
    return -1;
  }

  err=pthread_join(tid1,&tret);
  if(err!=0)
  {
    printf("exit1 error...\n");
    return -1;
  }
  printf("thread 1 exit code %d\n",(int)tret);

  err=pthread_create(&tid2,NULL,thr_fn2,(void *)1);
  if(err!=0)
  {
    printf("error create2\n");
    return -1;
  }  
  
  err=pthread_join(tid2,&tret);
  if(err!=0)
  {
    printf("exit2 error...\n");
    return -1;
  }
  printf("thread 2 exit code %d\n",(int)tret);
  return 1;
 
}

执行：
thread 1 start
thread 1 push complete
thread 1 exit code 1

thread 2 start
thread 2 push complete
cleanup:thread 2 second handler
cleanup:thread 1 first handler
thread 2 exit code 1
*Linux进程概述
进程组成 ：正文段(代码段)，用户数据段，系统数据段
（1）运行状态（task_running）
（2）等待状态:即就绪态
（3）暂停状态（task_stopped）：即阻塞态
（4）僵死状态（task_zombie）：进程无法再执行，所有数据空间都无法使用了，过一段时间，Linux的init进程会处理掉这                              个进程，回收资源
       
     被唤醒       单步调试   异常，进程终止
    -------停止态------    ---------------->僵死状态
   ↓      进程调度   |   | 未申请到相应I/O请求，或资源
等待状态<---------->运行状态--------------------------->可中断暂停状态(即可以通过软件中断来唤醒)，或者
          时间片用完                                  | 不可中断暂停状态(即只能通过硬件中断来唤醒)
 /\                                                   |
 |____________________________________________________|

Linux进程的同步和通信：信号机制，管道机制，消息队列，共享内存，信号量

//********    
//串口编程
//********
1、原理： 串口传输是一位接一位的，象串起的珠子一样，以字节流的方式传送地址，或者数据进行访问。 并口传输是可以并发数据的可以同时传输多位，可以将数据与地址同时传输访问。串口一般用于通讯使用。一般使用RS-232-C标准。

1)校验位：
奇校验：数据位中‘1’的个数+校验位中‘1’的个数=必须为奇数
例：
发送方：
数据位10101100   校验位x，   4+x=奇数，所以校验位x=1 

接收方：
如果接收到的 数据位中‘1’的个数+校验位中‘1’的个数=为奇数，则没错；如果是偶数个，则说明发送出错

偶校验：数据位中‘1’的个数+校验位中‘1’的个数=必须为偶数
例：
发送方：
数据位10101100   校验位x，   4+x=偶数，所以校验位x=0 

接收方：
如果接收到的 数据位中‘1’的个数+校验位中‘1’的个数=为偶数，则没错；如果是奇数个，则说明发送出错

2)传输速率：注意，传输速率越高时，它最大传送距离越短。因此，一般传长距离时，是使用RS485转接
比特率：每秒传输的二进制代码的位数，单位是位/秒(bps)。
例：每秒传送240个字符，每个字符包含(1个起始位+8个数据位+1个停止位),这时比特率为
10*240个/秒=2400bps;

3）连接方式：是三线制
   A机器                         A机器
第2根RXD接收数据<---\/-------->第2根RXD接收数据
第3根TXD发送数据----/\---------第3根TXD发送数据
第5根SGND信号接地--------------第5根SGND信号接地



4）芯片内部常具有UART控制器，其可工作于Interrupt(中断模式)或DMA（直接内存访问）模式。串口通讯一般工作在中断方式中。UART的操作主要包括以下几个部分：
数据发送；
数据接收；
产生中断；实现中断控制，由相应的引脚产生相应的中断，再由中断通知操作系统采取什么操作
产生波特率；代表两台机器之间通讯的速率，两台机器的速率要相互匹配才可以，有9600，15200等
Loopback模式；发送数据到端口，再回送回来；实际上就是资料发送端TXD在UART内部就从逻辑上和接收端RXD连在一起
红外模式；连接到红外接口
自动流控模式；当传输速率过慢时，通过软件或硬件进行控制，保证速率稳定，数据及时到达

5）linux中的串口设备文件存放于/dev目录下：其中串口一，串口二对应设备名依次为“/dev/ttyS0”、“/dev/ttyS1”。
在linux下操作串口与操作文件相同。open->参数设置->read和write->close

2、串口打开：串口进行打开，
1）打开串口
#include <fcntl.h>

fd = open( "/dev/ttyS0", O_RDWR|O_NOCTTY|O_NDELAY);

   Open函数中除普通参数外，另有两个参数O_NOCTTY和O_NDELAY。
   O_NOCTTY: 通知linux系统，这个程序只是进行串口传输数据使用，因此不会成为这个串口端口的控制终端,即不会进行交             互操作。（例如：通过串口与开发板进行调试，此时就把串口作为一个控制终端。而对于一般的串口数据传输             ，是非控制终端的）
   O_NDELAY: 通知linux系统，不管这个另一端的设备是否处于正常状态，都发送数据过去。

2）恢复串口的状态为阻塞状态，用于等待串口数据的读入。用fcntl函数：
	fcntl（fd, F_SETFL, 0）;//0代表阻塞状态。 成功返回0，出错<0

3）测试打开的文件描述府是否引用一个终端设备，以进一步确认串口是否正确打开：串口设置完了，打开之后，需要确认
这个串口目前是否被别人使用。如果没有使用，则下面这个确认函数返回是正常的。如果被使用了，则会返回一个错误的描述符
	isatty(STDIN_FILENO);出错返回0

3、串口详细配置
1）串口参数的配置主要包括：波特率、数据位(发送时，一个片段里面包含几个数据位，有5,6,7,8)、校验位（发送的这个片段的数据含有1的数目，如果是奇数个，就是奇校验；如果是偶数个，就是偶校验）、停止位(一个片段发送过去后，一般是设1，表示一个停止位)、流控协议(设置是硬件流控制，软件流控制，无流控制模式，同样，两边设置应该一样)。串口设置由下面结构体实现
struct termios
{
  tcflag_t c_iflag;输入标记。是一个整形数，可以通过二进制来访问。设置时，是通过二进制数                   的相应位置1或置0来设，代表第几位置1或0时，是代表什么含义。Linux已设置了相应的宏来代表了
  tcflag_t c_oflag;输出标记。同理
  tcflag_t c_cflag;控制标记，即设置上面的参数配置
  tcflag_t c_lflag;本地标记
  cc_t     c_cc[NCCS];控制字符串
}
c_cflag控制标记：可设置波特率、数据位、校验位、停止位。在设置波特率时需在数字前加上‘B’，如B9600。B19200。使用其需通过“与”“或”操作方式。
CCTS_OFLOW            输出的CTS流控制,较少用到
CIGNORE               忽略控制标志,较少用到
CLOCAL                忽略调制-解调器状态行,较少用到
CREAD                 启用接收装置
CRTS_IFLOW            输入的RTS流控制,较少用到
CSIZE                 字符大小屏蔽，设置发送时，一个片段里面包含几个数据位，有5,6,7,8
CSTOPB                置1(默认)，送两个停止位；置0，否则为1位
HUPCL                 最后关闭时离开，默认就是断开，可设可不设
MDMBUF                经载波的流控输出
PARENB                设置1，则启用奇偶校验
PARODD                置1，奇校验；置0，为偶校验

c_iflag输入标记:接收端有关字符的控制
BRKINT    接到BREAK时产生的中断SIGINT
ICRNL     将输入的CR转换为NL,较少用到
IGNBRK    忽略BREAK条件
IGNCR     忽略CR
IGNPAR    忽略奇偶错字符，当奇偶校验出错时，是重新请求传送这个数据，还是忽略
IMAXBEL   在输入队列空时振铃,较少用到
INLCR     将输入的NL转换为CR
INPCK     打开输入奇偶校验，用于输入端的
ISTRIP    剥除输入字符的第8位
IUCLC     将输入的大写字符转换为小写字符,较少用到
IXANY     使任一字符都重新启动输出
IXOFF     使启动/停止输入控制流起作用
IXON      使启动/停止输出控制流起作用
PARMRK    标记奇偶错，如果不用这一个片段的数据，标记上这一位，就把它删掉了

2）串口控制函数
Tcgetattr		获取串口的基本属性参数设置(termios结构)
Tcsetattr		设置串口的基本属性参数设置(termios结构)
cfgetispeed 	        得到当前设置的输入波特率
Cfgetospeed		得到当前设置的输出波特率
Cfsetispeed		设置输入波特率
Cfsetospeed		设置输出波特率
Tcdrain		        阻塞等待，确认所有的输出都被传输完成，然后把buffer清空
tcflow 		        挂起传输或接收，将它置为阻塞态
tcflush 		将未完成的输入/输出的buffer空间强制清空
Tcsendbreak		fa送BREAK(停止)字符
tcgetpgrp 		得到前台进程组ID
tcsetpgrp 		设置前台进程组ID

3）串口配置流程
#include <termios.h>
(1)使用串口时，要重新配置串口参数，这时候就需要先保存原先的串口设置。等使用完毕之后，再恢复原先的串口设置
保存原先串口配置使用tcgetattr(fd,&oldtio)函数
例：struct termios newtio,oldtio;

tcgetattr( fd,&oldtio ）； 成功返回0，出错不为0

（2）激活选项有CLOCAL和CREAD,用于本地连接和接收使能。
          bzero( &newtio, sizeof( newtio ) );将结构体newtio里面的数据全部都清0
	  newtio.c_cflag | =  CLOCAL | CREAD; 

（3）设置波特率，使用函数cfsetispeed、 cfsetospeed
     cfsetispeed(&newtio, B115200);
     cfsetospeed(&newtio, B115200);

(4)设置数据位，需使用掩码设置。
	newtio.c_cflag &= ~CSIZE; CSIZE取反后，想与操作，表示把以前的设置清空
	newtio.c_cflag |= CS8;    CS8代表使用8位数据，表示数据位设为8位

（5）设置奇偶校验位，使用c_cflag和c_iflag。
	设置奇校验：
		newtio.c_cflag |= PARENB;
		newtio.c_cflag |= PARODD;
		newtio.c_iflag |= (INPCK | ISTRIP);
	设置偶校验：
                newtio.c_cflag |= PARENB;
		newtio.c_cflag &= ~PARODD;
		newtio.c_iflag |= (INPCK | ISTRIP);
        不设校验位：
                newtio.c_cflag &= ~PARENB;

		
（6）设置停止位，通过激活c_cflag中的CSTOPB实现。若停止位为1，则清除CSTOPB，若停止位为2，则激活CSTOPB。
		1位：newtio.c_cflag &= ~CSTOPB;
                2位：newtio.c_cflag |=  CSTOPB;

（7）设置最少字符和等待时间，对于接收字符和等待时间没有特别要求时，可设为0。
		newtio.c_cc[VTIME]  = 0;
		newtio.c_cc[VMIN] = 0;

（8）处理要写入的引用对象
tcflush函数刷清（抛弃）输入缓存（终端驱动程序已接收到，但用户程序尚未读）或输出缓存（用户程序已经写，但尚未发送）。原先的输入输出缓存是在驱动层次的，例如：设备接收了数据后就存放在输入缓存中，当缓存满后，发出一个软中断，告诉系统，可以读取了。
int tcflush(int filedes, int queue )
queue数应当是下列三个常数之一：
 TCIFLUSH 刷清输入队列。
 TCOFLUSH 刷清输出队列。
 TCIOFLUSH 刷清输入、输出队列。

 例：tcflush(fd,TCIFLUSH);

（9）激活配置。在完成配置后，需激活配置使其生效。使用tsettattr()函数。原型：
//int tcgetattr(int filedes, struct termios *termptr); 成功返回0，出错不为0
int tcsetattr(int filedes, int opt参数选项, const struct termios * termptr终端结构); 成功返回0，出错不为0

opt参数：使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常数中的一个：
 TCSANOW 更改立即发生。
 TCSADRAIN 发送了所有输出后更改才发生。若更改输出参数则应使用此选择项。
 TCSAFLUSH 发送了所有输出后更改才发生。更进一步，在更改发生时未读的所有输入数据都被删除（刷清）
使用如：tcsetattr(fd,TCSANOW,&newtio)


4、读写串口：
1)普通串口读写：串口的读写与普通文件一样，使用read,write函数。
read(fd,buff,8);
write(fd,buff,8);

2）多路复用式串口读写：使用前面说过的select复用函数
fd_set rd;
int nread;
char buff[8];
.....
FD_ZERO(&rd);
FD_SET(FD,&rd);
while(FD_ISSET(fd,&rd))
{
  if(select(fd+1,&rd,NULL,NULL,NULL)<0)
    perror;
  else 
  {
    while((nread=read(fd,buff,8))>0)
    {
       printf("nread=%d,%s\n",nread,buff);
    }
  }
  close(fd);
  return;
}

5、关闭串口close(fd);

例：
#include<stdio.h>
#include<string.h>
#include<sys/types.h>
#include<errno.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<termios.h>
#include<stdlib.h>

int set_opt(int fd,int nspeed,int nbits,char nevent,int nstop)
{
  struct termios newtio,oldtio;
  if(tcgetattr(fd,&oldtio)!=0)  //1保存原先串口配置
  {
    perror("setupserial error\n");
    return -1;
  }

  bzero(&newtio,sizeof(newtio));//2激活选项有CLOCAL和CREAD,用于本地连接和接收使能
  newtio.c_cflag|=CLOCAL|CREAD;


  switch(nspeed)//3设置波特率
  {
    case 2400:
       cfsetispeed(&newtio,B2400);
       cfsetospeed(&newtio,B2400);break;
    case 4800:
       cfsetispeed(&newtio,B4800);
       cfsetospeed(&newtio,B4800);break;
    case 9600:
       cfsetispeed(&newtio,B9600);
       cfsetospeed(&newtio,B9600);break;
    case 115200:
       cfsetispeed(&newtio,B115200);
       cfsetospeed(&newtio,B115200);break;
    default:
        cfsetispeed(&newtio,B9600);
        cfsetospeed(&newtio,B9600);break;
  }


  newtio.c_cflag&=~CSIZE;//4设置数据位
  switch(nbits)
  {
    case 7:
        newtio.c_cflag|=CS7;break;
    case 8:
        newtio.c_cflag|=CS8;break;
  }

  switch(nevent)//5设置奇偶校验位
  {
    case 'o':
       newtio.c_cflag|=PARENB;
       newtio.c_cflag|=PARODD;
       newtio.c_cflag|=(INPCK|ISTRIP);break;
    case 'e':
       newtio.c_cflag|=PARENB;
       newtio.c_cflag|=~PARODD;
       newtio.c_cflag|=(INPCK|ISTRIP);break;
   case 'n':
       newtio.c_cflag&=~PARENB;break;
  }
  
  
  

  if(nstop==1)//6设置停止位
     newtio.c_cflag&=~CSTOPB;
  else if(nstop==2)
     newtio.c_cflag|=CSTOPB;

  newtio.c_cc[VTIME]=0;//7设置最少字符和等待时间，对于接收字符和等待时间没有特别要求时，可设为0。
  newtio.c_cc[VMIN]=0;

  tcflush(fd,TCIFLUSH);//8处理要写入的引用对象
  
  if((tcsetattr(fd,TCSANOW,&newtio))!=0)//9激活配置
  {
    perror("com set error\n");
    return -1;
  } 
  printf("set done!\n");
  return 0;
}

int open_port(int fd,int comport)
{
  char *dev[]={"/dev/ttyS0","/dev/ttyS1","/dev/ttyS2"};
  long vdisable;
  //1打开串口
  if(comport==1)
  {
    fd=open("/dev/ttyS0",O_RDWR|O_NOCTTY|O_NDELAY);
    if(fd==-1)
    {
      perror("can't open serial port 1\n");
      return -1;
    }
    else
      printf("open ttyS0\n");
  }
  if(comport==2)
  {
    fd=open("/dev/ttyS1",O_RDWR|O_NOCTTY|O_NDELAY);
    if(fd==-1)
    {
      perror("can't open serial port 2\n");
      return -1;
    }
    else
      printf("open ttyS1\n");
  }
  if(comport==3)
  {
    fd=open("/dev/ttyS2",O_RDWR|O_NOCTTY|O_NDELAY);
    if(fd==-1)
    {
      perror("can't open serial port3\n");
      return -1;
    }
    else
      printf("open ttyS2\n");
  }

  //2恢复串口的状态为阻塞状态，用于等待串口数据的读入
  if(fcntl(fd,F_SETFL,0)<0)
    printf("fcntl failed!\n");
  else
    printf("fcntl=%d\n",fcntl(fd,F_SETFL,0)); 
  
  //3测试打开的文件描述府是否引用一个终端设备，以进一步确认串口是否正确打开
  if(isatty(STDIN_FILENO)==0)
    printf("standard input is not a terminal device\n");
  else
    printf("isatty success!\n");

  printf("fd-open=%d\n",fd);
  return fd;
}

int main()
{
  int fd;
  int nread,i;
  char buff[]="Helo\n";

  //1打开串口
  if((fd=open_port(fd,1))<0)
  {
    perror("open_port error\n");
    return;
  }
  //2配置串口
  if((i=set_opt(fd,115200,8,'n',1))<0)
  {
    perror("set_opt error\n");
    return;
  }
  printf("fd=%d\n",fd);
  //3使用串口
  nread=read(fd,buff,8);
  printf("nread=%d,%s\n",nread,buff);
  //4关闭串口
  close(fd);
  return;
}



看到 清华332, 高级编程164
//========
//==单片机
//========
//**************
//存储器基本知识：
//**************
*存储器分类：
ROM：只读存储器，只能读，断电后不消失
     掩膜ROM：由厂家写入的，不可再更改。一般用来存放程序，固定数据和函数表
     一次性可编程ROM(PROM):用户只可写一次
     可擦除可编程ROM(EPROM):可以重复擦写
     电可擦除可编程ROM(EEPROM):可以重复擦写
     快闪存储器(Flash ROM):EEPROM的升级，现在单片机，U盘等一般都是用它 
RAM：可读写，断电后消失
     静态随机存储器(SRAM):只要不对存储单元进行改写，存储信息就不会丢失
     动态随机存储器(DRAM):需要过段时间就刷新一次，不然存储信息就会丢失
存储器容量：用存储器所能记忆的全部二进制信息量表示。
例如：4096个存储单元，即4KB，即4*1024B=4096B，即4096*8b



*单片机到底学什么
1、对I/O口的控制，无论单片机对外界进行何种控制，都是通过I/O口进行的。必须让单片机在正确的时间，通过那四组I/O口，输出高电平，或低电平
2、接受外部的控制，通过I/O来感受外部的电压
3、单片机有四组I/O口：P0，P1，P2，P3，每组有8位(例如P0.0~P0.7)，每个端口都有锁存器，输出驱动，输入缓冲器。四组I/O端口都能作输入输出口用
4、单片机TTL：高电平+5V，低电平0V，
5、RS232：高电平-12V(注意，是-号)，低电平+12V。所以单片机与计算机之间进行通讯时要加电平转换芯片max232


*单片机的组成
例如：AT89S5224PC型号，
型号说明：AT表示是Atmel公司产品，89的9表示它的内部是用Flash存储器的，
    S：它是支持ISP下载的Flash，而C代表CMOS工艺，LV代表它是低电压产品，因为普通的芯片它是接5V的，而低电压产品则是接3.3v的
    52：代表它的型号，例如53,54等等
    24：还有12,16,20,24这几种，它表示晶振的频率是24MHZ
    P：它的封装形式是双列直插，D表示陶瓷封装的，J表示POCC封装，S和Q是贴片封装
    C:它是商用的，I是工业用品，A是汽车用品，M是军用，U是无铅产品
*单片机的全局结构
--------------------
|                  |  ------------  ------------  ---------------------
|振荡器，频率基准源|  |4KB ROM   |  |128B RAM  |  |定时\计数器         |
|                  |  |程序存储器|  |数据存储器|  | 定时器0、定时器1...|
-↓------------------ ------------  ------------  ----------------------
-----                     ↑           ↑             ↑
|CPU| ←---------------数据总线，以及地址总线，以及控制总线 
|   |                      ↓           ↓            ↓
-----                -------------     ---------    -----------
                     |64KB总线扩展|    |并行I/O|    |可编程全双工|
 ↑↑                |控制        | → |接口   |    |串行接口    |
 中断                -------------     --------     ------------
                                          ↑↓        ↑     ↓
                                       P0 P2 P1 P3   RXD    TXD

1、ALU(CPU)：是8位数据宽度的处理器，能处理8位二进制数据或代码。它主要完成算术运算与逻辑运算，还有位操作：置位，清零，求补，条件判断等。它由以下部分组成
1）运算器：实现算术和逻辑运算。
           ALU：算术/逻辑运算部件
           ACC(A)：累加器，是一个8位寄存器，在运算时，先暂存一个操作数(如被加数)
                而在运算后，又暂存其结果。或者也放在AB寄存器中
          寄存器B：是一个8位寄存器，用于乘法，和除法操作。也可作为一般数据青                   寄存器使用
                   乘法：B存放乘数，乘法操作后，B存放乘积的高8位，B存放乘积的                         低8位
                   除法：A存放被除数，B存放除数，除法操作后，A存放商，B存放余                         数
   程序状态寄存器PSW：是一个8位寄存器，存放运算结果的一些特征，如有无进位、借                      位等
                   
  
          布尔处理器：位处理器
          暂存器TMP： 
2）控制器：用于指挥控制各部分工作。包括逻辑电路，指令寄存器，译码器，外部数据指针寄存器DPTR，程序计数器PC，堆栈指针SP等
    程序计数器PC：要执行一个程序，该程序先保存到ROM中，程序计数器PC保存该程          序的第一条指令地址，即指向第一条指令。在它每取出一条指令(如为多字节指       令，则每次取出一个指令字节)，则它指向下一条指令。它是一个16位的计数器，      寻找范围为64KB 
    指令寄存器：按程序计数器PC保存得指令地址，将该条指令存放在指令寄存器中寄                存     
    译码器：将该条指令译成各控制信号，与单片机的时钟振荡器产生的时钟脉冲相结            合，形成电平和时钟，进行操作
2、存储器：
   有128个专用寄存器单元，它只能存放控制指令数据，用户只能访问，不能存放用户数据   
   用户能使用的RAM为128个 

3、定时器\计数器：进行定时，或者计数，以控制单片机

4、并行输入/输出 I/O口：有4个8位接口P0 P2 P1 P3用于数据输入，输出  

5、全双工串行接口：用于与其它设备间的串行数据进行传送，该串口可以作一步通信收发器，或者同步移位器

6、中断系统：当有需要中断的条件触发时，发送中断信息给cpu，让cpu自行判断，何时采取中断操作
   它由两个外部中断(用于与其他单片机或者微机设备进行通用异步串行通信)，两个定时器\计数器中断，一个串行中断。含有两级优先级

7、时钟电路：有一个12MHZ的时钟电路，用于产生单片机脉冲时序。但是一般如果作串口通讯，或者与计算机，与其它单片机进行通讯时，晶振都会选用11..0592MHZ
 

*单片机的外部引脚:由于该引脚一般都是8个，即是每次8位，即总线型单片机
 看芯片的datasheet时：                                              __
 注意数电知识：上面有横杠，表示低电平有效，例如OE，
               Z代表高阻态，即芯片不是高电平，也不是低电平；而把该芯片接高电平，或者是低电平，它即为高电平，                  或低电平；也即表示此芯片没有工作
               X(是代表叉的意思):无论这个接口是输入高电平，还是低电平，都没有关系
               Q0：保持上一次的状态，不变。例如：如果上一次该接口已经跳到高电平了，而因为其它操作，此时该接口                   变为Q0状态，则实际还是维持原先的高电平状态。(也称作将输出端口锁存) 
 Vss:接地，Vcc:接+5V电源
 时钟振荡电路引脚：XTAL1片内时钟震荡电路输入端，XTAL2片内时钟震荡电路输出端;
 使用内部振荡电路时，这两个端子用来外接石英晶体，振荡频率为晶振频率，振荡信号                     送至内部时钟电路，产生时钟脉冲信号；
 使用外部振荡电路时，XRAL2用于输出外部振荡脉冲，该信号直接送至内部时钟，而                     XTAL1接地
 并行I/O口：4个双向并行I/O口P0~P3，每一根I/O线都能独立的用作输入或输出，它们            均包含锁存器，输出驱动和输入缓冲器
 P0.0~P0.7：注意，没有默认内置接上拉电阻，因此我们需要外部每个接口都添加一个上拉电阻，或者直接连上一个上拉排阻芯片。排阻的阻值选10K
            访问外部存储器时：作低8位地址线，和8位双向数据总线 
            没有外部存储器时，即作内部ROM的编程和校验时：作为并行I/O接口使用            ，用于数据输入，输出，但需外部接上拉电阻
 P1.0~P1.7：自带内部上拉电阻，作准双向I/O接口。作内部ROM的编程和校验时，用于            接收低8位地址
 P2.0~P2.7：自带内部上拉电阻，作准双向I/O接口。访问外部存储器时：输出高8位地            址。
            作内部ROM的编程和校验时，用于接收高8位地址和控制信号。作为并行I/O            接口使用，用于数据输入，输出
 P3.0~P3.7：自带内部上拉电阻，第一功能是作I/O接口
           第二功能(程序运行时优先考虑第二功能，剩下不用时，才考虑第一功能)：
            P3.0(RXD)串行数据输入，P3.1(TXD)串行数据输出，
                 ____                     ____
            P3.2(INT0)外部中断0输入，P3.3(INT1)外部中断1输入，
            P3.4(T0)定时器\计数器0外部输入，P3.5(T1)定时器\计数器1外部输入，
                ____               ____ 
            P3.6(WR)外部RAM写，P3.7(RD)外部RAM读， 
 控制信号引脚：
 RST/VPD:功能一、当保持两个以上机器周期(24个时钟周期)的高电平时，将使单片机复                 位
         功能二、为内部RAM的备用电源输入端
     ____
 ALE/PROG:地址锁存，访问外部存储器时，用来锁存P0扩展地址8位的地址信号
 ____
 PSEN:访问外部ROM时，低电平可以使单片机实现对外部程序存储器ROM的读选通操作
 __
 EA/Vpp：低电平，则全部对外部ROM读操作；
         高电平，则对4KB地址内对内部ROM读操作，超出4KB地址对外部ROM读操作；
         (因此注意，在连接单片机时，需要接上高电平，否则它会默认查找外部ROM。而我们并没有接外部ROM，这时，单         片机就无法工作)
         功能二、为编程电源输入,
 串行I/O口：通过异步通信方式(UART),与串行传送信息的外部设备相连接，或用于通过         标准异步通信协议进行全双工通信

*单片机的存储器：有片内程序存储器，片外程序存储器，片内数据存储器，片外数据存储器
1、片内程序存储器，片外程序存储器：单片机有4KB的存储单元，其地址为0000H~FFFFH
      PC程序计数器地址只有16位    
FFFFH
....  真正存放程序代码的地方
002BH
-----
002AH
.....串行中断地址区
0023H
-----
0022H
.....定时器/计数器1中断地址区          这是用于存放中断处理程序的地址单元，当
001BH                                  触发一个中断后，将会按照该中断的类型，
-----                                  自动转到各自的中断区去执行程序
001AH
.....外部中断1中断地址区
0013H
------
0012H
.....定时器/计数器0中断地址区，
000BH
-----
000AH
.....外部中断0中断地址区，在这些存储单元中放上无条件转移指令，让cpu去
0003H  执行指定的中断服务程序
------
0002H
.... 
0000H<-系统复位后，PC程序计数器首先指向这里，如果程序不是从这里开始进行，则应
       在这三个存储单元中放上无条件转移指令，让cpu去执行指定的程序 

2、数据存储器，由RAM组成，用于存储实时输入的数据
1）内部数据存储器：容量为256各单元。每个单元对应一个地址，即有256各地址。
   地址：由两位16进制数表示，即00H~FFH
   各单元内容：每个存储单元存放一个8位二进制信息 
（1）内部数据RAM的地址00H~7FH，即低128单元
①通用寄存器区：在00H~1FH中，共有32个单元，即每组8个单元，每个单元又8位，
即每组8个8位寄存器，统称为R0~R7。
1FH
..第3组通用寄存器区
..第2组通用寄存器区
..第1组通用寄存器区
..第0组通用寄存器区
00H               

有一个程序状态寄存器PSW：用来指定是哪一组的哪个寄存器
RS1     RS0    寄存器组   R0~R7地址
0       0       第0组     00H~07H
0       1       第1组     08H~0FH 
1       0       第2组     10H~17H 
1       1       第3组     18H~1FH  
②内部位寻址区的位地址
单元地址              位地址
            1   2  3    4   5   6  7    8 
2FH        7FH.......................... 
.....................
21H        0FH,0EH,0DH,0CH,0BH,0AH,09H，08H
20H        07H,06H,05H,04H,03H,02H,01H，00H 

注意：位地址0FH，与字节地址0FH的区别
    位地址0FH：表示0FH这一二进制位的地址，是在内存中21H的第1位
    字节地址0FH：表示地址为0FH的单元地址

③用户RAM区：30H~7FH，用给用户使用，一般作堆栈/数据缓冲区
7FH 
..
30H 

（2）特殊功能寄存器SFR的地址80H~FFH，即高128单元。这里面的所有寄存器功能已作规定。
程序计数器PC：它是一个16位的计数器，寻找范围为64KB，不可寻址
还有ACC,B寄存器等
程序状态字PSW：
PSW.7 PSW.6 PSW.5 PSW.4 PSW.73 PSW.2 PSW.1 PSW.0
 CY    AC    F0    RS1    RS0   OV    没用  P
CY：进位标志位，当最高位有进位，或借位时，CY=1，否则CY=0.例如：作加法时，如果    范围超过0~255时，将最高位进位到CY中
AC：辅助进位位，作加法或者减法操作时，产生的低4位向高4位的进位，或借位时，将      AC置1。否则，就被清除。例如，D3向D4位进位，AC即被置1，否则被清零AC还用于    十进制BCD码调整，同DAA指令结合使用
F0：用户标识位，它是用户定义的一个状态标记
RS0，RS1：选择当前工作寄存器区
OV：溢出标志位，
   加减操作时：OV=1表示运算结果超出累加器ACC所表示的范围(-128~127),产生溢出，              结果是错误的。OV=0结果是正确的
   乘法操作时：OV=1表示乘积超过255，即乘积放在B(高8位)与A(低8位)中；OV=0，表              示乘积放在A中，B=0
   除法操作时：OV=1表示除数为0，除法不能进行；OV=0，表示除数不为0，除法可以进              行
P：奇偶位，P=1，累加器A中1的个数为奇数；P=0，累加器A中1的个数为偶数；
堆栈指针SP：是8位寄存器，表示堆栈顶部在内部数据存储器中的位置。系统复位后，         SP=07H。但持续一般要将它置为30H~7FH中。堆栈最大为128B
数据指针DPTR：是唯一一个16位专用寄存器，由两个8位寄存器DPH(高8位)和DPL(低8位)            组成，它即可作为一个16位寄存器使用，存放16位地址，用于访问外部RAM             ，访问ROM；也可作为两个独立的8位寄存器使用。

2）外部数据存储器：单片机可访问外部RAM的地址空间为0~64KB，最大可由16位地址线寻找；外部RAM和外部I/O接口统一编址，即CPU对RAM和I/O不加区分
    对内部ROM和外部ROM：通过EA引脚来控制
    对内部RAM和外部RAM：通过MOV和MOVX来区分


*特殊功能寄存器地址映像
SFR（特殊功能寄存器）名称|符号简称|D7口 位地址/位定义(可以定位寄存器的每个口)D0口|整个寄存器所在的字节地址
     B寄存器                 B     F7 F6 F5 F4 F3 F2 F1 F0（该寄存器的每个口地址）FOH
                                  (该寄存器的各个口名称，如果没有，这行置空)  
     
     累加器A                 ACC   E7  E6 E5 E4  E3  E2  E1  E0                   EOH 
     
     程序状态字              PSW   D7  D6 D5 D4  D3  D2  D1  D0                   D0H
                                   Cy  AC F0 RS1 RS0 OV       P(该寄存器的各个口名称)
     
     中断优先级刻制          IP    BF  BE  BD BC  BB   BA  B9  B8                 B8H
                                              PS PT1  PX1 PT0 PX0  
     
     I/O端口3                P3    B7   B6   B5   B4   B3   B2   B1   B0          B0H
                                  P3.7 P3.6 P3.5 P3.4 P3.3 P3.2 P3.1 P3.0  
     
     中断允许控制            IE    AF   AE   AD   AC   AB   AA   A9   A8          A8H
                                   EA             ES   ET1  EX1  ET0  EX0  
     
     I/O端口2                P2    A7   A6   A5   A4   A3   A2   A1   A0          A0H
                                  P2.7 P2.6 P2.5 P2.4 P2.3 P2.2 P2.1 P2.0   
     
    串行数据缓冲            SBUF        (不能位寻址)                              99H
    
    串行控制                SCON   9F   9E   9D   9C   9B   9A   99   98          98H 
                                  SM0   SM1  SM2  REN  TB8  RB8  T1   R1    

    I/O端口1                P1    97   96   95   94   93   92   91   90           90H
                                  P1.7 P1.6 P1.5 P1.4 P1.3 P1.2 P1.1 P1.0  

    定时器/计数器1(高字节)  TH1                                                   8DH  
    定时器/计数器0(高字节)  TH0                                                   8CH 
    定时器/计数器1(低字节)  TL1                                                   8BH  
    定时器/计数器0(低字节)  TL0                                                   8AH  

    定时器/计数器0方式选择  TMOD  
                                          _                   _                   89H
                                  GATE  C/T  M1   M0  GATE  C/T   M1   M0           
   
    定时器/计数器控制       TCON   8F   8E   8D   8C   8B   8A   89   88          88H
                                   TF1  TR1  TF0  TR0  IE1  IT1  IE0  IT0

    电源控制及波特率选择    PCON                                                  87H
                                   SMOD                 GF1  GF0  PD   IDL 

    数据字节高字节          DPH                                                   83H
    数据字节低字节          DPL                                                   82H
    
    堆栈指针                SP                                                    81H

    I/O端口0                P0    87   86   85   84   83   82   81   80           80H
                                  P0.7 P0.6 P0.5 P0.4 P0.3 P0.2 P0.1 P0.0  


  如何使用：例如，针对P0口，
            sfr  P0=0x80;     即定义了P0口的物理地址， 在程序中直接输入P0 使用P0口
            sbit OV=P0^2;     即0x80^2=10000000^00000010=10000010=0x82=P0.2的I/O口
                 在程序中直接通过OV使用P0.2的I/O口
   	    
*定时器/计数器
    _
由C/T来选择是作定时器，还是计数器来使用。

*时钟电路和复位电路
1、时钟：由内部晶振振荡器，外接石英晶体形成谐振回路，产生时钟信号。振荡频率越高，单片机运行越快

一个机器周期：一个机器周期是晶振频率的1/12
状态，节拍：一个机器周期由6个状态(S)组成，一个状态由2个节拍(P)组成，即S1P1,S1P2,S2P1..S6P6
一个指令周期：不同的指令种类，它的指令周期也不同，分别有1个，2个，3个，4个机器周期

2、复位电路：进入系统的正常初始化，程序出错，操作错误，都可进行复位。RST/VPD:当保持两个以上机器周期(24个时钟周期,即24MHZ)的高电平时，将使单片机复位

*低功耗方式
电源控制及波特率选择    PCON        D7    D6 D5 D4      D3   D2   D1   D0          87H
                                   SMOD                 GF1  GF0  PD   IDL 
复位时，PCON中所有定义位均为0
SMOD:波特率倍增位，在串行通信时使用
GF1和GF0:通用标志位。由软件置、复位
PD:置1时，进入掉电工作方式。如果此时IDL也为1，还是进入掉电工作方式
IDL:置1时，进入空闲待机工作方式

1、空闲待机
1）ORL PCON, #1将IDL=1时进入待机状态。
2）振荡器仍工作，并向中断逻辑，串行口，定时/计数器提供时钟，但CPU停止工作，相关的寄存器，如SP，PC，PWS，ACC等也停止工作
3）重新启动：
RST/VPD:保持两个以上机器周期(24个时钟周期,即24MHZ)的高电平时，即使IDL置0，启动
中断方法：任何一个允许的中断被触发，则IDL都会被置0，启动。再在启动出安排RETI指令，使单片机返回断电继续执行程序

2、(停机)掉电保护：当检测到外部电压下降时
1）将Vcc恢复正常工作电压。
2）通过INT0或INT1产生外部中断请求，中断响应后执行中断服务程序
3）通过掉电中断程序：将系统的所有有用数据转存到内部RAM中
4）将PD=1，进入掉电保护状态。
振荡时钟停止，所有部件停止，但内部RAM和特殊功能寄存器区的内容被保留，而端口的输出状态值都被存在对应的SFR中
此时：为了在掉电后保存有用数据，应在掉电后使用备用电源，给内部RAM充电。备用电源由单片机的RST/VPD引脚输入。电路中应具有备用电源和Vcc电源的自动切换电路
5）重新启动：先将Vcc恢复正常工作电压10ms时间
6）硬件复位，但此时RAM和特殊功能寄存器区的内容不会丢失

//***********
//C51扩展基础
//***********
*单片机特殊数据类型
sfr:特殊功能寄存器声明（平时编程很少使用），          大小为1字节，即8位
    sfr TMOD=0x89;//注意，这里必须是常数，不允许使用带运算符的表达式
sfr16:sfr的16位数据声明（平时编程很少使用），         大小为2字节，即16位
    sfr16 T2=0xCC;//定义了T2的低地址为0xcc,它的高地址自动计算出是下一位0xCD
sbit:特殊功能位声明，或内部RAM中的可寻址位                                   大小为1位 
    sbit OV=0xD2 直接赋位地址
    sbit OV=PSW^2特殊功能寄存器名^位位置 
    sbit OV=0xD0^2字节地址^位位置
bdata:当位对象位于单片机内部存储器的可位寻址区bdata时，称为“可位寻址对象”。单片机编译    时，会将对象放入单片机内部可位寻址区
    int bdata my_x=12345;//将12345放入可位寻址区
    独立访问可位寻址区对象中的某一位：
    sbit my_bit0=my_x^0;
    sbit my_bit15=my_x^15
    注意：后面的位位置，取决于my_x的基本地址类型，char是0~7，int是0~15，long是0~31
bit:位变量或位类型声明,只有一位，它的值不是0，就是1，   大小为1位
    可以定义一个位标量，但不能定义位指针，也不能定义位数组

*变量的定义
C51中，变量的定义：[存储种类] 数据类型 [存储器类型] 变量名
其中，[]内是可选项。
[存储种类] ：auto static extern register

[存储器类型] :C51可以访问单片机硬件系统的所有部分。对于每个变量，可以准确地赋予其存储器类型，使之能在单片机系统内准确的定位

data:直接寻址的51内部数据存储器，即是直接访问其内部数据存储器(128B),访问速度最快
bdata:可位寻址的51内部数据存储器，即是可位寻址访问其内部数据存储器(16B),允许位和字节混      合访问
idata:间接寻址的51内部数据存储器，即是间接访问其内部数据存储器(256B),允许访问全部内部地     址
pdata:"分页"寻址的51外部数据存储器，即是分页访问外部数据存储器(256B),用MOVX @Ri指令访问
xdata:51外部数据存储器，即是访问外部数据存储器(64KB),用MOVX @DPTR指令访问
code:51程序存储器(64KB),用MOVC @A+DPTR指令访问
interrupt:定义一个中断函数
reetrant:定义一个再入函数
using：定义51的工作寄存器组

指针：一般指针占3个字节，而有[存储器类型]的指针，其长度可为idata,data,pdata是1个字节，code,xdata是两个字节
例如：
int *p;定义一个指向int的一般指针，指针自身在默认的存储区(由编译模式决定)，指针长度为3个字节
char xdata *p;在xdata存储器中定义一个指向char的基于存储器的指针，指针自身在默认的存储器区域(由编译模式决定)，指针长度为2个字节

float xdata * data p;在xdata存储器中定义一个指向float的基于存储器的指针，指针自身在data区域，指针长度为2个字节

例如，针对P0口，
            sfr  P0=0x80;     即定义了P0口的物理地址， 在程序中直接输入P0 使用P0口
            sbit OV=P0^2;     即0x80^2=10000000^00000010=10000010=0x82=P0.2的I/O口
                 在程序中直接通过OV使用P0.2的I/O口

*变量的数据类型的选择：
1、计算机在处理16位的数据类型时，比8位数据类型多耗很多时间。所以以后如果有可能，应尽量使用数据类型小的值。例如，如果处理的值在0~255之中，则使用unsigned char i;
2、如果程序处理中不需要负数，则可用unsigned
3、如果不需要浮点数，则应避免使用浮点数类型的变量。要知道，在8位单片机上使用32位浮点数会浪费大量的时间

*常量
const unsigned char b = 0xf1;
而且，扩展类型中，只有bit类型可以使用常量

*单片机C51包含的头文件
reg51.h,reg52.h：定义特殊功能寄存器和位寄存器，51单片机则头文件选51，52单片机则头文件选52
math.h,ctype.h,stdio.h,stdlib.h,absacc.h
看头文件信息：光标移到该文件名，右击，选Open document

*通常的宏定义,仅供个人习惯，没有强制要求
#define uchar unsigned char
#define uint unsigned int
#define ulint unsigned long

*延时函数:在12MHZ的晶振频率下，如果要延时50us微秒
void Delay_50us(unsigned int t)
{
  unsigned char j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}
如果要延时50ms毫秒
void Delay_50ms(unsigned int t)
{
  unsigned int j;
  for(;t>0;t--)
    for(j=6245;j>0;j--); 
}

*单片机的I/O口操作：单片机默认上电后，其I/O口都会置为高电平。因此，如果
某些芯片标注，必须要低电平才能工作的话，那连到这个芯片的I/O口需要置为低电平。
如果要高电平才能工作的话，那连到这个芯片的I/O口无需操作

*闪烁灯的开发：循环点亮和熄灭一个发光二极管
由于：此板子一边是高电平，因此芯片的P0口需要输出低电平(0V),灯才能点亮
新建工程lesson41
选择芯片at89s52->选是
新建文件lesson41.c。(注意：如果是汇编文件，选择lesson41.asm)
右击左边的Source Grop 1,选择Add File to Group,将lesson41.c加载到工程中
点击Target 1左边那个图标->Output->勾选 Create HEX File编译时，会再产生一个.hex的文件，用于下载到单片机中运行

方法一：位操作方法，只是对P0.0口进行操作，只要将P0.0置0即可
        sbit led0=P0^0即P0.0这个位，P1^3即P1.3这个位
#include<reg52.h>
sbit led0=P0^0;/*P必须大写*/
void main()
{
   led0=0;/*0输出低电平，1输出高电平*/ 
}

方法二：总线操作方法，对整个P0口进行操作
思路：整个P0口由八位二进制组成
若给P0=0xFd，转为二进制即是11111101
传到P0口时，1是高电平，0是低电平
1   1  1  1  1  1  0  1
P7 P6 P5 P4 P3 P2 P1 P0
则点亮了第二个发光二极管
#include<reg52.h>
void main()
{
   unsigned int a;   
   led0=0;/*0输出低电平，1输出高电平*/ 
   while(1)
   {
     P0=0xfd;/*用总线形式点亮第二个发光二极管*/
     a=50000;
     while(a--);
     P0=0xff;
     a=50000;
     while(a--);
   }
}
生成lesson41.hex文件，将这个文件下载到单片机中执行

*软件仿真
点击放大镜，里面有个红色d的图标，左边的窗口中，
1、
reg是此单片机的各个寄存器状态，
Sys是单片机系统里面各特殊寄存器的状态，其中sec记录单片机执行了多少时间
此时，出现的工具栏：
RST:让单片机复位重启
Run:让单片机全速执行，即是模拟开始运行单片机
2、
双击左边列行时，会添加，删除断点
3、
菜单栏：Peripherals:Interrupt中断，I/O-Ports:I/O口，Serial:串口，Timer:定时器
这是用来查看此时，单片机的各个I/O-Ports:I/O口，Serial:串口，Timer:定时器的状态。
I/O-Ports：查看I/O口的状态，打勾表示1，空格表示0
例：在程序的P0口设置那里添加断点，然后全速执行，当可查看P0口的状态

4、点击View->Watch Call Stack Window->选Watch 1
可以监控程序中各变量的值
例如：想要监控本程序中变量a的值
将a拖进Watch 1中，或者点击F2，添加变量a。右击该行变量->Number Base->选十进制

5、需要查看执行的这几条语句需要多少时间，(因为单片机执行时，需要精确地时间控制)
点击Target 1左边那个图标：出现的页面中，下面几项默认是C51的参数，无需修改：
Memory Model内存模式，默认使用Small。用于设置RAM使用情况，
           Small表示所有变量,对象，堆栈都在内部RAM中运行，堆栈长度取决于不同函数的嵌套              深度;
           Compact表示可以使用一页(256B)外部扩展RAM，而变量被定义到分页外部数据存储器             (pdata区)中，外部数据长度可达256字节。这时，对变量的访问是通过寄存器间接寻             址(MOVX @Ri)进行的。堆栈位于内部数据存储器中，而变量的高8位地址由P2口转存
           Large表示可以使用全部外部扩展RAM，变量被定义到外部数据存储区(xdata区，可达             64KB)中，使用数据指针DPTR来间接访问变量。
Code Rom Size：程序空间，默认使用Large：外接64K。用于设置ROM程序空间的使用，Small表示只            用低于2Kb的程序空间；Compact表示单个函数的代码量不能超过2Kb，整个程序可以使            用64Kb程序空间；Large表示可以用全部64Kb空间
Operating:单片机上跑的操作系统

需要修改的地方：
Xtal(MHz)晶振频率:一定要设为本次使用的开发板的晶振频率。如12MHz等等，

设为调试模式，为需要测试速度的两条代码添加断点，将两个sec相减，则得到执行这些代码所用的时间。

若需要设置它的时间，假设灯需要亮5s后，再让它灭，则在修改程序后，要先退出调试状态，再重新编译，生成hex文件，再进行调试，因为调试是直接调试hex文件的

//*************
//KeilC51编译器
//*************
*仿真工具栏
 | -↓
{ }   :直接执行完这个子程序，跳到该子程序外部的下一条语句
→{}:执行到光标处
√:代码作用范围分析窗口,先让程序运行一遍之后,打开.里面有各个代码执行情况的更详细分析.同时,在源程序页面,左侧颜色为淡灰表示不可执行代码,如变量或函数定义;颜色为灰色表示可执行但还未执行过的代码;颜色为绿色表示已执行的代码。这时，可以查看那些尚未被执行到的代码，看他们是否是无效的代码


*查看窗口介绍：
1、变量观察窗口：view->watch% call stack window,查看各变量在调试时，值的变化

2、存储器观察窗口：view->Memory Window,
    输入D：DATA是可直接寻址的片内数据存储区，
    输入X：XDATA是外部数据存储区，
    输入I：IDATA是间接寻址的片内数据存储区，
    输入C：CODE是程序存储区
           例：输入C：0x00，系统会给出从00H单元开始的程序存储器(ROM)及相应的值，即查看           程序的二进制代码

3、寄存器观察窗口：调试时，左侧即显示出了
    通用寄存器组Regs：r0~r7
    系统寄存器组Sys：a,b,sp,pc,dptr,psw,sec
   
4、串口调试观察窗口：view->Serial Window#1 , Serial WIndow #2

//********
//普通器件
//********
1、蜂鸣器：简单的只能发出报警声，复杂的即是手机里面的小扬声器，可以放64和铉的歌。设置的时候只需该口
   sbit beep=P0^3;//例如，P0.3口接蜂鸣器
   beep=1，或beep=0，   即可工作
2、ULN2003：多用于单片机，职能仪表，PLC等控制电路中，用于增加驱动能力用的。
3、继电器：一般是用较小的电流去控制较大电流的一种自动开关，用于自动调节，安全保护，转换电路等作用。
   sbit replay=P0^3;//例如，P0.3口接继电器
   replay=1;
   delay();
   replay=0，
   delay(); 即可工作
4、步进电机：分为单相(只有A端)，双相(有A端B端)，以及多相(有ABCD等多端)。
   例如：四相电机
       A            A            A            A                 A

    D  ↑   B    D  →  B     D  ↓   B    D  ←  B          D  /  B

       C            C            C            C                 C
       A通电       B通电        C通电       D通电              AB通电
   其中，转一周是需要A-B-C-D依次通电一次，而它的步聚角：每次能转动的最小角度，即是AB通电而得到的旋转角度，明显可以看出是单个通电旋转角度的一半。
   例如：这个步进电机外面接5根线，分别为Vcc，A相，B相，C相，D相。
   它的参数是它是一个减速步进电机，减速比是1/64；即它有一个减速齿轮，里面转64圈，外面转1圈
   它的步进角度（即步距角）是5.625*1/64：
   即AB通电时步距角是5.625*1/64，里面A-B-C-D-A循环一次时，里面电机转8倍的步聚角=5.625*1/64*8=0..7031
   外面转一圈，它需要循环的次数是360/0.7031=512次

5、LED数码管：注意，在实际设计电路图的时候，I/O口还要再接一个类似373的芯片，再连LED。因为单片机的I/O口驱动能力只有10mA,而一个发光二极管的点亮需要3mA。则一个8段数码管的点亮需要3mA*8=24mA。4各数码管点亮需要24*4=96mA。明显驱动能力不行。因此只有外加数字芯片放大了
              A
             ---
           F |G|B
             ---            
           E | |C
             ---   。H
              D
   P0.    0     1    2    3    4   5    6   7
          A     B    C    D    E   F    G   H
   共阴数码管：全部数码管共同一端接地 ，点亮置1        共阳数码管：全部数码管共同一端接+5v，点亮置0
例 显示1：0000 0110=0x06h                               显示1：1111 1001=0xf9h

   
第二种方法：I/O口再接一个BCD译码芯片，再连LED
共阴：74LS48,74LS49，CD4511
共阳：74LS46,74LS47，CD4513
p0.0-| |-  
 0.1-| |-
 0.2-| |-   LED灯    例 显示7:输入1110=0x07即可
 0.3-| |-
       |-
       |-
       |-
       |-
数码管显示方式
静态显示：一个I/O口接一个数码管，如果需要显示4个数码管，则P1P2P3P4就全部用光掉了。不推荐用
          一个I/O口接多个数码管，如需要显示4个数码管，即端口复用接4个数码管。要显示一个值就一起显示了。不推荐                                 用
动态显示：一个I/O口控制数码管的段选，控制它的显示符号，如1，7等。一个I/O口控制数码管的位选，控制哪个数码管工         作。推荐使用。对共阴数码管来说，因为他是共阴的，因此这个位选芯片需要连接低电平，才能点亮这个数码管。共       阳则需输入高电平
编写方法：
while(1)//执行一次for循环后，重复循环执行
{
  for(i=0;i<=n;i++)//n是需要显示数码管的个数
  {......}
}      

6、8乘8LED点阵驱动：我们看到的滚动广告牌即是这种点阵拼接而成。单色点阵用于广告牌，有双色点阵，有三色(每个点里有红黄绿三色的发光二极管)点阵,用于大型的可以放电视电影的液晶广告牌
单色8乘8LED点阵：它的每个点阵没有共阴或共阳的区分，只有两种接法：一种，每一列数码管都共同接于阴极，每一行数码管都共同接于阳极；另一种，每一列数码管都共同接于阳极，每一行数码管都共同接于阴极；其实这两种接法都差不多，因为倒过来一放，两种LED点阵就都一样了。
例：一个列共阴，行共阳的数码管
P0.           0     1    2    3    4    5   6   7  
点阵I/O口：   1     2    3    4    5    6   7   8
P1.7        1
P1.6        2                 x    x    x
P1.5        3            x                  x
P1.4        4            x                  x  
P1.3        5            x                  x
P1.2        6            x                  x
P1.1        7            x                  x
P1.0        8                 x    x    x
要点亮第一个数码管：P0输入01111111，P1输入10000000即可。

如上图所示：要显示一个“0”的字符。则P0控制哪一列点亮,即位选；P1控制此列哪几个字符点亮，即段选。
P0选中第一列时：11111110=0xfe，P0选中第二列时：11111101=0xfd，P0选中第三列时：11111011=0xfb，
即P0=table1[0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f];
当P0选中第一列时,P1任何一个都不会亮，即00000000=0x00；P0选中第二列时，P1=0x00；
P0选中第三列时，P1=00111110=0x3e;
即P1=table2[0x00,0x00,0x3e,0x41,0x41,0x41,0x3e,0x00];

mian()
{
  unsigned char i;
  while(1)
  {
    for(i=0;i<8;i++)
    {
       P0=table1[i];
       P1=table2[i];
       delay();
    }
  }
}

7、键盘
1)非编码键盘：普通的按键，需要由单片机自己来设定键值，和识别。分为独立式非编码键盘(即独立按键)和行列式非编码键盘(即矩阵键盘，例如电话按钮面板即是)
（1）一般独立按键：需要接10K的电阻。但是，在单片机中，由于I/O口内部的P1P2P3口已经包含上拉电阻，因此如果按键接在这里的话，可以不接电阻了
（2）驱动原理：先给这个I/O口置1，（原因：单片机的P1P2P3的I/O口是准双向I/O口。例如，键盘的I/O口是接P3，而这时     ，若要 将P3作为输入使用，则要先P3=0xff置1(输出1)，然后，这个P3口才能作为输入口使用）。再读这个I/O口，若    还是1，则还没有按下；若是0，则按下了
（3）线与的概念：1__。/  __0,  如果开关合上的话，即1&0=0，这条线即是低电平了
                 1__。/  __1,  如果开关合上的话，即1&1=1，这条线还是高电平了
     线或的概念：0__。/  __Z(高阻态),  如果开关合上的话，即0|Z=0，这条线即是低电平了
                 1__。/  __Z(高阻态),  如果开关合上的话，即1|Z=1，这条线还是高电平了

(4)独立式非编码键盘
#include <reg52.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选
sbit key1=P3^2;
sbit led0=P0^0;

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

void main()
{
  uchar num=0;
  //按键接口先置1
  P3=0xff;
  //循环检测，有按键按下，灯就亮
  while(1)
  {
    if(key1==0)//1、判断，是否有按键按下去
	{
	   Delay_50us(200);//2、延时10ms
       if(key1==0)//3、判断，是否这个按键真的是按下去，用于防抖动设计
	   {
	       led0=0;//灯就亮
		   //按下次数的值加1 
	       num++;
	       if(num==10)num=0;
		   //等到松手的时候，才跳出
		   while(key1==0);//1、判断，是否有按键松开		   
	   }   
       Delay_50us(200);//2、延时10ms
       while(key1==0);//1、判断，是否有按键松开
	}
    else
       led0=1;

	 //LED显示按下次数
	 P2=smg_du[num];
  }
}

(5)4*4矩阵键盘
例：
P3.   P3.4     P3.5    P3.6    P3.7   

P3.0       
P3.1                        
P3.2                    
P3.3          

步骤一：为P3输出11110000=0xf0;即
P3.0 0 x
P3.1 0
P3.2 0
P3.3 0
       1     1     1     1
      P3.4  P3.5  P3.6  P3.7
步骤二：若第一个按键按下，即'x'的地方。则
利用线与概念，P3.0 0__。/  __1 P3.4 ，如果开关合上的话，即0&1=0，这条线即是低电平了，变成
P3.0 0 x
P3.1 0
P3.2 0
P3.3 0
       0     1     1     1
      P3.4  P3.5  P3.6  P3.7

定义一个变量K=P3; 
        k=k&0xf0;得到这次的高四位的值，即值1110 0000,即k=0xe0,从而得知哪一列被按下;
步骤三：为P3输出:高位输出k的值，即1110，低位输出1111，即11101111=0xef;即
P3.0 1 x
P3.1 1
P3.2 1
P3.3 1
       0     1     1     1
      P3.4  P3.5  P3.6  P3.7

步骤四：利用线与概念，P3.0 1__。/  __0 P3.4 ，如果开关合上的话，即1&0=0，这条线即是低电平了，变成
P3.0 0 x
P3.1 1
P3.2 1
P3.3 1
       0     1     1     1
      P3.4  P3.5  P3.6  P3.7


再定义一个变量Kh=P3; 
        kh=kh&0x0f;得到这次的低四位的值，即值0000 1110，即k=0x0e，哪一行被按下了;

步骤五：得到它的值是kall=k+kh;得到它的最终值1110 1110，即第1列为0，第1行为0，即kall=0xee;

步骤六：列出，所有键被按下时，分别产生的kall的值，然后通过一个switch函数进行查找，找到后，显示相应的值

①测试程序：
#include <reg52.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

void main()
{
  uchar key_l,key_h,key_all;
  while(1)
  {
	  P3=0xf0;//步骤一：为P3输出11110000=0xf0;即
	  key_l=P3;//步骤二：定义一个变量K=P3;
	  key_l&=0xf0;//得到这次的高四位的值，即列的值
	  if(key_l!=0xf0)//1、如果不等于0xf0，则说明它有按键按下了
	  {
	    Delay_50us(200);//2、延时10ms
	    if(key_l!=0xf0)//3、判断，是否真的有按键按下了，用于防抖动设计
		{
		  key_l=P3;
		  key_l&=0xf0;//再次得到这次的高四位的值，为了保证安全，防止抖动
	
		  P3=key_l|0x0f;//步骤三：为P3输出，高位输出k的值，低位输出1111		  
		  key_h=P3;//步骤四：定义一个变量key_h=P3;
		  key_h=key_h&0x0f;//得到这次的低四位的值，即行的值
	      key_all=key_l+key_h;//步骤五：得到它的最终值
	
		}
	  }
	  switch(key_all)
	  {
	    case 0xee:P0=smg_du[0];break;
		case 0xde:P0=smg_du[1];break;
		case 0xbe:P0=smg_du[2];break;
		case 0x7e:P0=smg_du[3];break;
		case 0xed:P0=smg_du[4];break;
		case 0xdd:P0=smg_du[5];break;
		case 0xbd:P0=smg_du[6];break;
		case 0x7d:P0=smg_du[7];break;
		case 0xeb:P0=smg_du[0];break;
		case 0xdb:P0=smg_du[1];break;
		case 0xbb:P0=smg_du[2];break;
		case 0x7b:P0=smg_du[3];break;
		case 0xe7:P0=smg_du[4];break;
		case 0xd7:P0=smg_du[5];break;
		case 0xb7:P0=smg_du[6];break;
		case 0x77:P0=smg_du[7];break;
	
	  }
  }
}

②本开发板的程序
p1.4 0  x
p1.5 0
p1.6 0
p1.7 0
        1      1     1     1
      p1.0  p1.1  p1.2  p1.3
#include <reg52.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选
sbit key1=P3^2;
sbit led0=P0^0;

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

void main()
{
  uchar key_l,key_h,key_all;
  P2=smg_wei[0];
  P0=smg_du[0];
  while(1)
  {
	  P1=0x0f;//步骤一：为P1输出00001111=0x0f;即
	  key_l=P1;//步骤二：定义一个变量K=P1;
	  key_l&=0x0f;//得到这次的低四位的值，即得知哪一列被按下
	  if(key_l!=0xf0)//1、如果不等于0xf0，则说明它有按键按下了
	  {
	    Delay_50us(200);//2、延时10ms
	    if(key_l!=0xf0)//3、判断，是否真的有按键按下了，用于防抖动设计
		{
		  key_l=P1;
		  key_l&=0x0f;//再次得到这次的低四位的值，为了保证安全，防止抖动
	
		  P1=key_l|0xf0;//步骤三：为P1输出，低位输出k的值，高位输出1111		  
		  key_h=P1;//步骤四：定义一个变量key_h=P1;
		  key_h=key_h&0xf0;//得到这次的高四位的值，即行的值
	      key_all=key_h+key_l;//步骤五：得到它的最终值
	
		}
	  }
	  switch(key_all)
	  {
	    case 0xee:P0=smg_du[0];break;
		case 0xed:P0=smg_du[1];break;
		case 0xeb:P0=smg_du[2];break;
		case 0xe7:P0=smg_du[3];break;
		case 0xde:P0=smg_du[4];break;
		case 0xdd:P0=smg_du[5];break;
		case 0xdb:P0=smg_du[6];break;
		case 0xd7:P0=smg_du[7];break;
		case 0xbe:P0=smg_du[8];break;
		case 0xbd:P0=smg_du[9];break;
		case 0xbb:P0=smg_du[10];break;
		case 0xb7:P0=smg_du[11];break;
		case 0x7e:P0=smg_du[12];break;
		case 0x7d:P0=smg_du[13];break;
		case 0x7b:P0=smg_du[14];break;
		case 0x77:P0=smg_du[15];break;
	
	  }
  }
}

③但是这种程序，由于是循环扫描的，存在一个弊端，就是使CPU繁忙，而且当CPU正在忙于处理其他
事情，就会遗漏了对键盘的反应。
处理方法是：使用定时器中断，定时器定时在几十ms的时间内，就不会出现这些问题了。
void time0() interrupt 1
{
  TH0=..
  TL0=..
  scan_key();//行列扫描键盘函数
  ...
}
   
2)编码键盘：如电脑使用的PS2键盘，它的每个按键都有一个专用的硬件编码器进行识别，发送一个键编码号或键值，如BCD码键盘，ASCII码键盘等
(1)连接方式
  5  6
3      4
  1  2
1数据线,接单片机的P30，即RXD脚；
3GND；4电源+5v；
5时钟CLK,接单片机的P32，即外部中断0，INT0脚


（2）原理：他有主从之分，主设备使用母头，电脑上即是主设备。从设备使用公头，键盘上的数据连接线即是公头，因此键           盘是从设备。它必须外接上拉电阻（一般上拉电阻设置在主设备中，比如单片机的P3口上），主从设备通过串行           方式传输，时钟信号由从设备产生。

（3）设备通信
①设备通信：从设备->主设备，较为常用，例如键盘鼠标向单片机发送数据
当从设备向主设备发送数据时，首先检查时钟线，当时钟线是高电平，说明这个总线是空闲的，从设备就传输数据；当时钟线是低电平，说明这个总线是繁忙的，从设备要等待总线空闲后，才能开始传输数据。

数据位，是11位：开始位0+D0....D7+1位奇校验+停止位1

传输方式：从设备总是在时钟线为高时，才发送下一个数据，而当时钟线为低时，保存数据不变；而主设备总是在时钟发生下降沿时，才读入这个数据

②设备通信：主设备->从设备，较为不常用，例如单片机向键盘鼠标发送数据

主设备先将时钟线和数据线置为请求发送状态：时钟线置为低电平最少100us，为了不让从设备通信->数据线置为低电平->时钟线置为高电平。在这个过程中，从设备需要检测是否主设备已经设为了请求发送状态，如果是的话，他将产生时钟信号，然后，主设备开始向从设备发送数据，此时每一帧数据由12位组成


数据位，是12位：上面的11位数据位+1位应答位ACK

ACK：主设备发送完数据给从设备后，从设备添加一个ACK，总是为0，告诉主设备我已经接收完了

传输方式：主设备总是在时钟线为低时，才发送下一个数据，而当时钟线为高时，保存数据不变；而从设备总是在时钟发生上升沿时，才读入这个数据




（4）PS2键盘的编码：PS2键盘有两种不同的类型，当一个按键按下时，键盘会将该键的通码发送给主机；当一个按键被释放时，键盘会将该键的断码发送给主机。
键盘有一套扫描码集，他将键盘的类型分为三类：其它具体的可以查看datasheet
第一类，用于普通字符：通码为一个字节0xXX，断码为0xF0+0xXX。例，A键，通码为0x1C，断码为0xF0 0x1C
第二类，用于一般的控制按键：通码为两个字节0xE0+0xXX，断码为0xE0+0xF0+0xXX。例，Right Ctrl，通码为0xE0 0x14，        断码为0xE0 0xF0 0x14
第三类，用于特殊的按键，只有两个：Print Screen键，通码为0xE0 0x12 0xE0 0x7C,断码为0xE0 0xF0 0x7C 0xE0 0xF0       0x12；Pause键，通码为0xE1 0x14 0x77 0xE1 0xF0 0x14 0xF0 0x77，断码为空	
组合按键发送顺序，按照按键发生的顺序：例Shift+A：按下左Shift->按下A键->释放A键->释放左Shift，计算机上收到的
      数据为0x12 0x1C 0xF0 0x1C 0xF0 0x12

(5)编写方法
注意:以后读串行总线数据时，一定要用到移位运算
例：
#include <reg52.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

uchar numbit=0,keyv=0x00;
sbit psdata=P3^0;
sbit psclk=P3^2;
uchar key[3];
uchar keynum=0;
uchar m,n;

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

void
main()
{
  //打开外部中断0
  EA=1;
  EX0=1;
  IT0=1;
  while(1)
  {
    //如果数组中已经保存了三个码了,就可以进行判断是哪个按键按下了
    if(keynum==3)
	{
	   keynum=0;
       n=key[0]/16;
	   m=key[0]%16;
	}
	//显示数值
    P0=smg_du[n];
    P2=smg_wei[0];
	Delay_50us(20);
	P0=smg_du[n];
    P2=smg_wei[1];
	Delay_50us(20);
  }
}

//中断服务函数，接收从设备到主设备的通信
void int0() interrupt 0
{
  //步骤一、读一帧数据位
  if((numbit>0)&&(numbit<9))
  {
    //以后读串行总线数据时，一定要用到移位运算
	keyv>>1;
	//如果接收的这个位是1时
	if(psdata==1)
	{
	  keyv|=0x80;//与1000 0000相或运算，得到最高位的值1
	}
	//如果接收的这个位是0时，直接移位，最高位就置0了
  }
  numbit++;//numbit表示目前这帧数据位是传送到第几位了

  //步骤二、如果已经读了一帧数据了，则将它保存到数组中
  if(numbit>10)
  {
    numbit=0;
    key[keynum]=keyv;
	keynum++;
  }
}

8、液晶LCD1602：可以显示两行，每行16个字符。注意，液晶不像数码管，它显示一遍以后，就会在断电前，一直保存着数据。因为液晶的编写比数码管动态扫描简单很多，而且也更灵活，建议平常使用液晶来显示。但是他有一个不如的地方，就是工作温度在0~50°C，因此极端环境下可能无法显示出来字符，这时只能使用数码管，这个要注意
1）datasheet说明：
（1）芯片操作方法，在datasheet中有列出：
RS=L,RW=H,E=H 在D0~D7将会组成一个状态字，让单片机读取
RS=H,RW=H,E=H 在D0~D7将会组成一个数据，让单片机读取
RS=L,RW=L,D0~D7=一个指令码，E=高脉冲(刚开始先低电平，突然间升为高电平，持续一会，再降为低电平) ，用于写指令。
具体方法即：RS=L--->RW=L--->写D0~D7--->E产生一个高脉冲--->写指令结束
RS=H,RW=L,D0~D7=数据，E=高脉冲，用于写数据

（2）地址映射：表示要显示的该字符在液晶上的哪个位置上进行显示，由于LCD是16字*2行
00 01 02 03 04 05 06 07 08 09  0A 0B 0C 0D 0E 0F，   10............27在这几个地址显示的数据，本来是看不见的，
40 41 42 43 44 45 46 47 48 49  4A 4B 4C 4D 4E 4F，   50............67但是可以通过移屏指令，让他们可见

指向数据显示地址：80H+(0~27H,或40~67H),例如80H+05H=85H

（3）初始化：
①通过指令码，初始化液晶：00111000，功能是将液晶设成16*2，而且每个字符是由5*7点阵(即横5个点，竖7个点)，8位数据接口
②设置指令码：
00001D(1是开显示，0关显示)C(1显示光标，0无光标)B(1光标闪烁，0不闪烁)
000001N(1读写一个字符后，地址和光标自动加一，指向下一个字符位置；0读写一个字符后，地址和光标自动减一，指向上一个字符位置)S(1时，当写完一个字符后，此时N=1时，整个屏幕会左移一个字符。N=0时，整个屏幕会右移一个字符；0时屏幕不移动，此时N=0)
③清屏01H，回车02H

例：
#include<reg52.h>
#define uchar unsigned char
#define uint unsigned int

sbit rs=P2^4;
sbit rw=P2^5;
sbit e=P2^6;
//要显示的字符串数组
uchar table1[]="www.tlxmcu.com";
uchar table2[]="LCD1602 test ok!";

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

//写指令
void writecom(uchar com)
{
  e=0;//e先设为低电平
  rs=0;//RS=L
  rw=0;//RW=L
  P0=com;//写D0~D7
  Delay_50us(10);//从时序图看，延时tsp2
  //E产生一个高脉冲
  e=1;
  Delay_50us(20);//从时序图看，延时tpw
  e=0;
}

//写数据
void write_data(uchar dat)
{
  e=0;//e先设为低电平
  rs=1;//RS=L
  rw=0;//RW=L
  P0=dat;//写D0~D7
  Delay_50us(10);//从时序图看，延时tsp2
  //E产生一个高脉冲
  e=1;
  Delay_50us(20);//从时序图看，延时tpw
  e=0;
}

//初始化液晶
void init()
{
  Delay_50us(300);//1、延时15ms  
  writecom(0x38);//2、写指令38H
  Delay_50us(100);//3、延时5ms  
  writecom(0x38);//4、写指令38H
  Delay_50us(100);//5、延时5ms  
  writecom(0x38);//6、写指令38H
  writecom(0x38);//7、写指令38H，显示模式设置
  writecom(0x08);//8、写指令08H，显示关闭
  writecom(0x01);//9、写指令01H，显示清屏
  writecom(0x06);//10、写指令06H，显示光标移动设置
  writecom(0x0c);//11、写指令01H，显示开及光标设置
}

void 
main()
{
  uchar j;
  init();//初始化液晶  
  //显示第一行字符
  writecom(0x80);//指向LCD要显示第一个字符的地址
  for(j=0;j<16;j++)
  {
    write_data(table1[j]);//每个字符会自动转成ASCII码
	Delay_50us(10);
  }
  //显示第二行字符
  writecom(0x80+0x40);//指向LCD要显示第二个字符的地址
  for(j=0;j<16;j++)
  {
    write_data(table2[j]);
	Delay_50us(10);
  }
  while(1);
}

9、LCD12864：他有两种，一种带中文字库，可以显示中文，以及图像；一种不带中文字库，不可以显示中文。它有4行，
一行可以显示8个中文
分辨率128*64：横的有128个点，竖的有64个点
1）datasheet说明：
（1）芯片操作方法，在datasheet中有列出：
RS=L,RW=H,E=H 在D0~D7将会组成一个状态字，让单片机读取忙标志BF(1表示正忙，不接受外部指令和数据；0表示空闲，可              以接收外部指令以及数据)，及地址接收器AC的状态
RS=H,RW=H,E=H 在D0~D7将会组成一个数据，让单片机读取
RS=L,RW=L,D0~D7=一个指令码，E=高脉冲(刚开始先低电平，突然间升为高电平，持续一会，再降为低电平) ，用于写指令。
具体方法即：RS=L--->RW=L--->写D0~D7--->E产生一个高脉冲--->写指令结束
RS=H,RW=L,D0~D7=数据，E=高脉冲，用于写数据

（2）显示中文
CGROM：将中文字库固化到ROM中，要显示只要到这里面去选择即可。
CGRAM：提供图形绘制，以及汉字造字功能
DDRAM：可以显示4行16个字的中文，第一行80H到87H，第二行90H到97H，
地址计数器AC

（3）地址映射：表示要显示的该字符在液晶上的哪个位置上进行显示
80H 81H 82H 83H 84H 85H 86H 87H
90H 91H 92H 93H 94H 95H 96H 97H
88H 89H 8AH 8BH 8CH 8DH 8EH 8FH
98H 99H 9AH 9BH 9CH 9DH 9EH 9FH

（4）初始化：
①打开电源，至少等待40ms
②送指令000011x0xx（RS R/W D7..D0）,至少等待100us；送指令000011x0xx,至少等待37us
③送指令0000001DCB,至少等待100us；
D(1是开显示，0关显示)C(1显示光标，0无光标)B(1光标闪烁，0不闪烁)
④送指令0000000001,至少等待10ms；
⑤送指令00000001 I/D S
I/D(1读写一个字符后，地址和光标自动加一，指向下一个字符位置；0读写一个字符后，地址和光标自动减一，指向上一个字符位置)
S(1时，当写完一个字符后，此时I/D=1时，整个屏幕会左移一个字符。I/D=0时，整个屏幕会右移一个字符；0时屏幕不移动，此时I/D=0)

例：
#include <reg52.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

sbit rs=P2^4;
sbit rw=P2^5;
sbit e=P2^6;
sbit psb=P2^7;

uchar table[]="身体健康20100419abc";

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

//*****************************
//一、单片机往LCD写指令或者数据
//*****************************
//写指令
void write_12864com(uchar com)
{
  e=0;
  rs=0;
  rw=0;
  Delay_50us(1);  
  P0=com;
  Delay_50us(1);  
  e=1;
  Delay_50us(10);  
  e=0;
  Delay_50us(2); 
}

//写数据
void write_12864dat(uchar dat)
{
  e=0;
  rs=1;
  rw=0;
  Delay_50us(1);  
  P0=dat;
  Delay_50us(1);  
  e=1;
  Delay_50us(10);  
  e=0;
  Delay_50us(2); 
}

//初始化液晶
void initinal()
{
  Delay_50ms(2);
  write_12864com(0x30);
  Delay_50us(4); 
  write_12864com(0x30);
  Delay_50us(4); 
  write_12864com(0x0f);
  Delay_50us(4);
  write_12864com(0x01);
  Delay_50ms(1); 
  write_12864com(0x06);
  Delay_50us(4); 
}

//*******************
//二、单片机往LCD写字
//*******************
//单片机往LCD写ASC字符,与LCD1602一样
void displayeg()
{
  uchar i;
  uchar a=0x10;
  write_12864com(0x80);//显示到第一行
  Delay_50us(1);
  for(i=0;i<16;i++)
  {
    write_12864dat(a);
	Delay_50us(1);
	a++;
  }
}

//单片机往LCD写汉字,根据datasheet的表格进行查询，看要显示一个汉字，需要输入什么数据
void displayca()
{
  uchar i;
  uchar a=0xba,b=0xc0;//这两个字节，显示汉字"豪"
  write_12864com(0x88);//显示到第三行
  Delay_50us(1);
  for(i=0;i<8;i++)
  {
    write_12864dat(a);
	write_12864dat(b);
	Delay_50us(1);
	b++;
  }
}

//单片机往LCD写汉字或字符，最实用的方法,与LCD1602一样
void displayeasy()
{
  uchar i;
  write_12864com(0x90);//显示到第二行
  Delay_50us(1);
  for(i=0;i<16;i++)
  {
    write_12864dat(table[i]);
	Delay_50us(1);
  }
}

void main()
{
  initinal();  
  displayeg();
  displayca();
  displayeasy();
}

10、A/D模数转换器，D/A数模转换器
1）D/A数模转换器
(1)原理：
    D0  ---|   |     它的最高电压为5v，所以可以一级一级地逐渐的调升它的输出电压，每一级的
数字    ...| 8 |---，          8
电路D7  ---|   |     电压为5v/2 =5v/256.例如，要调升它的电压为3级，则单片机输入0x10，输出5v/256*（0x10）=
                     5v/256*3
(2)性能指标
分辨率：指单片机数字信号输入每增进一级时，输出电压的变化量，即是输出模拟量的最小变化值。变化值越小，它的
        分辨率越高。所以，单片机的输入引脚数越多，它的变化率就越高。
线性度：实际输出电压与理论计算应输出电压的最大误差。也称绝对精度，它的误差值应该小于一级的电压的变化量。相对
        精度也一样，但是它是用百分比来表示
建立时间：完成一次数字信号输入，和模拟信号的转换输出所需要的时间

（3）DAC0832是8位数模转换器：根据datasheet可知，我们使用它的直通工作方式，操作步骤即片选信号CS，写信号WR，数据传送控制信号XFER全部接地。允许输入缓存信号ILE接+5v时。此时，数字信号一输入，就马上转为模拟信号输出

例：
#include<reg52.h>
#define uchar unsigned char
#define uint unsigned int

sbit cs=P3^1;
sbit wr=P3^4;


//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}


void
main()
{  
  uchar a=0x00; 
  //编程时，是按照时序图的顺序编写的
  cs=0;  
  wr=0;
  while(1)
  {
    P0=a;
	Delay_50us(100);
	a++;
  }
}

（4）DAC0832是教学使用，比较初级，做工程一般使用TLC5615,TLC5617芯片，因为他是串行输入的D/A芯片，只需要一个
引脚即可，但是这个引脚需要模拟SPI总线的形式输入值，编程比较复杂

2)A/D模数转换器
(1)原理：输入端最高电压为5v，他把输入端分为256份，当输入一个电压后，它会经过计算，得到这是属于第几级的，接着
在输出数字给数字信号

5v  ---|   |         
    ...| 8 |---数字，          
0   ---|   |   信号  
(2)性能指标
分辨率：指单片机需要驱动数字信号数字量每增进一级时，所需要输入模拟电压的变化量。例，电压最大为10v，数字信号为
                                   12 
        12位，则它的分辨率为10V*1/2
量化误差：ADC把模拟量转为数字量称为量化，实际上，数字量值随着模拟输入的电压值不断升高时，它的值也是以阶梯状
       的形式一级一级提升的。因此，在下一级提升以前，无论电压值输入升高多少，他都不会改变，这时，就产生了误差
       ，而误差的最大值就是量化误差
偏移误差：指输入信号为0时，输出信号不为0的值。
满刻度误差：是指，当输出数字信号为最大值时，理论输入电压与实际输入的电压的误差
线性度：实际输入电压与理论计算输入电压的最大误差。也称绝对精度，它的误差值应该小于一级的电压的变化量。相对
        精度也一样，但是它是用百分比来表示
转换速率：转换速率是指每秒可以进行转换的次数，而一次A/D转换的时间(包括稳定时间)=1/转换速率。注意，它的转换速        率要比D/A转换要慢的多

（3）ADC0804是8位模数转换器：注意，以后做工程时，最好在输入一个电压后，读它的输出数字信号值几十次，然后再取
一下平均值，这样子，输出的值就会比较稳定而且正确了

例：
#include<reg52.h>
#define uchar unsigned char
#define uint unsigned int

sbit rs=P2^4;
sbit rw=P2^5;
sbit e=P2^6;
sbit adrd=P3^0;
sbit adwr=P3^3;
sbit adcs=P3^5;
//要显示的字符串数组
uchar table1[]="www.tlxmcu.com";
uchar table2[]="LCD1602 test ok!";
uchar table3[]="0123456789";

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

//写指令
void writecom(uchar com)
{
  e=0;//e先设为低电平
  rs=0;//RS=L
  rw=0;//RW=L
  P0=com;//写D0~D7
  Delay_50us(10);//从时序图看，延时tsp2
  //E产生一个高脉冲
  e=1;
  Delay_50us(20);//从时序图看，延时tpw
  e=0;
}

//写数据
void write_data(uchar dat)
{
  e=0;//e先设为低电平
  rs=1;//RS=L
  rw=0;//RW=L
  P0=dat;//写D0~D7
  Delay_50us(10);//从时序图看，延时tsp2
  //E产生一个高脉冲
  e=1;
  Delay_50us(20);//从时序图看，延时tpw
  e=0;
}

//初始化液晶
void init()
{
  Delay_50us(300);//1、延时15ms  
  writecom(0x38);//2、写指令38H
  Delay_50us(100);//3、延时5ms  
  writecom(0x38);//4、写指令38H
  Delay_50us(100);//5、延时5ms  
  writecom(0x38);//6、写指令38H
  writecom(0x38);//7、写指令38H，显示模式设置
  writecom(0x08);//8、写指令08H，显示关闭
  writecom(0x01);//9、写指令01H，显示清屏
  writecom(0x06);//10、写指令06H，显示光标移动设置
  writecom(0x0c);//11、写指令01H，显示开及光标设置
}

void 
main()
{
  uchar j,value;
  uchar k,m,n;
  while(1)
  {
	  //步骤一、启动AD转换器的步骤
	  adcs=0;
	  adwr=0;
	  Delay_50us(2);
	  adwr=1;
	  adcs=1; 
	  Delay_50us(10);
	  //步骤二、AD转换器开始读数据
	  adcs=0;
	  adrd=0;
	  Delay_50us(2);
	  value=P1;
	  adrd=1;
	  adcs=1;
	
	  //将数字value转为字符型
	  k=value/100;
	  m=value%100/10;
	  n=value%10;
	  table1[0]=table3[k];//让table1显示百位数
	  table1[1]=table3[m];//让table1显示十位数
	  table1[2]=table3[n];//让table1显示个位数
	
	  //步骤三、在液晶上显示字符数字
	  init();//初始化液晶  
	  //显示第一行字符
	  writecom(0x80);//指向LCD要显示第一个字符的地址
	  for(j=0;j<3;j++)
	  {
	    write_data(table1[j]);//每个字符会自动转成ASCII码
		Delay_50us(10);
	  }  
  }
}


//****
//中断
//****
1）中断系统：
CPU在处理事件A时，发生了另一事件B，要求CPU迅速去处理。即中断发生
B事件时引起CPU中断的根源。即为中断源，中断源向CPU提出中断请求
CPU在A程序中设好断点，暂停处理A事件，转去处理B事件。即中断响应和中断服务
CPU处理完B后，再回来原事件A被中断的断点地方，继续处理A事件。即中断返回
                          ____  ____
2）单片机它有两个外部中断(INT0，INT1用于与其他单片机或者微机设备进行通用异步串行通信)，两个定时器\计数器中断（T0，T1），一个串行中断（RX加上TX）。含有两级优先级可实现两级中断嵌套(即在运行中断1程序时，可以再次中断，去运行优先级更高的中断2程序)
             
3）中断详细性质：
(1)
外部中断0(INT0)：P3.2引脚。触发条件：可由IT0(TCON.0)设置是低电平有效(即一检测到引脚置0时即有效)；还是下降沿有效(即检测到引脚电平由1，降为0)。当有中断触发时，中断标志IE0(TCON.1)置1，向CPU申请中断。中断号0

外部中断1(INT1)：P3.2引脚。触发条件：可由IT1(TCON.2)设置是低电平有效(即一检测到引脚置0时即有效)；还是下降沿有效(即检测到引脚电平由1，降为0)。当有中断触发时，中断标志IE1(TCON.3)置1，向CPU申请中断。中断号2

定时/计数器0(T0)：TF0(TCON.5)触发条件：定时/计数器0计数回0溢出。当有T0溢出发生中断时，TF0(TCON.5)置1。中断号1

定时/计数器1(T1)：TF1(TCON.7)触发条件：定时/计数器1计数回0溢出。当有T1溢出发生中断时，TF1(TCON.7)置1。中断号3

串口中断(T1/R1)：T1(SCON.0)或R1(SCON.1)触发条件：串行通信完成一帧数据发送时引起中断，置位R1。或接收完一帧串行数据时引起中断，置位T1。中断号4

(2)优先级：
中断优先级(优先级别越高的，中断号越低)：外部中断0(INT0)>定时/计数器0(T0)>外部中断1(INT1)>定时/计数器1(T1)>串行口

中断原则：同时有几个中断时，先响应优先级别高的中断；正在进行的中断执行过程，不能被它的同优先级，或者更低优先级的中断请求所中断，而只能被更高优先级的中断请求所中断

4）CPU中断运行控制
CPU对中断源的开放与屏蔽是由中断允许寄存器IE控制的
EX0（IE.0）外部中断0允许位，为1则允许中断
ET0（IE.1）定时、计数器T0中断允许位，为1则允许中断
EX1（IE.2）外部中断1允许位，为1则允许中断
ET1（IE.3）定时、计数器T1中断允许位，为1则允许中断
ES（IE.4）串行口中断允许位，为1则允许中断
EA（IE.7）CPU中断允许位，如果要有任何一个中断允许中断，这个必须为1  

因此，开中断条件：一个中断源发出中断请求，这个中断源的中断允许位为1，EA=1

5)中断请求标志
IT0（TCON.0）外部中断0触发方式控制位，IT0=0低电平触发，IT0=1下降沿触发
IE0（TCON.1）外部中断0中断请求标志位
IT1（TCON.2）外部中断1触发方式控制位
IE1（TCON.3）外部中断1中断请求标志位
TF0（TCON.5）定时器，计数器T0溢出中断请求标志位
TF1（TCON.7） 定时器，计数器T1溢出中断请求标志位  

6)开发中断程序：
（1）开发中断程序：需要做的步骤
①选择想要使用的中断，这样就选择了相应的中断号
②分析这次希望的中断触发条件是什么，是低电平，下降沿，还是计数器，串口等
③确定这次中断了，是要做什么事，编写相应的处理程序

（2）开发中断程序，需要做的步骤：
例如，打开外部中断0
①主程序需要使用的代码
EA=1;打开总中断允许开关
EX0=1;打开外部中断0允许开关
IT0=0/1;设置外部中断0触发方式控制位，IT0=0低电平触发，IT0=1下降沿触发
②中断服务函数
//int0是函数名，可自定义。interrupt表示这是一条中断服务函数。0代表选择的中断号，告诉单片机此次想要使用哪个
//中断。[ using 1]单片机有0到3四组寄存器，用来保存中断处理的程序，最好每个函数占用一个寄存器。建议不需要写，
//这样，让编译器自动寻找，并加上更保险。

void int0 () interrupt 0[ using 1]
{
  xxx;//注意：中断服务程序CPU会不做别的，而一直做这里的事情，因此建议要写的尽量短
}

例：
#include<reg52.h>
#define uchar unsigned char
#define uint unsigned int
unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

sbit led0=P0^0;

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}


void
main()
{
  uchar i;
  void int0();
  //步骤一
  EA=1;//打开总中断允许开关
  EX0=1;//打开外部中断0允许开关
  //IT0=0;//设置外部中断0触发方式控制位，IT0=0低电平触发
  IT0=1;//设置外部中断0触发方式控制位，IT0=1下降沿触发
  P2=smg_wei[0];
  while(1)
  {    
	for(i=0;i<10;i++)
	{
      P0=smg_du[i];
      Delay_50ms(10);
	}
  }
}

//步骤二、写中断服务程序
void int0() interrupt 0
{
  led0=0;
  Delay_50ms(20);
  led0=1;
}

执行：按下P3.2关联的按钮后，会自动触发总断，跳出cpu的主程序运行，而执行中断程序

//******
//定时器
//******
1、CPU周期知识
振荡周期：是为CPU提供定时信号的振荡源的周期，即是晶振周期，或者是外界振荡源(此时CPU无需接上晶振也可工作)的周期，例如晶振是12MHZ，则振荡周期是12MHZ，则一个机器周期时间是1/12MHZ=1/12us
状态周期：用S表示，一个状态周期=2个振荡周期，例如晶振是12MHZ，则状态周期是6MHZ，则一个状态周期时间是1/6MHZ=1/6us
机器周期：1个机器周期=6个状态周期=12个振荡周期，例如晶振是12MHZ，则机器周期是1MHZ，则一个机器周期时间是1/1MHZ=1us
指令周期：完成1条指令所用的时间，一般是1-4个机器周期，例如机器周期是1MHZ，则一个机器周期时间是1/1MHZ=1us，即是指令周期时间是1us-4us

2、原理
1）单片机有两组定时器/计数器，定时器/计数器与CPU是互相独立的，它的工作过程是自动完成的，无需CPU参与。它的工作过程是根据机器内部时钟，或者外部的脉冲信号(通过P3.4，P3.5接入)，每次对寄存器中的数据加1。这样，一些简单的重复加1的工作可以交给定时器/计数器处理，而CPU转而处理复杂的事情。同时也可以实现精确定时作用；
当它接时钟振荡器时，由于计数脉冲为一时间基准，所以他就作定时功能；
当它的脉冲源为间隔时间不等的外部脉冲发生器时，他就是作为外部事件的计数器。这时，它的P3.4
接T0，P3.5接T1，用于外接脉冲源，当这个脉冲源有一个负跳变时，会加1

2)定时器/计数器介绍
定时/计数器0(T0)：TF0(TCON.5)触发条件：定时/计数器0计数回0溢出。当有T0溢出发生中断时，TF0(TCON.5)置1。中断号1

定时/计数器1(T1)：TF1(TCON.7)触发条件：定时/计数器1计数回0溢出。当有T1溢出发生中断时，TF1(TCON.7)置1。中断号3

3)优先级：
中断优先级(优先级别越高的，中断号越低)：外部中断0(INT0)>定时/计数器0(T0)>外部中断1(INT1)>定时/计数器1(T1)>串行口

中断原则：同时有几个中断时，先响应优先级别高的中断；正在进行的中断执行过程，不能被它的同优先级，或者更低优先级的中断请求所中断，而只能被更高优先级的中断请求所中断

4）定时/计数器结构：它是一个加1计数器，他有16位，由高8位和低8位两个寄存器组成。(例如定时/计数器0由TH0和TL0组成定时/计数器1是由TH1和TL1组成)。TMOD是定时/计数器的工作方式寄存器，确定工作方式和功能；TCON是控制寄存器，控制T0，T1的启动和停止及设置溢出标志
                T1引脚                            T0引脚 
  寄存器  |TH1          TL1|                 |TH0         TL0| 
  TCON：      TR1      TF1                       TR0      TF0
                  _                                   _
  TMOD：  GATE  C/T  M1  M0                   GATE  C/T  M1  M0

（1）TMOD：设置定时/计数器的工作方式，低四位用于T0，高四位用于T1                                 _
     T0，以及T1的TMOD工作方式：GATE,C/T,M1，M0
GATE：门控位，如果GATE=0，则TR0=1或TR1=1即启动了定时/计数器0或1工作；而如果GATE=1，则TR0=1或TR1=1，而且外部中断引脚INT0或INT1为高电平时，才启动了定时/计数器0或1工作；一般情况下GATE=0

C/T：C/T=0为定时器，C/T=1为计数器
                                                                                           
M1，M0：工作方式设置位，一般为01
00 方式0， 是13位定时/计数器
01 方式1， 是16位定时/计数器
10 方式2， 是8位自动重装定时/计数器，就是说当TL溢出，触发中断后，单片机处理中断后，会自动将TH的值再拷贝到TL中
                                     ，而不用再编程写了。
11 方式3， T0分成两个独立的8位定时/计数器，T1停止计数功能

①计算方式：                                                                                                                                                            16
在01工作方式下：由于它是每隔1us的时间加1，所以这个16位定时/计数器的最大计数是2  =65536，即最大定时时间是
65.536ms

②定时50ms：
所以定时50ms=50000us=计数器加50000次
                              16
计数个数与计数初值的关系为：X=2 -N,  X=65536-50000=15536,将初值15536这个值放到寄存器TH0,TL0中

③程序是
TH0=(65536-50000)/256;
TL0=(65536-50000)%256;

④定时1s：
即可当作每次定时50ms，定时20次
void
main()
{
  //步骤二、每次定时1s，即可当作每次定时50ms，定时20次
  //设置初值,本次定时50ms后触发
  TH0=(65536-50000)/256;
  TL0=(65536-50000)%256;
  。。。。。。。。。。。。
  //CPU开始循环执行，而每当定时器到达50ms之后，就会跳到中断函数去执行一下，完毕后，
  //CPU继续执行
  while(1)
  {
    //判断，只有循环达到20次之后，才可以点亮数码管
	if(i==20)
	{
	  i=0;	  
          P0=smg_du[num];
	  num++;
	  if(num==9)num=0;
	}
  }
}

void timer0() interrupt 1
{
  //重设初值
  TH0=(65536-50000)/256;
  TL0=(65536-50000)%256;
  //每次定时1s，即可当作每次定时50ms，定时20次
  i++;
}

（2）TCON：
TR0：TR0=1启动定时器0工作，再TR0=0暂停此定时器
TR1：TR1=1启动定时器1工作，再TR1=0暂停此定时器
TF0（TCON.5）定时器，计数器T0溢出中断请求标志位，不用去管
TF1（TCON.7） 定时器，计数器T1溢出中断请求标志位 ，不用去管


5）CPU中断运行控制
CPU对中断源的开放与屏蔽是由中断允许寄存器IE控制的
ET0（IE.1）定时、计数器T0中断允许位，为1则允许中断
ET1（IE.3）定时、计数器T1中断允许位，为1则允许中断
EA（IE.7）CPU中断允许位，如果要有任何一个中断允许中断，这个必须为1  

因此，开中断条件：一个中断源发出中断请求，这个中断源的中断允许位为1，EA=1

6)开发定时/计数器程序：
（1）开发定时/计数器程序：需要做的步骤
①对TMOD赋值，以确定T0和T1的工作方式
②计算初值，写入TH0，TL0或TH1，TL1
③EA=1，ET0=1或者ET1=1对定时/计数器0或者定时/计数器1开允许中断
④设置TCON的TR0=1或TR1=1，启动定时/计数器
⑤中断服务函数
//timer0是函数名，可自定义。interrupt表示这是一条中断服务函数。1代表选择的中断号，告诉单片机此次想要使用哪个
//中断。[ using 1]单片机有0到3四组寄存器，用来保存中断处理的程序，最好每个函数占用一个寄存器。建议不需要写，
//这样，让编译器自动寻找，并加上更保险。

void timer0 () interrupt 1[ using 1]
{
  xxx;//注意：中断服务程序CPU会不做别的，而一直做这里的事情，因此建议要写的尽量短
}
例：使用定时/计数器0
#include<reg52.h>
#define uchar unsigned char
#define uint unsigned int
unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

sbit led0=P0^0;

uchar num=0,i;

void main()
{
  void timer0();
  //步骤一、设置TMOD=0000 0001，即0x01
  TMOD=0x01;
  //步骤二、每次定时1s，即可当作每次定时50ms，定时20次
  //设置初值,本次定时50ms后触发
  TH0=(65536-50000)/256;
  TL0=(65536-50000)%256;
  //步骤三、允许开定时器\计数器中断
  EA=1;
  ET0=1;
  //步骤四、使设置TCON的TR0=1，启动定时/计数器
  TR0=1;

  P2=smg_wei[0];
  //CPU开始循环执行，而每当定时器到达50ms之后，就会跳到中断函数去执行一下，完毕后，
  //CPU继续执行
  while(1)
  {
    //判断，只有循环达到20次之后，才可以点亮数码管
	if(i==20)
	{
	  i=0;	  
      P0=smg_du[num];
	  num++;
	  if(num==10)num=0;
	}
  }
}

void timer0() interrupt 1
{
  //重设初值
  TH0=(65536-50000)/256;
  TL0=(65536-50000)%256;
  //每次定时1s，即可当作每次定时50ms，定时20次
  i++;
}

//********    
//串口编程
//********
1、原理： 串口传输是一位接一位的，象串起的珠子一样，以字节流的方式传送地址，或者数据进行访问。 并口传输是可以并发数据的可以同时传输多位，可以将数据与地址同时传输访问。串口一般用于通讯使用。一般使用RS-232-C标准。

1）并行通讯：
接收    <----------------------     发送
设备    <----8位同时传送-------     设备
        <----------------------
        <-------询问------------
        --------应答----------->
流程：发送方询问，是否可以发送数据->接收方应答，可以发送数据->8位数据同时发送。优点速度快，但是缺点当长距离传送时，接收较困难，因为无法保证各位数据同时接收到

2）串行通讯：
接收设备<-----8位数据顺次传送----发送设备
优点：可以长距离进行通讯，缺点是数据流的控制较复杂

3）异步通讯：通讯机制类似串行通讯，但是发送设备和接收设备使用各自的时钟控制数据的发送和接收，但是还是尽可能要求它们的时钟要尽可能一样
传送格式：
   空闲，高电平   起始位，低电平 数据位，由低到高位  校验位  停止位，高电平
         ――――|______________|D0..............D7|       |

4）串行通讯的分类
单工：只能传送，或者接收一项
半双工：可以进行传送，或者接收，但是同一时刻只能有一项
全双工：可以同时进行接收，或者传送

5）校验位
奇校验：数据位中‘1’的个数+校验位中‘1’的个数=必须为奇数
例：
发送方：
数据位10101100   校验位x，   4+x=奇数，所以校验位x=1 

接收方：
如果接收到的 数据位中‘1’的个数+校验位中‘1’的个数=为奇数，则没错；如果是偶数个，则说明发送出错

偶校验：数据位中‘1’的个数+校验位中‘1’的个数=必须为偶数
例：
发送方：
数据位10101100   校验位x，   4+x=偶数，所以校验位x=0 

接收方：
如果接收到的 数据位中‘1’的个数+校验位中‘1’的个数=为偶数，则没错；如果是奇数个，则说明发送出错

6）传输速率：注意，传输速率越高时，它最大传送距离越短。因此，一般传长距离时，是使用RS485转接
比特率：每秒传输的二进制代码的位数，单位是位/秒(bps)。
例：每秒传送240个字符，每个字符包含(1个起始位+8个数据位+1个停止位),这时比特率为
10*240个/秒=2400bps;

7）串口一般用于通讯使用。一般使用RS-232-C标准。芯片内部常具有UART控制器。

8）连接方式：是三线制
   A机器                         A机器
第2根RXD接收数据<---\/-------->第2根RXD接收数据
第3根TXD发送数据----/\---------第3根TXD发送数据
第5根SGND信号接地--------------第5根SGND信号接地

9)连接方式：单片机-->MAX232芯片---->串口

2、结构:它有两个缓存，读SBUF写SBUF
输出：将数据从单片机中->写入写缓冲SBUF->串行数据通过TXD接口，发送出去->发送完毕，TI=1
输入：通过RXD接口采样到1->0的跳变->确认时开始位0->通过RXD接收串行数据->接收完毕，RI=1
      ->保存到读缓冲SBUF中，单片机从SBUF中读取数据

1)SCON：设定工作方式
   D7  D6   D5   D4   D3   D2   D1  D0
  SM0  SM1  SM2  REN  TB8  RB8  TI  RI

SM0和SM1：工作方式01(即使用方式1)，是10位异步收发器(1个起始位+8个数据位+1个停止位)
SM2：0,编程时可不用写
REN：1
TB8：0,编程时可不用写
RB8：0,编程时可不用写
TI：在发送完一段数据包括停止位后，CPU会自动将它置1，以向CPU发出中断请求，让它来处理这个函数，但是它不会自动再    置回0。因此，需要在中断函数中，写上TI=0
RI：在接收完一段数据包括停止位后，CPU会自动将它置1，以向CPU发出中断请求，让它来处理这个函数，但是它不会自动再     置回0。因此，需要在中断函数中，写上RI=0

2）PCON的SMOD标志位：SMOD=0时，速率是正常波特率；SMOD=1时，波特率提高一倍

3）波特率计算：接收方和发送方的波特率要相同
  串口在工作方式一的波特率=(2SMOD/32)*(T1溢出率)

  此时，T1要设为工作方式二，T1溢出率=晶振频率/{12*[256-(TH1)]},注意，此时的晶振频率要选用11.0592MHZ，因为
  这个频率，算出来的波特率才会没有误差

  例：SMOD=0时
  串口在工作方式一的波特率=(1/32)*(T1溢出率)=(1/32)* (晶振频率/{12*[256-(TH1)]})
                          (1/32)* (11.0592MHZ/{12*[256-(TH1)]})=9600
                          (1/32)* (11059200/{12*[256-(TH1)]})=9600
                                 TH1=FDH
  常用波特率与定时器初值计算关系,晶振为11.0592MHZ
  波特率(b/s)   SMOD        初值
  19.2K           1         FDH
  9600            0         FDH
  4800            0         FAH
  2400            0         F4H
  1200            0         F8H

3、开发串口程序需要做的步骤：设置产生波特率的定时器1，串口控制，中断控制
①对TMOD赋值，以确定T1的工作方式
②根据波特率计算T1初值，将值写入TH1，同时TL1的值与TH1的值一样
③设置TCON的TR1=1，启动定时/计数器T1
④确定串口控制，设置SCON寄存器
⑤EA=1，ES=1对串口开允许中断
⑥中断服务函数，要进行中断设置(编程IE，IP寄存器)
//serial是函数名，可自定义。interrupt表示这是一条中断服务函数。4代表选择的中断号，告诉单片机此次想要使用哪个
//中断。[ using 1]单片机有0到3四组寄存器，用来保存中断处理的程序，最好每个函数占用一个寄存器。建议不需要写，
//这样，让编译器自动寻找，并加上更保险。

void serial() interrupt 4[ using 1]
{
  xxx;
}

例：
#include<reg52.h>
#define uchar unsigned char
#define uint unsigned int
unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

uchar a,flag;

void
main()
{
  //步骤一、设置TMOD=0010 0000，即0x01
  TMOD=0x20;
  //步骤二、根据波特率计算T1初值，将值写入TH1，同时TL1的值与TH1的值一样
  TH1=0xFD;
  TL1=0xFD;
  //步骤三、设置TCON的TR1=1，启动定时/计数器T1
  TR1=1;
  //步骤四、 确定串口控制，设置SCON寄存器
  SM0=0;
  SM1=1;
  REN=1;
  //步骤五、EA=1，ES=1对串口开允许中断
  EA=1;
  ES=1;

  P2=smg_wei[1]; 
  while(1)
  {
    //判断，如果没有等于1，说明单片机没收到数据。
	//如果有等于1，就给电脑发送一个数据，其实就是发送的串口调试
    //助手的接收端中
    if(flag==1)
	{
	   ES=0;//先把串口中断关闭
       flag=0;
	   SBUF=a;
	   while(!TI);//等待数据发送结束
	   TI=0;
	   ES=1; 
	}
  }

}

void serial() interrupt 4
{
  //单片机从串口SBUF中接收电脑发送的一个数据，保存到a中
  //其中电脑发送的数据，其实是由串口调试助手发送的数据
  a=SBUF;
  P0=a;//将数据显示到数码管上  
  RI=0;//串口读清零
  flag=1;//表示收到数据
}

//************    
//红外遥控解码
//************
1、原理：
键盘矩阵->编码和调制芯片->能够发送红外光线的LED.......LED光电转换器，同时对电信号放大->解调器->单片机解码
                 遥控器                                             一体化红外接收器            

一体化红外接收器:接收红外线，转换为电信号，并且将这个电信号放大，输出为单片机的TTL电平，由out脚输出

1)编码方式：使用TC9012方式,发送一帧数据包含以下32位
（1）发送数据：

-----------|_____________|<D0------D7>|<D0------D7>|<D0------D7>|<D0-----------D7>|X
4.5ms高电平    4.5ms低电平
    引导码                  8位用户码    8位用户码    8位数据码  8位数据码的反码  1个同步位

用户码：同一个遥控器，它的用户码是一样的。用户码为S0--S7，而
        S2S1S0有8种，分别是：000，,01,010,011,100,101,110,111；S3为1，S4S5S6S7为：0000
        例：S0--S7为010 1 0000
数据码：遥控器上不同的按键，则是由数据码来进行判断

（2）接收数据：遥控器发送的一个上升沿，对应到接收器那里，就是接收到一个下降沿，即接收的与发送的都是相反的

_____________|-------------|<D0------D7>|<D0------D7>|<D0------D7>|<D0-----------D7>|X
4.5ms低电平    4.5ms高电平
    引导码                  8位用户码    8位用户码    8位数据码     8位数据码的反码  1个同步位


2）信号调制后，遥控器发送信号波形
发送0：先发送高电平0.56ms时间，再发送低电平是0.565ms时间，大约是1:1，总时间是1.125ms
发送1：先发送高电平0.56ms时间，再发送低电平是1.69ms时间，大约是1:3，总时间是2.25ms

2、编程方法
1）编程原理：
（1）遥控器发送一帧数据
（2）->单片机的接收信号引脚接到外部中断上，一旦接收到信号，单片机立即开始中断服务；因为发送信号刚产生一个上升     沿后，接收信号就产生一个下降沿，因此该外部中断要设为下降沿触发。以后，遥控器一发送一个上升沿，接收器就接   收一个下降沿，这样就会引发中断
（3）->遥控器先发送一个引导码，单片机的外部中断由下降沿触发了
（4）->此时单片机启动一个定时器，启动定时器使用方式二
    定时器使用方式二：TH0=0,TL0=0;这样，晶振使用12MHZ，因此机器周期为1us，即定时器每隔1us加1，所以经过了
    255us后，定时器加满，产生了中断。而在中断服务程序中，假设有一个全局变量timevalue，就是为它加1，以记录
    随着时间的推移，目前中断的次数

（5）->单片机触发第一次外部中断，说明目前是发送的是引导码，将定时器内的中断次数timevalue=0；

（6）->第二个上升沿发送过来后，单片机的外部中断由下降沿触发了第二次中断，在处理函数中，进行判断时间经过了
     多久。如果是大约9ms，则说明发送的这一个是引导码，将经过时间保存起来。并将timevalue=0

（7）等第三个上升沿再过来的时候，单片机的外部中断由下降沿触发了第三次中断。同样，把经过时间保存起来。并将          timevalue=0。接下来数据的接收同理，直到一帧数据接收结束

（8）查看产生了这两个外部中断的这段时间内，定时器一共中断了几次，既可以得到时间了。例如，中断了10次，则说明了    这两个外部变量，相距地时间是2.56ms。
    如果用时1.125ms，即大约中断4.4次，说明是接收到0数据，如果用时2.25ms，即大约中断8.8次，说明是接收到1数据
    通过这样，分别将这帧数据的经过的各个保存时间，转为0和1 ，注意，它的发送顺序是D0->D7,所以每一个字节保存的
    时候，需要倒过来保存

2）例：
#include <reg52.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

uchar irtime;
uchar startflag,irreceok,irprosok;
uchar irdata[33];
uchar bitnum;
uchar ircode[4];
uchar disp[8];

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

//定时器0开中断,使用方式二，这样当中断后，程序处理过后，单片机可以自动将TH0的
//值填充到TL0中，而不用程序来做
void timer0init()
{
  TMOD=0x02;
  TH0=0x00;
  TL0=0x00;
  ET0=1;
  EA=1;
  TR0=1;
}
//外部中断0开中断
void int0init()
{
  IT0=1;
  EX0=1;
  EA=1;  
}
//步骤五、红外解调，解码
/*
查看产生了这两个外部中断的这段时间内，定时器一共中断了几次，既可以得到时间了。例如，
中断了10次，则说明了这两个外部变量，相距地时间是2.56ms?
1)如果用时1.125ms，即大约中断4.4次，说明是接收到0数据，  
2)如果用时2.25ms，即大约中断8.8次，说明是接收到1数据
通过这样，分别将这帧数据的经过的各个保存时间，转为0和1
，注意，它的发送顺序是D0->D7,所以每一个字节保存的时候，需要倒过来保存
*/
void irpros(void)
{
  uchar k,i,j;
  uchar value;
  k=1;//跳过引导码
  for(j=0;j<4;j++)
  {
	  for(i=0;i<8;i++)
	  {
		  value=value>>1;
		  if(irdata[k]>6)//如果发送的是1
		  {
		    value=value|0x80;
		  }
		  k++;
	  }
	  ircode[j]=value;//将解调后的数据保存在这里
  }
  irprosok=1;//表示解调完毕
}

//显示发送的按键码
void irwork()
{
  disp[0]=ircode[0]/16;
  disp[1]=ircode[0]%16;
  disp[2]=ircode[1]/16;
  disp[3]=ircode[1]%16;
  disp[4]=ircode[2]/16;
  disp[5]=ircode[2]%16;
  disp[6]=ircode[3]/16;
  disp[7]=ircode[3]%16;
}
void display()
{
  uchar i;
  for(i=0;i<8;i++)
  {
    P0=smg_du[disp[i]];
    P2=smg_wei[i];
	Delay_50us(20);
  }
}
void main()
{
  //开中断
  timer0init();
  int0init();
  while(1)
  {
    if(irreceok)//如果红外已经接受完了的话
	{
	  irpros();
	  irreceok=0;
	}
	if(irprosok)//如果红外已经解调解码完了的话
	{
	  irwork();
	  irprosok=0;
	}
	display();
  }
 
}

/*
定时器使用方式二：TH0=0,TL0=0;这样，晶振使用12MHZ，因此机器周期为1us，
即定时器每隔1us加1，所以经过了255us后，定时器加满，产生了中断。而在中断服务程序中，
假设有一个全局变量irtime，就是为它加1，以记录随着时间的推移，目前中断的次数

irtime经过的次数*255us，即是经过的时间了
*/
void timer0() interrupt 1
{
  irtime++;
}

void int0() interrupt 0
{
  //步骤一、
  //startflag是指启动标志位，为0时，表示原先还未发送，这一次中断是接收到它的引导码
  //则将它设为startflag=1;为1时，说明原先的引导码已经发送完毕了，就可以开始进行接收数据了
  if(startflag)
  {
    //步骤二、判断时间经过了多久。如果是大约9ms，则说明发送的这一个是引导码
    if(irtime>32)
	{
	  bitnum=0;//位变量清0，表示待会会将引导码时间放到irdata[0]中
	}
	irdata[bitnum]=irtime;
	//步骤三、将irtime清0，用来计算下一个发送数据的时间；bitnum加1，用来以后将下一个数据
	//的发送时间保存在下一个数组值中
	irtime=0;
	bitnum++;
    //步骤四、如果这帧数据已经接收完了的话
	if(bitnum==33)
	{
	  bitnum=0;
	  irreceok=1;//标志，这帧数据已经接收完了
	}
  }
  else
  {    
    startflag=1;
	irtime=0;
  }
}

3)本开发板程序
#include <reg52.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

uchar irtime;
uchar startflag,irreceok,irprosok;
uchar irdata[35];
uchar bitnum;
uchar ircode[4];
uchar disp[8];

sbit led0=P0^0;
sbit led7=P0^7;

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

//定时器0开中断,使用方式二，这样当中断后，程序处理过后，单片机可以自动将TH0的
//值填充到TL0中，而不用程序来做
void timer0init()
{
  TMOD=0x02;
  TH0=0x00;
  TL0=0x00;
  ET0=1;
  EA=1;
  TR0=1;
}
//外部中断1开中断
void int1init()
{
  IT1=1;
  EX1=1;
  EA=1;  
}
//步骤五、红外解调，解码
/*
查看产生了这两个外部中断的这段时间内，定时器一共中断了几次，既可以得到时间了。例如，
中断了10次，则说明了这两个外部变量，相距地时间是2.56ms?
1)如果用时1.125ms，即大约中断4.4次，说明是接收到0数据，  
2)如果用时2.25ms，即大约中断8.8次，说明是接收到1数据
通过这样，分别将这帧数据的经过的各个保存时间，转为0和1
，注意，它的发送顺序是D0->D7,所以每一个字节保存的时候，需要倒过来保存
*/
void irpros(void)
{
  uchar k,i,j;
  uchar value;
  k=1;//跳过引导码
  for(j=0;j<4;j++)
  {
	  for(i=0;i<8;i++)
	  {
		  value=value>>1;
		  if(irdata[k]>6)//如果发送的是1
		  {
		    value=value|0x80;
		  }
		  k++;
	  }
	  ircode[j]=value;//将解调后的数据保存在这里
  }
  irprosok=1;//表示解调完毕
}

//显示发送的按键码
void irwork()
{
  /*
  disp[0]=ircode[0]/16;
  disp[1]=ircode[0]%16;
  disp[2]=ircode[1]/16;
  disp[3]=ircode[1]%16;
  disp[4]=ircode[2]/16;
  disp[5]=ircode[2]%16;
  disp[6]=ircode[3]/16;
  disp[7]=ircode[3]%16;
  */
  disp[0]=ircode[0]/16;
  disp[1]=ircode[0]%16;
  disp[2]=ircode[2]/16;
  disp[3]=ircode[2]%16;
}
void display()
{
  uchar i;
  for(i=0;i<4;i++)
  {
    P0=smg_du[disp[i]];
    P2=smg_wei[i];
	Delay_50us(20);
  }
}
void main()
{
  //开中断
  timer0init();
  int1init();
  while(1)
  {
    if(irreceok)//如果红外已经接受完了的话
	{
	  irpros();
	  irreceok=0;      
	}
	if(irprosok)//如果红外已经解调解码完了的话
	{
	  irwork();
	  irprosok=0;	  
	}
	display();
  }
 
}

/*
定时器使用方式二：TH0=0,TL0=0;这样，晶振使用12MHZ，因此机器周期为1us，
即定时器每隔1us加1，所以经过了255us后，定时器加满，产生了中断。而在中断服务程序中，
假设有一个全局变量irtime，就是为它加1，以记录随着时间的推移，目前中断的次数

irtime经过的次数*255us，即是经过的时间了
*/
void timer0() interrupt 1
{
  irtime++;  
}

void int1() interrupt 2
{
  //P0=smg_du[0];
  //P2=smg_wei[0];
  
  //步骤一、
  //startflag是指启动标志位，为0时，表示原先还未发送，这一次中断是接收到它的引导码
  //则将它设为startflag=1;为1时，说明原先的引导码已经发送完毕了，就可以开始进行接收数据了
  if(startflag)
  {
    //步骤二、判断时间经过了多久。如果是大约9ms，则说明发送的这一个是引导码
    if(irtime>45)
	{
	  bitnum=0;//位变量清0，表示待会会将引导码时间放到irdata[0]中
	}
	irdata[bitnum]=irtime;
	//步骤三、将irtime清0，用来计算下一个发送数据的时间；bitnum加1，用来以后将下一个数据
	//的发送时间保存在下一个数组值中
	irtime=0;
	bitnum++;
    //步骤四、如果这帧数据已经接收完了的话
	if(bitnum==33)
	{
	  bitnum=0;
	  irreceok=1;//标志，这帧数据已经接收完了
	}
  }
  else
  {    
    startflag=1;
	irtime=0;
  }
}


//*******
//IIC总线
//*******
常用总线有IIC总线，SPI总线。
1、原理：IIC总线可以将所有有IIC接口的设备都挂在同一条总线上，一般在单片机的串行总线扩展中，都是以单片机为主机，其它接口器件为从机；典型的设备有串行EEPROM，它掉电后数据不会丢失
它的特点是

数据线SDA-------。----------。---------------------------------------
时钟线SCL----。-|--------。-|-----------------------------------------
         SCL |  |SDA     |  |      |              |         |         |
各设备     单片机A     单片机B  SRAM或EEPROM   A/D或D/A  日历时钟   其它IIC外围设备        

1）各个挂在两根线上的设备，都有一个唯一的地址，这样主机就可以通过地址寻找到一个设备，主机发送数据
   到该设备。这时主机即发送器，总线上接收数据的器件则为接收器
2）它都要接上上拉电阻，两根总线空闲时总是高电平。但是，如果总线上的任何一个设备的SDA突然变为低电平，则这整根
   SDA总线都变为低电平；同理，如果总线上的任何一个设备的SCL突然变为低电平，则这整根SCL总线都变为低电平
3）总线裁决：在多主机的系统中，如果有几个主机同时企图占用总线传输数据，IIC总线就会通过总线裁决，以决定是由
   哪个主机控制总线
4）高低速器件同步

2、数据传送
1）数据传送：当SCL为高电平时，数据SDA不能改变，需要保持稳定；只有当SCL为低电平时，SDA才能改变数据。即，当
             SCL为高电平时，数据SDA进行读，当CLK为低电平时，数据SDA进行写
2）起始位和终止位：都由主机发出，当SCL为高电平时，SDA由高电平->低电平为起始位,开始占用总线；当SCL为高电平时，SDA由低电平->高电平为终止位，释放总线
        SCL____|----------------                            SCL____|----------------
起始位：SDA-----------|________                     终止位：SDA__________|---------
3）一个接收器接收一个数据字节后,如果需要进行其它工作，例如处理中断等，无法马上接收下一个字节->接收器将SCL拉为
低电平->主机处于阻塞等待状态，并且总线不会释放->接收器处理完毕，将SCL释放为高电平->主机继续传送数据

3、一帧数据传送格式:
1）主机通过总线向从机写数据：主机发送一帧数据有9位，且传送时是先传高位字节，再传低位字节：D[7]...D[0] S应答位                            (应答信号0，非应答信号1，且应答信号是由从机发送的)

(注意：它都要接上上拉电阻，两根总线空闲时总是高电平。但是，如果总线上的任何一个设备的SDA突然变为低电平，则这整根SDA总线都变为低电平；同理，如果总线上的任何一个设备的SCL突然变为低电平，则这整根SCL总线都变为低电平)

（1）scl=0;//先将时钟线置为低电平，这样就可以通过数据线sda写数据

 //主机循环写一个字节的数据:
（2）单片机写一位数据到总线
（3）scl=1;将时钟总线scl拉为高电平，让器件读总线上传的这一个位
（4）scl=0;重新拉低时钟线，准备写下一个数据  
（5）循环8位数据都写完成 

（6）sda=1;一个字节的数据写完了之后，单片机sda先释放，只有这样子，等下才可以收到器件的应答信号

2）当此时从机繁忙时，它没有时间接收主机发送的数据，则它需要将SDA拉为高电平，即S设为非应答，这样主机就会产生一  个终止信号，以结束数据发送
3）当从机接收了部分的数据后，此时无法继续接收更多的数据时，从机可以通过对无法接收的第一个数据字节的SDA拉为高  电平，即S设为非应答，这样主机就会产生一个终止信号，以结束数据发送
4）主机通过总线,从从机发送的数据中读一个字节数据：主机接收的一帧数据有9位，且接收时是先收高位字节，再收低位字                节：D[7]...D[0] S应答位(应答信号0，非应答信号1，且应答信号是由主机发送的)；如果主机接收完最后                 一个数据字节后->向从机发送一个非应答信号->从机释放SDA线->主机产生终止信号，结束接收

(注意：它都要接上上拉电阻，两根总线空闲时总是高电平。但是，如果总线上的任何一个设备的SDA突然变为低电平，则这整根SDA总线都变为低电平；同理，如果总线上的任何一个设备的SCL突然变为低电平，则这整根SCL总线都变为低电平)
（1）scl=0;//先将时钟线置为低电平
（2）sda=1;//释放数据线，这样器件就可以往数据线上写数据了

 //主机循环读一个字节的数据 
（2）scl=1;将时钟线置为高电平，单片机从sda里面读入一位数据
（3）scl=0;将时钟总线scl设为低电平，让器件再往总线上写下一个位 
（4）循环读8位数据都完成 

4、IIC总线传送流程：IIC总线上传送的数据,包括地址信号，与数据信号

1）主机写数据：
（1）步骤一、主机发送地址位（格式是起始信号+7位从机地址+数据传送方向位0，代表写数据），发送完了之后，释放SDA。

①主机发送：起始信号+7位从机地址+数据传送方向位(0主机发送数据，1主机接收数据)。
  接着主机传送数据，如果传送完了之后，主机需要结束传送，则主机需要发送一个终止信号。但是，主机如果需要继续占    用总线，进行新的数据传送，则可以马上发出起始信号，对另一个从机进行寻址
②总线寻址：D7...D1从机地址+数据传送方向位
③主机发送地址位，每个从机都可以收到，然后各从机进行比较。如果有一个从机发现自己的地址相同后，则这个从机，     就通过"数据传送方向位"，将自己确认为接收器
④从机地址：4位固定位(1010)+3位可编程位，不同的器件有不同的固定位，如EEPROM为1010。因此可以接8个从机到IIC总线中。其中A2A1A0的地址有8个选择，可以让器件的这三个引脚通过接Vcc，或者接地来进行设置，因此焊接完了之后，这个器件的地址就不能再改变了

（2）步骤二、从机发现自己的地址相同后，在SDA线上产生一个应答信号

（3）步骤三、主机发送数据给从机。传送数据时，先要发送一个字节，表明需要存储到该存储区的首地址的位置，即告诉器件，这些数据待会要写到哪个单元里。在收到器件的应答后，就逐个发送数据字节，存储到那个地址上了，但每发送一个字节后都要等待应答。
注意，当存储了一个字节的数据到存储区后，存储区的地址指针会自动加1，因此不需要程序来添加地址。因此，在该芯片的
一次装载字节数范围内，只需要输入首地址，就可以不断地传送数据了

（4）数据传输完成后：主机应发送一个终止信号，以结束写操作。

（5）总体信号格式是
开始位 | 地址位（器件地址+0）|从机应答ACK| 写入首地址 |从机应答A| 写入数据|从机应答A|写入数据...|从机应答A|终止位


2）主机读数据：
（1）步骤一、主机发送器件地址位（格式是起始信号+7位从机地址+数据传送方向位0，代表写数据），发送完了之后，释放SDA。

①主机发送：起始信号+7位从机地址+数据传送方向位(0主机发送数据，1主机接收数据)。
  接着主机传送数据，如果传送完了之后，主机需要结束传送，则主机需要发送一个终止信号。但是，主机如果需要继续占    用总线，进行新的数据传送，则可以马上发出起始信号，对另一个从机进行寻址
②总线寻址：D7...D1从机地址+数据传送方向位
③主机发送地址位，每个从机都可以收到，然后各从机进行比较。如果有一个从机发现自己的地址相同后，则这个从机，     就通过"数据传送方向位"，将自己确认为接收器
④从机地址：4位固定位(1010)+3位可编程位，不同的器件有不同的固定位，如EEPROM为1010。因此可以接8个从机到IIC总线中。其中A2A1A0的地址有8个选择，可以让器件的这三个引脚通过接Vcc，或者接地来进行设置，因此焊接完了之后，这个器件的地址就不能再改变了

（2）步骤二、从机发现自己的地址相同后，在SDA线上产生一个应答信号

（3）步骤三、主机先要发送一个字节，表明需要读该存储区的数据的首地址的位置，即告诉器件，要从哪里开始读数据。

（4）步骤四、在收到器件的应答后->单片机会重复一次起始信号，并器件发送地址位和读写方向位（格式是起始信号+7位从     机地址+数据传送方向位1，代表读数据）

（5）步骤五、在收到器件的应答后，就逐个读出数据字节，且每读出一个字节后，单片机都要发出一个应答信号。

（6）当最后一个数据读完成后：主机应返回非应答信号，并发送一个终止信号，以结束写操作。

（7）总体信号格式是
开始位 | 地址位（器件地址+0）|从机应答ACK| 读出首地址 |从机应答A| 重发地址位（器件地址+1）|从机应答A|读出数据|主机应答A|读出数据...|主机应答A|...读出最后一个数据|主机非应答A|主机终止信号


5、51单片机模拟IIC总线：由于51单片机本身并不带有IIC总线，因此，当需要挂在IIC总线上与具有IIC接口的器件进行数据传送时，就需要模拟IIC总线
1）传送时序
起始信号：当CLK为高电平时，SDA由高电平(延时时间>4.7us)->低电平,需要保持>4us后，CLK才允许发生变化
SCL____|------------------|____ 
SDA------4.7us--|____4us__ 

终止信号：当CLK为高电平时，SDA由低电平(保持时间>4us)->高电平,需要保持>4.7us
SCL____|------------------
SDA_______4us_|----4.7us--

数据传送0：发送的低电平，当CLK为高电平时需要保持，并且至少持续4us
SCL_______|-------------|___________
SDA----|_______4us________|-----------
数据传送1：发送的高电平，当CLK为高电平时需要保持，并且至少持续4us
SCL_______|-------------|___________
SDA____|-------4us---------|________                                                       

2)信号模拟
（1）起始信号
void 12cstart(void)
{
  SDA=1;
  delay();
  SCL=1;
  delay();
  SDA=0;
  delay();
}     

6、例：将单片机这段时间的开机次数存储在EEPROM中，EEPROM是掉电数据不丢失的器件，EEPROM也挂在IIC总线上，
可以与单片机进行读写通讯
作用：单片机每次一启动，或者复位启动后，就从EEPROM中读取开机次数，将它加1，再保存到EEPROM中

#include <reg52.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

sbit scl=P2^0;
sbit sda=P2^1;

void start(void);//起始信号
void stop(void);//终止信号
void ack(void);//应答信号
void noack(void);//非应答信号
void iicwr_byte(uchar dat);//IIC写一个字节数据
uchar iicrd_byte(void);//IIC读一个字节数据
void init(void);//初始化总线
void write_byte(uchar add,uchar dat);//往里面写一个字节数据
uchar read_byte(uchar add);//读一个字节数据

//延时函数:在12MHZ的晶振频率下
void Delay()
{
  _nop_();_nop_();_nop_();_nop_();
  _nop_();_nop_();_nop_();_nop_();
}

void Delay1()
{
  uint a=30000;
  while(a--);
}

//**************************************************
//一、信号起始、终止、发送应答、发送非应答、接收应答
//**************************************************

//起始信号
void start(void)
{
  sda=1;
  Delay();
  scl=1;
  Delay();
  sda=0;
  Delay();  
}
//终止信号
void stop(void)
{
  sda=0;
  Delay(); 
  scl=1;
  Delay(); 
  sda=1;
  Delay(); 
}
//单片机，开始等待器件的应答信号
void ack(void)
{
  uchar i;
  scl=1;//单片机时钟线拉高
  Delay(); 
  //单片机，开始等待接收器件的应答信号,当应答信号是sda==1时,仍然进行
  //循环等待，只有当sda==0时,单片机才跳出循环，表明这个字节数据已经传送过去了
  //如果一直循环等待，没有收到应答信号，且i循环到了200之后，仍然也会跳出等待
  while((sda==1)&&(i<200))i++;
  
  scl=0;  
  Delay(); 
}

//单片机，发送应答信号
void Acksend()
{
        sda=0;
        Delay();
        scl=1;
        Delay();
        scl=0;
        Delay();
        sda=1;
        Delay();
}

//单片机，发送非应答信号
void noack(void)
{
  sda=1;
  Delay();
  scl=1;
  Delay();
  scl=0;
  Delay();
}

//********************************
//二、单片机与器件读写一个字节数据
//********************************

//IIC中，单片机写一个字节数据到器件中
void iicwr_byte(uchar dat)
{
  uchar i;
  scl=0;//先将时钟线置为低电平，这样就可以通过数据线sda写数据
  
  //主机循环写一个字节的数据
  for(i=0;i<8;i++)
  {
    //1、往sda里面写入一位数据
    //如果dat的高位与1作与操作，值为1时，说明这个高位是1
    if(dat&0x80)
	{
	  sda=1;//往数据总线上写1
	}
	else
	{
	  sda=0;//往数据总线上写0
	}
	dat<<=1;//移位操作
    Delay();

	//2、将时钟总线scl拉为高电平，让器件读总线上传的这一个位
	scl=1;
    Delay();

	//3、重新拉低时钟线，准备写下一个数据  
	scl=0;
    Delay();
  }

  //4、一个字节的数据写完了之后，单片机sda先释放，只有这样子，等下才可以
  //收到器件的应答信号
  sda=1;
  Delay();
}

//IIC中，单片机从器件发送的数据总线中读一个字节数据
uchar iicrd_byte(void)
{
  uchar i;
  uchar dat;
  scl=0;//先将时钟线置为低电平
  Delay();
  sda=1;//释放数据线，这样器件就可以往数据线上写数据了
  Delay();

  //主机循环读一个字节的数据
  for(i=0;i<8;i++)
  {
    //1、将时钟线置为高电平，单片机从sda里面读入一位数据
	scl=1;
	Delay();
	dat<<=1;
	if(sda)//如果数据线是高电平时
	{
	  dat++;
	}

	//2、将时钟总线scl设为低电平，让器件再往总线上写下一个位
	scl=0;
	Delay();
  }
  return dat;
}


//***********************************************************
//三、启动IIC，让单片机与器件进行通讯，读写一个字节数据的过程
//***********************************************************

//往里面写一个字节数据
void write_byte(uchar add,uchar dat)
{
  //******
  //写数据
  //******
  //初始化
  init();
  //1、起始信号
  start();
  //2、写一个器件地址，表明数据要发到该器件上
  iicwr_byte(0xa0);//1010固定地址 000器件的A0A1A2 0写操作
  //3、等从机应答ACK
  ack();
  //4、往器件写一个地址，表明需要存储到该存储区的首地址的位置，
  //即告诉器件，这些数据待会要写到哪个单元里。
  iicwr_byte(add);
  ack();
  //5、发送数据字节，存储到那个地址上
  iicwr_byte(dat);
  ack();
  //6、发送一个终止信号
  stop();
  Delay1();
}

//读一个字节数据
uchar read_byte(uchar add)
{
  uchar a;
  //******
  //读数据
  //******
  //初始化
  init();
  //1、起始信号
  start();
  //2、写一个器件地址，表明要从哪个器件上读数据
  iicwr_byte(0xa0);//1010固定地址 000器件的A0A1A2 0写操作
  //3、等从机应答ACK
  ack();
  //4、往器件写一个地址，表明需要读该存储区的数据的首地址的位置，
  //即告诉器件，要从哪里开始读数据。
  iicwr_byte(add);
  ack();
  //5、在收到器件的应答后->单片机会重复一次起始信号，并发送地址位和读写方向位
  start();
  iicwr_byte(0xa1);
  ack();
  //6、在收到器件的应答后，就逐个读出数据字节，且每读出一个字节后，
  //单片机都要发出一个应答信号
  //7、当最后一个数据读完成后：主机应返回非应答信号，并发送一个终止信号，以结束写操作
  a=iicrd_byte();
  noack();
  //8、发送一个终止信号
  stop();

  return a;
}


//步骤一、初始化总线
void init(void)
{
  sda=1;
  scl=1;
}
//主程序：单片机每次一启动，或者复位启动后，就从EEPROM中读取开机次数，将它加1，再保存到EEPROM中
void main()
{  
  uchar k;
  k=read_byte(7);
  k=k%10;//只显示个位数
  P0=smg_du[k];
  P2=smg_wei[0];
  k++;
  write_byte(7,k);
  while(1);
}

例：读取多个字节数据
#include<reg52.h>
#include<intrins.h>

#define uchar unsigned char
#define uint unsigned int
unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

sbit SCL=P3^7;
sbit SDA=P3^6;
bit flag;

uint idata ucSendBuffer[1]=0;
uint idata ucReceData;
uint idata ucReceiveBuffer;//从器件中读出的一个字节数据暂存区


//延时函数:在12MHZ的晶振频率下
void DELAY(void)
{
  uint i;
  for(i=100;i>0;i--)
  _nop_();
}

void DELAY1MS()
{
 uchar i;
 for(i=124;i>0;i--);  //延时124*8+10=1002us
}

//**************************************************
//一、信号起始、终止、发送应答、发送非应答、接收应答
//**************************************************

//⒊跏蓟总?
void init(void)
{
  SDA=1;
  SCL=1;
}

//起始信号
void I2C_Start()
{
  SDA=1;
  DELAY();
  SCL=1;
  DELAY();
  SDA=0;
  DELAY();  
}

//终止信号
void I2C_Stop()
{
  SDA=0;
  DELAY(); 
  SCL=1;
  DELAY(); 
  SDA=1;
  DELAY(); 
}

//单片机，发送应答信号
void Ack()
{
  SDA=0;
  DELAY(); 
  SCL=1;
  DELAY(); 
  SCL=0;
  SDA=1;
  DELAY(); 
}

//单片机，发送非应答信号
void NoAck()
{
  SDA=1;
  DELAY();
  SCL=1;
  DELAY();
  SCL=0;
  DELAY();
  SDA=0;
  DELAY();
}

//单片机，开始检测器件的应答信号, 
//有应答时flag为0，无应答时flag为1
bit Test_Ack()
{
  SCL=0;
  DELAY();
  SDA=1;
  DELAY();
  SCL=1;
  DELAY();  
  if(SDA==0)
    flag=1;
  else
    flag=0;
  SCL=0;
  DELAY();
  return flag;
}

//********************************
//二、单片机与器件读写一个字节数据
//********************************

//IIC中，单片机写一个字节数据到器件中
void SendData(uint buffer)
{
  uchar i;
  SCL=0;
  DELAY();

  while(i<8)
  {
    i++;
	if(buffer&0x80)
	  SDA=1;
	else
	  SDA=0;
    buffer<<=1;

	SCL=1;
	DELAY();
	SCL=0;
	DELAY();
  }

  SDA=1;
  DELAY();  
}

//IIC中，单片机从器件发送的数据总线中读一个字节数据
uint ReceiveData()
{
  uchar i,dat;
  SCL=0;
  DELAY();
  SDA=1;
  DELAY();
  SCL=1;

  while(i<8)
  {
    SCL=1;
	DELAY();
	dat<<=1;
	if(SDA)
	  dat++;
    SCL=0;
	DELAY();
  }
  return dat;
}

//***********************************************************
//三、启动IIC，让单片机与器件进行通讯，读写多个字节数据的过程
//***********************************************************

//往里面写多个字节数据
//说明：sla-器件地址, suba-数据高8位地址,subab-数据低8位地址，
//*s-写入的数据，n-写入的字节数(n<=32)
bit WriteNByte(uint sla,uint suba,uint subab,uint *s,uint n)
{
  uint i;
  init();
  I2C_Start();
  SendData(sla);
  Test_Ack();
  if(flag==0)
     return 0;
  SendData(suba);
  Test_Ack();
  if(flag==0)
     return 0;
  SendData(subab);
  Test_Ack();
  if(flag==0)
     return 0;

  for(i=0;i<n;i++)
  {
    SendData(*(s+i));
	Test_Ack();
	if(flag==0)
     return 0;
  }
  I2C_Stop();
  DELAY1MS();
  return 1;
}

//读多个字节数据
bit ReadNByte(uint sla,uint suba,uint subab,uint *p,uint n)
{
  uint i;
  init();
  I2C_Start();
  SendData(sla);
  Test_Ack();
  if(flag==0)
     return 0;
  SendData(suba);
  Test_Ack();
  if(flag==0)
     return 0;
  SendData(subab);
  Test_Ack();
  if(flag==0)
     return 0;

  I2C_Start();
  SendData(sla+1);
  Test_Ack();
  if(flag==0)
     return 0;
  
  //从第一个字节数据，接收到最后第二个字节数据	  
  for(i=0;i<n-1;i++)
  {
    *(p+i)=ReceiveData();
	Ack();
  }

  //接收最后一个字节数据
  *(p+i)=ReceiveData();
  NoAck();

  I2C_Stop();
  return 1;
}

void main()
{
  ReadNByte(0xa0,0x00,0xff,ucSendBuffer,1);
  ucSendBuffer[0]++;

  WriteNByte(0xa0,0x00,0xff,ucSendBuffer,1);

  while(1)
  {
    P2=smg_wei[0];
	P0=smg_du[ucSendBuffer[0]%1000/100];//百位
	DELAY1MS();

	P2=smg_wei[1];
	P0=smg_du[ucSendBuffer[0]%100/10];//百位
	DELAY1MS();

	P2=smg_wei[2];
	P0=smg_du[ucSendBuffer[0]%10];//百位
	DELAY1MS();
  }
}

//**************************************************
//工程时通常芯片数据读写方式，以及实时时钟芯片DS1302
//**************************************************
实时时钟芯片DS1302：即显示日历的芯片，可自动进行闰年补偿等，而这些如果单纯使用定时器，则年月日等都需要计算，非常麻烦；芯片有一个备份电源，当主电源掉电后，备份电源继续工作

1）传送方式：它采用串行传输方式，SCLK是始终引脚，I/O是数据输入输出引脚

(1)命令字节：在传输数据前，需要先传一个命令字节，它的格式如下，它的传送方式是D0..D7
         1  RAM/CK                                          A4..A0                 RD/W
        D7   D6：判断是对时钟操作，还是对内部的RAM进行操作  D5..D1:选择内部寄存器  D0：判断输入，还是输出
   RD/W：0写，1读

(2)数据输入，RST先拉高，要先传一个命令字节，上升沿有效；再传一个数据字节，下降沿有效。都是当scl低电平时，写
   数据；scl高电平时，保持数据
  RST__|------------------------------------------
 SCLK   上升沿有效                  下降沿有效
 I/O    RD/W A0 A1 A2 A3 A4 R/C 1, 数据D0..D7

(3)数据输出，RST先拉高，要先传一个命令字节，上升沿有效；再传一个数据字节，上升沿有效。是当scl低电平时，读
   数据；scl高电平时，不用去管
  RST__|------------------------------------------
 SCLK   上升沿有效                  上升沿有效
 I/O    RD/W A0 A1 A2 A3 A4 R/C 1, 数据D0..D7

 (5)突发模式：RST保持高位，SCLK周期可以一直发送，然后可以一直发送多个字节的I/O数据。这个模式用于进行时钟
初始化对时，把时分秒，年月日等一次性传过去给芯片

（6）内部寄存器A0 A1 A2 A3 A4 ：大体的可以查看datasheet
    WP(write protect bit)写保护位：在控制寄存器control register那里，0-6位置0，第七位0时才可以对任何一个寄存器进行写操作，为1时就不能对里面的任何一个寄存器进行写操作了。当芯片一上电时，这个位是不确定的，因此必须先对这个进行手动清0

例
#include <reg52.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

uchar time_data[7]={10,6,5,17,11,58,30};//存放顺序，年周月日时分秒，这是根据芯片datasheet得来的
//表明写年周月日时分秒，在寄存器地址中的相应位置以及控制码，这是根据芯片datasheet得来的
uchar write_add[7]={0x8c,0x8a,0x88,0x86,0x84,0x82,0x80};
//表明读年周月日时分秒，在寄存器地址中的相应位置以及控制码，这是根据芯片datasheet得来的
uchar read_add[7]={0x8d,0x8b,0x89,0x87,0x85,0x83,0x81};
uchar disp[8];

sbit sck=P1^0;
sbit io=P1^1;
sbit rst=P3^6;

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

//如果要延时50ms毫秒
void Delay_50ms(uint t)
{
  uint j;
  for(;t>0;t--)
    for(j=6245;j>0;j--);
}

//****************************
//一、单片机读写单字节芯片数据
//****************************
//单片机往芯片写单字节写数据
void write_ds1302_byte(uchar dat)
{
   uchar i;
   for(i=0;i<8;i++)
   {
     sck=0;//时钟线拉低，让单片机往芯片写一位数据
	 io=dat&0x01;
	 dat>>=1;
	 sck=1;//时钟线拉高，让芯片读取这一位数据
   }
}

//单片机从芯片读单字节写数据
uchar read_ds1302_byte()
{
  uchar i,value;
  //读数据
  for(i=0;i<8;i++)
  {
    sck=0;//时钟线拉低，让单片机从芯片读一位数据
	value>>=1;
	if(io)
	  value|=0x80;
    sck=1;//时钟线拉高，让芯片再往单片机写一个数据
  }
  return value;
}


//********************************************
//二、单片机初始化，并往芯片读写一个字节写数据
//********************************************
//单片机往芯片写数据
void write_ds1302(uchar add,uchar dat)
{
  //初始化
  rst=0;
  _nop_();
  sck=0;
  _nop_();
  rst=1;
  _nop_();

  write_ds1302_byte(add);//写地址
  //因为写指令之后，就会马上在下一周期写数据，因此中间没有间隔
  write_ds1302_byte(dat);//写数据
  rst=0;
  _nop_();
  io=1;
  sck=1;
}

//单片机从芯片读单字节数据
uchar read_ds1302(uchar add)
{
  uchar value;
  //初始化
  rst=0;
  _nop_();
  sck=0;
  _nop_();
  rst=1;
  _nop_();

  write_ds1302_byte(add);//写地址
  
  value=read_ds1302_byte();//读数据

  rst=0;
  _nop_();
  sck=0;
  _nop_();
  io=1;
  sck=1;

  return value;
}

//**********************************************
//三、将时钟的年月日等数据一次性读完，或者设置完
//**********************************************
//一次性写全部时钟信息到芯片中
void set_rtc()
{
  uchar i,j;
  //步骤一、去除写保护
  //地址:由于是写数据，因此RD/W：0，因此是1000 1110
  //数据:WP000 0000,关闭写保护WP，因此是0000 0000
  write_ds1302(0x8e,0x00);
  //步骤二、日常的时间日期都是十进制，要存到芯片中，就要将他转为BCD码，即每一位数字
  //都转成十六进制，例56，将5，和6分别转成十六进制，即0101 0110=0x56,即十进制的86
  for(i=0;i<7;i++)
  {
    j=time_data[i]/10;
	time_data[i]=time_data[i]%10;
	time_data[i]=j*16+time_data[i];
  }

  //步骤三、将时钟日期的信息一次性全写到芯片中
  for(i=0;i<7;i++)
  {
    write_ds1302(write_add[i],time_data[i]);
  }
  write_ds1302(0x8e,0x80);//添加写保护
}

//一次性读出全部时钟信息
void read_rtc()
{
  uchar i;
  //步骤一、将芯片中的所有时钟日期的信息读出来
  for(i=0;i<7;i++)
  {
    time_data[i]=read_ds1302(read_add[i]);
  }
  //步骤二、将这些时间日期由BCD码转为十进制
  disp[0]=time_data[6]%16;//秒
  disp[1]=time_data[6]/16;
  disp[2]=16;
  disp[3]=time_data[5]/16;//分
  disp[4]=time_data[5]%16;
  disp[5]=16;
  disp[6]=time_data[4]/16;//分
  disp[7]=time_data[4]%16;
  
}

//显示
void display()
{
  uchar i;
  for(i=0;i<8;i++)
  {
    P0=smg_du[disp[i]];
    P2=smg_wei[i];
    Delay_50us(2);
  }
}

void
main()
{
  set_rtc();
  while(1)
  {
    read_rtc();
	display();
  }
}

//*********************************************
//单总线协议数据读写，以及数字温度传感器DS18B20
//*********************************************
1、单总线：数据线只有一根线，即在的总线上，即要传输0，又要传输1

2、DS18B20：每一个芯片都有一个唯一的ROM序列号，因此可以将多个芯片，同时都连接在一根单总线上。它有两个存储单元
TH和TL，分别可以往里面写两个温度数值，这样，当实际温度>TH，或者<TL时，芯片就会报警。它的供电可以使用外部电源；也可以直接就从单总线上进行供电，这样当信号处于高电平时就存储能量，信号处于低电平时，就使用这个能量
1）操作：要对芯片进行操作，它就要对两个地方分别进行操作
（1）ROM操作命令：必须先建立ROM操作协议，然后，才能进行存储器和控制操作
读出ROM：代码0x33，读出这个芯片的序列号
选中ROM：代码0x55,选中这个芯片，以待等下操作
搜索ROM：代码0xf0,搜索总线上的节点数，以及所有节点的序列号
操作所有ROM：代码0xcc,对总线上的所有该种芯片进行操作
报警搜索：代码0xec,定位系统中超出警戒温度的芯片

(2)存储器操作命令
温度转换：代码0x44,发送指令过去后，就可以启动芯片，进行温度测量了。温度测量需要一定的时间，如果它还没有测量完          ，这个时候单片机需要读温度数据，它将在总线上输出0；若他已经测量完了，则会输出1
读温度数据：代码0xbe,芯片内最大只有9个字节，因此最多只能读取9个字节的数据
设报警温度值：代码0x4e,设置TH和TL
保存报警温度值：代码0x48,将报警温度值TH和TL，复制到EERAM，以后这个数值掉电后，不丢失
重读报警温度值：代码0xb8,将EERAM的报警温度值重新读入到TH和TL中
读电源：代码0xb4,返回芯片的供电方式，0代表使用总线供电，1代表使用外部电源供电

2）温度表示方法：
（1）
          高位MSb                      低位LSb
高字节MSB     S   S   S   S   S  2(6) 2(5) 2(4)
低字节LSB   2(3)2(2)2(1)2(0)2(-1)2(-2)2(-3)2(-4)
正温度SSSSS：11111，负温度SSSSS:00000
2(0次方)，左边的是整数，右边的是小数。
（2）温度精度匹配寄存器
高位MSb                 低位LSb

  0     R1 R0   1  1  1  1  1 


R1R0：00精度9bit，转换时间最小；01精度10bit；10精度11bit；11精度12bit，转换时间最大

3）内部寄存器结构

第0个字节，实际所测温度的低位；第1个字节，实际所测温度的高位；第2个字节TH；第3个字节TL；第4个字节，匹配温度精度；
EERAM：可以存放TH，TL，匹配精度

4）时序图：它默认高电平，即1。它的读写顺序是D0-D7
（1）证明此总线上有挂接该芯片：
    主机，把总线拉低480us到960us的时间之间  主机，放开总线，等待15us至60us的时间  芯片，会自动再把它拉低60us
---|______________________________________|-------------------------------------|______________________
至240us

此时，可以在这里进行采样，如果有发现芯片有将总线进行拉低，则说明该总线上有挂接这个芯片
（2）写数据

   主机，拉低60us至120us，芯片会在总线的15us至60us的时间进行采样，如果是0，则说明主机对芯片写0
--|_____________________________________________________________________________|--
   主机，拉低略微大于1us时间且小于15us，然后放开。芯片会在总线的15us至60us的时间进行采样，如果是1，则说明主机对芯片写1
--|_________|----------------------------

即主机将总线拉低之后，就会通知芯片准备进行采样了，芯片在15us至60us的时间段之内，进行数据采样，如果采到是0，就是主机往芯片写0了；如果采到是1，就是主机往芯片写1了
（3）读数据
主机拉低总线，延时一下之后，主机再释放总线；然后在1us<时间段<15us,的时间段之内，主机进行读总线，即进行采样。如果有此时总线是0，则读0；如果此时总线是1，则读1

（4）总结：主机将总线拉低之后，进行通信。在0us至15us的时间之内，芯片会往总线上发个数据，给主机读。然后，芯片
在15us至60us的时间之内，就进行采样数据

例
#include <reg52.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int

unsigned char smg_du[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};

unsigned char smg_wei[]={0xfe,0xfd,0xfb,0xf7};//数码管的位选

sbit DQ=P2^2;
uchar temp;

//延时函数:在12MHZ的晶振频率下，如果要延时50us
void Delay_50us(uint t)
{
  uchar j;
  for(;t>0;t--)
    for(j=19;j>0;j--); 
}

void delay(uint t)
{
  while(t--);
}

//步骤一、初始化芯片
void init_ds18b20()
{
  uchar n;
  DQ=1;
  delay(8);
  DQ=0;
  Delay_50us(15);
  DQ=1;
  delay(8);
  n=DQ;
  delay(4);
}

//****************
//读写一个字节数据
//****************
//主机写一个字节数据到总线上，让芯片读取
void write_byte(uchar dat)
{
  uchar i;
  for(i=0;i<8;i++)
  {
    DQ=0;
	DQ=dat&0x01;
	delay(4);
	DQ=1;//拉高后，即释放总线，准备写下一个数据
	dat>>=1;
  }
  delay(4);
}

//主机从总线上，读取芯片发出的一个字节的数据
uchar read_byte()
{
  uchar i,value;
  for(i=0;i<8;i++)
  {
    DQ=0;
	value>>=1;
	DQ=1;
	if(DQ)
	  value|=0x80;
	delay(4);	
  }
  return value;
}

//**************************
//读取温度数据，设置温度数据
//**************************
//主机从总线上，读取温度数据
uchar readtemperature()
{
  uchar a,b;
  init_ds18b20();
  //1、对ROM进行操作，由于我们只接了一个芯片，因此选择操作所有ROM指令
  write_byte(0xcc);
  //2、启动温度测量
  write_byte(0x44);
  Delay_50us(10);

  init_ds18b20();
  write_byte(0xcc);
  //3、设置，现在要读取温度
  write_byte(0xbe);
  //4、开始读取温度数据
  a=read_byte();//读取第0个字节的数据，从内部寄存器结构中可知，是所测的低位温度数据
  b=read_byte();//读取第1个字节的数据，从内部寄存器结构中可知，是所测的高位温度数据

  //5、将所得的两个字节数据拼接起来，并且舍去小数数据，再转为实际温度数据
  b<<=4;
  b+=(a&0xf0)>>4;
  
  return b;//b即是原先a与b拼接起来的，2(6)到2(0)的数据
}

void display()
{   
  P0=smg_du[temp%10];
  P2=smg_wei[0];
  Delay_50us(20);
  P0=smg_du[temp/10];
  P2=smg_wei[1];
  Delay_50us(20);
}

void main()
{
  while(1)
  {
    temp=readtemperature();
	display();
  }
}

//************
//得到调试信息
//************
1、需要得到跟踪信息的，使用Trace( "\n CheckHardWare i= %bu", i );
2、//#undef _DEBUG_TRACE注释掉
3、CX51:define:#define _DEBUG_TRACE
4、在串口通讯中，波特率使用38400，None,8,1

看到 从零开始109，手把手269


//=========
//==ARM体系
//=========
//*******
//ARM基础
//*******
1、处理器工作状态：ARM状态，它执行32位ARM指令；Thumb状态，它是基于16位的指令，它可以使用更小的代码实现相同
的功能
2、多处理器状态模式：它定义了7种处理器模式，这是为了实现它的权限控制。它是用户，快中断，中断，管理，终止，
未定义，系统模式
3、它嵌入了在线仿真调试模块功能，就可以通过JTAG来进行仿真调试
4、开发ARM的工具：ADS需要进行灵活的配置，以及需要对ARM的汇编指令比较清楚。IAR原先是开发AVR单片机的，也比较适合开发ARM
的。
IAR的优点：
1）它的配置比较简单
2）它不需要自己编写ARM的启动代码。ARM的启动代码是当ARM启动时，用来初始化ARM的外围硬件接口，以及堆栈的一些配置  ，它使用ARM的汇编来编写。
3）它使用C语言编写运用程序
4）它可以使用H-JTAG来直接在FLASH中进行程序调试，而不用占用宝贵的RAM资源。而是用ADS，H-JTAG就必须在RAM中进行调   试。如果RAM就几K时，调试代码就很小了
5、调试工具
1）H-JTAG它使用电脑的并口进行调试，并且只能通过IAR软件，在FLASH中进行调试仿真
2）J-LINK它使用电脑的USB或网络端口进行调试，可以通过ADS，或IAR，在FLASH中进行调试仿真

//************
//系统开发基础
//************
1、系统构架
应用程序
API应用程序接口
OS核，包括必备的电源管理，文件管理，GUI管理；可扩展的TCP/IP,WAP,HTTP,浏览器，数据库
设备驱动接口
CPU，扩展设备

2、开发板结构
CPU处理器，SDRAM内存

FLASH存储：又称闪存
Nand Flash掉电非易失：闪存的容量较大，速度较慢，典型应用例子是U盘，启动时，需要先将程序传到SDRAM中，再启动
Nor Flash掉电非易失：闪存的容量较小，速度较快，且用户可以直接运行这里面的代码，类似于SDRAM。因此开发板上存储
          启动代码,可以直接启动

RTC备份电池：RTC是当主系统掉电时，使用的备份电池。

USB接口：有两个USB Host，USB Slave。USB Host主要用于连接U盘，传输资料。USB Slave通过USB延长线，连接到PC，用于        使用USB下载功能

串口：PC通过它，和开发板直接进行交互操作，数据传输，调试操作等

网口：在uboot的下载模式下面，可以使用TFTP下载数据到开发板

JTAG接口：功能一是当Nand Flash或Nor Flash中没有uboot时，使用它烧写uboot进去；功能二是进行仿真调试

LCD触摸屏


3、开发ARM一般使用的流程
1)安装ubuntu，用于编译内核使用
2)安装Source Insight用于编译原代码；SecureCRT即超级终端，用于串口通讯，远程登录，与数据下载到开发板上控制；
cuteftp用于将编辑好的程序文件传送到linux上去；
在windows上安装tftpboot程序：一个tftp服务器程序，这样开发板的uboot程序上执行tftp命令后，就能从主机上通过网络
        下载程序到开发板上
3）软件开发流程
(1)开发Windows桌面程序步骤如下
使用VC++，编译，链接，生成执行文件都在这里
(2)开发Linux桌面程序步骤如下
①使用Source Insight编写程序，hello.c,a.c文件
②将这两个文件，通过CuteFtp传到Linux上
③通过gcc编译：gcc -o hello.exe hello.c a.c，用gdb调试，或者直接使用Makefile
④./hello.exe进行执行
(3)开发Windows下的嵌入式程序
①使用ads编辑代码
②使用ads指定链接地址(或加载一个链接脚本文件)，指定链接顺序(具体方法下面有说)，然后进行编辑
③下载到开发板上执行
(4)开发Linux下的嵌入式程序
①编写程序，然后上传到Linux
②使用一个链接脚本
例：leds.lds
SECTIONS
{
.=0x00;从0地址开始按顺序排放
.text :{*.(.text)}代码段
.rodata ALIGN(4) :{*.(.rodata)}只读数据段
.data ALIGN(4) :{*.(.data)}数据段
.bss ALIGN(4) :{*.(.bss) *(COMMON)}
}

③使用一个Makefile，它包括：指定链接脚本，用命令行链接文件顺序。指定初始启动地址。将生成的执行文件转换
成二进制的bin文件。
使用命令行进行编译；然后执行Make命令一次性完成
单独的链接脚本如下所示
然后使用Makefile来指定链接顺序，其中包含前面这一个的链接脚本的调用
arm-linux-ld -Tleds.lds crt0.o leds.o -o leds_elf
Tleds.lds是表示加上前面的链接脚本
后面几个文件，说明链接顺序是链接crt0.o的代码段，然后是leds.o的代码段，然后是crt0.o的只读数据段，然后是leds.o
的只读数据段，然后是crt0.o的数据段，然后是leds.o的数据段，然后是...bbs,COMMON这样子依次排下来

例：
led_on.bin:leds.s
arm-linux-gcc -g -c -o led_on.o led_on.s   将文件编译成led_on.o文件
arm-linux-ld  -Ttext 0x0000000 -g led_on.o -o led_on_elf  链接，并指定开始执行地址
arm-linux-objcopy -o binary -s led_on_elf led_on.bin将文件转成bin文件，只有这个二进制文件下载到开发板上才有用


注意：gcc是在主机上进行程序编译，而arm-linux-gcc 是编译出arm开发板的程序

③将bin文件下载到开发板上执行


4、交叉编译
1)1、安装交叉编译工具
交叉编译工具包是arm-linux-gcc-3.4.5-glibc-2.3.6.tar.bz2

(1)、改变文件夹属性sudo chown 777 work
(2)、安装交叉编译工具链
cd /work/tools
tar xjf arm-linux-gcc-3.4.5-glibc-2.3.6.tar.bz2
在环境变量PATH中添加路径,使得可以直接运行目录下的这个程序，而无需指定位置
export PATH=$PATH:/home/user/arm/gcc-3.4.5-glibc-2.3.6/bin

为了不要每次使用时都收工设置环境变量，在/etc/environment文件中修改PATH的值
PATH="...:/home/user/arm/gcc-3.4.5-glibc-2.3.6/bin"

(3)、安装ncurses,ncurses是一个提供快捷键，屏幕绘制，以及基于文本终端的图形功能的动态库，
如果没有安装这个库，则在执行"make menuconfig"命令配置程序时，就会出错
cd /work/tools/
tar xzf ncurses.tar.gz
cd ncurses-5.6
./configure --with-shared --prefix=/usr
make
make install

2)、在我们使用交叉编译工具时，有时需要使用一些高级参数(这些参数在普通gcc中也有，但是不常用)
(1)添加链接器的选项-library
(2)不链接系统标准启动文件，在编译bootloader，内核时，将用到
  gcc -nostartfiles -o test main.c
(3)不链接系统标准启动文件和标准库文件，在编译bootloader，内核时，将用到
 gcc -nostdlib-o test main.c
(4)不链接共享库gcc -o test main.o -static


3)、arm-linux-ld
指定代码段，数据段，bss段得起始地址，以及直接指定一个链接脚本，在链接脚本上进行更复杂的
地址设置
(1)
格式如下
-Ttext startaddr(起始地址，是一个十六进制数)代码段
-Tdata startaddr(起始地址，是一个十六进制数)数据段
-Tbss  startaddr(起始地址，是一个十六进制数)bss段

例：
arm-linux-ld -Text 0x0000000 -g led_on.o -o led_on_elf 它表示代码段的起始地址0x0000000，
由于没有指定数据段，bss的起始地址，他们被按顺序放到代码段的后面

(2)
使用链接脚本
使用链接脚本test.lds来设置可执行文件test的地址信息
arm-linux-ld -test.lds -o test mian.o

链接脚本test.lds如下所示
SECTIONS
{
  .=0x30000000;表示当前运行地址
  .text      :{*(.text)}定义了一个名为.text的段，它的内容为*(.text),表示所有输入文件的
代码段，这些代码段的起始运行地址为0x30000000
  .rodata ALIGN(4): {*(.rodata)}它的存放位置紧挨着.text,ALIGN(4)表示它的运行地址为4字节
对齐，虽然start指定了运行地址，但是仍然可以用这个来指定对齐的要求，这个对齐的地址才是真正
的运行地址
  .data ALIGN(4): {*(.data)}
  .bss ALIGN(4): {*(.bss) *(COMMON)}
  
}


查看执行文件信息，看是被那种编译器编译的
file hello
hello:ELF 32-bit LSB executable, ARM(或Inter 80386)...not stripped


4)、arm-linux-objcopy将ELF格式的可执行文件转换为二进制文件,然后烧写到开发板中
参数
input-file,outfile 表示输入目标文件和输出文件
-I bfdname源文件的格式
-O bfdname使用指定的格式来输出文件
-F bfdname同时指定源文件，和目标文件的格式，即不做格式转换
-R sectionname从输出文件中删掉所有名为sectionname的段
-g 不复制调试符号到目标文件中
-s 不复制重定位信息和符号到目标文件中去
在编译bootloader,内核时，常用这个命令将ELF格式的生成结果转换为二进制文件
例：arm-linux-objcopy -O binary -S elf_file bin_file

5)、arm-linux-objdump显示二进制文件信息，用于查看反汇编代码
-d 将可执行段反汇编
-D 将所有段反汇编
在调试程序时，用来得到汇编代码
例：将ELF格式的文件转换为反汇编文件
arm-linux-objdump -D elf_file>dis_file
将二进制文件转换为反汇编文件
arm-linux-objdump -D -b binary -m arm_file>dis_file输出到文件dis_file中
arm-linux-objdump -D -S hello

6)ELF文件查看工具:arm-linux-readelf
我们编译出来的下载程序都是ELF格式的，用这个工具查看他们的信息
(1)
arm-linux-readelf -a hello查看hello的全部信息
注意这几个点：
程序的大小端，必须与板子的大小端是一样的
程序的版本必须是ARM的，同样用file hello也可以知道

(2)动态链接库：
一般的程序只用到c库，而且c库不用特别写，它就默认给使用的。但是，一些特殊的程序需要用到
特殊的库，比如线程程序会用到线程库。
它的编译arm-linux-gcc -lpthread -o hello hello.c，
这时通过arm-linux-readelf -d hello，看到NEEDED提示里面需要使用到线程库libpthread.so.0

如果我们的应用程序需要的库就几个，就可以用静态链接，如果需要的库很多，就使用动态链接


arm-linux-readelf -d hello查看hello的使用的动态库

例如，如果hello程序它是动态链接的，它所依赖的动态链接库没有找到，则会提示./hello:not found,这里不是指这个执行程序没有找到
动态链接库在Linux的lib目录下
通过arm-linux-readelf -d hello，看到NEEDED这里面提示需要库libc.so.6
解决方法：
方法一：使用静态链接
arm-linux-gcc -static -o hello hello.c
方法二：把宿主机的/lib/中的动态链接库拷一起移植到ARM平台的linux中，并且要保证目录(即到嵌入设备的lib中去)


(3)静态链接库与动态链接库的区别与使用
动态库而言：某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存
里是否已有此库函数的拷贝了。如果有，则让其共享那一个拷贝;只有没有才链接载入。
在程序运行的时候，被调用的动态链接库函数被安置在内存的某个地方，所有调用它的程序将指向这个代码段。因此，
这些代码必须使用相对地址，而不是绝对地址。
在编译的时候，我们需要告诉编译器，这些对象文件是用来做动态链接库的，所以要用地址不无关
代码(PIC)。
注意：linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，
将与动态库相连接。
①创建：无论静态库，还是动态库，都是由.o文件创建的
静态库：
gcc Cc file1.c file2.c  //生成file1.o file2.o
ar -rc libxxx.a file1.o file2.o 
//生成静态库文件libxxx.a 静态链接库的命名方式一般为：lib+链接库文件名+.a。否则编译器就无法找到库
解释：其中ar命令是生成、更新静态库的一个命令。

动态库：
gcc -fPIC -c file1.c //生成file1.o 
gcc -fPIC -c file2.c //生成file2.o
gcc -shared libxxx.so file1.o file2.o//生成动态库文件libxxx.so 一定要以so为后缀名。否则编译器就无法找到库
②有两种方法使用动态链接库。
方法一：
将静态库copy到/usr/lib/,或/lib/目录下
cp libmulib.a /usr/lib/
gcc -o test test.c libtest.so
这时要保证这个库所在目录包括再PATH 环境变量中
方法二：
gcc -o main main.c ./libtest.so

③静态库和动态库的使用
两者的使用相同：
情况一
gcc Co main main.o libxxx.a(libxxx.so)
情况二
gcc testsum.c -I /home/sunny/DS/lib libsum.a -o testsum 
./testsum 15 
其中，-I /home/sunny/DS/lib libsum.a表示 “-I “include进来的库所在目录
情况三
gcc file1.o file2.o -Lpath -lxxx -o program.exe
编译器会先在path文件夹下找libxxx.so文件，如果没有找到，继续找libxxx.a静态库

③
-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。
-Lpath：表示在path目录中搜索库文件，如-L.则表示在当前目录。
-Ipaht：表示在path目录中搜索头文件。
-ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加lib，后面加上.so来确定库的名称
LD_LIBRARY_PATH：这个环境变量指示动态连接器可以装载动态库的路径。

④搜索库的路径问题：
　　动态库的搜索路径搜索的先后顺序是：
　　1.编译目标代码时指定的动态库搜索路径;
　　2.环境变量LD_LIBRARY_PATH指定的动态库搜索路径;
　　3.配置文件/etc/ld.so.conf中指定的动态库搜索路径;//只需在在该文件中追加一行库所在的完整路径如"/root/test/conf/lib"即可,
      然后ldconfig是修改生效。
　　4.默认的动态库搜索路径/lib;
　　5.默认的动态库搜索路径/usr/lib。

⑤ “-I “include进来了，库所在目录通过 “-L”参数引导，并指定了”-l”的库名，但通过ldd命令察看时，就是死活找
不到你指定链接的so文件，这时你要作的就是通过修改 LD_LIBRARY_PATH或者/etc/ld.so.conf文件来指定动态库的目录。
通常这样做就可以解决库无法链接的问题了。特别注意在使用交叉编译器编译了一个程序后，当移植到ARM平台运行时，
由于往往采用的是动态链接库，在ARM平台发现报错，说找不到文件，其实是因为程序所依赖的动态库函数在ARM平台
的linux下没有，往往解决的办法有两个：
    1.在PC机，编译时才有静态编译，即加-static
    2.将相应的动态库文件同程序一起移植到ARM平台的linux中，并且要保证目录

⑥arm板的静态库的创建
arm-linux-ar -r libello.a h1.o h2.o


5、连接方式：
1）宿主机编译后，通过并口，串口，网络或JTAG口，连接到开发板上，进行运行
2）台式电脑连接到JTAG仿真器：台式电脑通过并口连接到JTAG仿真器（进行在线编程和烧写），再通过数据线连接到开发板   上。
   JTAG仿真器使用的软件：H-JTAG

3）笔记本通过USB口，连接一个叫作JLink的JTAG仿真器，再通过数据线连接到开发板上
   JTAG仿真器使用的软件：J-Flash
   基于USB的下载工具:dnw.exe

6、安装SecureCRT(类似于windows的超级终端)
   1)连接上USB转串口接头，驱动程序：G:\PL2303HX\windows 7_ vista_32_64，需要打开进行手动安装，本次这个串口
     分配为COM6
   2）解压SecureCRT，打开SecureCRT.exe,->Quick Connect连接配置->Protocol:选Serial，-           >Port:COM6,Baud:115200,Data:8,Parity:None,Stop bit:1,取消RTS/CTS勾选，确认(串口号由计算机管理上看)
   3）将串口连接到开发板上，打开开发板，如果有连接上，则会出现菜单页面。如果没有菜单页面，则有可能是串口
通讯没有连接上，或者开发板没有安装uboot(即Bootloader)

7、安装JTAG
1)
H-JTAG:
(1）
   安装H-JTAG->运行H-JTAG，->打开Setting/Jtag Setting->User Defined,TMS:Pin4,TCK:Pin2,TDI:Pin3,TDO:Pin11,
   nTRST:NO,nSRST:NO
   ->连接好目标板后，启动目标板，点击Reset target->Detect target,连接好后，它会自检到CPU
(2）
   ->点击启动H-Flasher,->Load载入配置单：接下来可以烧写uboot进开发板中
   打开J-Flash软件，或H-JTAG软件，通过Jtag下载SuperVivi到nor flash->打开超级终端，会显示一个安装系统的列表
   ->安装USB下载驱动程序->安装基于USB下载数据的软件dnw.exe
2)
J-Flash:
(1）
   安装Setup_JLinkARM_V408i->打开SEGGER/J-Link/J_Flash ARM
   ->电脑USB口通过USB线，连接到J-Link，另一头连接到转接板，由转接板通过另一条线，连接到开发板JTAG口上
   ->F:\TQ2440配套光盘\TQ2440_CD\Windows平台开发工具包\Jlink资源\Flash.csv软件拷贝覆盖到
     C:\Program Files\SEGGER\JLinkARM_V408l\ETC\JFlash中，建议备份原先的文件 
   ->File/Open Project:F:\TQ2440配套光盘\TQ2440_CD\Windows平台开发工具包\Jlink资源\TQ2440.jflash
   ->Options/Project Setting->Flash选项页->Select flash device->选择Eon公司的EN29LV160AB
   ->如果还没有设置的，需要设置一下Options/Project Setting->CPU选项页->打勾Use target RAM:40000000,4KB
   ->Target/Connect:连接成功，出现Connected successfully字符串
(2）
   加载uboot(即Bootloader)（作用类似于Linux的LILO，或GRUB,BIOS）:File->Open:选择相应LCD屏的uboot，例如   F:\TQ2440配   套光盘\TQ2440_CD\出厂烧录镜像合集\   天嵌3.5寸屏的镜像\U-boot->地址默认为0不变，直接点击OK即   可
   ->Target->Program进行烧写

8、Linux系统安装
打开超级终端或者SecureCRT，
1)安装DNW.exe软件，(在F:\TQ2440配套光盘\TQ2440_CD\Windows平台开发工具包中)，这个软件用于等下通过USB进行下载操作系统
  (1)以管理员身份打开DNW，->Configuration/Options->Baud:115200,COM:COM1,Addr:0x30000000这个是PC通过USB发送到开发板的
     SDRAM的地址(串口号是自己设定的，可以设为COM1)
2）因为本次是要通过USB进行烧写系统，开发板连上串口线和电源线->打开超级终端或者SecureCRT，进入uboot控制台  
  ->接上USB连接线，系统会弹出找到新硬件向导->F:\TQ2440配套光盘\TQ2440_CD\Windows平台开发工具包\USB下载驱动
  ->安装好USB下载驱动
  ->打开DNW.exe,在标题栏上，可以看到COM:x,USB:OK字样。同时，在设备管理器上，可以看到2440 Board的USB转串口了
  ->此时，就可以使用USB下载uboot，操作系统，和文件系统了

3)格式化Nand Flash分区：在Nand Flash上进行格式化
  开发板连上串口线和电源线，确保处于Nor Flash模式下->打开超级终端或者SecureCRT，进入uboot控制台。打开DNW
  ->9->y->回车
4)烧写(uboot镜像)BootLoader
  ->1,显示USB host is connected.Waiting a download等待下载uboot镜像
  ->打开dnw软件->USB Port->Transmit->Transmit->F:\TQ2440配套光盘\TQ2440_CD\出厂烧录镜像合集\天嵌3.5寸屏的镜像    \U-boot\u-boot-1.1.6_Q35_20100601.bin
  ->超级终端，先从DNW获取镜像数据到内存中，uboot擦除Nand Flash的对应空间，共uboot烧写镜像用，uboot把内存中的
    镜像写入Nand Flash中

5)烧写Linux内核镜像
  ->3,等待烧写
  ->打开dnw软件->USB Port->Transmit->Transmit->F:\TQ2440配套光盘\TQ2440_CD\出厂烧录镜像合集\天嵌3.5寸屏的镜像    \Linux-2.6.30.4\zImage_Q35_2.6.30.4_20100531.bin
6)烧写Linux文件系统镜像
  ->6,等待烧写
  ->打开dnw软件->USB Port->Transmit->Transmit->F:\TQ2440配套光盘\TQ2440_CD\出厂烧录镜像合集\Linux文件系统镜像    \root_qtopia_2.2.0_2.6.30.4_256MB_20100601.bin


*设置Linux启动方式：ARM有两种文件系统yaffs，NFS。一般使用yaffs，NFS用于让ARM可以连接PC端的Linux系统的文件
 当作映射文件
  设置从yaffs启动：0->2

*无OS裸跑程序烧写
  ->a,等待烧写
  ->打开dnw软件->USB Port->Transmit->Transmit->F:\TQ2440配套光盘\TQ2440_CD\出厂烧录镜像合集\天嵌3.5寸屏的镜像    \TQ2440_Test\TQ2440_Test_Q35_20100607.bin
*ucosII烧写
  ->a,等待烧写
  ->打开dnw软件->USB Port->Transmit->Transmit->F:\TQ2440配套光盘\TQ2440_CD\出厂烧录镜像合集\天嵌3.5寸屏的镜像    \uCOS-II\uCOS2_Image_W35_20091031.bin

*QT程序：图形化应用程序的开发，一般用来绘制图形

9、使用NFS网络文件系统的Linux系统安装
NFS网络文件系统：主要用于开发调试时。如果是使用Flash的文件系统，这样根文件每修改一次，Flash就
          需要重新烧写一次，Flash容易坏。而使用NFS，他把网络上的另一台机器的文件当做自己的文件，
          这样在宿主机上建立一个根文件系统，开发板的Linux挂载该文件系统，这样任何更改都只需要在
          宿主机上更改，就不用频繁烧写Flash，然后重启开发板了  
1)服务器端安装tftp服务(注意，其它ftp服务，如vsftpd不行),要关闭Linux防火墙
  然后，修改服务器端的ip地址ifconfig eth0 192.168.4.7
        ifconfig 查看，注意ip地址要与实际pc机处于同一个网段
2)
进入uboot后，默认的下载模式是USB下载模式
  ->n  进入TFTP下载模式 
  ->5 配置IP地址等信息
Enter the TFTP Server IP address:输入FTP服务器地址，即pc端地址。本次因为FTP服务器是建立
在Linux上的，因此输入服务器的地址为

Enter the TQ2440 IP address:输入客户端地址，即板子上的IP地址 

输入掩码255.255.255.0
->y 保存刚才设置的参数

->p测试板子和PC服务器端是否通讯上
............
checksum bad
checksum bad
host xx.xx.xx.xx is alive说明通讯上了  

............
checksum bad
checksum bad
host xx.xx.xx.xx is not alive说明通讯不上  

3)修改各烧写镜像名称。由于uboot的tftp下载已经写死了，因此必须要用这些固定的名称
烧写到NandFlash的uboot：u-boot.bin
烧写到NorFlash的uboot：uboot.bin
Linux内核:zImage.bin
文件系统:root.bin
logo镜像：logo.bin
stepldr镜像：stepldr.nb1
eboot镜像：eboot.nb0

把这些需要下载的镜像，复制到tftp的根目录下，如/tftpboot

4)烧写
->1烧写uboot到NandFlash
->3烧写Linux内核
->6烧写文件系统
->b烧写开机logo

故障情况：
TFTP error:'File not found'不存在此镜像，要么是TFTP根目录路径设置不对，或不存在这个镜像文件
Loading:TTTTTT             没有启动TFTP服务器

5)设置Linux启动方式：
->0
(1)设置为yaffs2文件系统
->2 设置从yaffs启动
bootargs:noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC0
->s 保存设置
->q
(2)设置为NFS文件系统作为根文件系统
①
Linux服务器端，安装NFS文件系统,根目录在/opt/EmbedSky/root_nfs/
假设服务器端192.168.4.7，板子是192.168.4.20
②
->1 设置从NFS启动
Enter the PC IP address:
192.168.4.7
Enter the TQ2440 IP address:
192.168.4.20
掩码
255.255.255.0
Enter NFS directory: 根文件路径
/opt/EmbedSky/root_nfs/
->s保存启动参数
->q返回
->8启动Linux

10、ADS1.2，
1）ADS由命令行开发工具(现在不用了)，GUI(图形用户界面)，主要包括(目前都用这两个开发)：Code Warriror(用于C，C++，ARM代码的开发工具),AXD（AXD用于调试程序）

2）启动CodeWarriror for ARM Developer Suite进行工程编译,新建一个工程
(1)File->New->Project->ARM Executable Image->写工程名
(2)右键，Add Files 添加文件，记住DebugRel,Release,Debug都要勾选，进行文件编写
(3)配置ARM选项
Edit->DebugRel Settings->Target Setttings选项页,Post-linker选ARM fromELF；ARM Assembler选项页，汇编器选
      ARM920T；ARM C Compiler选项页，C编译器选ARM920T；ARM C++ Compiler选项页，如果需要使用到C++，则
      选ARM920T；Thumb C Compiler选项页，C编译器选ARM920T；Thumb C++ Compiler选项页，如果需要使用到C++，则
      选ARM920T；
      ARM Linker选项页，RO Base:选内存页0x30000000   ,->其中的Options选项页：Image entry point填0x30000000
      ->其中的Layout选项页：Object/Symbol(指定这个编译出来的可执行程序刚启动，就执行哪个文件的哪一段) 填2440init.o        文件,Section填 Init段(汇编程序) 
      ->其中的Listings选项页：List file填List.txt
     ARM fromELF选项页，Output file name填TQ2440_Test.bin

(4）编译工程
Project->Make，产生执行程序F:\test\ads4\ads4.1_Data\DebugRel\ads4.1.bin
(5)如果要在工程中添加*.h文件，只需要在该*.c文件中，#include "*.h"即可
   如果要在工程中添加*.c文件，只需要右击工程，Add Files 即可 

 
3)、AXD用于调试程序
H-JTAG:打开H-JTAG，Operations->Detect Target
JLink:不用打开JFlash
CodeWarrior for ARM Developer Suite,AXD:右击->属性->勾选用兼容模式运行这个程序，windows xp pack 2。
        禁用桌面元素  
启动AXD->Options->Configure Target->Add->找到H-JTAG的安装目录中的H-JTAG.dll文件，或者JLink安装目录的
        C:\Program Files\SEGGER\JLinkARM_V408l\JLinkRDI.dll
打开CodeWarriror for ARM Developer Suite，->三角形按钮Debug，程序就通过JTAG仿真器下载到开发板的内存中
->通过AXD进行单步调试，点击Processor Views->Registers查看寄存器变量


//***********
//ARM汇编程序
//***********
1、程序框架
			AREA	Example,CODE,READONLY	; 声明代码段Example ,Example代码段名称，CODE
                                                        ; 说明Example它是代码段，READONLY表示它是只读的
			ENTRY				; 标识程序入口,类似于main,代码从下面开始执行
			CODE32				; 声明使用32位的ARM指令集，还有一种是16位指令集
START			MOV		R0,#1	
			MOV		R0,#0		
			END	;标明程序结束

2、ARM工作模式
1）ARM的两种工作状态：
   ARM状态：执行32位的字对齐的ARM指令。即每个字都是由4个字节所构成
   Thumb状态：执行16位的半字对齐的Thumb指令。即每个字都是由2个字节所构成
   微处理器可以在两种工作状态之间自由切换，并且，不会影响处理器的工作模式和相应寄存器中的内容
2）指令长度：有字节(8位)，半字(16位)，字(32位)三种数据类型，其中，字需要4字节对齐(地址的低两位为0)，
   半字需要2字节对齐(地址的最低位为0)
3)存储格式：各芯片都不确定的
   大端格式：一个字数据的逻辑高字节存储在物理低地址，逻辑低字节存储在物理高地址
   小端格式：一个字数据的逻辑低字节存储在物理低地址，逻辑高字节存储在物理高地址

4）ARM的7种工作模式：可以通过软件改变，可以通过外部中断或异常处理改变
   用户模式Usr：正常执行程序（一般情况下运行在这里）
   系统模式sys:运行具有特权的操作系统任务

   下面几种模式用于处理中断或异常，以及需要访问受保护的系统资源等情况：
   快速中断模式FIQ：高速数据传输，它的处理中断的优先级高于IRQ
   外部中断模式IRQ：通常的中断处理（例如按键中断）
   管理模式svc：操作系统使用的保护模式
   数据访问终止模式abt：当数据或指令预取终止时进入该模式，可用于虚拟存储以及存储保护   
   未定义指令中止模式und:当未定义的指令执行时进入该模式，可用于支持硬件（例如程序运行时遇到ARM无法识别的
                         汇编指令时，跳到这里）

3、ARM寄存器：有37个32位寄存器，其中31个为通用寄存器，6个为状态寄存器。它们什么时候可以被访问取决于运行模式，
   以及运行状态。但在任何时候，通用寄存器R0-R14，程序计数器PC，一个状态寄存器都是可以访问的
1） 31个通用寄存器 ：
R0～R15；
R13_svc、R14_svc；
R13_abt、R14_abt；
R13_und、R14_und；
R13_irq、R14_irq；
R8_fiq-R14_fiq。 
2）6个状态寄存器 ：这些寄存器在状态切换时，会自动保存，不用再手动保存，因此状态恢复回来后，
会自动恢复
CPSR；SPSR_svc、SPSR_abt、SPSR_und、SPSR_irq和SPSR_fiq 。

3）各运行状态寄存器使用情况
   用户模式Usr，系统模式sys:R0-R14，PC,CPSR
   快速中断模式FIQ：RO-R7，R8_frq-R14_frq，PC,CPSR,PSR_fiq
   外部中断模式IRG：R0-R12，R13_irq、R14_irq,PC,CPSR,SPSR_irq
   管理模式svc：R0-R12，R13_svc、R14_svc,PC,CPSR,SPSR_svc
   数据访问终止模式abt：R0-R12，R13_abt、R14_abt,PC,CPSR, SPSR_abt  
   未定义指令中止模式und:R0-R12，R13_und、R14_und,PC,CPSR,SPSR_und
4)有特殊作用的通用寄存器
  R15：PC程序计数器，指向当前正在执行的指令的地址+8（因为在取地址和执行之间多了一个译码阶段）
  R13：堆栈指针SP
  R14：子程序链接寄存器LR指针，函数的返回地址。当我们要返回时，将LR的值赋给pc指针，就调回去原来的地址了。

5)特殊状态寄存器
  CPSR：保存程序运行的状态，比如是ARM状态还是Thumb状态等
  各个对应的SPSR：是CPSR的备份，当程序发生异常时，需要切换到相应异常模式下面去，此时CPSR值可能被破坏。当把中
                  断处理完毕之后，返回用户模式时，需要将备份的数据覆盖回CPSR中去

6）CPSR，以及SPSR保存数据的格式
 N  Z  C  V  ......................... I F T    M4 M3 M2 M1 M0
  M4-M0：工作用户模式，可以通过它来软件切换工作模式：10000 用户，10001 FIQ,10010 IRQ,10011管理，10111中止，
         11011未定义，11111系统
  T:1是Thumb状态，0是ARM状态
  F:FIQ快中断禁止位，1禁止，0允许
  I：IRQ中断禁止位，1禁止，0允许
  可以查看AXD，的cpsr寄存器->双击该寄存器，就可以看到各个状态值了，各状态弹出表示0，按下表示1


4、寻址方式
1)立即数寻址
  ADD R0,R0,#1; RO=RO+1 R0加十进制1
  ADD R0,R0,#0x3f; RO=RO+0x3f 	R0加十六进制3f

2)寄存器寻址：利用寄存器中的数值作为立即数
  ADD R0,R0,R2; RO=RO+R2

3）寄存器间接寻址：寄存器中的值是存放操作数的地址，而这个存储器地址的值就是立即数
  ADD R0,R0,[R2]; RO=RO+[R2]
  LDR R0,[R1]; RO=[R1] 
  

4）基址变址寻址：寄存器中的值加上一个偏移量是存放操作数的地址，而这个存储器地址的值就是立即数
  LDR R0,[R2，#4]; RO=[R2+4]所在地址的值存入R0中
  LDR R0,[R2，#4]！; RO=[R2+4]所在地址的值存入R0中；然后，R2=R2+4
  LDR R0，[R1],#4  ; R0=[R1],R1=R1+4
  LDR R0，[R1，R2] ; R0=[R1+R2]

5)多寄存器寻址：完成多个寄存器值得访问，最多可以访问16个通用寄存器
  LDMIA R0，{R1，R2，R3，R4};R1=[R0];R2=[R0+4];R3=[R0+8];R4=[R0+12];

6)相对寻址 
  BL NEXT;跳转到NEXT
   。。。
  NEXT   
   。。。
  MOV PC,LR;  从子程序中返回到BL所在位置

7）堆栈寻址
递增堆栈：向高地址方向生长
递减堆栈：向低地址方向生长
满堆栈：堆栈指针SP指向最后压入堆栈的有效数据项
空堆栈：堆栈指针SP指向下一个要放入数据的空位置

5、ARM指令集
<opcode>{<cond>}{S} <Rd>,<Rn>{,<opcode2>}
其中，<>内的项是必须的，{}内的项是可选的，如<opcode>是指令助记符，是必须的，而{<cond>}为指令执行条件，是可选的，如果不写则使用默认条件AL(无条件执行)。
opcode 指令助记符，如LDR，STR等
cond 执行条件，如EQ，NE等
S 是否影响CPSR 寄存器的值，书写时影响CPSR，当没有S时，操作不更新CPSR中条件标志位的值
Rd 目标寄存器
Rn 第一个操作数的寄存器
operand2 第二个操作数。在ARM指令中，灵活的使用第2个操作数能提高代码效率，第2个操作数的形式如0x3FC、0、0xF0000000、200，0xF0000001等。

指令格式举例如下：
LDR     R0,[R1]       ；读取R1地址上的存储器单元内容，执行条件AL
BEQ     DATAEVEN   ；跳转指令，执行条件EQ，即相等跳转到DATAEVEN
ADDS    R1,R1,#1      ；加法指令，R1＋1＝R1 影响CPSR寄存器，带有S
SUBNES  R1,R1,#0xD   ；条件执行减法运算(NE),R1-0xD=>R1,影响CPSR寄存器,带有S

条件码：
几乎所有的ARM指令都包含一个可选择的条件码，即{<cond>}。使用指令条件码，可实现高效的逻辑操作，提高代码效率。ARM条件码如表所示。
EQ  Z＝1  相等
NE  Z＝0  不相等
CS/HS  C=1  无符号数大于或等于
CC/LO  C=0  无符号数小于
MI N=1 负数
PL N=0 正数或零
VS V=1 溢出
VC V=0 没有溢出
HI C=1，Z=0 无符号数大于
LS C=0，Z=1 无符号数小于或等于
GE N=V 带符号数大于或等于
LT N！=V 带符号数小于
GT Z=0，N=V 带符号数大于
LE Z=1，N！=V 带符号数小于或等于
AL 任何 无条件执行（指令默认条件）


各指令的分类：
1）跳转指令：类似于goto指令，跳转指令用于实现程序流程的跳转，在 ARM 程序中有两种方法可以实现程序流程的跳转：
（1）向程序计数器PC中直接写入跳转地址值，可以实现4GB的地址空间的跳转。在跳转前，使用
MOV LR,PC保存将来的返回地址值，可以实现类似于子程序调用
（2）使用专门的跳转指令：实现当前指令向前，或者向后32MB的地址范围空间的跳转。存储在跳转指令中的实际值是相对当前 PC 值的一个偏移量，而不是一个绝对地址
①B指令：
  B{条件}  目标地址;使用{}，表示这个条件可有可无
例：B START；无条件跳转到START
    
    CMP R1，#0;
    BEQ START;
    让R1，和0相比较，如果有相等，则跳转到START
②BL指令
     BL{条件}  目标地址；跳转到目标地址，并且将PC当前值保存到R14，即LR中。这样，相当于子程序运行。运行后，
    可以通过将LR的内容加载到PC中，即可以返回到刚才的地方的下一条指令
③BLX指令
     BLX{条件}  目标地址
     跳转到目标地址，并且将PC当前值保存到R14，即LR中。并将工作状态由ARM状态切换到Thumb状态。因此，当子程序使     用 Thumb 指令集，而调用者使用 ARM指令集时，可以通过 BLX指令实现子程序的调用和处理器工作状态的切换。同时      ，子程序的返回可以通过将寄存器 R14 值复制到 PC 中来完成。 

④BX指令
     BX{条件}  目标地址
     跳转到目标地址，目标地址的指令可以是ARM指令，也可以是Thumb指令

2）数据传送指令
(1)MOV {条件}{S} 目的寄存器，源
S表示：这条指令的操作是否会影响CPSR中条件标志位的值。当没有S时，操作不更新CPSR中条件标志位的值
例：
MOV PC,R14
MOV R1，R0，LSL #3 将R0的值左移3位后送到R1。如果R0原先是0x00000012，左移三位之后即*3，0x00000090

(2)MVN {条件}{S} 目的寄存器，源; 将源先按位取反，再传到目的寄存器中
MVN R0，#0xff； R0=0xffffff00；它是4位*8个=32位的二进制数
MVN R0，#0xA0000007； A0000007的反码，R0=0x5FFFFFF8；它是4位*8个=32位的二进制数

3）算术逻辑运算指令
(1)ADD加指令，SUB减指令，MUL，MULS乘指令，
ADD R0，R1，LSL#1；R0=R2+(R3<<1),R3左移一位
MUL R0，R1，R2；R0=R1*R2，同时置位CPSR

4）比较指令
(1)CMP {条件} 数1，数2;两个数进行比较(即相减比较)，根据结果更新CPSR中条件标志位的值。标志位表示数1，与数2的关系(大，小，等) 

数1>数2,HI C=1，Z=0 无符号数大于
数1<=数2,LS C=0，Z=1 无符号数小于或等于

例：
MOV	R0,#1
MOV	R1,#2	
CMP	R0,R1	;若R0>R1,则置R0=3,若R0<=R1，则置R1=3
MOVHI	R0,#3	 ;根据CPSR条件标志位中的HI(无符号大于)判断，若R0>R1，则R0=3
MOVLS	R1,#3	 ;根据CPSR条件标志位中的LS(无符号小于或等于)判断,R0<=R1，则R1=3
结果：R1=3

(2)TST {条件} 数1，数2;两个数进行按位与运算，根据结果更新CPSR中条件标志位的值。如果他按位与的结果为0，则EQ位被设置了。它是用于测试某一个位，是否被设置了
例：TST R1，#%1；R1与 二进制(%表示二进制数)的立即数1进行按位与运算

;TST指令,测试R5的bit23是否为1，若是则置R5=0x01,不是则置R5=0x00
LDR	R5,=0xffffffff
TST	R5,#(1<<23)	;当bit23位为1时，CPSR EQ位被设置
MOVEQ	R5,#0x00
MOVNE	R5,#0x01
结果：R5=0x01

(3)AND {条件}{S} 目的寄存器，数1，数2；数1与数2进行逻辑与操作，保存到目的寄存器中。它与按位与是不同的
例：
MOV	R0,#0xff
AND	R0,R0,#3	;逻辑与运算,R0 = R0 & 3
结果：R0=0x03

(4)ORR {条件}{S} 目的寄存器，数1，数2；逻辑或

(5)BIC {条件}{S} 目的寄存器，数1，数2,数3；它是一个清零指令，它把数2中的某些位按位清零，并把结果存放到数1中。数3为32位的掩码，如果它的某一位设置为1，则清除数2中的相对应这一位
例：BIC R0，R0，#%1011；将R0的0,1,3位清除，其余不变

5)程序状态寄存器访问指令：在程序状态寄存器和通用寄存器之间传送数据，而上面的指令只能在通用寄存器之中传数                     
(1)
MRS {条件}通用寄存器，程序状态寄存器CPSR,或SPSR；用于将程序状态寄存器的内容传到通用寄存器中；
使用情况：当需要改变程序状态寄存器的内容时，或异常处理，或进程切换时，可以做这些事情
MSR {条件} 程序状态寄存器CPSR,或SPSR_特定域， 数1；用于将数1的内容存放到程序状态寄存器的特定域中，各域的
           作用，可以参照CPSR的四个部分的作用
            r：位[31:24]条件标志位域  s:位[13:26]状态位域
            x: 位[15:8]扩展位域       c:位[7:0]控制位域
MRS R0，CPSR
MSR CPSR,R0
MSR CPSR_c,R0;仅仅修改CPSR中的控制位域

(2)
加载/存储指令
加载用于将存储器中的数据传送到寄存器，存储用于将寄存器中的数据传送到存储器
查看：使用AXD的processor views-->memory查看内存的值->输入内存地址->可以看到该内存所存储的值


①
LDR 指令用于从内存中将一个32 位的字数据传送到目的寄存器中。该指令通常用于从内存中读取32 位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC 作为目的寄存器时，指令从内存中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。

LDR {条件} 目的通用寄存器， 存储器（或称内存地址）;从存储器中读取32位的字数据到通用寄存器
例：
LDR R0，[R1] ；将内存地址为R1 的字数据读入寄存器R0。
LDR R0，[R1，R2] ；将内存地址为R1+R2 的字数据读入寄存器R0。
LDR R0，[R1，＃8] ；将内存地址为R1+8 的字数据读入寄存器R0。
LDR R0，[R1，R2] ！ ；将内存地址为R1+R2 的字数据读入寄存器R0，并将新地址R1＋R2 写入R1。
LDR R0，[R1，＃8] ！ ；将内存地址为R1+8 的字数据读入寄存器R0，并将新地址R1＋8 写入R1。
LDR R0，[R1]，R2 ；将内存地址为R1 的字数据读入寄存器R0，并将新位址R1＋R2 写入R1。
LDR R0，[R1，R2，LSL＃2]！ ；将内存地址为R1＋R2×4 的字数据读入寄存器R0，并将新地址R1＋R2×4 写入R1。
LDR R0，[R1]，R2，LSL＃2 ；将内存地址为R1 的字数据读入寄存器R0，并将新位址R1＋R2×4 写入R1。

例：
MOV	R1,=0x30003100	;R1=0x30003100
,使用AXD的processor views-->memory查看内存的值，为
地址：0x30003100 ..3101 3102 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
相应存储值：78      56   34  12 12 00 00 00 AB 00 00 00 33 CC 33 CC
LDR	R0,[R1]	;R0=[R1]
因为R0是存储32位的二进制数据，又因为ARM是小端存储(存在高地址处地是高位)，所以它保存值是
12 34 56 78
即R0=0x12345678

同理：
LDR	R0,[R1,#4]	;R0=[R1,#4]
即R0=0x00000012

②. LDRB 指令
LDRB 指令的语法为：
LDR{条件}B 目的寄存器，<内存地址>
LDRB 指令用于从内存中将一个8 位的字节数据传送到目的寄存器中，同时将寄存器的高24 位清零。该指令通常用于从内存中读取8 位的位元组数据到通用寄存器，然后对数据进行处理。当程序计数器PC 作为目的寄存器时，指令从内存中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。
例：
LDRB R0，[R1] ；将内存地址为R1 的字节数据读入寄存器R0，并将R0的高24 位清零。
LDRB R0，[R1，＃8] ；将内存地址为R1＋8 的字节数据读入寄存器R0，并将R0 的高24 位清零。

③ LDRH 指令
LDRH 指令的语法为：
LDR{条件}H 目的寄存器，<内存地址>
LDRH 指令用于从内存中将一个16 位的半字数据传送到目的寄存器中，同时将寄存器的高16 位清零。该指令通常用于从内存中读取16 位的半字数据到通用寄存器，然后对数据进行处理。当程序计数器PC 作为目的寄存器时，指令从内存中读取的字数据被当作目的地址，从而可以实现程序流程的跳移。
范例：
LDRH R0，[R1] ；将内存地址为R1 的半字数据读入寄存器R0，并将R0 的高16 位清零。
LDRH R0，[R1，＃8] ；将内存地址为R1＋8 的半字数据读入寄存器R0，并将R0的高16 位清零。
LDRH R0，[R1，R2] ；将内存地址为R1＋R2 的半字数据读入寄存器R0，并将R0 的高16 位清零。

④. STR 指令
STR 指令的语法为：
STR{条件} 来源寄存器，<内存地址>;从源通用寄存器中读取32位的字数据到存储器
例：
STR R0，[R1],#8；将R0的字数据写入以R1为地址的存储器中，并将R1+8写入R1
STR R0，[R1,#8]；将R0的字数据写入以R1+8为地址的存储器中


例：
MOV	R1,=0x30003100
MOV	R0,#0xab
STR R0,[R1]					;将R0中的字数据写入以R1为地址的存储器中
运行后，因为R0是存储32位的二进制数据，又因为ARM是小端存储(存在高地址处地是高位)，所以它保存值是
地址：0x30003100 ..3101 3102 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
相应存储值：AB      00   00  00 12 00 00 00 AA 00 00 00 33 CC 33 CC

同理：
STR	R0,[R1,#8]			;将R0中的字数据写入以R1＋8为地址的存储器中

⑤STRB 指令
STR{条件}B 来源寄存器，<内存地址>;用于从来源寄存器中将一个8 位的字节数据传送到内存中。该字节数据为来源寄存器中的低8 位。
范例：
STRB R0，[R1] ；将寄存器R0 中的字节数据写入以R1 为地址的内存中。
STRB R0，[R1，＃8] ；将寄存器R0 中的字节数据写入以R1＋8 为地址的内存中。
 
⑥ STRH 指令
STRH 指令的语法为：
STR{条件}H 来源寄存器，<内存地址>
STRH 指令用于从来源寄存器中将一个16 位的半字数据传送到内存中。该半字数据为来源寄存器中的低16 位。
指令范例：
STRH R0，[R1] ；将寄存器R0 中的半字数据写入以R1 为地址的内存中。
STRH R0，[R1，＃8] ；将寄存器R0 中的半字数据写入以R1＋8 为地址的内存中。


(3)批量加载/存储指令：一次在一片连续的存储器单元和一组多个寄存器之间传送数据。
该指令的常见用途是将多个寄存器的内容入堆栈或出堆栈。其中，{类型}为以下几种情况：
IA 每次传送后地址加1；
IB 每次传送前地址加1；
DA 每次传送后地址减1；
DB 每次传送前地址减1；
FD 满递减堆栈；
ED 空递减堆栈；
FA 满递增堆栈；
EA 空递增堆栈；

{！}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。
例如原先R1地址为0，存储后变为13。如果没有！，则它下次写时，地址还是从0开始。如果有！，则这个地址13就被写入了R1。下次就从13开始了存储。寄存器不允许为R15，寄存器列表可以为R0～R15 的任意组合。

{∧}为可选后缀，当指令为LDM 且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR 复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。

STM 连续数据存储指令

①
LDM 连续数据加载指令：将一片连续的内存中的数据传送到多个寄存器

LDM（或STM）{条件}{类型} 基址寄存器{！}，寄存器列表{∧}
由基址寄存器所指示的一片连续存储器传数据到寄存器列表所指示的多个寄存器。

例：
LDMFD R13!,{R0，R4-R12，LR}
将R13基址寄存器所指示的一片连续存储器堆栈存入寄存器列表{R0，R4-R12，LR}

例：
LDR		R1,=0x30003100
LDMIA R1,{R5,R6};    即是R5 = [R1],R6 = [R1+4]
原先
地址：0x30003100 ..3101 3102 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
相应存储值：AB      00   00  00 12 00 00 00 AB 00 00 00 33 CC 33 CC
存储后，
结果：R5=0xab,R6=0x12

②
STM从源通用寄存器中批量读取字数据到基址寄存器所指向的内存中去。

例：
STMFD R13!,{R0，R4-R12，LR}
将寄存器列表{R0，R4-R12，LR}存入R13基址寄存器所指示的一片连续存储器堆栈

例：
MOV 	R2,#0x33
MOV	R3,#0X44
STMIA	R1,{R2,R3};  [R1]=R2,[R1+4]=R2

6) 数据交换指令
ARM 微处理器所支持数据交换指令能在内存和寄存器之间交换数据。资料交换指令有如下两条：
SWP 字数据交换指令
SWPB 字节数据交换指令

(1)SWP 指令
SWP 指令的语法为：
SWP{条件} 目的寄存器，来源寄存器1，[来源寄存器2]

SWP 指令用于将来源寄存器2 所指向的内存中的字数据传送到目的寄存器中，同时将来源寄存器1 中的字数据传送到来源寄存器2 所指向的内存中。显然，当来源寄存器1 和目的寄存器为同一个寄存器时，指令交换该寄存器和记忆体的内容。指令范例：
SWP R0，R1，[R2] ；将R2 所指向的内存中的字数据传送到R0，同时将R1 中的字数据传送到R2 所指向的存储单元。
SWP R0，R0，[R1] ；该指令完成将R1 所指向的内存中的字数据与R0 中的字资料交换。注意，最后，它是将变化之前的
                   R0的值传给R1，而不是变化之后的R0的值，因此，可以实现数据的交换

(2)SWPB 指令
SWPB 指令的语法为：
SWP{条件}B 目的寄存器，来源寄存器1，[来源寄存器2]

SWPB指令用于将来源寄存器2 所指向的内存中的字节数据传送到目的寄存器中，目的寄存器的高24 清零，同时将来源寄存器1 中的字节数据传送到来源寄存器2 所指向的内存中。显然，当来源寄存器1 和目的寄存器为同一个寄存器时，指令交换该寄存器和内存的内容。
指令范例：
SWPB R0，R1，[R2] ；将R2 所指向的内存中的字节数据传送到R0，R0 的高24位清零，同时将R1 中的低8 位数据传送到R2 所指向的存储单元。
SWPB R0，R0，[R1] ；该指令完成将R1 所指向的内存中的字节数据与R0 中的低8位数据交换。



7)
移位指令：在汇编中不作为单独的指令，只是一个选项
LSL逻辑左移，ASL算术左移
LSR逻辑右移，ASR算术右移，ROR循环右移
例：
MOV R1，#4；
MOV R0，R1，LSL#2; R1=0x04<<2，即R1=0x10
MOV	R1,#3	
MOV	R0,R1,ROR#2 ;将R1中的内容循环右移两位后传送到R0中,即0xc0000000


8)异常产生指令
(1)
SWI软件中断指令：产生软件中断，以便用户程序能够调用操作系统的系统API
SWI{条件} 24位的立即数
例
SWI 0x02 调用操作系统编号位02的系统例程
(2)
BKPT断电中断指令


9)伪指令：为完成汇编程序作各种准备操作
(1)
①定义全局变量GBLA,GBLL,GBLS
  GBLA:数字变量，并初始化为0
  GBLL：逻辑变量，并初始化为F(假)
  GBLS：字符串变量，并初始化为空
②定义局部变量LCLA,LCLL,LCLS
③对变量赋值SETA,SETL,SETS
例：
GBLA TEST1
TEST1 SETA 0xaa将该变量赋值为0xaa

GBLL TEST2
TEST2 SETL {TRUE}将该变量赋值为真

GBLS TEST3
TEST3 SETS "Testing"将该字符串变量赋值为"Testing"

④为通用寄存器列表定义别名RLIST
例：
RegList RLIST {R0-R5,R8,R10}将该组寄存器列表名称定义为RegList，可在LDM/STM中使用


(2)数据定义伪指令：为特定的数据分配存储单元，同时可完成已分配存储单元的初始化
DCB DCW DCD DCFD DCFS DCQ SPACE MAP FIELD

①DCB：可以用"="来替换
标号 DCB 表达式；表达式可以说0-255的数字，或字符串
Str DCB "This is a test";分配一片连续的字节存储单元，并初始化
即:Str = "This is a test"

②标号 SPACE 表达式:分配一片连续的字节存储单元，并初始化为0。其中，表达式为要分配的字节数
DataSpace SPACE 100;分配连续100字节的存储单元并初始化为0

③MAP 表达式{，基址寄存器}；用于定义结构化内存表的首地址

MAP 0x100,R0;首地址为0x100+R0
MAP 0x100;首地址为0x100

标号 FIELD 表达式:表明这个数据域在内存表中所占的大小
例：
MAP 0x100;定义内存表首地址
A FIELD 16；定义A的位置为0x100，大小为16个字节
B FIELD 32；定义B的位置为0x110，大小为32个字节
S FIELD 256；定义S的位置为0x130，大小为256个字节



(3)汇编控制伪指令
IF ELSE ENDIF;
例：
IF Test=TRUE
  ...
ELSE
  ...
ENDIF

WHILE WEND;


MACRO MEND;
MEXIT;


(4)其它伪指令
①
AREA
AREA 段名 属性1，属性2，...;定义一个代码段，或者数字段。如果段名以数字开头，则需用"|"表示，比如|1_test|
各属性：
CODE说明是定义代码段，DATA说明是数据段，READONLY,READWRITE 
代码默认是字对齐的(字节，半字是2个字节，字是4个字节)
ALIGN指定对齐方式。为2的幂次方。如1,2,4,8,16等。

例：AREA Init,CODE,READONLY,ALIEN=3;指定后面的指令为2的3次方，即8字节对齐
CODE16，CODE32：CODE16为Thumb指令，CODE32为Arm指令

例：
CODE32；
。。。。。。
CODE16；
。。。。。。
END

②
ENTRY：指定汇编程序的入口点，即main
END：程序结尾

③
EQU：类似于#define
例：
Test EQU 50;即 Test就是50
Addr EQU 0x55,CODE32;即 Addr就是0x55,且该处为32位指令

④
使用其它文件的标号的方法：
EXPORT(或GLOBAL)：可用GLOBAL代替，表示它可以在其它文件中引用
IMPORT：声明一下，表示要使用其它文件中的一个标号
例：
A.asm文件
EXPORT Main;表示它可以在其它文件中引用
B.asm文件
IMPORT Main；声明要使用Main，但Main在文件A.asm中定义

EXTERN
GET(或INCLUDE)

6、C与ARM混合编程：一般系统，除了CPU初始化部分用到汇编语言，其它都用C/C++完成
1)在C/C++程序中嵌入汇编指令
 _asm
{
  汇编指令程序
}
2)在汇编程序中访问C/C++定义的全局变量：如果汇编代码较多，一般都把它放到单独的汇编文件中，这时需要在C和汇编
  之间进行数据的传递，这时就需要使用全局变量
例：
c2.c中
int gVar_1 = 12;
main()
{}

s2.s中
IMPORT gVar_1

3)在C/C++程序中调用汇编函数
  在汇编文件中：用EXPORT导出文件名，并用该函数名作为汇编代码段的标识
  在c文件中：声明函数原型，使用extern
  在汇编文件中：使用mov pc,lr返回
例：
s3.s中
AREA asmfile, CODE, READONLY
；第二步，说明函数可以在外部使用
EXPORT asm_strcpy
；第一步，实现函数asm_strcpy
asm_strcpy
loop:
	ldrb r4, [r0], #1
	cmp r4, #0
	beq over
	strb r4, [r1], #1
	b loop

over:
；第三步，返回调用
	mov pc, lr

c3.c中
第一步，声明这个函数
extern void asm_strcpy(const char *src, char *dest);

int main()
{
  const char *s = "seasons in the sun";
  char d[32];
  第二步，使用该函数
  asm_strcpy(s, d);
}
4)在汇编程序中调用C/C++函数
  在汇编文件中：IMPORT对应的C函数名，然后将C的代码独立放在一个独立的c文件中，进行编译
例：
c4.c中
int cFun(int a, int b, int c)
{
    return a + b + c;
}

s4.s中
EXPORT asmfile
AREA asmfile, CODE, READONLY
IMPORT cFun；步骤一，导入cFun函数 
ENTRY
	mov r0, #11
	mov r1, #22
	mov r2, #33 
	BL cFun；步骤二，跳转到函数名处，相当于调用函数了
END


7、Linux的可移植性
1)Linux与硬件相关的数据类型<asm/types.h>
 s8带符号字节
 u8无符号字节
 s16带符号16位整数
 u16无符号16位整数
 s32,u32,s64,u64类似

*数据对齐：在移植时，需要先针对数据类型，与相关内存地址位置相对齐。因为，如果载入未对齐           的数据，会导致处理器出现错误
 例如，一个32位类型的数据，它的地址刚好可以被4整除，则它就是对齐的。 

*字节顺序：如果处理器将最高有效位所在字节放在高字节位置上，其它字节依次放在低字节位置上，那么这种字节顺序称作高位优先。如果处理器将最低有效位所在字节放在高字节位置上，其它字节依次放在低字节位置上，那么这种字节顺序称作低位优先.    

8、C和汇编的接口
内嵌汇编的语法_asm_,编译器不要优化代码_volatile_
_asm_(汇编语句模板：输出寄存器：输入寄存器：会被修改的寄存器)
各部分都是用":"隔开。其中，汇编语句模板必须存在，而其它三个部分为可选部分。除第1行以外，后面带冒号的行若不使用就都可以省略。但是，如果使用了后面的部分，而前面的部分为空，也必须用":"隔开，
例如_asm_ _volatile_("cli":::"memory")
1)、汇编语句模板
由很多汇编组成。各语句用";","\n",或"\n\t"分开。指令中的操作数可以使用占位符来引用C语言变量，操作数最多10个%0,%1,......%9
各占位符总被视为long型，即4个字节，但对其施加的操作根据指令可以是字或者字节,当把操作数当作字或者字节使用时，默认为低字或者字节，对字节操作可以显式地指明是高字节还是此字节，方法是是在%和序号之间插入一个字母，比如%b2是低字节，%h7是高字节
2)、输出寄存器：不同操作数之间用逗号隔开，它的具体形式是“=限定字符串”(C语言变量)。表示当这段嵌入汇编执行完之后，哪些寄存器用于存放输出数据。
例：_asm_ _volatile_("pushf1;pop1 %0;cli":“=g”(x))
"pushf1;pop1 %0;cli"说明有三条汇编语句
pushf1;
pop1 x;因为输出语句是“=g”(x)，表明它的输出字符串的意思是：g是限定字符串，g的意思下面会描述。它的值是x
cli
3)、输入寄存器：不同操作数之间用逗号隔开，它的具体形式是“限定字符串”(C语言表达式，或C语言变量)。表示在开始执行汇编代码时，这里指定的一些寄存器中应存放的输入值
例：
_asm_
(
 "bts1 %1, %0"\   在内嵌汇编的编写时，通常对这些进行分行编写，并用"\"表示换行
 ："=m"(ADDR)\
 :"Ir"(nr) 
)
这条语句类似于bts1 nr ADDR

4)、会被修改的寄存器：表示你已对其中列出的寄存器中的值进行了改动，gcc编译器不能再依赖于它原先对这些寄存器加载的值。如果必要的话，gcc需要重新加载这些寄存器。因此我们需要把那些没有在输出/输入寄存器中的部分列出。输出一般是寄存器名，除此之外，还有"memory"。例如"%eax","%ebx"，"memory"等

volatile:注意，不是前面的_volatile_。我们再线程的intSignal前面加上volatile关键字，这时候，编译器就会知道该变量的值会在外部，被别的线程改变，因此每次访问该变量时会重新读取

memory:类似于volatile的作用，但是我们要在每个变量前都增加volatile，不如直接使用一个       memory方便

5)、限定字符
代码 说明
a    将输入变量放入寄存器eax，若eax已经被使用，则gcc就会在起始处插入一条语句"pushl %    eax",将eax内容保存到堆栈，然后在这段代码结束处再加一条语句"popl %eax",恢复eax的内容
m    使用内存地址
b    将输入变量放入寄存器ebx
o    操作数为内存变量，但是其寻找方式是偏移量类型，即基址寻址或者基址加变址寻址
V    操作数为内存变量，但寻址方式不是偏移量类型
p    操作数是一个合法的内存地址(指针)
X    操作数可以是任何类型
c    将输入变量放入寄存器ecx
I    使用常数0-31,用于32位移位指令
i    立即数 
d    将输入变量放入寄存器edx
J    使用常数0-63,用于64位移位指令
S    将输入变量放入寄存器esi
K    使用常数0-255,用于out指令
D    使用edi
L    使用常数0-65535
q    将输入变量放入寄存器（eax、ebx、ecx或edx）中的一个
M    使用常数0-3
r    将输入变量放入（eax、ebx、ecx，edx，esi,edi）中的一个
N    使用1字节常数（0-255）
n    立即数，有些系统不支持除字以外的立即数，这些系统应该使用ner不是i
g    将输入变量放入（eax、ebx、ecx、edx或内存变量）
O    使用常数0-31
0    表示用它限制的操作数与其某个指定的操作数匹配
1    表示该操作数就是制定的那个操作数，例如"0"
9    描述"%1"操作数，那么"%1"引用的其实就是"%0"操作数，注意作为限定符字母的0~9的区别，     前者描述操作数，后者代表操作数
A    把eax与edx合成一个64位的寄存器
=    表示操作数在指令中只是输出操作数。输出值将替换前值
+    表示操作数是输入输出操作数
&    该输出操作数不能使用过和输入操作数相同的寄存器
f    浮点寄存器
t    第一个浮点寄存器
u    第二个浮点寄存器
G    标准的80387浮点常数
%    该操作数可以和下一个操作数交换位置，例如add1的两个操作数可以交换顺序(当然两个操作     数都不能是立即数)
*    表示如果选用寄存器，则其后 的字母被忽略 



嵌入式linux 25

//***********
//ARM程序裸奔
//***********
查看头文件:点击右边的黑色三角箭头，即可选择*.h文件
*程序开发流程
1、程序先使用库，里面包含程序启动文件，启动文件的作用是
1）设置堆栈，即把sp堆栈指针指向某块内存
2)设置main函数的返回地址
3)调用main函数
4)使用完main函数之后，返回这里，并进行一些清理工作

2、程序启动时，进行的硬件初始化工作
1)关闭看门狗
2)初始化时钟,2440可以跑到400MHZ,但是刚开始启动时只有12MHZ,只有初始化一下才行
3)初始化SDRAM(如果有使用NorFlash时要用)

*通用GPIO接口
1、通用GPIO接口：通用输入输出I/O接口，有些很简单的外设，只需要一位控制信号即可，即只需要一个I/O控制端口，
   来控制它们的开关
   S2C2440有130个GPIO口，分为A-J共9个组：GPA...GPJ。可以通过设置相应的寄存器来控制某个GPIO口时用于输入，输出   ，还是其它特殊功能。例：设置GPH6作为输入端口
2、操作GPIO(GPA-GPJ)：每组GPIO，都可以通过3个寄存器来控制与访问，这3个寄存器为
   GPxCON:配置控制寄存器
   GPxDAT:数据寄存器
   GPxUP:上拉电阻控制寄存器
1）GPxCON:配置控制寄存器
   例如，GPBCON寄存器，控制它的第10个引脚，即GPB10，他由21,20这两位来控制：00表示作为输入口，01表示作为输出
   口，10表示作为特殊的作用，11保持不用
2）GPxDAT:数据寄存器，用来输出高电平，或者低电平
   GPB,由0到10，这11位来控制，且每个引脚口，依次对应一位。
   例如，GPB0设为10，即它为输出口。这时，要给它输出一个低电平，则GPB输出0即可。
   例如，GPB1设为00，即它为输入口。这时，GPB的第1位收到它得到的值是1，还是0，即可得知它是高电平，还是低电平。
3）GPxUP:上拉电阻控制寄存器，如果一个管脚它悬浮这，不是固定一个电平，则它可能会受到外界的电磁干扰，电平会
   发生变化，这时，最好加一个上拉电阻，让它固定到高电平上
   GPB,由0到10，这11位来控制，且每个引脚口，依次对应一位。该位为0，则加上拉电阻；为1，则不加上拉电阻
4)注意，有一个不同的寄存器是GPACON，它是每一位就对应一个引脚，当它被设为0时为输出，设为1时，
它就为地址线，此时GPADAT无用。一般GPACON被设为全1，用来访问外部存储器件


*LED程序设计：LED低电平有效点亮，高电平熄灭。它的资源引脚占用是LED1=GPB5,LED2=GPB6，LED3=GPB7，LED4=GPB8
例：
#define rGPBCON    (*(volatile unsigned *)0x56000010)	//Port B control
流程如下：
int *p;
将一个地址强制赋予某个指针：p=(int *)0x56000010  强制类型转换
给这个地址赋予值0x100： *p=0x100;即*((int *)0x56000010)=0x100;
volatile是不要让编译器把它优化掉



第一步：利用控制寄存器控制各引脚
/*************************************************
Function name: Led_port_init
Parameter    : void
Description	 : mini2440开发板有4个引脚连接了LED发光
               二极管，分别是GPB5--LED1，GPB6―LED2
               GPB7--LED3，GPB8--LED4，该函数的作用
               是对其个引脚进行初始化。
Return		 : void
Argument     : void
Autor & date : Daniel
**************************************************/   
void Led_port_init(void)
{
   /*设置GPB5-GPB8为输出端口*/
   rGPBCON &= ~((3<<10)|(3<<12)|(3<<14)|(3<<16));
   
   rGPBCON |= (1<<10)|(1<<12)|(1<<14)|(1<<16);
   
}

以GPB5引脚，即LED1为例
1)
3<<10
00000000000000000000 11 0000000000  说明它用于GPB5
~按位取反
11111111111111111111 00 1111111111
rGPBCON &
11111111111111111111 00 1111111111此时，该引脚为00，即输入模式

2)
1<<10
00000000000000000000 01 0000000000 说明它用于GPB5
rGPBCON |
11111111111111111111 01 1111111111  表示它属于输出模式,其它位不用

第二步：利用数据寄存器不停输出高电平，低电平
00000000000000000000000000100000，
~
11111111111111111111111111011111
即第5位，即GPB5，即LED1输出低电平，让LED亮
#define LED1_ON   ~(1<<5)

#define LED2_ON   ~(1<<6)
#define LED3_ON   ~(1<<7)
#define LED4_ON   ~(1<<8)

#define LED1_OFF   (1<<5)
#define LED2_OFF   (1<<6)
#define LED3_OFF   (1<<7)
#define LED4_OFF   (1<<8)


/* 全亮 */
rGPBDAT = rGPBDAT&(LED1_ON)&(LED2_ON)&(LED3_ON)&(LED4_ON);
    
delay(10000);
    
/* 全灭 */
rGPBDAT = rGPBDAT|(LED1_OFF)|(LED2_OFF)|(LED3_OFF)|(LED4_OFF);
    	
delay(10000);

*ARM中断机制：CPU在运行中，处理各类外设发生的某些不预期的事件，比如串口收到了数据，按键被按下
1、处理事件方式：
1)CPU轮询方式：CPU利用率低，不适合于多任务系统
2）中断方式：事件发生后会产生一个中断，CPU进入中断模式(切换到中断寄存器去)去处理中断，处理完后，再返回原来地方继续运行

2、中断方式
1)中断源：S3C2440有60个中断源(将中断，和子中断都算进去了)，有些中断中，还包含子中断。例如，我们的串口    INT_UART2中，还包含三个子中断ERR,RXD,TXD
子中断--->SUBSRCPND寄存器相应位置1，来申请该子中断要被处理-->INTSUBMASK寄存器-->SRCPND-->INTMASK寄存器
非子中断--------------------------------------------------------------------------/\

-->INTMOD寄存器-->INTPND寄存器

SUBSRCPND:用来表明子中断是否发生，它有15个子中断，每一位对应一个子中断，当这个子中断发生时，相应的位置1。
          清除该子中断，只要将相应位置0
INTSUBMSK:存储方式类似于SUBSRCPND，寄存器相应的位被置为1时，该中断信号被屏蔽，即该中断申请无效
SRCPND:存储方式类似于SUBSRCPND，寄存器相应的位被置为1时，表明该一个或者一类中断信号已经发生。清除该子中断，
       只要将相应位置0
INTMSK:存储方式类似于SUBSRCPND，寄存器相应的位被置为1时，该中断信号被屏蔽，即该中断申请无效。它只能屏蔽
       IRQ中断，不能屏蔽FIQ中断
INTMOD：存储方式类似于SUBSRCPND，寄存器相应的位被置为1时，该中断源会被设为FIQ快中断模式，即此中断发生时，CPU
       将进入快速中断模式，这个用来直接处理特别紧急的中断。置为0时，进入IRQ模式，用来优先级排序，再处理
INTPND：存储方式类似于SUBSRCPND，经过优先级仲裁器选出最高优先级的中断后，这个中断在寄存器相应的位被置为1，
       然后，CPU进入中断模式来处理它。在同一时间内，此寄存器只有一位被置为1，在ISR中可以根据这个位来确定中断
       类型。清除该中断时，往这个位写入0
3、按键程序设计：按键，对应的中断，对应的GPIO是K1=EINT8=GPG0;K2=EINT11=GPG3;K3=EINT13=GPG5;K4=EINT14=GPG6;
 K5=EINT15=GPG7;K6=EINT19=GPG11;低电平触发中断
1)、使用轮询方式，按一下点亮一个LED
int Wait_key(void)
{
   //实际上是判断，如果GPG0是按下的话，则它是0x0;想与后为0
   if(!(rGPGDAT & 0x1))
   delay(200);
   if(!(rGPGDAT & 0x1)) /*为什么又要判断，是要去抖动*/
     {
      while(!(rGPGDAT & 0x1));//按键按下，则一直处于循环中；松开，则返回1
      return 1;
     }
    else
      return 0;
}

2)使用中断触发机制的按键设计
程序有如下几个文件
Makefile编译链接文件。head.S程序在启动时，先运行这个文件。init.c初始化中断使能和设置的程序。interrupt.c中断发生
后，处理函数的程序。main.c应用层的程序

(1)具体中断流程：
硬件：
   ①进入IRQ模式，并且切换到中断模式下的sp寄存器，以后要入栈和出栈的时候都是用这个中断模式下的
   sp寄存器，即中断模式自己的栈
   ②pc寄存器跳入IRQ入口地址，然后执行相应的中断处理函数 
软件：
   ③计算刚才的主程序被中断处的地址
   ④保存现场的寄存器值
   ⑤调用中断处理函数
     ISR读取外设的相关寄存器分辨是哪个中断，NITOFFSET寄存器来读它的value值，可以知道是发生了哪个中断了
     处理该中断
     处理完毕之后，清除本次中断信号，EINTPEND的该中断所对应的位清0，SRCPEND，INTPND寄存器也清0
     只有清除后，才能再来新的中断，否则不能存新的中断 
   ⑥恢复现场，继续跳转回来执行原来被中断的程序 

(2)Makefile
objs := head.o init.o interrupt.o main.o

int.bin: $(objs)
	arm-linux-ld -Ttext 0x00000000 -o int_elf $^
	arm-linux-objcopy -O binary -S int_elf $@
	arm-linux-objdump -D -m arm int_elf > int.dis
可以看到，先要运行head文件

(3)从head.S文件可知，当程序启动时，运行的顺序
@******************************************************************************
@ File：head.S
@ 功能：初始化，设置中断模式、管理模式的栈，设置好中断处理函数
@******************************************************************************       
   
.extern     main
.text 
.global _start 
_start:
@******************************************************************************       
@ 中断跳转程序，用于指示当程序中断后，在哪里跳转；本程序中，
@除Reset和HandleIRQ外，其它异常都没有使用
@******************************************************************************       
    b   Reset

@ 0x04: 未定义指令中止模式的向量地址
HandleUndef:               ,未处理，所以直接跳回去进行死循环
    b   HandleUndef 
 
@ 0x08: 管理模式的向量地址，通过SWI指令进入此模式
HandleSWI:
    b   HandleSWI

@ 0x0c: 指令预取终止导致的异常的向量地址
HandlePrefetchAbort:
    b   HandlePrefetchAbort

@ 0x10: 数据访问终止导致的异常的向量地址
HandleDataAbort:
    b   HandleDataAbort

@ 0x14: 保留
HandleNotUsed:
    b   HandleNotUsed

④pc寄存器跳入IRQ入口地址，然后执行相应的中断处理函数
@ 0x18: 中断模式的向量地址
    b   HandleIRQ

@ 0x1c: 快中断模式的向量地址
HandleFIQ:
    b   HandleFIQ


Reset:                  
    ldr sp, =4096           @ 设置栈指针，只有这样，才能调用C函数
    bl  disable_watch_dog   @ 关闭WATCHDOG，否则CPU会不断重启

//注意：    
    msr cpsr_c, #0xd2       @ 进入中断模式，即设置CPSR寄存器的配置
    ldr sp, =3072           @ 设置中断模式栈指针

    msr cpsr_c, #0xd3       @ 进入管理模式
    ldr sp, =4096           @ 设置管理模式栈指针，
                            @ 其实复位之后，CPU就处于管理模式，
                            @ 前面的“ldr sp, =4096”完成同样的功能，此句可省略

    bl  init_led            @ 初始化LED的GPIO管脚
    
①初始化引脚，使能需要用的中断    
    bl  init_irq            @ 调用中断初始化函数，在init.c中
打开Init.c文件
/*
 * 初始化GPIO引脚为外部中断
 * GPIO引脚用作外部中断时，默认为低电平触发、IRQ方式(不用设置INTMOD)
 */ 
void init_irq( )
{
    // S2,S3对应的2根引脚设为中断引脚 EINT0,ENT2
    GPFCON &= ~(GPF0_msk | GPF2_msk);
    GPFCON |= GPF0_eint | GPF2_eint;

    // S4对应的引脚设为中断引脚EINT11，这个中断是外部中断
    GPGCON &= ~GPG3_msk;
    GPGCON |= GPG3_eint;
    
    // 对于外部中断，在使能时还需要再使能这个寄存器
    //对于EINT11，需要在EINTMASK寄存器中使能它
    EINTMASK &= ~(1<<11);
        
    /*
     * 设定优先级：
     * ARB_SEL0 = 00b, ARB_MODE0 = 0: REQ1 > REQ3，即EINT0 > EINT2
     * 仲裁器1、6无需设置
     * 最终：
     * EINT0 > EINT2 > EINT11即K2 > K3 > K4
     */
    PRIORITY = (PRIORITY & ((~0x01) | (0x3<<7))) | (0x0 << 7) ;

    // EINT0、EINT2、EINT8_23使能
    INTMSK   &= (~(1<<0)) & (~(1<<2)) & (~(1<<5));
}

②
    msr cpsr_c, #0x53       @ 设置I-bit=0，中断使能总开关打开，即打开总的IRQ中断
    
    ldr lr, =halt_loop      @ 设置返回地址
    ldr pc, =main           @ 调用main函数
    
③中断发生后，中断控制器汇集各类外设发出的中断信号，然后经过处理，根据一个规则选出一个信号，通知CPU
   根据本次中断类型，pc寄存器跳入IRQ入口地址0x18，然后执行相应的中断处理函数，在上面  
halt_loop:
    b   halt_loop


⑤该中断处理函数
HandleIRQ:
    ⑥计算刚才的主程序被中断处的地址
    sub lr, lr, #4                  @ 计算到返回被中断处的地址
    ⑦保存现场的寄存器值
    stmdb   sp!,    { r0-r12,lr }   @ 保存使用到的寄存器
                                    @ 注意，此时的sp是中断模式的sp
                                    @ 初始值是上面设置的3072
    
    ldr lr, =int_return             @ 设置调用ISR即EINT_Handle函数后的返回地址 
    ⑧ 
    ldr pc, =EINT_Handle            @ 调用中断服务函数，在interrupt.c中
Interrupt.c文件，进行中断处理函数
void EINT_Handle()
{
    //1.ISR读取外设的相关寄存器分辨是哪个中断，NITOFFSET寄存器来读它的value值，可以知道是发生了哪个中断了
    unsigned long oft = INTOFFSET;
    unsigned long val;
    
    //2.处理该中断
    switch( oft )
    {
        // S2被按下
        case 0: 
        {   
            GPFDAT |= (0x7<<4);   // 所有LED熄灭
            GPFDAT &= ~(1<<4);      // LED1点亮
            break;
        }
        
        // S3被按下
        case 2:
        {   
            GPFDAT |= (0x7<<4);   // 所有LED熄灭
            GPFDAT &= ~(1<<5);      // LED2点亮
            break;
        }

        // K4被按下
        case 5:
        {   
            GPFDAT |= (0x7<<4);   // 所有LED熄灭
            GPFDAT &= ~(1<<6);      // LED4点亮                
            break;
        }

        default:
            break;
    }

    //3.处理完毕之后，清除本次中断信号，EINTPEND的该中断所对应的位清0，SRCPEND，INTPND寄存器也清0
     只有清除后，才能再来新的中断，否则不能存新的中断
    if( oft == 5 ) 
        EINTPEND = (1<<11);   // EINT8_23合用IRQ5
    SRCPND = 1<<oft;
    INTPND = 1<<oft;
}


int_return:
    ⑨恢复现场，继续跳转回来执行原来被中断的程序 
    ldmia   sp!,    { r0-r12,pc }^  @ 中断返回, ^表示将spsr的值复制到cpsr

3)具体流程图
(1)在片内SRAM中，程序启动时，从Reset开始执行，然后跳到Main中，平时都是在main函数中进行运行
4096                     SP 
。。。。。
main函数                 ---->PC
ldr sp,=4096
b FIQ中断处理函数
b IRQ中断处理函数
b NotUsed中断处理函数
b DataAbort中断处理函数
b PrefetchAbort中断处理函数
b SWI中断处理函数
b Undef中断处理函数
b Reset
---------------------------
   Setppingstone

(2)发生按键中断后,进入中断模式，sp也随之切换，指向3072地址；然后将相关寄存器保存到这个地址中
3072                     SP 
。。。。。
main函数                 
ldr sp,=4096
b FIQ中断处理函数
b IRQ中断处理函数           ---->PC
b NotUsed中断处理函数
b DataAbort中断处理函数
b PrefetchAbort中断处理函数
b SWI中断处理函数
b Undef中断处理函数
b Reset
---------------------------
   Setppingstone

(3)当执行完毕之后，恢复现场，并且pc回去原来的main函数中继续进行


*SDRAM,存储控制器原理
1、S3C2440启动，为什么执行地址从0x0000000开始
2440有两种启动方式，Nor启动，Nand启动
2440
-------
CPU    |(Bank0)---->64M NorFlash
SRAM    |---->1G  NandFlash
       |---->SDRAM
-------
1)NandFlash启动:Bank0失效
(1)启动时，NandFlash先会强制将头4k的数据拷贝到SDRAM中去
|                                                      0x00001000 |
|。。。。。。。。。。。。。。。。。。                             |  
|ldr sp, =0x34000000 设置堆栈                                     |
|ldr pc, =on_sdram 跳到SDRAM中继续执行                            |
|bl  copy_steppingstone_to_sdram复制代码到SDRAM中                 | 
|bl  memsetup设置存储控制器                                       | 
|bl  disable_watch_dog关闭WATCHDOG                     0x00000000 | 
          Nand    Flash
               ||
               \/ 自动复制
|                                                      0x00001000 |
|。。。。。。。。。。。。。。。。。。                             |  
|ldr sp, =0x34000000 设置堆栈                                     |
|ldr pc, =on_sdram 跳到SDRAM中继续执行                            |
|bl  copy_steppingstone_to_sdram复制代码到SDRAM中                 | 
|bl  memsetup设置存储控制器                                       |      |SDRAM未初始化|0x34000000
|bl  disable_watch_dog关闭WATCHDOG                     0x00000000 | PC   |             |0x30000000
          片内内存SRAM的地址Steppingstone

(2)CPU从片内的SRAM的0地址开始执行(即SteppingStone地址)

(3)关看门狗，初始化存储管理器
|                                                      0x00001000 |
|。。。。。。。。。。。。。。。。。。                             |  
|ldr sp, =0x34000000 设置堆栈                          0x00000010 |
|ldr pc, =on_sdram 跳到SDRAM中继续执行                 0x0000000C |
|bl  copy_steppingstone_to_sdram复制代码到SDRAM中      0x00000008 |  
|bl  memsetup设置存储控制器                            0x00000004 |PC    |SDRAM已初始化|0x34000000
|bl  disable_watch_dog关闭WATCHDOG                     0x00000000 |      |             |0x30000000
          片内内存SRAM的地址Steppingstone


head.s文件中
memsetup:
    @ 设置存储控制器以便使用SDRAM等外设

    mov r1,     #MEM_CTL_BASE       @ 存储控制器的13个寄存器的开始地址
    adrl    r2, mem_cfg_val         @ 这13个值的起始存储地址
    add r3,     r1, #52             @ 13*4 = 54
1:  
    ldr r4,     [r2], #4            @ 读取设置值，并让r2加4
    str r4,     [r1], #4            @ 将此值写入寄存器，并让r1加4
    cmp r1,     r3                  @ 判断是否设置完所有13个寄存器
    bne 1b                          @ 若没有写成，继续
    mov pc,     lr                  @ 返回

(4)将这4k的代码，拷贝到SDRAM中去(起始地址0x30000000)，然后从内存SDRAM中，通过写程序进行读取
NandFlash，并且通过引导，读取NandFlash中的其它数据程序到SDRAM中，

|                                                      0x00001000 |
|。。。。。。。。。。。。。。。。。。                             |  
|ldr sp, =0x34000000 设置堆栈                                     |
|ldr pc, =on_sdram 跳到SDRAM中继续执行                            |
|bl  copy_steppingstone_to_sdram复制代码到SDRAM中                 |PC 
|bl  memsetup设置存储控制器                                       | 
|bl  disable_watch_dog关闭WATCHDOG                     0x00000000 | 
          片内内存SRAM的地址Steppingstone
               ||
               \/ 复制代码到SDRAM
|                                                      0x30001000 |
|。。。。。。。。。。。。。。。。。。                             |  
|ldr sp, =0x34000000 设置堆栈                          0x30000010 |
|ldr pc, =on_sdram 跳到SDRAM中继续执行                 0x3000000C |
|bl  copy_steppingstone_to_sdram复制代码到SDRAM中      0x30000008 |  
|bl  memsetup设置存储控制器                            0x30000004 |      
|bl  disable_watch_dog关闭WATCHDOG                     0x30000000 |   
                  SDRAM

head.s文件中
copy_steppingstone_to_sdram:
    @ 将Steppingstone的4K数据全部复制到SDRAM中去
    @ Steppingstone起始地址为0x00000000，SDRAM中起始地址为0x30000000
    
    mov r1, #0
    ldr r2, =SDRAM_BASE
    mov r3, #4*1024
1:  
    ldr r4, [r1],#4     @ 从Steppingstone读取4字节的数据，并让源地址加4
    str r4, [r2],#4     @ 将此4字节的数据复制到SDRAM中，并让目地地址加4
    cmp r1, r3          @ 判断是否完成：源地址等于Steppingstone的未地址？
    bne 1b              @ 若没有复制完，继续
    mov pc,     lr      @ 返回


(5)然后再跳到SDRAM中继续执行接下来的程序

|                                                      0x34000000 |SP
|。。。。。。。。。。。。。。。。。。                             |  
|ldr sp, =0x34000000 设置堆栈                          0x30000010 |
|ldr pc, =on_sdram 跳到SDRAM中继续执行                 0x3000000C |PC 
|bl  copy_steppingstone_to_sdram复制代码到SDRAM中      0x30000008 |  
|bl  memsetup设置存储控制器                            0x30000004 |      
|bl  disable_watch_dog关闭WATCHDOG                     0x30000000 |   
                  SDRAM

2)NorFlash启动
(1)此时，0地址是从NorFlash开始，而不是从SDRAM开始
(2)CPU从0地址开始执行，即开机后，程序可以从NorFlash开始启动

3)链接地址为什么从0x30000000开始：链接地址，是运行时程序应该位于哪个地址。因为我们SDRAM的起始地址是0x30000000，
因此链接后，程序运行时应该从0x30000000开始




2、存储管理器原理
例如，一个cpu外接如下所示设备
---------------
CPU           |---->SDRAM内存芯片
存储管理器    |---->网卡
---------------
1)CPU想要访问外部设备，需要做的事情
(1)配置存储管理器
(2)使用存储管理器来访问外部的设备

2)CPU通过存储管理器，来访问外部的设备。
例如，cpu要访问SDRAM设备：
cpu只要从内存0x30000000上读取4字节的指令，只要执行与存储管理器的相互操作指令
mov r1 0x30000000
ldr r0 [r1]
具体在存储管理器上，会根据配置信息，得知地址0x30000000是链接到SDRAM上，进行访问。


3)配置存储管理器
(1)存储管理器上想访问一个设备地址，它的的配置信息有以下几项
①地址线
②数据线，数据宽度(8位，或16位，或32位,根据不同的硬件来设置)
③访问该设备的频率有多快需要设置，如果该设备速度比较慢，则它访问的时钟频率就不能太快了
④其它该芯片相关的特性：比如SDRAM的寻址方式，就需要知道行地址是多少位，列地址是多少位，bank是多少块

(2)分配的外设
SRAM：速度快，但是贵，使用方法简单，只要发出地址信号给它，再进行读写即可
SDRAM：便宜，使用复杂，要发出Bank，行，列地址给它，才能读写。并且还要
通过一个刷新信号进行不停刷新，不然数据就会丢失。只能挂接到Bank6,Bank7
上
DDR：芯片不支持如此高级的存储芯片，
网卡，NorFlash：它的接口访问类似于SRAM，既是RAMLike的设备，访问方法也
比较简单。可以挂接到Bank0到Bank5上

(3)、具体访问SDRAM的步骤
SDRAM的内存结构图
       列地址

行  +++++++++++       +++++++++++     +++++++++++        +++++++++++
地  +++++++++++       +++++++++++     +++++++++++        +++++++++++        
址  +++++++++++       +++++++++++     +++++++++++        +++++++++++ 
      L-Bank0          L-Bank1         L-Bank2             L-Bank3
一个内存里有4个bank，即四块。
它的访问步骤如下：
①发出片选信号，它选中SDRAM芯片
②发出bank选择信号,它选中哪一块
③先发出行地址
④再发出列地址

(4)从电路图上TQ2440_V2核心板原理图，看出本电路板的存储管理器参数
①数据宽度：它的SDRAM芯片为两块HY57V561620芯片，每块的位宽为DQ0-DQ15，共16位。两块加起来就是32位
②看HY57V561620芯片手册，第7页可知，Row Address: RA0 ~ RA12, Column Address: CA0 ~ CA8。
  因此列行地址位为13，列地址位为9
③刷新周期从第5页可知，8,192 Refresh cycles / 64ms。即周期为64/8192
④bank从第5页可知，Internal 4bank operation。即4个bank
⑤从芯片手册第xx页，并且相对于我们的板子，我们总的内存是64MB，位宽是32位，可知我们的地址A[25:24],因此从原理图上可知，芯片地址总线A24，A25接到我们内存芯片SDRAM的Bank0，Bank1上。

而芯片地址的A0，A1未连接，是由于我们是使用32bit的数据位宽
 A0不接
 A1不接
 A2-------------A0
 A3-------------A1
2440芯片        SDRAM为32位 ，即读写一次都是4个字节
                例如CPU发出0，1，2，3地址都是访问同一个内存地址单元，
                返回同一个4字节的数据

 A0不接
 A1-------------A0
 A2-------------A1
 A3不接
2440芯片        SDRAM为16位 


 A0-------------A0
 A1-------------A1
 A2-------------A2
 A3不接
2440芯片        SDRAM为8位 

(5)访问使用SDRAM
---------------
CPU           |---->SDRAM内存芯片
存储管理器    |
---------------
配置存储管理器：既是写寄存器，把我们刚才得到的各个参数，比如数据宽度，
刷新周期，行列地址，bank信息都写入寄存器中。

写的方法如下：只要写相关寄存器即可，从芯片手册可知
①BUS WIDTH&WAIT CONTROL REGISTER总线宽度与等待控制寄存器，用来控制位
宽。2440可以外接8个设备。控制每个设备相关寄存器的WS,DW,ST的值即可
②BANK CONTROL REGISTER是Bank控制寄存器，2440可以外接8个设备，既有8个Bank
③REFRESH CONTROL REGISTER刷新周期寄存器，
④BANKSIZE REGISTER它的BANK6，BANK7寄存器是要怎么组合

(6)
例：
head.s文件

@*************************************************************************
@ File：head.S
@ 功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行
@*************************************************************************       

.equ        MEM_CTL_BASE,       0x48000000
.equ        SDRAM_BASE,         0x30000000

.text
.global _start
_start:
    bl  disable_watch_dog               @ 关闭WATCHDOG，否则CPU会不断重启
    bl  memsetup                        @ 设置存储控制器,bl是把目前memsetup的地址存到lr寄存器中
    bl  copy_steppingstone_to_sdram     @ 复制代码到SDRAM中
    ldr pc, =on_sdram                   @ 跳到SDRAM中继续执行
on_sdram:
    ldr sp, =0x34000000                 @ 设置堆栈，这个程序是把堆栈指针指向64M的SDRAM的顶端
    bl  main
halt_loop:
    b   halt_loop

disable_watch_dog:
    @ 往WATCHDOG寄存器写0即可
    mov r1,     #0x53000000
    mov r2,     #0x0
    str r2,     [r1]
    mov pc,     lr      @ 返回

copy_steppingstone_to_sdram:
    @ 将Steppingstone的4K数据全部复制到SDRAM中去
    @ Steppingstone起始地址为0x00000000，SDRAM中起始地址为0x30000000
    
    mov r1, #0
    ldr r2, =SDRAM_BASE
    mov r3, #4*1024
1:  
    ldr r4, [r1],#4     @ 从Steppingstone读取4字节的数据，并让源地址加4
    str r4, [r2],#4     @ 将此4字节的数据复制到SDRAM中，并让目地地址加4
    cmp r1, r3          @ 判断是否完成：源地址等于Steppingstone的未地址？
    bne 1b              @ 若没有复制完，继续
    mov pc,     lr      @ 返回


memsetup:
    @ 依上面所示，设置各存储控制器以便使用SDRAM等外设

    mov  r1,     #MEM_CTL_BASE       @ 存储控制器的13个寄存器的开始地址，从芯片手册知是BWSCON，是0x48000000
    adrl r2,     mem_cfg_val         @ 这13个值的起始存储地址
    add  r3,     r1, #52             @ 13*4 = 54
1:  
    ldr r4,     [r2], #4            @ 读取设置值，并让r2加4
    str r4,     [r1], #4            @ 将此值写入寄存器，并让r1加4
    cmp r1,     r3                  @ 判断是否设置完所有13个寄存器
    bne 1b                          @ 若没有写成，继续
    mov pc,     lr                  @ 把原先的lr保存的程序地址返回会pc中，即程序跳回到原地方运行
    
.align 4
mem_cfg_val:
    @ 存储控制器13个寄存器的设置值
    .long   0x22011110      @ BWSCON
    .long   0x00000700      @ BANKCON0
    .long   0x00000700      @ BANKCON1
    .long   0x00000700      @ BANKCON2
    .long   0x00000700      @ BANKCON3  
    .long   0x00000700      @ BANKCON4
    .long   0x00000700      @ BANKCON5
    .long   0x00018005      @ BANKCON6
    .long   0x00018005      @ BANKCON7
    .long   0x008C07A3      @ REFRESH
    .long   0x000000B1      @ BANKSIZE
    .long   0x00000030      @ MRSRB6
    .long   0x00000030      @ MRSRB7
    
    
Makefile文件
sdram.bin : head.S  leds.c
	arm-linux-gcc  -c -o head.o head.S
	arm-linux-gcc -c -o leds.o leds.c
	//链接地址，是指运行时程序应该处于的位置
	//指定程序链接地址代码段，因为从SDRAM开始运行，因此代码段地址从0x30000000开始
	arm-linux-ld -Ttext 0x30000000 head.o leds.o -o sdram_elf
	arm-linux-objcopy -O binary -S sdram_elf sdram.bin
	arm-linux-objdump -D -m arm  sdram_elf > sdram.dis
clean:
	rm -f   sdram.dis sdram.bin sdram_elf *.o
    

*内存管理单元MMU
1、MMU的主要作用
1)权限管理：我们使用Windows时，经常会遇到这个现象，程序运行时，程序崩溃了，会弹出访问非法地址对话框，然后关闭
该程序。但是不影响系统继续操作，这就是MMU的作用
A程序，B程序他们存在于各自独立的地址空间中，MMU的权限管理的作用是当A程序如果要访问B程序的地址空间时，就会将A程序
崩溃

2)地址映射：MMU是一张转换表格，进行虚拟地址与物理地址的转换
(1)原理
在程序A中，CPU访问虚拟地址0x422d8c的变量a的值
CPU-->访问虚拟地址0x422d8c-->MMU进行转换，转到物理地址-->|0x33e224  A程序，a=3|
                                                         |0x6473e3  B程序，a=2|存储管理器
即a=3

在程序B中，CPU访问虚拟地址0x422d8c的变量a的值
CPU-->访问虚拟地址0x422d8c-->MMU进行转换，转到物理地址-|   |0x33e224  A程序，a=3|
                                                       --->|0x6473e3  B程序，a=2| 
即a=2

因此，使用了MMU，CPU就发出虚拟地址；未使用MMU，CPU就发出物理地址。所有有关地址的都是一样的，例如我们写程序时，
提供的链接地址也是一样的道理

|                    |  
|CPU->MMU->存储管理器|--SDRAM
|                    |
因此，它的链接地址(Makefile或链接文件指定的)是不分虚拟地址，或物理地址的


(2)MMU地址映射原理：段映射，大页映射，小页映射，极小页映射
段映射，他的表格的每一个表项是一段，大小是1M。由于我们的CPU的寻址空间是4G，即虚拟地址空间是4G，因此我们表格大
小项是4096行

|4096-->存放一个物理地址|4G虚拟地址
|-----------------------
|.......................|
|1-->   存放一个物理地址|2M虚拟地址
|-----------------------
|0-->   存放一个物理地址|1M虚拟地址

例：
#define GPFCON      (*(volatile unsigned long *)0xA0000050)  我们设置一个虚拟地址来控制led灯，它的物理地址为
0x56000050

1M的十六进制为0x100000
0xA0000050/0x100000=2560,即是在内存映射叶表中，第2560页，需要存放实际地址0x56000050

以1M来对齐，0x100000*2560=0xA0000000，即是在这个地址中，需要存放实际地址0x56000000

我们一般的步骤是
①建立一个映射表格
②把表格地址告诉MMU
③启动MMU

(3)
例：
head.s文件
.text
.global _start
_start:
    ldr sp, =4096            @ 设置栈指针，4096即是指向片内4k地址的最顶部。如果下面的函数是C函数，调用前必须要设好栈
    bl  disable_watch_dog               @ 关闭WATCHDOG，否则CPU会不断重启
    bl  memsetup                        @ 设置存储控制器以使用SDRAM
    bl  copy_2th_to_sdram               @ 将第二部分代码复制到SDRAM

①NandFlash中，程序如下存放
从链接文件mmu.lds中可知
    SECTIONS 
  { 
     firtst    0x00000000 : { head.o init.o }第一段链接地址从0x00000000开始，它执行文件head.o init.o
     second    0xB0004000 : AT(2048) { leds.o }第二段链接地址从0xB0004000 开始，它执行文件leds.o 
   } 
注意：我们实际存放的值是地址0x56000050，而链接地址却是0xB0004000，所以这个地址即是虚拟地址，
但是他的物理地址是另外一个
如图所示
   |-------------|4096,即4K
   |leds.o       |
   |-------------|0地址偏移2048
   |head.o init.o|0地址

②程序启动时，把这段代码复制到SRAM中
   |-------------|4096,即4K
   |leds.o       |
   |-------------|0地址偏移2048
   |head.o init.o|0地址           |-----|SDRAM未初始化

③把第二段代码，即leds.o复制到SDRAM的地址中，从我们程序上，为这个地址定义了0x30004000开始，
这个是物理地址
            |-------------|
            |             |
            |-------------|
            |leds.o       |
0xB0004000->|-------------|0x30004000
            |             |0x30000000
            |-------------| 
            SDRAM
虚拟地址                     SDRAM实际地址

打开文件init.c中
/*
 * 将第二部分代码复制到SDRAM
 */
void copy_2th_to_sdram(void)
{
    unsigned int *pdwSrc  = (unsigned int *)2048;
    unsigned int *pdwDest = (unsigned int *)0x30004000;
    
    while (pdwSrc < (unsigned int *)4096)
    {
        *pdwDest = *pdwSrc;
        pdwDest++;
        pdwSrc++;
    }
}


目标：使用虚拟地址0xB0004000，来映射物理地址0x30004000。
创建页表的条件是，即建立以下三个页表
①虚拟地址0-4096，也要对应物理地址0-4096
②虚拟地址0xB0004000，要对应物理地址0x30004000
③还需要一个页表，进行映射0xA0000050，对应0x56000050

    bl  create_page_table               @ 创建页表
①Steppingstone的起始物理地址为0，第一部分程序的起始地址也是0，为了在开启MMU后仍然能运行第一
部分程序，0-1M的虚拟地址将会映射到同样的物理地址
③为了使0xA0000050，对应0x56000050。需要把从0xA0000000开始的1M虚拟地址空间映射到从0x56000000
开始的1M物理地址空间

      0xB4000000->|-------------|SP，指向栈顶指针
                  |             |64M
                  |-------------|
                  |leds.o       |
      0xB0004000->|-------------|0x30004000  PC
页表②0xB0000000->|0x30000000   |
                  |             |
                  |-------------| 
页表③0xA0000000->|0x56000000   | 
                  |-------------|
         页表①0->|0            |  
                  |-------------|0x30000000
                      SDRAM

/*
 * 设置页表
 */
void create_page_table(void)
{

/* 
 * 用于段描述符的一些宏定义
 */ 
#define MMU_FULL_ACCESS     (3 << 10)   /* 访问权限 */
#define MMU_DOMAIN          (0 << 5)    /* 属于哪个域 */
#define MMU_SPECIAL         (1 << 4)    /* 必须是1 */
#define MMU_CACHEABLE       (1 << 3)    /* cacheable */
#define MMU_BUFFERABLE      (1 << 2)    /* bufferable */
#define MMU_SECTION         (2)         /* 表示这是段描述符 */
#define MMU_SECDESC         (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | \
                             MMU_SECTION)
#define MMU_SECDESC_WB      (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | \
                             MMU_CACHEABLE | MMU_BUFFERABLE | MMU_SECTION)
#define MMU_SECTION_SIZE    0x00100000

    unsigned long virtuladdr, physicaladdr;
    unsigned long *mmu_tlb_base = (unsigned long *)0x30000000;
    
    /*
     * Steppingstone的起始物理地址为0，第一部分程序的起始运行地址也是0，
     * 为了在开启MMU后仍能运行第一部分的程序，
     * 将0～1M的虚拟地址映射到同样的物理地址
     */
    virtuladdr = 0;
    physicaladdr = 0;
    *(mmu_tlb_base + (virtuladdr >> 20)) = (physicaladdr & 0xFFF00000) | \
                                            MMU_SECDESC_WB;

    /*
     * 0x56000000是GPIO寄存器的起始物理地址，
     * GPFCON和GPFDAT这两个寄存器的物理地址0x56000050、0x56000054，
     * 为了在第二部分程序中能以地址0xA0000050、0xA0000054来操作GPFCON、GPFDAT，
     * 把从0xA0000000开始的1M虚拟地址空间映射到从0x56000000开始的1M物理地址空间
     */
    virtuladdr = 0xA0000000;
    physicaladdr = 0x56000000;
    *(mmu_tlb_base + (virtuladdr >> 20)) = (physicaladdr & 0xFFF00000) | \
                                            MMU_SECDESC;

    /*
     * SDRAM的物理地址范围是0x30000000～0x33FFFFFF，
     * 将虚拟地址0xB0000000～0xB3FFFFFF映射到物理地址0x30000000～0x33FFFFFF上，
     * 总共64M，涉及64个段描述符。这里创建了64M的映射
     */
    virtuladdr = 0xB0000000;
    physicaladdr = 0x30000000;
    while (virtuladdr < 0xB4000000)
    {
        *(mmu_tlb_base + (virtuladdr >> 20)) = (physicaladdr & 0xFFF00000) | \
                                                MMU_SECDESC_WB;
        virtuladdr += 0x100000;
        physicaladdr += 0x100000;
    }
}


    bl  mmu_init                        @ 启动MMU
/*
 * 启动MMU
 */
void mmu_init(void)
{

}

通过ttb=0x30000000;这个代码，将页表地址告诉MMU，再启动MMU



    ldr sp, =0xB4000000    @ 重设栈指针，指向SDRAM顶端(使用虚拟地址，实际地址0x34000000)
    ldr pc, =0xB0004000    @ 跳到SDRAM中继续执行第二部分代码，即立即跳到=main中开始执行(使用虚拟地址，实际地址0x30004000)
    @ ldr pc, =main
halt_loop:
    b   halt_loop

(4)实际程序运行流程
①启动时，NandFlash先会强制将头4k的数据拷贝到SDRAM中去
|。。。。。。。。。   |4096 ,sp
|。。。。。。。。。   |
|leds.o               |
|。。。。。。。。。   |2048 
|。。。。。。。。。   |
|ldr pc, =0xB0004000  | 
|ldr sp, =0xB4000000  | heads.o文件
|bl  mmu_init         | 和Init.o文件
|bl  create_page_table|
|bl  copy_2th_to_sdram|
|bl  memsetup         | 
|bl  disable_watch_dog| 
| ldr sp, =4096       | 
          Nand    Flash
               ||
               \/ 自动复制
|。。。。。。。。。   |4096 ,sp
|。。。。。。。。。   |
|leds.o               |
|。。。。。。。。。   |2048 
|。。。。。。。。。   |
|ldr pc, =0xB0004000  | 
|ldr sp, =0xB4000000  | heads.o文件
|bl  mmu_init         | 和Init.o文件
|bl  create_page_table|
|bl  copy_2th_to_sdram|
|bl  memsetup         | 
|bl  disable_watch_dog| 
| ldr sp, =4096       | pc 
片内内存SRAM的地址Steppingstone                               |SDRAM未初始化|0x34000000
                                                              |             |0x30000000
          

②CPU从片内的SRAM的0地址开始执行(即SteppingStone地址)

③从片内SRAM通过写程序进行读取NandFlash，将第二段代码leds.o拷贝到SDRAM中去(起始地址0x30004000)

|。。。。。。。。。   |4096 ,sp
|。。。。。。。。。   |
|leds.o               |
|。。。。。。。。。   |2048 
|。。。。。。。。。   |
|ldr pc, =0xB0004000  | 
|ldr sp, =0xB4000000  | heads.o文件
|bl  mmu_init         | 和Init.o文件
|bl  create_page_table|
|bl  copy_2th_to_sdram|
|bl  memsetup         | 
|bl  disable_watch_dog| 
| ldr sp, =4096       | pc 
片内内存SRAM的地址Steppingstone 
               ||
               \/ 复制代码到SDRAM
|                     | 0x34000000,sp               
|    leds.o           | 0x30004000               
|                     |               
|                     | 0x30000000
                  SDRAM

④在0x30000000设置页表
|                     | 0x34000000,sp               
|    leds.o           | 0x30004000               
|                     |               
|     页表            | 0x30000000
                  SDRAM
                  
页表如下所示
      0xB4000000->|-------------|SP，指向栈顶指针
                  |             |64M
                  |-------------|
                  |leds.o       |
      0xB0004000->|-------------|0x30004000  PC
页表②0xB0000000->|0x30000000   |
                  |             |
                  |-------------| 
页表③0xA0000000->|0x56000000   | 
                  |-------------|
         页表①0->|0            |  
                  |-------------|0x30000000
                      SDRAM
                      
                      
⑤启动MMU，然后PC要访问真正的内存，就需要通过MMU了                      
|。。。。。。。。。   |4096 ,sp
|。。。。。。。。。   |
|leds.o               |
|。。。。。。。。。   |2048 
|。。。。。。。。。   |
|ldr pc, =0xB0004000  | 
|ldr sp, =0xB4000000  | 
|bl  mmu_init         | pc启动MMU
|bl  create_page_table|
|bl  copy_2th_to_sdram|
|bl  memsetup         | 
|bl  disable_watch_dog| 
| ldr sp, =4096       |  
片内内存SRAM的地址Steppingstone 


⑥然后再跳到SDRAM中继续执行接下来的程序
0xB4000000|                     | 0x34000000,sp               
0xB0004000|    leds.o           | 0x30004000 pc              
          |                     |               
0xB0000000|     页表            | 0x30000000
                  SDRAM
通过虚拟地址访问物理地址                  




*NandFlash控制器访问NandFlash：
程序启动时，我们将这SRAM的4k的代码，拷贝到SDRAM中去(起始地址0x30000000)，然后从内存SDRAM中，通过写程序进行读取NandFlash，并且通过引导，读取NandFlash中的其它数据程序到SDRAM中
1、2440接外设的寻址方法：NandFlash与其它设备的寻址方式不同
1)SDRAM，网卡，片内内存，寄存器等的地址总线与2440芯片的地址总线相连，是cpu统一分配地址的
访问方法：
(1)发出地址信号
(2)传输数据，有读信号，和写信号
2)NandFlash没有地址总线，只有数据总线。因此他们的地址与CPU内部的地址是不一样的
我们每一页有2K的地址，每一段有128K的空间，即是64页。
       0   | |       2048| |
       2047| |       4095| |
           ---           ---
额外64的OOB| |  64字节OOB| |
           第0页       第1页    
如果我们要找2049这个地址的数据，只能是在第一页
访问方法：
(1)发出命令(将CLE引脚置高电平)：读(置nFRE引脚)，写(先擦除再写)(置nFWE引脚)，擦除
具体操作方法不必亲自操作引脚，只需往NFCMMD寄存器中写入值即可
例：volatile unsigned char *p=(volatile unsigned char *)&s3c2440nand->NFCMD;
    *p=0xff;
(2)发出地址(将ALE引脚置高电平)
具体操作方法不必亲自操作引脚，只需往NFADDR寄存器中写入值即可
    volatile unsigned char *p=(volatile unsigned char *)&s3c2440nand->NFADDR
(3)传输数据(将CLE,ALE引脚置低电平)
具体操作方法不必亲自操作引脚，写数据只需往NFDATA寄存器中写入值即可，读数据从NFDATA寄存器中读即可
读数据
    volatile unsigned char *p=(volatile unsigned char *)&s3c2440nand->NFDATA
    return *p; 
(4)查看状态:看当前状态是正在擦除，在读，或者在写
例：等待Nand Flash就绪
    volatile unsigned char *p=(volatile unsigned char *)&s3c2440nand->NFSTAT;
    while(!(*p&BUSY))
          for(i=0;i<10;i++); 
(5)是否使用这个NandFlash：nFCE置高，不使用
通过寄存器NFSTAT可知

例：
连接脚本Nand.lds
SECTIONS
{
 first 0x0000000:{head.o init.o nand.o}
 second 0x30000000:AT(4096) {main.o} 
}
编译出的nand.bin程序如下所示
①
   |-------------|
   |main.o       |                         ----->0x30000000地址
   |-------------|0地址偏移4096,即4K以外  程序运行时
   |head.o init.o|
   |nand.o       |0地址                    ----->0地址
      NandFlash
      
②上电后,将4K的程序复制到片内SRAM中
   |-------------|0地址偏移4096  
   |head.o init.o|
   |nand.o       |0地址                    ----->0地址
     SRAM
它在里面初始化SDRAM，然后将main程序引导复制到SDRAM的0x30000000中。这里，需要确定三个参数：
从哪里读(从偏移4096开始)，读到哪里去(SDRAM的0x30000000)，读多少(估计有2K大小，就读2K了)

head.s文件
.text
.global _start
_start:
    ldr sp, =4096            @ 设置栈指针，4096即是指向片内4k地址的最顶部。如果下面的函数是C函数，调用前必须要设好栈
    bl  disable_watch_dog               @ 关闭WATCHDOG，否则CPU会不断重启
    bl  memsetup                        @ 初始化SDRAM
    bl  nand_init                       @ 初始化NandFlash

/* 初始化NAND Flash */
void nand_init(void)
{
#define TACLS   0
#define TWRPH0  3
#define TWRPH1  0

    /* 判断是S3C2410还是S3C2440 */
    if ((GSTATUS1 == 0x32410000) || (GSTATUS1 == 0x32410002))
    {
        nand_chip.nand_reset         = s3c2410_nand_reset;
        nand_chip.wait_idle          = s3c2410_wait_idle;
        nand_chip.nand_select_chip   = s3c2410_nand_select_chip;
        nand_chip.nand_deselect_chip = s3c2410_nand_deselect_chip;
        nand_chip.write_cmd          = s3c2410_write_cmd;
        nand_chip.write_addr         = s3c2410_write_addr;
        nand_chip.read_data          = s3c2410_read_data;

		/* 使能NAND Flash控制器, 初始化ECC, 禁止片选, 设置时序 */
        s3c2410nand->NFCONF = (1<<15)|(1<<12)|(1<<11)|(TACLS<<8)|(TWRPH0<<4)|(TWRPH1<<0);
    }
    else
    {
        nand_chip.nand_reset         = s3c2440_nand_reset;
        nand_chip.wait_idle          = s3c2440_wait_idle;
        nand_chip.nand_select_chip   = s3c2440_nand_select_chip;
        nand_chip.nand_deselect_chip = s3c2440_nand_deselect_chip;
        nand_chip.write_cmd          = s3c2440_write_cmd;
#ifdef LARGER_NAND_PAGE
        nand_chip.write_addr         = s3c2440_write_addr_lp;
#else
		nand_chip.write_addr		 = s3c2440_write_addr;
#endif
        nand_chip.read_data          = s3c2440_read_data;

		/* 设置时序 */
        s3c2440nand->NFCONF = (TACLS<<12)|(TWRPH0<<8)|(TWRPH1<<4);
        /* 使能NAND Flash控制器, 初始化ECC, 禁止片选 */
        s3c2440nand->NFCONT = (1<<4)|(1<<1)|(1<<0);//NFCONT是低电平有效，刚开始时先禁能，所以先置高电平
    }
    
    /* 复位NAND Flash */
    nand_reset();
}

/* 复位 */
static void s3c2440_nand_reset(void)
{
    s3c2440_nand_select_chip();选中该芯片
    s3c2440_write_cmd(0xff);  // 发出复位命令
    s3c2440_wait_idle();     等待设备复位成功 
    s3c2440_nand_deselect_chip();取消片选
}

/* 发出片选信号 */即Flash使能芯片的控制器NFCONT置低电平，使能芯片
static void s3c2440_nand_select_chip(void)
{
    int i;
    s3c2440nand->NFCONT &= ~(1<<1);
    for(i=0; i<10; i++);    
}

/* 取消片选信号 */
static void s3c2440_nand_deselect_chip(void)
{
    s3c2440nand->NFCONT |= (1<<1);
}

/* 发出命令 */
static void s3c2440_write_cmd(int cmd)
{
    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFCMD;
    *p = cmd;
}

/* 等待NAND Flash就绪 */
static void s3c2440_wait_idle(void)
{
    int i;
    volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFSTAT;
    while(!(*p & BUSY))
        for(i=0; i<10; i++);
}


③程序跳到SDRAM的0x30000000地址上
读数据的过程：

我们想读4096(即4K地址)的数据，即0x1000, 由于NFADDR只是一个8位的寄存器
从Datasheet可知，它的地址需要拆成5部分，然后分为5次来写

             IO0  IO1 IO2 IO3 IO4 IO5 IO6 IO7 IO8-15  
第一次写：    A0   A1 A2   A3  A4  A5  A6  A7   0(其它位不需要写，以0来代替)
第二次写：    A8   A9 A10      0(其它位不需要写，以0来代替)
第三次写：    A11  A12 A13 A14 A15 A16 A17 A18  0(其它位不需要写，以0来代替)
第四次写：    A19  A20 A21 A22 A23 A24 A25 A26  0(其它位不需要写，以0来代替)
第五次写：    A27  0(其它位不需要写，以0来代替)

从上表可知，地址0x1000可以分成以下五个部分：
A0-A7:0x00
A8-A10:0x00
A11-A18:0x02
A19-A26:0x00
A27:0x00

/* 读函数 */
void nand_read(unsigned char *buf, unsigned long start_addr, int size)
{
    int i, j;

//有不对齐时，不进行读操作
#ifdef LARGER_NAND_PAGE
    if ((start_addr & NAND_BLOCK_MASK_LP) || (size & NAND_BLOCK_MASK_LP)) {
        return ;    /* 地址或长度不对齐 */
    }
#else
    if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
        return ;    /* 地址或长度不对齐 */
    }
#endif	

   //1
    /* 选中芯片 */
    nand_select_chip();

    for(i=start_addr; i < (start_addr + size);) 
    {
      //2    s3c2440nand->NFCMD 发出0命令，即准备读数据
      /* 发出READ0命令 */
      write_cmd(0);

      //3输入需要读数据的地址  s3c2440nand->NFADDR发出源地址
      /* Write Address */
      write_addr(i);

//从上表可知，地址数据分为五次来写      
static void s3c2440_write_addr_lp(unsigned int addr)
{
	int i;
	volatile unsigned char *p = (volatile unsigned char *)&s3c2440nand->NFADDR;
	int col, page;

	col = addr & NAND_BLOCK_MASK_LP;
	page = addr / NAND_SECTOR_SIZE_LP;
	
	*p = col & 0xff;			/* Column Address A0~A7 */
	for(i=0; i<10; i++);		
	*p = (col >> 8) & 0x0f; 	/* Column Address A8~A11 */
	for(i=0; i<10; i++);
	*p = page & 0xff;			/* Row Address A12~A19 */
	for(i=0; i<10; i++);
	*p = (page >> 8) & 0xff;	/* Row Address A20~A27 */
	for(i=0; i<10; i++);
	*p = (page >> 16) & 0x03;	/* Row Address A28~A29 */
	for(i=0; i<10; i++);
}



      
      //4.发出0x30命令，即准备读数据   s3c2440nand->NFCMD 发出0x30命令，即准备读数据
      //对于大页，要读数据，需要发出0x00,0x30命令；对于小页，要读数据，只需要发出0x00命令
#ifdef LARGER_NAND_PAGE
      write_cmd(0x30);		
#endif


      //5.等待执行完毕，重新就绪s3c2440nand->NFSTAT查询它的状态，等待它就绪
      wait_idle();
      
     

      //6.开始读数据s3c2440nand->NFDATA开始读数据
      //可以连续读1页
#ifdef LARGER_NAND_PAGE
      for(j=0; j < NAND_SECTOR_SIZE_LP; j++, i++) {
#else
	  for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
#endif
          *buf = read_data();
          buf++;
      }
    }

    //7.
    /* 取消片选信号 */
    nand_deselect_chip();
    
    return ;
}

/* 读取数据 */
static unsigned char s3c2410_read_data(void)
{
    volatile unsigned char *p = (volatile unsigned char *)&s3c2410nand->NFDATA;
    return *p;
}


*系统时钟和串口
1、系统时钟：2440的频率(FCLK)可以跑400MHZ，SDRAM或网卡或NorFlash(HCLK)等外设是100-133MHZ，
UART或定时器或IIC等(PCLK)是50MHZ
PLL寄存器：设备的晶振是12MHZ，而设备其实运行频率更高，就需要通过这个寄存器将它提高。具体分频方法是
12MHZ-->通过PLL提到400MHZ的FCLk-->FCLK分频降到100MHZ的HCLK
                               |->FCLK分频降到50MHZ的PCLK  
需要配置的地方：锁定时间(即这个时间段内，是用来配置各设备的频率的，锁定住之后，不会对现有系统产生影响。解锁之后，
再一起更改过去)；PLL寄存器的配置，FCLK到HCLK，PCLK的配置


例：
@******************************************************************************
@ File：head.S
@ 功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行
@******************************************************************************       
   
.extern     main
.text 
.global _start 
_start:
Reset:                  
    ldr sp, =4096           @ 设置栈指针，以下都是C函数，调用前需要设好栈
    bl  disable_watch_dog   @ 关闭WATCHDOG，否则CPU会不断重启
    // bl是位置无关码，相当于：PCnew = PC + 偏移
    //                         PCnew = (4+8) + 0x28 = 0x34
    
    ldr pc, =disable_watch_dog
    
    bl  clock_init          @ 初始化时钟，设置MPLL，改变FCLK、HCLK、PCLK

1)
文件init.c中
    /*
 * 对于MPLLCON寄存器，[19:12]为MDIV，[9:4]为PDIV，[1:0]为SDIV
 * 有如下计算公式：
 *  S3C2410: MPLL(FCLK) = (m * Fin)/(p * 2^s)
 *  S3C2440: MPLL(FCLK) = (2 * m * Fin)/(p * 2^s)
 *  其中: m = MDIV + 8, p = PDIV + 2, s = SDIV
 * 对于本开发板，Fin = 12MHz
 * 设置CLKDIVN，令分频比为：FCLK:HCLK:PCLK=1:2:4，
 * FCLK=200MHz,HCLK=100MHz,PCLK=50MHz
 */
void clock_init(void)
{
（1）
    // LOCKTIME = 0x00ffffff;   // 锁定时间，使用默认值，即无需进行配置
    CLKDIVN  = 0x03;            // FCLK:HCLK:PCLK=1:2:4, HDIVN=1,PDIVN=1；他将FCLK进行分频

    /* 如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode” */
__asm__(
    "mrc    p15, 0, r1, c1, c0, 0\n"        /* 读出控制寄存器 */ 
    "orr    r1, r1, #0xc0000000\n"          /* 设置为“asynchronous bus mode” */
    "mcr    p15, 0, r1, c1, c0, 0\n"        /* 写入控制寄存器 */
    );

(2)MPLLCON寄存器即配置CPLK的寄存器
    /* 判断是S3C2410还是S3C2440 */
    if ((GSTATUS1 == 0x32410000) || (GSTATUS1 == 0x32410002))
    {
        MPLLCON = S3C2410_MPLL_200MHZ;  /* 现在，FCLK=200MHz,HCLK=100MHz,PCLK=50MHz */
    }
    else
    {
        MPLLCON = S3C2440_MPLL_200MHZ;  /* 现在，FCLK=200MHz,HCLK=100MHz,PCLK=50MHz */
    }       
}



    bl  memsetup            @ 设置存储控制器以使用SDRAM
    bl  copy_steppingstone_to_sdram     @ 复制代码到SDRAM中
    ldr pc, =on_sdram                   @ 跳到SDRAM中继续执行
on_sdram:
    ldr sp, =0x34000000     @ 设置栈指针
    ldr lr, =halt_loop      @ 设置返回地址
    ldr pc, =main           @ 调用main函数
halt_loop:
    b   halt_loop

2、串口
1)使用串口顺序
(1)初始化串口：串口号，波特率，流控，把需要使用的串口，它对应的引脚设为UART模式
    bl  memsetup            @ 设置存储控制器以使用SDRAM
    bl  copy_steppingstone_to_sdram     @ 复制代码到SDRAM中
    ldr pc, =on_sdram                   @ 跳到SDRAM中继续执行
on_sdram:
    ldr sp, =0x34000000     @ 设置栈指针
    ldr lr, =halt_loop      @ 设置返回地址
    ldr pc, =main           @ 调用main函数，里面有一个串口初始化函数uart0_init

文件Serial.c中
/*
 * 初始化UART0
 * 115200,8N1,无流控
 */
void uart0_init(void)
{
    //使用这个串口
    GPHCON  |= 0xa0;    // GPH2,GPH3用作TXD0,RXD0
    GPHUP   = 0x0c;     // GPH2,GPH3内部上拉


    ULCON0  = 0x03;     // 8N1(8个数据位，无较验，1个停止位)
    //对于串口，怎么知道有数据来了呢，有两种方式，查询方式和中断方式
    UCON0   = 0x05;     // 查询方式，UART时钟源为PCLK
    UFCON0  = 0x00;     // 不使用FIFO
    UMCON0  = 0x00;     // 不使用流控
    UBRDIV0 = UART_BRD; // 波特率为115200
}

(2)读写串口
通过状态寄存器UTRSTAT0来判断
/*
 * 发送一个字符
 */
void putc(unsigned char c)
{
    /* 等待，直到发送缓冲区中的数据已经全部发送出去 */
    while (!(UTRSTAT0 & TXD0READY));
    
    /* 向UTXH0寄存器中写入数据，UART即自动将它发送出去 */
    UTXH0 = c;
}

/*
 * 接收字符
 */
unsigned char getc(void)
{
    /* 等待，直到接收缓冲区中的有数据 */
    while (!(UTRSTAT0 & RXD0READY));
    
    /* 直接读取URXH0寄存器，即可获得接收到的数据 */
    return URXH0;
}



*液晶显示
1、设备原理：
1)需要几个参数值：
VDEN：使能信号
LED-,LED+：背光电压信号，只有有电压，LCD屏幕才会点亮。需要设置GPB0输入高电平，这样才会输出
           背光信号
VCLK：时钟信号
VD0-VD23：数据信号
Vsync，Hsync：垂直同步信号，水平同步信号

2)
通过这两个信号来控制像素点位置,从2440手册的418页可知
LCD从左到右，从上到下依次描像素点

(1)
Vsync
头部
|
-|发出高电平，保持VSPW+1行
 |
-|
|回到低电平，VBPD+1行
|        
在这里，真正的行开始了，可以开始画点了
         ----------
         |        |
         |  LCD   |320
         ----------
            240
画了LINEVAL+1行
在这里，行结束。
|在这里，过了VFPD+1
|
末尾
--
 |再一个高电平后，又会返回最头部

Vsync垂直同步信号：每次时序图_|-|_之后，就移到最头部

(2)
当Vsync来到这里，真正的行开始了，可以开始画点了的时候，开始操作Hsync的时序

                                                  ----------
                                                  |        |
                                                  |  LCD   |320
                                                  ----------
                                                     240
  高电平保持HSPW+1像素 低电平HBPD+1像素                                    HFPD+1 再高，返回
_|------------------|_______________开始像素有效  画了HOZVAL+1像素  像素无效______|------
                                         像素有效区域，由VDEN来指示

Hsync水平同步信号：每次时序图|-|___之后，就移到该行最左边的头位置，然后根据VCLK，一个VCLK
     对应就画一个像素点

2、LCD寄存器的配置：
1)在2440中，有一个LCD寄存器，专门用于LCD的控制。
里面有一块专门的内存(Frame Buffer)，用于依次存放的每个数值对应LCD的像素点，
每个像素由两个字节组成(16位，即16bpp)，则内存每行240*2，每列320*2。然后LCD寄存器就
将这个内存通过Vsync，Hsync等，一次传到LCD中显示出来
写驱动的步骤：
①打开背光
②配置Vsync，Hsync等，进行时序设置
③在这个专用内存(Frame Buffer)中，写数据

2)
|P1 P2 P3|--->|P1 P2 P3|
LCD内存         LCD
像素点按时序显示过去，依据2440手册的413页可知
BSWP = 0, HWSWP = 1

3)16bpp配置：每个像素由两个字节组成，由RGB进行配色。
xxxxx    xxxxxx    xxxxx
红色区   绿色区    蓝色区
例如，红色编码为“c= (0x1f<<11) | (0x00<<5) | (0x00），即最左边R:11111 ，G:000000, B:00000

Red： (0x1f<<11) | (0x00<<5) | (0x00)其实就是二进制数：11111 000000 00000
Green：(0x00<<11) | (0x3f<<5) | (0x00)其实就是二进制数：00000 111111 00000
Bule：(0x00<<11) | (0x00<<5) | (0x1f) 其实就是二进制数：00000 000000 11111
White：(0x1f<<11) | (0x3f<<5) | (0x1f)其实就是二进制数：11111 111111 11111
Black：(0x00<<11) | (0x00<<5) | (0x00) 其实就是二进制数：00000 000000 00000

4)
程序：
MakeFile中
objs := head.o init.o nand.o interrupt.o serial.o lcddrv.o framebuffer.o lcdlib.o main.o lib/libc.a

lcd.bin: $(objs)
	${LD} -Tlcd.lds -o lcd_elf $^


打开链接脚本Tlcd.lds
SECTIONS {
    . = 0x00000000;
    .init : AT(0){ head.o init.o nand.o}
    . = 0x30000000;
    .text : AT(4096) { *(.text) }
    .rodata ALIGN(4) : AT((LOADADDR(.text)+SIZEOF(.text)+3)&~(0x03)) {*(.rodata*)} 
    .data ALIGN(4)   : AT((LOADADDR(.rodata)+SIZEOF(.rodata)+3)&~(0x03)) { *(.data) }
    __bss_start = .;
    .bss ALIGN(4)  : { *(.bss)  *(COMMON) }
    __bss_end = .;
}



说明程序从head.s开始
@******************************************************************************
@ File: head.S
@ 功能: 设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行
@******************************************************************************       
   
.extern     main
.text 
.global _start 
_start:
@******************************************************************************       
@ 中断向量，本程序中，除Reset和HandleIRQ外，其它异常都没有使用
@******************************************************************************       
    b   Reset

@ 0x04: 未定义指令中止模式的向量地址
HandleUndef:
    b   HandleUndef 
 
@ 0x08: 管理模式的向量地址，通过SWI指令进入此模式
HandleSWI:
    b   HandleSWI

@ 0x0c: 指令预取终止导致的异常的向量地址
HandlePrefetchAbort:
    b   HandlePrefetchAbort

@ 0x10: 数据访问终止导致的异常的向量地址
HandleDataAbort:
    b   HandleDataAbort

@ 0x14: 保留
HandleNotUsed:
    b   HandleNotUsed

@ 0x18: 中断模式的向量地址
    b   HandleIRQ

@ 0x1c: 快中断模式的向量地址
HandleFIQ:
    b   HandleFIQ

Reset:                  
    ldr sp, =4096           @ 设置栈指针，以下都是C函数，调用前需要设好栈
    bl  disable_watch_dog   @ 关闭WATCHDOG，否则CPU会不断重启
    bl  clock_init          @ 设置MPLL，改变FCLK、HCLK、PCLK
    bl  memsetup            @ 设置存储控制器以使用SDRAM
    bl  nand_init           @ 初始化NAND Flash
    
                            @ 复制代码到SDRAM中
    ldr r0, =0x30000000     @ 1. 目标地址 = 0x30000000，这是SDRAM的起始地址
    mov r1, #4096           @ 2. 源地址   = 4096，运行地址在SDRAM中的代码保存在NAND Flash 4096地址开始处
    mov r2, #16*1024        @ 3. 复制长度 = 16K，对于本实验，这是足够了
    bl  CopyCode2SDRAM      @ 调用C函数CopyCode2SDRAM
    
    bl  clean_bss           @ 清除bss段，未初始化或初值为0的全局/静态变量保存在bss段

    msr cpsr_c, #0xd2       @ 进入中断模式
    ldr sp, =0x31000000     @ 设置中断模式栈指针

    msr cpsr_c, #0xdf       @ 进入系统模式
    ldr sp, =0x34000000     @ 设置系统模式栈指针，

    ldr lr, =ret_initirq    @ 设置返回地址    
    ldr pc, =init_irq       @ 调用中断初始化函数
ret_initirq:
    msr cpsr_c, #0x5f       @ 设置I-bit=0，开IRQ中断

    ldr lr, =halt_loop      @ 设置返回地址
    ldr pc, =main           @ 调用main函数
(1)打开文件Lcdlib.c中
/* 
 * 以240x320,16bpp的显示模式测试TFT LCD
 */
void Test_Lcd_Tft_16Bit_240320(void)
{
    Lcd_Port_Init();                     // 设置LCD引脚
/*
 * 初始化用于LCD的引脚
 */
void Lcd_Port_Init(void)
{
    GPCUP   = 0xffffffff;   // 禁止内部上拉
    GPCCON  = 0xaaaaaaaa;   // GPIO管脚用于VD[7:0],LCDVF[2:0],VM,VFRAME,VLINE,VCLK,LEND 
    GPDUP   = 0xffffffff;   // 禁止内部上拉
    GPDCON  = 0xaaaaaaaa;   // GPIO管脚用于VD[23:8]
  	GPBCON &= ~(GPB0_MSK);  // Power enable pin
    GPBCON |= GPB0_out;
    GPBDAT &= ~(1<<0);			// GPB0是背光信号板，初始化时先设为低电平，即关闭
                                           背光显示
    printf("Initializing GPIO ports..........\n");
}



    Tft_Lcd_Init(MODE_TFT_16BIT_240320); // 初始化LCD控制器,这个最重要
/*
 * 初始化LCD控制器
 * 输入参数：
 * type: 显示模式
 *      MODE_TFT_8BIT_240320  : 240*320 8bpp的TFT LCD
 *      MODE_TFT_16BIT_240320 : 240*320 16bpp的TFT LCD
 *      MODE_TFT_8BIT_640480  : 640*480 8bpp的TFT LCD
 *      MODE_TFT_16BIT_640480 : 640*480 16bpp的TFT LCD
 */
void Tft_Lcd_Init(int type)
{
    switch(type)
    {
    case MODE_TFT_8BIT_240320:
        /* 
         * 设置LCD控制器的控制寄存器LCDCON1~5
         * 1. LCDCON1:
         *    设置VCLK的频率：VCLK(Hz) = HCLK/[(CLKVAL+1)x2]
         *    选择LCD类型: TFT LCD   
         *    设置显示模式: 8BPP
         *    先禁止LCD信号输出
         * 2. LCDCON2/3/4:
         *    设置控制信号的时间参数
         *    设置分辨率，即行数及列数
         * 现在，可以根据公式计算出显示器的频率：
         * 当HCLK=100MHz时，
         * Frame Rate = 1/[{(VSPW+1)+(VBPD+1)+(LIINEVAL+1)+(VFPD+1)}x
         *              {(HSPW+1)+(HBPD+1)+(HFPD+1)+(HOZVAL+1)}x
         *              {2x(CLKVAL+1)/(HCLK)}]
         *            = 60Hz
         * 3. LCDCON5:
         *    设置显示模式为8BPP时，调色板中的数据格式: 5:6:5
         *    设置HSYNC、VSYNC脉冲的极性(这需要参考具体LCD的接口信号): 反转
         *    字节交换使能
         */
        LCDCON1 = (CLKVAL_TFT_240320<<8) | (LCDTYPE_TFT<<5) | \
                  (BPPMODE_8BPP<<1) | (ENVID_DISABLE<<0);
        LCDCON2 = (VBPD_240320<<24) | (LINEVAL_TFT_240320<<14) | \
                  (VFPD_240320<<6) | (VSPW_240320);
        LCDCON3 = (HBPD_240320<<19) | (HOZVAL_TFT_240320<<8) | (HFPD_240320);
        LCDCON4 = HSPW_240320;
        LCDCON5 = (FORMAT8BPP_565<<11) | (HSYNC_INV<<9) | (VSYNC_INV<<8) | \
                  (BSWP<<1);

        /*
         * 设置LCD控制器的地址寄存器LCDSADDR1~3
         * 帧内存与视口(view point)完全吻合，
         * 图像数据格式如下(8BPP时，帧缓冲区中的数据为调色板中的索引值)：
         *         |----PAGEWIDTH----|
         *    y/x  0   1   2       239
         *     0   idx idx idx ... idx
         *     1   idx idx idx ... idx
         * 1. LCDSADDR1:
         *    设置LCDBANK、LCDBASEU
         * 2. LCDSADDR2:
         *    设置LCDBASEL: 帧缓冲区的结束地址A[21:1]
         * 3. LCDSADDR3:
         *    OFFSIZE等于0，PAGEWIDTH等于(240/2)
         */
        LCDSADDR1 = ((LCDFRAMEBUFFER>>22)<<21) | LOWER21BITS(LCDFRAMEBUFFER>>1);
        LCDSADDR2 = LOWER21BITS((LCDFRAMEBUFFER+ \
                    (LINEVAL_TFT_240320+1)*(HOZVAL_TFT_240320+1)*1)>>1);
        LCDSADDR3 = (0<<11) | (LCD_XSIZE_TFT_240320/2);

        /* 禁止临时调色板寄存器 */
        TPAL = 0;

        fb_base_addr = LCDFRAMEBUFFER;
        bpp = 8;
        xsize = 240;
        ysize = 320;
        
        break;

    //我们只用这个
    case MODE_TFT_16BIT_240320:
        ①配置LCD控制器
        /* 
         * 设置LCD控制器的控制寄存器LCDCON1~5
         * 1. LCDCON1:
         *    设置VCLK的频率：VCLK(Hz) = HCLK/[(CLKVAL+1)x2]
         *    选择LCD类型: TFT LCD   
         *    设置显示模式: 16BPP
         *    先禁止LCD信号输出：ENVID_DISABLE是LCD控制器开关
         * 2. LCDCON2/3/4:
         *    设置控制信号的时间参数
         *    设置分辨率，即行数及列数
           3.其中LCDCON2/3：设上下左右那几个数值VSPW VBPD VFPD HSPW HBPD HFPD
           4.LCDCON4：设BSWP = 0, HWSWP = 1
         * 现在，可以根据公式计算出显示器的刷新频率：
         * 当HCLK=100MHz时，
         * Frame Rate = 1/[{(VSPW+1)+(VBPD+1)+(LIINEVAL+1)+(VFPD+1)}x
         *              {(HSPW+1)+(HBPD+1)+(HFPD+1)+(HOZVAL+1)}x
         *              {2x(CLKVAL+1)/(HCLK)}]
         *            = 60Hz
         * 3. LCDCON5:
         *    设置显示模式为16BPP时的数据格式: 5:6:5
         *    设置HSYNC、VSYNC脉冲的极性是否需要反转(这需要参考具体LCD的接口信号): 需要反转(原先原理是高电平有效，如果
              这个LCD是低电平有效，则需要反转)
         *    半字(2字节)交换使能
         */
        LCDCON1 = (CLKVAL_TFT_240320<<8) | (LCDTYPE_TFT<<5) | \
                  (BPPMODE_16BPP<<1) | (ENVID_DISABLE<<0);
        LCDCON2 = (VBPD_240320<<24) | (LINEVAL_TFT_240320<<14) | \
                  (VFPD_240320<<6) | (VSPW_240320);
        LCDCON3 = (HBPD_240320<<19) | (HOZVAL_TFT_240320<<8) | (HFPD_240320);
        LCDCON4 = HSPW_240320;
        LCDCON5 = (FORMAT8BPP_565<<11) | (HSYNC_INV<<9) | (VSYNC_INV<<8) | \
                  (HWSWP<<1);

        ②配置Frame Buffer,用于保存像素数据
        /*
         * 设置LCD控制器的地址寄存器LCDSADDR1~3
         * 帧内存与视口(view point)完全吻合，
         * 图像数据格式如下：
         *         |----PAGEWIDTH----|
         *    y/x  0   1   2       239
         *     0   rgb rgb rgb ... rgb
         *     1   rgb rgb rgb ... rgb
         * 1. LCDSADDR1:
         *    设置LCDBANK、LCDBASEU
         * 2. LCDSADDR2:
         *    设置LCDBASEL: 帧缓冲区的结束地址A[21:1]
         * 3. LCDSADDR3:
         *    OFFSIZE等于0，PAGEWIDTH等于(240*2/2)
         */
        LCDSADDR1 = ((LCDFRAMEBUFFER>>22)<<21) | LOWER21BITS(LCDFRAMEBUFFER>>1);
        LCDSADDR2 = LOWER21BITS((LCDFRAMEBUFFER+ \
                    (LINEVAL_TFT_240320+1)*(HOZVAL_TFT_240320+1)*2)>>1);
        LCDSADDR3 = (0<<11) | (LCD_XSIZE_TFT_240320*2/2);

        /* 禁止临时调色板寄存器 */
        TPAL = 0;

        fb_base_addr = LCDFRAMEBUFFER;
        bpp = 16;
        xsize = 240;
        ysize = 320;

        break;

    case MODE_TFT_8BIT_640480:
        /* 
         * 设置LCD控制器的控制寄存器LCDCON1~5
         * 1. LCDCON1:
         *    设置VCLK的频率：VCLK(Hz) = HCLK/[(CLKVAL+1)x2]
         *    选择LCD类型: TFT LCD   
         *    设置显示模式: 8BPP
         *    先禁止LCD信号输出
         * 2. LCDCON2/3/4:
         *    设置控制信号的时间参数
         *    设置分辨率，即行数及列数
         * 现在，可以根据公式计算出显示器的频率：
         * 当HCLK=100MHz时，
         * Frame Rate = 1/[{(VSPW+1)+(VBPD+1)+(LIINEVAL+1)+(VFPD+1)}x
         *              {(HSPW+1)+(HBPD+1)+(HFPD+1)+(HOZVAL+1)}x
         *              {2x(CLKVAL+1)/(HCLK)}]
         *            = 60Hz
         * 3. LCDCON5:
         *    设置显示模式为8BPP时，调色板中的数据格式: 5:6:5
         *    设置HSYNC、VSYNC脉冲的极性(这需要参考具体LCD的接口信号): 反转
         *    字节交换使能
         */
        LCDCON1 = (CLKVAL_TFT_640480<<8) | (LCDTYPE_TFT<<5) | \
                  (BPPMODE_8BPP<<1) | (ENVID_DISABLE<<0);
        LCDCON2 = (VBPD_640480<<24) | (LINEVAL_TFT_640480<<14) | \
                  (VFPD_640480<<6) | (VSPW_640480);
        LCDCON3 = (HBPD_640480<<19) | (HOZVAL_TFT_640480<<8) | (HFPD_640480);
        LCDCON4 = HSPW_640480;
        LCDCON5 = (FORMAT8BPP_565<<11) | (HSYNC_INV<<9) | (VSYNC_INV<<8) | \
                  (BSWP<<1);

        /*
         * 设置LCD控制器的地址寄存器LCDSADDR1~3
         * 帧内存与视口(view point)完全吻合，
         * 图像数据格式如下(8BPP时，帧缓冲区中的数据为调色板中的索引值)：
         *         |----PAGEWIDTH----|
         *    y/x  0   1   2       639
         *     0   idx idx idx ... idx
         *     1   idx idx idx ... idx
         * 1. LCDSADDR1:
         *    设置LCDBANK、LCDBASEU
         * 2. LCDSADDR2:
         *    设置LCDBASEL: 帧缓冲区的结束地址A[21:1]
         * 3. LCDSADDR3:
         *    OFFSIZE等于0，PAGEWIDTH等于(640/2)
         */
        LCDSADDR1 = ((LCDFRAMEBUFFER>>22)<<21) | LOWER21BITS(LCDFRAMEBUFFER>>1);
        LCDSADDR2 = LOWER21BITS((LCDFRAMEBUFFER+ \
                    (LINEVAL_TFT_640480+1)*(HOZVAL_TFT_640480+1)*1)>>1);
        LCDSADDR3 = (0<<11) | (LCD_XSIZE_TFT_640480/2);

        /* 禁止临时调色板寄存器 */
        TPAL = 0;

        fb_base_addr = LCDFRAMEBUFFER;
        bpp = 8;
        xsize = 640;
        ysize = 480;
        
        break;
        
    case MODE_TFT_16BIT_640480:
        /* 
         * 设置LCD控制器的控制寄存器LCDCON1~5
         * 1. LCDCON1:
         *    设置VCLK的频率：VCLK(Hz) = HCLK/[(CLKVAL+1)x2]
         *    选择LCD类型: TFT LCD   
         *    设置显示模式: 16BPP
         *    先禁止LCD信号输出
         * 2. LCDCON2/3/4:
         *    设置控制信号的时间参数
         *    设置分辨率，即行数及列数
         * 现在，可以根据公式计算出显示器的频率：
         * 当HCLK=100MHz时，
         * Frame Rate = 1/[{(VSPW+1)+(VBPD+1)+(LIINEVAL+1)+(VFPD+1)}x
         *              {(HSPW+1)+(HBPD+1)+(HFPD+1)+(HOZVAL+1)}x
         *              {2x(CLKVAL+1)/(HCLK)}]
         *            = 60Hz
         * 3. LCDCON5:
         *    设置显示模式为16BPP时的数据格式: 5:6:5
         *    设置HSYNC、VSYNC脉冲的极性(这需要参考具体LCD的接口信号): 反转
         *    半字(2字节)交换使能
         */
        LCDCON1 = (CLKVAL_TFT_640480<<8) | (LCDTYPE_TFT<<5) | \
                  (BPPMODE_16BPP<<1) | (ENVID_DISABLE<<0);
        LCDCON2 = (VBPD_640480<<24) | (LINEVAL_TFT_640480<<14) | \
                  (VFPD_640480<<6) | (VSPW_640480);
        LCDCON3 = (HBPD_640480<<19) | (HOZVAL_TFT_640480<<8) | (HFPD_640480);
        LCDCON4 = HSPW_640480;
        LCDCON5 = (FORMAT8BPP_565<<11) | (HSYNC_INV<<9) | (VSYNC_INV<<8) | \
                  (HWSWP<<1);

        /*
         * 设置LCD控制器的地址寄存器LCDSADDR1~3
         * 帧内存与视口(view point)完全吻合，
         * 图像数据格式如下：
         *         |----PAGEWIDTH----|
         *    y/x  0   1   2       639
         *     0   rgb rgb rgb ... rgb
         *     1   rgb rgb rgb ... rgb
         * 1. LCDSADDR1:
         *    设置LCDBANK、LCDBASEU
         * 2. LCDSADDR2:
         *    设置LCDBASEL: 帧缓冲区的结束地址A[21:1]
         * 3. LCDSADDR3:
         *    OFFSIZE等于0，PAGEWIDTH等于(640*2/2)
         */
        LCDSADDR1 = ((LCDFRAMEBUFFER>>22)<<21) | LOWER21BITS(LCDFRAMEBUFFER>>1);
        LCDSADDR2 = LOWER21BITS((LCDFRAMEBUFFER+ \
                    (LINEVAL_TFT_640480+1)*(HOZVAL_TFT_640480+1)*2)>>1);
        LCDSADDR3 = (0<<11) | (LCD_XSIZE_TFT_640480*2/2);

        /* 禁止临时调色板寄存器 */
        TPAL = 0;

        fb_base_addr = LCDFRAMEBUFFER;
        bpp = 16;
        xsize = 640;
        ysize = 480;

        break;

    default:
        break;
    }   
}


    Lcd_PowerEnable(0, 1);               // 设置LCD_PWREN有效，它用于打开LCD的电源

/*
 * 设置是否输出LCD电源开关信号LCD_PWREN
 * 输入参数：
 *     invpwren: 0 - LCD_PWREN有效时为正常极性
 *               1 - LCD_PWREN有效时为反转极性
 *     pwren:    0 - LCD_PWREN输出有效
 *               1 - LCD_PWREN输出无效
 */
void Lcd_PowerEnable(int invpwren, int pwren)
{
    GPGCON = (GPGCON & (~(3<<8))) | (3<<8);   // GPG4用作LCD_PWREN
    GPGUP  = (GPGUP & (~(1<<4))) | (1<<4);    // 禁止内部上拉    
        
    LCDCON5 = (LCDCON5 & (~(1<<5))) | (invpwren<<5);  // 设置LCD_PWREN的极性: 正常/反转
    LCDCON5 = (LCDCON5 & (~(1<<3))) | (pwren<<3);     // 设置是否输出LCD_PWREN
}  

    Lcd_EnvidOnOff(1);                   // 使能LCD控制器输出信号，作用使能或禁能LCD

/*
 * 设置LCD控制器是否输出信号
 * 输入参数：
 * onoff: 
 *      0 : 关闭
 *      1 : 打开
 */
void Lcd_EnvidOnOff(int onoff)
{
    if (onoff == 1)
    {
        LCDCON1 |= 1;         // ENVID ON
		GPBDAT |= (1<<0);// Power on背光打开
    }
    else
    {
        LCDCON1 &= 0x3fffe;  // ENVID Off
	    GPBDAT &= ~(1<<0);	 // Power off背光关闭
    }
}    


    //开始在FrameBuffer上画东西了
    ClearScr(0x0);  // 清屏，黑色
    printf("[TFT 64K COLOR(16bpp) LCD TEST]\n");

    printf("1. Press any key to draw line\n");
    getc();
    DrawLine(0  , 0  , 239, 0  , 0xff0000);     // 红色
    DrawLine(0  , 0  , 0  , 319, 0x00ff00);     // 绿色
    DrawLine(239, 0  , 239, 319, 0x0000ff);     // 蓝色
    DrawLine(0  , 319, 239, 319, 0xffffff);     // 白色
    DrawLine(0  , 0  , 239, 319, 0xffff00);     // 黄色
    DrawLine(239, 0  , 0  , 319, 0x8000ff);     // 紫色
    DrawLine(120, 0  , 120, 319, 0xe6e8fa);     // 银色
    DrawLine(0  , 160, 239, 160, 0xcd7f32);     // 金色

/* 
 * 画线
 * 输入参数：
 *     x1、y1 : 起点坐标
 *     x2、y2 : 终点坐标
 *     color  : 颜色值
 *         对于16BPP: color的格式为0xAARRGGBB (AA = 透明度),
 *     需要转换为5:6:5格式
 *         对于8BPP: color为调色板中的索引值，
 *     其颜色取决于调色板中的数值
 */
void DrawLine(int x1,int y1,int x2,int y2,int color)
{
    int dx,dy,e;
    dx=x2-x1; 
    dy=y2-y1;
    
    if(dx>=0)
    {
        if(dy >= 0) // dy>=0
        {
            if(dx>=dy) // 1/8 octant
            {
                e=dy-dx/2;
                while(x1<=x2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){y1+=1;e-=dx;}   
                    x1+=1;
                    e+=dy;
                }
            }
            else        // 2/8 octant
            {
                e=dx-dy/2;
                while(y1<=y2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){x1+=1;e-=dy;}   
                    y1+=1;
                    e+=dx;
                }
            }
        }
        else           // dy<0
        {
            dy=-dy;   // dy=abs(dy)

            if(dx>=dy) // 8/8 octant
            {
                e=dy-dx/2;
                while(x1<=x2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){y1-=1;e-=dx;}   
                    x1+=1;
                    e+=dy;
                }
            }
            else        // 7/8 octant
            {
                e=dx-dy/2;
                while(y1>=y2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){x1+=1;e-=dy;}   
                    y1-=1;
                    e+=dx;
                }
            }
        }   
    }
    else //dx<0
    {
        dx=-dx;     //dx=abs(dx)
        if(dy >= 0) // dy>=0
        {
            if(dx>=dy) // 4/8 octant
            {
                e=dy-dx/2;
                while(x1>=x2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){y1+=1;e-=dx;}   
                    x1-=1;
                    e+=dy;
                }
            }
            else        // 3/8 octant
            {
                e=dx-dy/2;
                while(y1<=y2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){x1-=1;e-=dy;}   
                    y1+=1;
                    e+=dx;
                }
            }
        }
        else           // dy<0
        {
            dy=-dy;   // dy=abs(dy)

            if(dx>=dy) // 5/8 octant
            {
                e=dy-dx/2;
                while(x1>=x2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){y1-=1;e-=dx;}   
                    x1-=1;
                    e+=dy;
                }
            }
            else        // 6/8 octant
            {
                e=dx-dy/2;
                while(y1>=y2)
                {
                    PutPixel(x1,y1,color);
                    if(e>0){x1-=1;e-=dy;}   
                    y1-=1;
                    e+=dx;
                }
            }
        }   
    }
}


/* 
 * 画点
 * 输入参数：
 *     x、y : 象素坐标
 *     color: 颜色值
 *         对于16BPP: color的格式为0xAARRGGBB (AA = 透明度),
 *     需要转换为5:6:5格式
 *         对于8BPP: color为调色板中的索引值，
 *     其颜色取决于调色板中的数值
 */
void PutPixel(UINT32 x, UINT32 y, UINT32 color)
{
    UINT8 red,green,blue;

    switch (bpp){
        case 16:
        {
            //fb_base_addr是FrameBuffer的起始地址，再加上x，y的偏移，得到真正像素点应该在
            哪里
            UINT16 *addr = (UINT16 *)fb_base_addr + (y * xsize + x);
            red   = (color >> 19) & 0x1f; // 5 BIT
            green = (color >> 10) & 0x3f; // 6 bit
            blue  = (color >>  3) & 0x1f; // 5 bit
            color = (red << 11) | (green << 5) | blue; // 格式5:6:5
            *addr = (UINT16) color;
            break;
        }
        
        case 8:
        {
            UINT8 *addr = (UINT8 *)fb_base_addr + (y * xsize + x);
            *addr = (UINT8) color;
            break;
        }

        default:
            break;
    }
}

    printf("2. Press any key to draw circles\n");
    getc();
    Mire();

    printf("3. Press any key to fill the screem with one color\n");
    getc();
    ClearScr(0xff0000);             // 红色

    printf("4. Press any key to fill the screem by temporary palette\n");
    getc();
    ClearScrWithTmpPlt(0x0000ff);   // 蓝色
清屏的第一种方法
/* 
 * 将屏幕清成单色
 * 输入参数：
 *     color: 颜色值
 *         对于16BPP: color的格式为0xAARRGGBB (AA = 透明度),
 *     需要转换为5:6:5格式
 *         对于8BPP: color为调色板中的索引值，
 *     其颜色取决于调色板中的数值
 */
void ClearScr(UINT32 color)
{   
    UINT32 x,y;
    
    for (y = 0; y < ysize; y++)
        for (x = 0; x < xsize; x++)
            PutPixel(x, y, color);
}

清屏的第二种方法：把一种颜色写到寄存器TPAL中，然后使能这个寄存器，LCD控制器就会从
TPAL中取值，将LCD全部填充了，而不会到FrameBuffer中取数据了
/*
 * 使用临时调色板寄存器输出单色图像
 * 输入参数：
 *     color: 颜色值，格式为0xRRGGBB
 */
void ClearScrWithTmpPlt(UINT32 color)
{
    TPAL = (1<<24)|((color & 0xffffff)<<0);//(1<<24)是他的使能信号，((color & 0xffffff)<<0)是颜色值
}    

    printf("5. Press any key stop the testing\n");
    getc();
    Lcd_EnvidOnOff(0);关闭LCD
}





halt_loop:
    b   halt_loop

HandleIRQ:
    sub lr, lr, #4                  @ 计算返回地址
    stmdb   sp!,    { r0-r12,lr }   @ 保存使用到的寄存器
                                    @ 注意，此时的sp是中断模式的sp
                                    @ 初始值是上面设置的4096
    
    ldr lr, =int_return             @ 设置调用IRQ_Handle函数后的返回地址  
    ldr pc, =IRQ_Handle             @ 调用中断分发函数，在interrupt.c中
int_return:
    ldmia   sp!,    { r0-r12,pc }^  @ 中断返回, ^表示将spsr的值复制到cpsr
    


*触摸屏原理：按照工作原理和传输信息的介质不同，触摸屏分为电阻式、电容感应式、红
外线式以及表面声波式。当触笔接触屏幕时，相应的ADC 管脚分别测量X、Y 两个方向的电阻分压。这就构
成了四线电阻式触摸屏的硬件系统。


先初始化了触摸屏的ADC 中断，并在中断中刷新了我们的全局变量xdata 和ydata 的数值
->然后点击屏幕时能得到它的x与y的值

1、ADC原理：
ADC：通过一个模数转换器，将输入的电压值转过来为输出数字信号
一般模拟输入脚AIN4，AIN5，ANI6,ANI7被用作丝线电阻触摸的YM,YP,XM,XP通道。AIN0-AIN3被引出，
其中在实验板上，AIN0和一个可调电阻W1连接，用来做AD测试
1)ADC驱动流程：初始化->启动ADC->等待转换完成INT_ADC->读取转换结果
初始化：
配置转换精度，采样频率，转换通道


2)
例：
main()
{
    while(1)
    {
	    //(1)AIN0初始化
	    init_adc_ain0();
	    //(2)启动ADC，AIN0
	    start_adc_ain0();
	    //(3)轮询等待转换结束
	    while(1)
	    {
	    	if(end_adc_ain0())
	    		break;
	    }
	    //(4)读取ain0转换结果
	    data=read_adc_ain0();//0-1024之间
	    //(5)计算对应转换的电压值
	    //data/1024*3.3
    }
}

2、触摸屏
1)原理
     y+
  |       |
x0|    +  |x+
  |       |
  ---------
       y0
其中y now ，X now等需要先分频，再通过ADC进行转成数字信号，再计算。这样才会比较准
其中看y坐标，需要看x输入的电压值；看x坐标，需要看y输入的电压值
因此该点的x，y电压值是
    y now 
y=  ----- *height
    y all

    x now 
x=  ----- *weight
    x all

一般模拟输入脚AIN4，AIN5，ANI6,ANI7被用作丝线电阻触摸的YM(y0接地),YP(y now)y轴电压输入,
XM(x0接地),XP(x now)通道

INT_PENDNUP寄存器，触摸笔按下，或弹起，触发的中断

2)
SEL_MUX选择输入通道的寄存器
YM_SEN，YP_SEN，XM_SEN，XP_SEN使能
AUTO_PST选择x，y坐标转换模式是分别转换，还是一起转换
XY_PST要设成11，为等待中断模式
XPDATA，YPDATA读X坐标和Y坐标

3)触摸工作流程
(1)初始化
①触摸屏：转换精度，采样频率，转换通道
②中断：int_adcAD 转换器,int_pen触摸笔
③设为等待中断模式
SEL_MUX选择输入通道的寄存器
YM_SEN，YP_SEN，XM_SEN，XP_SEN使能
AUTO_PST选择x，y坐标转换模式是分别转换，还是一起转换
XY_PST要设成11，为等待中断模式

(1)设置触摸屏接口为等待中断模式，等待触摸屏被按下
(2)如果中断INT_PENDNUP发生，选择x，y坐标转换模式(坐标先转x再转y模式，或者xy坐标一起转换模式)，启动AD转换
(3)当AD转换完成后，通过中断INT_ADC，获取x/y数字值坐标，ADCDAT0 bit[9:0]-x坐标,ADCDAT1 bit[9:0]-y坐标
(4)设置触摸屏接口为等待中断模式，等待触摸屏弹起
(5)返回(1)，继续等待

4)例：
1)、
触摸屏中断初始化
    
void Test_Touchpanel(void)
{
   
	rADCDLY=50000;                  //Normal conversion mode delay about (1/3.6864M)*50000=13.56ms
	rADCCON=(1<<14)+(ADCPRS<<6);   //ADCPRS En, ADCPRS Value

	Uart_Printf("\nTouch Screen test\n");

	rADCTSC=0xd3;  //Wfait,XP_PU,XP_Dis,XM_Dis,YP_Dis,YM_En

	pISR_ADC = (int)AdcTsAuto;
	rINTMSK=~BIT_ADC;       //ADC Touch Screen Mask bit clear
	rINTSUBMSK=~(BIT_SUB_TC);

	Uart_Printf("\nPress any key to quit!\n");
	Uart_Printf("\nStylus Down, please...... \n");
	Uart_Getch();

	rINTSUBMSK|=BIT_SUB_TC;
	rINTMSK|=BIT_ADC;
	Uart_Printf("Touch Screen Test is Finished!!!\n");

}

(2)
触摸屏中断程序捕捉处理
void __irq AdcTsAuto(void)
{
	U32 saveAdcdly;

        //①等待有触摸笔按下或弹起来触发中断        
        {
	   if(rADCDAT0&0x8000)//第15位表示UPDOWN寄存器，0表示触摸笔按下，1表示弹起
	   {
		//Uart_Printf("\nStylus Up!!\n");
		rADCTSC&=0xff;	// Set stylus down interrupt bit
	   }
	   //else 
		//Uart_Printf("\nStylus Down!!\n");
        }

        ②配置等待转换
	rADCTSC=(1<<3)|(1<<2);         //Pull-up disable, Seq. X,Y postion measure.
	saveAdcdly=rADCDLY;
	rADCDLY=40000;                 //Normal conversion mode delay about (1/50M)*40000=0.8ms

	rADCCON|=0x1;                   //start ADC

        //③等待转换完，触发中断INT_ADC
	while(rADCCON & 0x1);		//check if Enable_start is low
	while(!(rADCCON & 0x8000));        //check if EC(End of Conversion) flag is high, This line is necessary~!!
		
	while(!(rSRCPND & (BIT_ADC)));  //check if ADC is finished with interrupt bit

        //④获取x，y的坐标
	xdata=(rADCDAT0&0x3ff);
 	ydata=(rADCDAT1&0x3ff);

	//check Stylus Up Interrupt.
	rSUBSRCPND|=BIT_SUB_TC;
	ClearPending(BIT_ADC);//清掉本次中断号
	rINTSUBMSK=~(BIT_SUB_TC);
	rINTMSK=~(BIT_ADC);
			 
	rADCTSC =0xd3;    //Waiting for interrupt
	rADCTSC=rADCTSC|(1<<8); // Detect stylus up interrupt signal.

        //⑤等待有触摸笔弹起来触发中断  
	while(1)		//to check Pen-up state
	{
		if(rSUBSRCPND & (BIT_SUB_TC))	//check if ADC is finished with interrupt bit
		{
			//Uart_Printf("Stylus Up Interrupt~!\n");
			break;	//if Stylus is up(1) state
		}
	}	

	Uart_Printf("count=%03d  XP=%04d, YP=%04d\n", count++, xdata, ydata);    //X-position Conversion data            

	rADCDLY=saveAdcdly; 
	rADCTSC=rADCTSC&~(1<<8); // Detect stylus Down interrupt signal.
	rSUBSRCPND|=BIT_SUB_TC;
	rINTSUBMSK=~(BIT_SUB_TC);	// Unmask sub interrupt (TC)     
	ClearPending(BIT_ADC);
}

2)、//可以缩小倍数来显示图片
void Paint_Bmp1(int x0,int y0,int h,int l,int k,unsigned char bmp[])
{
	int x,y;
	U32 c;
	int p = 0;
	h=h/k;
	l=l/k;
	for( y = 0 ; y < l ; y++ )
	{
		for( x = 0 ; x < h ; x++ )
		{
			c = bmp[p+1] | (bmp[p]<<8) ;
			if ( ( (x0+x) < SCR_XSIZE_TFT) && ( (y0+y) < SCR_YSIZE_TFT) )
				LCD_BUFFER[y0+y][x0+x] = c ;
			p = p + 2*k;
		}
		p=p+640*(k-1);
	}
}

3)、由于电阻式触摸屏的电阻分布并不是理想的线性关系，经坐标变换计算所得
的显示屏上的坐标会与笔触点实际位置存在一定的偏差。

*字库移植
字库在Font_Libs.c中

1、显示驱动
TFT LCD单个象素的显示数据输出
void PutPixel(U32 x,U32 y, U32 c )
{
	if ( (x < SCR_XSIZE_TFT) && (y < SCR_YSIZE_TFT) )
		LCD_BUFFER[(y)][(x)] = c;
}

TFT LCD全屏填充特定颜色单元或清屏
void Lcd_ClearScr( U32 c)
{
	unsigned int x,y ;
		
    for( y = 0 ; y < SCR_YSIZE_TFT ; y++ )
    {
    	for( x = 0 ; x < SCR_XSIZE_TFT ; x++ )
    	{
			LCD_BUFFER[y][x] = c ;
    	}
    }
}

LCD屏幕显示垂直翻转
// LCD display is flipped vertically
// But, think the algorithm by mathematics point.
//   3I2
//   4 I 1
//  --+--   <-8 octants  mathematical cordinate
//   5 I 8
//   6I7
void Glib_Line(int x1,int y1,int x2,int y2,int color)
{
	int dx,dy,e;
	dx=x2-x1; 
	dy=y2-y1;
    
	if(dx>=0)
	{
		if(dy >= 0) // dy>=0
		{
			if(dx>=dy) // 1/8 octant
			{
				e=dy-dx/2;
				while(x1<=x2)
				{
					PutPixel(x1,y1,color);
					if(e>0){y1+=1;e-=dx;}	
					x1+=1;
					e+=dy;
				}
			}
			else		// 2/8 octant
			{
				e=dx-dy/2;
				while(y1<=y2)
				{
					PutPixel(x1,y1,color);
					if(e>0){x1+=1;e-=dy;}	
					y1+=1;
					e+=dx;
				}
			}
		}
		else		   // dy<0
		{
			dy=-dy;   // dy=abs(dy)

			if(dx>=dy) // 8/8 octant
			{
				e=dy-dx/2;
				while(x1<=x2)
				{
					PutPixel(x1,y1,color);
					if(e>0){y1-=1;e-=dx;}	
					x1+=1;
					e+=dy;
				}
			}
			else		// 7/8 octant
			{
				e=dx-dy/2;
				while(y1>=y2)
				{
					PutPixel(x1,y1,color);
					if(e>0){x1+=1;e-=dy;}	
					y1-=1;
					e+=dx;
				}
			}
		}	
	}
	else //dx<0
	{
		dx=-dx;		//dx=abs(dx)
		if(dy >= 0) // dy>=0
		{
			if(dx>=dy) // 4/8 octant
			{
				e=dy-dx/2;
				while(x1>=x2)
				{
					PutPixel(x1,y1,color);
					if(e>0){y1+=1;e-=dx;}	
					x1-=1;
					e+=dy;
				}
			}
			else		// 3/8 octant
			{
				e=dx-dy/2;
				while(y1<=y2)
				{
					PutPixel(x1,y1,color);
					if(e>0){x1-=1;e-=dy;}	
					y1+=1;
					e+=dx;
				}
			}
		}
		else		   // dy<0
		{
			dy=-dy;   // dy=abs(dy)

			if(dx>=dy) // 5/8 octant
			{
				e=dy-dx/2;
				while(x1>=x2)
				{
					PutPixel(x1,y1,color);
					if(e>0){y1-=1;e-=dx;}	
					x1-=1;
					e+=dy;
				}
			}
			else		// 6/8 octant
			{
				e=dx-dy/2;
				while(y1>=y2)
				{
					PutPixel(x1,y1,color);
					if(e>0){x1-=1;e-=dy;}	
					y1-=1;
					e+=dx;
				}
			}
		}	
	}
}


在LCD屏幕上画一个矩形
void Glib_Rectangle(int x1,int y1,int x2,int y2,int color)
{
    Glib_Line(x1,y1,x2,y1,color);
    Glib_Line(x2,y1,x2,y2,color);
    Glib_Line(x1,y2,x2,y2,color);
    Glib_Line(x1,y1,x1,y2,color);
}


在LCD屏幕上用颜色填充一个矩形
void Glib_FilledRectangle(int x1,int y1,int x2,int y2,int color)
{
    int i;

    for(i=y1;i<=y2;i++)
	Glib_Line(x1,i,x2,i,color);
}


在LCD屏幕上指定坐标点画一个指定大小的图片
void Paint_Bmp(int x0,int y0,int h,int l,unsigned char bmp[])
{
	int x,y;
	U32 c;
	int p = 0;
	
    for( y = y0 ; y < l ; y++ )
    {
    	for( x = x0 ; x < h ; x++ )
    	{
    		c = bmp[p+1] | (bmp[p]<<8) ;

			if ( ( (x0+x) < SCR_XSIZE_TFT) && ( (y0+y) < SCR_YSIZE_TFT) )
				LCD_BUFFER[y0+y][x0+x] = c ;
			
    		p = p + 2 ;
    	}
    }
}


在LCD屏幕上指定坐标点写ASCII码
void Lcd_PutASCII(unsigned int x,unsigned int y,unsigned char ch,unsigned int c,unsigned int bk_c,unsigned int st)
{
       unsigned short int i,j;
       unsigned char *pZK,mask,buf;
	
	

       pZK = &__VGA[ch*16];
       for( i = 0 ; i < 16 ; i++ )
       {
              mask = 0x80;
              buf = pZK[i];
              for( j = 0 ; j < 8 ; j++ )
              {
                     if( buf & mask )
                     {
                            PutPixel(x+j,y+i,c);
                     }
                     else
                     {
                            if( !st )
                            {
                                   PutPixel(x+j,y+i,bk_c);
                            }
                     }
            
                     mask = mask >> 1;
              }
       }
}


在LCD屏幕上指定坐标点写汉字
void Lcd_PutHZ(unsigned int x,unsigned int y,unsigned short int QW,unsigned int c,unsigned int bk_c,unsigned int st)
{
       unsigned short int i,j;
       unsigned char *pZK,mask,buf;

       pZK = &__CHS[ (  ( (QW >> 8) - 1 )*94 + (QW & 0x00FF)- 1 )*32 ];
       for( i = 0 ; i < 16 ; i++ )
       {
              //左
              mask = 0x80;
              buf = pZK[i*2];
              for( j = 0 ; j < 8 ; j++ )
              {
                     if( buf & mask )
                     {
                            PutPixel(x+j,y+i,c);
                     }
                     else
                     {
                            if( !st )
                            {
                                   PutPixel(x+j,y+i,bk_c);
                            }
                     }
                     mask = mask >> 1;
              } 
        
              //右
              mask = 0x80;
              buf = pZK[i*2 + 1];
              for( j = 0 ; j < 8 ; j++ )
              {
                     if( buf & mask )
                     {
                            PutPixel(x+j + 8,y+i,c);
                     }
                     else
                     {
                            if( !st )
                            {
                                   PutPixel(x+j + 8,y+i,bk_c);
                            }
                     }
                     mask = mask >> 1;
              }                 
       }
}

//----------------------

void Lcd_printf(unsigned int x,unsigned int y,unsigned int c,unsigned int bk_c,unsigned int st,char *fmt,...)
{
       char __LCD_Printf_Buf[256];
       va_list ap;
       unsigned char *pStr = (unsigned char *)__LCD_Printf_Buf;
       unsigned int i = 0;

       va_start(ap,fmt);
       vsprintf(__LCD_Printf_Buf,fmt,ap);
       va_end(ap);
	 
       while(*pStr != 0 )
       {
              switch(*pStr)
              {
                     case '\n' :
                            {
			
                                   break;
                            }

                     default:
                            {
                                   if( *pStr > 0xA0 & *(pStr+1) > 0xA0 )  //中文输出
                                   {
                                          Lcd_PutHZ( x , y , (*pStr - 0xA0)*0x0100 + *(pStr+1) - 0xA0 , c , bk_c , st);

                                          pStr++;
                                          i++;

                                          x += 16;
                                   }
                                   else               //英文输出
                                   {
                                          Lcd_PutASCII( x , y , *pStr , c , bk_c , st );

                                          x += 8;

                                   }

                                   break;
                            }
              }
		
              pStr++;
              i++;		

              if( i > 256 ) break;
       }
   
}

2、测试程序
void Ziku_Test( void ) 
{
     unsigned int i = 0;
      
        //显示中文
	//在LCD上打印日期，星期，时间
	Lcd_printf(0,65,RGB( 0xFF,0xFF,0xFF),RGB( 0x00,0x00,0x00),0,"时间:%4d-%02d-%02d 星期%d  %02d:%02d:%02d\n",
       	      rYear, rMonth, rDay,rDayOfWeek, rHour, rMinute, rSecond);

	Lcd_printf(84,92,RGB( 0xFF,0xFF,0xFF),RGB( 0x00,0x00,0x00),1," uC/OS2任务演示");
	Lcd_printf(89,122,RGB( 0xFF,0xFF,0xFF),RGB( 0x00,0x00,0x00),0,"任务 计数中:%02d" , i);
	
        //显示英文 
	Lcd_ClearScr((0x3f<<5) | (0x1f) );//刷屏刷为青色
       for(i=1;i<10;i++)
       {//画坐标为50 为一格的格子，方便查看字的位置
            Glib_Line(0,50*i,320,50*i,0x0000);
            Glib_Line(50*i,0,50*i,240,0x0000);
       }

	  
       //while(1)
       //{
              Lcd_PutASCII(50,100,'c',0x0000,0xffff,1);
              Lcd_PutASCII(100,100,'h',0x0000,0xffff,0);
              Lcd_PutASCII(150,100,'c',0x0000,0x001f,0);
              Lcd_PutASCII(158,100,'h',0x0000,0x001f,0);
              Lcd_PutASCII(166,100,'i',0x0000,0x001f,0);
              Lcd_PutASCII(174,100,'n',0x0000,0x001f,0);
              Lcd_PutASCII(182,100,'a',0x0000,0x001f,0);
       //}
}       


//**************
//cortext深入
//**************
*
cortex的gpio处理函数
1.把这个脚设为gpio后，把它设为输入模式，即可以得到它的输入值。需要去抖动。对于底层来说，它的
寄存器有通过轮询采样它的上升沿，但对于软件来说，只要得到它的输入是高或低电平即可
2.不用再设寄存器设置它接收外部中断，因为一般这个都是用于uart,iic,spi总线上的，产生中断后，
它会跳转到中断向量表中，一般default它是丢弃。我们只需要在这个中断项量中添加自己的中断处理
函数即可。

*iic总线与spi总线的区别：iic慢，spi快
1)
我们主板上要对芯片使用iic总线，还是spi总线，并不是由我们决定的，而是由所选芯片决定的。看该芯片
支持哪种总线访问。这是由该芯片的厂商，去买这个总线的授权，然后才能支持该芯片的。
一般现在的芯片，都支持两种总线访问，只需要通过设置一下，就可以选择访问的总线类型。
iic总线：前面有一个设备地址码，主板发送地址，就能选通某个设备了。
spi总线：没有设备地址码的概念，一条总线挂上多个设备，通过片选cs引脚来选通，看哪个设备要起作用，
就将那个设备的cs片选拉低。
spi总线原理

cs--|_________________________________________|---------
sclk  _|-|_|-|_|-|_|-|_|-|_|-|_|-|_|-|_|-|_|-|_
si   --|_|-|_|-........
so   ..................--|_|-|_|-

cs片选拉低时，该芯片有效。sclk是时钟。si是主板先发送数据(一般是要访问的数据的地址)给芯片,然后
等待该芯片通过so返回数据给主板

2)我们目前板子上，大部分设备如flash,字库，lcd都使用spi总线，其中除了lcd使用io口自己模拟spi总线
调用以外，其它都使用板子上的spi总线寄存器进行收发。这样子更方便，像串口收发一样。
目前只有rtc使用iic总线读取

//**************
//ucosII操作系统
//**************
*内核结构
1、任务状态，任务状态图
                        WAITING(等待状态) 
DORMANT(睡眠状态)   READY      RUNNING         ISR

睡眠态（DORMANT）:任务编写后，写放在这里，只有创建了之后，才进入就绪态
READY，RUNNING：任务创建了之后，进入就绪态。优先级最高的，被调度入运行态
调用OSStart()任务，用来开始可以启动多任务系统，系统开始运行。
WAITING(等待状态)：正在运行的任务通过OSTimeDly()或OSTimeDlyHMSM()进入等待状态，等待这段时间                过去，重新进入就绪态
正在运行的任务期待某一事件的发生时也要等待，手段是调用以下3个函数之一：OSSemPend()，                OSMboxPend()，或OSQPend()。调用后任务进入了等待状态（WAITING）。
中断服务态（ISR）：程序在运行时，如果有触发中断->原来在运行态的任务被挂起，放入等待态，系统       开始处理响应中断->中断服务子程序报告一个或多个事件的发生，将这些事件放入就绪态->查看各       中断事件，如果优先级较高，先将该事件放入运行态。如果优先级没有原就绪态里面的事件高，则       先执行原就绪态的任务，之后再执行中断事件->等到所有中断事件都执行完了之后，恢复挂起的运       行任务，恢复现场 
当所有的任务都挂起，在等待事件发生或等待延迟时间结束，μC/OS-Ⅱ执行空闲任务（idle task），执行OSTaskIdle()函数。

2、给调度器加锁OSSchedlock()和解锁OSSchedUnlock()
在运行态的任务，如果加锁OSSchedlock()，则尽管有个优先级更高的任务进入了就绪态，也不会被调度。然而，此时中断是可以被识别的，中断服务也能得到。函数OSSchedLock()和OSSchedUnlock()的使用要非常谨慎，因为它们影响μC/OS-Ⅱ对任务的正常管理。

3、空闲任务和统计任务 
1)空闲任务：它的优先级最低，即OS_LOWEST_PRI0。空闲任务OSTaskIdle()什么也不做，只是在不停地给一个32位的名叫OSIdleCtr的计数器加1，统计任务使用这个计数器以确定现行应用软件实际消耗的CPU时间。空闲任务不可能被应用软件删除。void OSTaskIdle (void *pdata)

2)统计任务：OS_TaskStat()告诉用户应用程序使用了多少CPU时间 

4、时钟节拍： μC/OS需要用户提供周期性信号源，用于实现时间延时和确认超时。节拍率应在每秒10次到100次之间，或者说10到100Hz。用户必须在多任务系统启动以后再开启时钟节拍器，也就是在调用OSStart()之后。换句话说，在调用OSStart()之后做的第一件事是初始化定时器中断。

5、初始化和启动
OSInit()，建立空闲任务和统计任务
OSStart()至少要建立一个应用任务，再启动任务
例：
void main (void) 
{ 
    OSInit();           /* 初始化uC/OS-II                            */
     .
     .
     通过调用OSTaskCreate()或OSTaskCreateExt()创建至少一个任务;
     .
     .
    OSStart();          /* 开始多任务调度!OSStart()永远不会返回 */
}
 
6、获取当前μC/OS-Ⅱ的版本号,OSVersion()函数返回版本号值乘以100。换言之，200表示版本号2.00。



*任务管理
1、任务可以是一个无限的循环，也可以是在一次执行完毕后被删除掉。这里要注意的是，任务代码并不是被真正的删除了，而只是μC/OS-Ⅱ不再理会该任务代码，所以该任务代码不会再运行。一个任务与C函数类似，但是有不同的地方，既是有一个参数，而且它从不返回。因此，任务的返回类型必须被定义成void型。
μC/OS-Ⅱ可以管理多达64个任务，并从中保留了四个最高优先级和四个最低优先级的任务供自己使用，所以用户可以使用的只有56个任务。任务的优先级越高，反映优先级的值则越低。在最新的μC/OS-Ⅱ版本中，任务的优先级数也可作为任务的标识符使用。
无限循环使用：
void YourTask (void *pdata) 
 
{ 
 
    for (;;) { 
 
        /* 用户代码 */ 
 
        调用μC/OS-Ⅱ的服务例程之一:
 
            OSMboxPend();
 
            OSQPend();
 
            OSSemPend();
 
            OSTaskDel(OS_PRIO_SELF);
 
            OSTaskSuspend(OS_PRIO_SELF); 
 
            OSTimeDly();
 
            OSTimeDlyHMSM();
 
        /* 用户代码 */
 
    } 
 
} 

执行一次： 
void YourTask (void *pdata)
 
{ 
 
    /* 用户代码 */ 
 
    OSTaskDel(OS_PRIO_SELF);
 
}
 
2、建立任务:任务的建立可以是在多任务运行开始之前，也可以是动态地被一个运行着的任务建立。如果一个任务是被另一个任务建立的，而这个任务的优先级高于建立它的那个任务，则这个刚刚建立的任务将立即得到CPU的控制权。
1)
INT8U OSTaskCreate (void (*task)(void *pd), void *pdata, OS_STK *ptos, INT8U prio)
task是任务代码的指针，pdata是当任务开始执行时传递给任务的参数的指针，ptos是分配给任务的堆栈的栈顶指针，prio是分配给任务的优先级。

(1)优先级：任务的优先级必须在0到OS_LOWSEST_PRIO之间，如果某个优先级是空闲未使用的，则分配给该任务，并放置一个非空指针在OSTCBPrioTbl[]中来保留该优先级。因此，该任务可以允许中断，        因为这个优先级不会再被别的任务使用了

(2)堆栈：函数返回新的堆栈栈顶(psp),并被保存在任务的0S_TCB中。堆栈既可以从上(高地址)往下(低地址) 递减也可以从下往上递增。用户在调用OSTaskCreate()的时候必须知道堆栈是递增的还是递减的(   参看所用处理器的OS_CPU.H中的OS_STACK_GROWTH)，因为用户必须得把堆栈的栈顶传递给      OSTaskCreate()，而栈顶可能是堆栈的最高地址(堆栈从上往下递减)，也可能是最低地址(堆栈从      下往上长)。

当OS_CPU.H文件中的OS_STK_GROWTH置为0时，堆栈从下往上递增，用户需要将堆栈的最低内存地址传递给任务创建函数
OS_STK  TaskStack[TASK_STACK_SIZE];
OSTaskCreate(task, pdata, &TaskStack[0], prio);

当OS_CPU.H文件中的OS_STK_GROWTH置为1时，堆栈从上往下递减，用户需要将堆栈的最高内存地址传递给任务创建函数
OS_STK  TaskStack[TASK_STACK_SIZE];
OSTaskCreate(task, pdata, &TaskStack[TASK_STACK_SIZE-1], prio);

通用作法：
OS_STK  TaskStack[TASK_STACK_SIZE];
 
#if OS_STK_GROWTH == 0 
    OSTaskCreate(task, pdata, &TaskStack[0], prio); 
#else 
    OSTaskCreate(task, pdata, &TaskStack[TASK_STACK_SIZE-1], prio); 
#endif
 


2)
INT8U OSTaskCreateExt (void   (*task)(void *pd), 
                       void    *pdata, 
                       OS_STK  *ptos, 
                       INT8U    prio, 
                       INT16U   id,将任务的id设置成与任务的优先级一样的值就可以了。
                       OS_STK  *pbos, 指向任务的堆栈栈底的指针，用于堆栈的检验。  
                       INT32U   stk_size, 指定堆栈成员数目的容量。也就是说，如果堆栈的入口宽
                                度为4字节宽，那么stk_size为10000是指堆栈有40000个字节。该
                                参数与pbos一样，也用于堆栈的检验。
                       void    *pext, 指向用户附加的数据域的指针
                       INT16U   opt)指定是否允许堆栈检验OS_TASK_OPT_STK_CHK，是否将堆栈清零OS_TASK_OPT_STK_CLR，任务是否要进行浮点OS_TASK_OPT_SAVE_FP                                操作等等。(OS_TASK_OPT_STK_CHK,OS_TASK_OPT_STK_CLR和                                OS_TASK_OPT_SAVE_FP),可以通过位或运算来进行操作

3、 任务堆栈：每个任务都有自己的堆栈空间。堆栈必须声明为OS_STK类型，并且由连续的内存空间组成。用户可以静态分配堆栈空间(在编译的时候分配)也可以动态地分配堆栈空间(在运行的时候分配)。这两种声明应放置在函数的外面。
static OS_STK  MyTaskStack[stack_size];
OS_STK  MyTaskStack[stack_size];
可以用C编译器提供的malloc()函数来动态地分配堆栈空间，在动态分配中，用户要时刻注意内存碎片问题。特别是当用户反复地建立和删除任务时，内存堆中可能会出现大量的内存碎片，导致没有足够大的一块连续内存区域可用作任务堆栈，这时malloc()便无法成功地为任务分配堆栈空间。
例：
OS_STK  *pstk;
pstk = (OS_STK *)malloc(stack_size);
If (pstk != (OS_STK *)0)/* 确认malloc()能得到足够地内存空间 */
{   
    Create the task;
}
 
1)堆栈检验：有时候决定任务实际所需的堆栈空间大小是很有必要的。因为这样用户就可以避免为任务分配过多的堆栈空间，从而减少自己的应用程序代码所需的RAM(内存)数量。

使用堆栈条件：
在OS_CFG.H文件中设OS_TASK_CREATE_EXT为1。
用OSTaskCreateExt()建立任务，并给予任务比实际需要更多的内存空间。
在OSTaskCreateExt()中，将参数opt设置为OS_TASK_OPT_STK_CHK+OS_TASK_OPT_STK_
CLR。
将用户想检验的任务的优先级作为OSTaskStkChk()的参数并调用之。
INT8U OSTaskStkChk (INT8U prio, OS_STK_DATA *pdata)

4、删除任务：删除任务,是说任务将返回并处于休眠状态，并不是说任务的代码被删除了，只是任务的代码不再被μC/OS-Ⅱ调用。
1)OSTaskDel():
OSTaskDel()一开始应确保用户所要删除的任务并非是空闲任务，因为删除空闲任务是不允许的(空闲任务是由系统生成的，只有存在一个空闲任务，arm才能持续运行)。不过，用户可以删除statistic任务(统计任务)。接着，OSTaskDel()还应确保用户不是在ISR例程(中断例程)中去试图删除一个任务，因为这也是不被允许的。调用此函数的任务可以通过指定OS_PRIO_SELF参数来删除自己。接下来OSTaskDel()会保证被删除的任务是确实存在的。
INT8U OSTaskDel (INT8U prio)

2)请求删除任务，OSTaskDelReq():有时候，如果任务A拥有内存缓冲区或信号量之类的资源，而任务B想删除该任务，这些资源就可能由于没被释放而丢失。在这种情况下，用户可以想法子让拥有这些资源的任务在使用完资源后，先释放资源，再删除自己。用户可以通过OSTaskDelReq()函数来完成该功能。
发出删除任务请求的任务(任务B)和要删除的任务(任务A)都需要调用OSTaskDelReq()函数。
INT8U OSTaskDelReq (INT8U prio)

(1)
任务B需要决定在怎样的情况下请求删除任务.如果任务需要被删除，可以通过传递被删除任务的优先级来调用OSTaskDelReq().

要被删除的任务不存在(即任务已被删除或是还没被建立)，OSTaskDelReq()返回OS_TASK_NOT_EXIST。    
请求已被接受但任务还没被删除,返回值为OS_NO_ERR
当任务A完全删除自己后，返回值成为0S_TASK_NOT_EXIST

任务B
void RequestorTask (void *pdata)
{
      pdata = pdata;如果这个指针参数今后在函数里面没有调用到得话，这样子写一句，编译时就不会      有警告发生了
      for (;;) 
      {
          while (OSTaskDelReq(TASK_TO_DEL_PRIO) != OS_TASK_NOT_EXIST)
                OSTimeDly(1);延时
      }
}

(2)
任务A确认自己是否需要被删除,在OS_TAB中存有一个标志，这个标志的值是通过调用OSTaskDelReq(OS_PRIO_SELF)而得到的。
当返回值为OS_TASK_DEL_REQ，表明需要删除这个任务
返回OS_TASK_NOT_EXIST，表明任务不存在
void TaskToBeDeleted (void *pdata)
{
  pdata = pdata;
  for (;;)
  {
     If (OSTaskDelReq(OS_PRIO_SELF) == OS_TASK_DEL_REQ)
     {           
            释放所有占用的资源;                                               
            释放所有动态内存;
            OSTaskDel(OS_PRIO_SELF); 删除任务                                          (3)
     }
     else
     {
             /*应用程序代码*/
     }
 }

}


5、改变任务的优先级，OSTaskChangePrio()用户不能改变空闲任务的优先级，但用户可以改变调用本函数的任务或者其它任务的优先级。用户可以指定该任务当前的优先级或OS_PRIO_SELF
INT8U OSTaskChangePrio (INT8U oldprio, INT8U newprio)

6、任务挂起与恢复
1)挂起任务OSTaskSuspend()，任务可以挂起自己(OS_PRIO_SELF)或者其它任务。用户的应用程序不是在挂起空闲任务，接着确认用户指定优先级是有效的。记住最大的有效的优先级数(即最低的优先级)是OS_LOWEST_PRIO。注意，用户可以挂起统计任务（statistic）。
INT8U OSTaskSuspend (INT8U prio)返回OS_STAT_SUSPEND标志了，以表明任务正在被挂起

2)恢复任务，OSTaskResume(),确保用户不是在恢复优先级为OS_PRIO_SELF的任务



7、获得有关任务的信息，OSTaskQuery()获得自身或其它应用任务的信息
INT8U OSTaskQuery (INT8U prio, OS_TCB *pdata)


*时间管理
任务延时函数Void OSTimeDly (INT16U ticks)延时的参数是使用延时的时钟节拍数――一个1 到65535之间的数

按时分秒延时函数INT8U OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U milli)，
例如OSTimeDlyHMSM(0，10，55，350)

让处在延时期的任务结束延时，也可以唤醒正在等待事件的任务，INT8U OSTimeDlyResume (INT8U prio)

系统时间，OSTimeGet()和OSTimeSet()


*任务之间的通讯与同步
1、事件控制块ECB
1)等待该事件发生的任务都被加入到该事件的事件控制块中的等待任务列表中，所有的任务的优先级被分成8组（每组8个优先级），分别对应.OSEventGrp中的8位。当某组中有任务处于等待该事件的状态时，.OSEventGrp中对应的位就被置位。相应地，该任务在.OSEventTbl[]中的对应位也被置位。
当一个事件发生后，该事件的等待事件列表中优先级最高的任务，也即在.OSEventTbl[]中，所有被置1的位中，优先级代码最小的任务得到该事件。

typedef struct 
{ 
    void   *OSEventPtr;                /* 指向消息或者消息队列的指针 */
    INT8U   OSEventTbl[OS_EVENT_TBL_SIZE]; /* 等待任务列表      */
    INT16U  OSEventCnt;               /* 计数器(当事件是信号量时) */
    INT8U   OSEventType;                   /* 事件类型  */
    INT8U   OSEventGrp;               /* 等待任务所在的组  */
} OS_EVENT;
 
OSEventPtr指针,只有在所定义的事件是邮箱或者消息队列时才使用。当所定义的事件是邮箱时，它指向一个消息，而当所定义的事件是消息队列时，它指向一个数据结构
OSEventTbl[] 和 OSEventGrp:等待某事件的任务列表
OSEventCnt 当事件是一个信号量时，是用于信号量的计数器 
OSEventType定义了事件的具体类型。它可以是信号量（OS_EVENT_SEM）、邮箱（OS_EVENT_TYPE_MBOX）        或消息队列（OS_EVENT_TYPE_Q）中的一种。用户要根据该域的具体值来调用相应的系统函数

2)初始化一个事件控制块，OSEventWaitListInit()
当建立一个信号量、邮箱或者消息队列时，相应的建立函数OSSemInit()，OSMboxCreate()，或者OSQCreate()通过调用OSEventWaitListInit()对事件控制块中的等待任务列表进行初始化。该函数初始化一个空的等待任务列表，其中没有任何任务。该函数的调用参数只有一个，就是指向需要初始化的事件控制块的指针pevent。
void OSEventWaitListInit (OS_EVENT *pevent)

3) 使一个任务进入等待某事件发生状态, OSEventTaskWait()
当某个任务要等待一个事件的发生时，相应事件的OSSemPend()，OSMboxPend()或者OSQPend()函数会调用该函数将当前任务从就绪任务表中删除，并放到相应事件的事件控制块的等待任务表中。
void OSEventTaskWait (OS_EVENT *pevent)


4)使一个任务进入就绪态，OSEventTaskRdy()
当发生了某个事件，该事件对应的OSSemPost()，OSMboxPost()，OSQPost()，和OSQPostFront()函数调用OSEventTaskRdy()函数，将该事件的等待任务列表中的最高优先级任务置于就绪态。
void OSEventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)

5)由于等待超时而将任务置为就绪态, OSEventTO()
当在预先指定的时间内任务等待的事件没有发生时，OSTimeTick()函数会因为等待超时而将任务的状态置为就绪。在这种情况下，事件的OSSemPend()，OSMboxPend()或者OSQPend()函数会调用OSEventTO()来完成这项工作。该函数负责从事件控制块中的等待任务列表里将任务删除，并把它置成就绪状态。最后，从任务控制块中将指向事件控制块的指针删除。


2 信号量:信号量由两部分组成：一个是信号量的计数值，它是一个16位的无符号整数(0 到65,535之间)；另一个是由等待该信号量的任务组成的等待任务表。用户要在OS_CFG.H中将OS_SEM_EN开关量常数置成1，这样μC/OS-II才能支持信号量。

首先要建立该信号量，也即调用OSSemCreate()函数，对信号量的初始计数值赋值。如果信号量是用来表示一个或者多个事件的发生，那么该信号量的初始值应设为0。如果信号量是用于对共享资源的访问，那么该信号量的初始值应设为1。最后，如果该信号量是用来表示允许任务访问n个相同的资源，那么该初始值显然应该是n，并把该信号量作为一个可计数的信号量使用。

1)建立一个信号量, OSSemCreate()
它从空闲任务控制块链表中得到一个事件控制块,如果这时有任务控制块可用，就将该任务控制块的事件类型设置成信号量OS_EVENT_TYPE_SEM。其它的信号量操作函数通过检查该域来保证所操作的任务控制块类型的正确。用信号量的初始值对任务控制块进行初始化，对等待任务列表进行初始化

信号量一旦建立就不能删除了
OS_EVENT *OSSemCreate (INT16U cnt)

2)等待一个信号量, OSSemPend()
void OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)

3)发送一个信号量, OSSemPost()+
INT8U OSSemPost (OS_EVENT *pevent)

4)无等待地请求一个信号量, OSSemAccept()当一个任务请求一个信号量时，如果该信号量暂时无效，也可以让该任务简单地返回，而不是进入睡眠等待状态。
INT16U OSSemAccept (OS_EVENT *pevent)

5)查询一个信号量的当前状态, OSSemQuery()
INT8U OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *pdata)

做法即是先OSxxxPost(),再OSxxxPend()

3、邮箱
使一个任务或者中断服务子程序向另一个任务发送一个指针型的变量。该指针指向一个包含了特定“消息”的数据结构。为了在μC/OS-II中使用邮箱，必须将OS_CFG.H中的OS_MBOX_EN常数置为1。邮箱包含的内容是一个指向一条消息的指针。一个邮箱只能包含一个这样的指针（邮箱为满时），或者一个指向NULL的指针（邮箱为空时）。

1)建立一个邮箱，OSMboxCreate()
建立该邮箱,要指定指针的初始值:如果使用邮箱的目的是用来通知任务某一个事件已经发生（发送一条消息），那么就要初始化该邮箱为NULL，因为在开始时，事件还没有发生。
如果用户用邮箱来共享某些资源，那么就要初始化该邮箱为一个非NULL的指针。在这种情况下，邮箱被当成一个二值信号量使用。

OSMboxCreate()基本上和函数OSSemCreate()相似。不同之处在于事件控制块的类型被设置成OS_EVENT_TYPE_MBOX，以及使用.OSEventPtr域来容纳消息指针，而不是使用.OSEventCnt域。

邮箱一旦建立，是不能被删除的。
OS_EVENT *OSMboxCreate (void *msg)


2)等待一个邮箱中的消息，OSMboxPend()
void *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
例：ss=OSMboxPend(Str_Box,10,&err);
如果这个邮箱为空，则等待：timeout是等待时间，如果设为0，就无休止的等待下去
如果邮箱有消息：取出消息的地址给ss，并将邮箱置为NULL，同时，err=OS_NO_ERR

3)发送一个消息到邮箱中，OSMboxPost()
INT8U OSMboxPost (OS_EVENT *pevent, void *msg)
例：
sprintf(s,"%d",Times);
OSMboxPost(Str_Box,s);
要发送的消息在s中

4)无等待地从邮箱中得到一个消息, OSMboxAccept()
应用程序也可以以无等待的方式从邮箱中得到消息。
void *OSMboxAccept (OS_EVENT *pevent)

5)查询一个邮箱的状态, OSMboxQuery()
INT8U OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *pdata)

6)用邮箱作二值信号量
在初始化时，将邮箱设置为一个非零的指针（如 void *1）。这样，一个任务可以调用OSMboxPend()函数来请求一个信号量，然后通过调用OSMboxPost()函数来释放一个信号量。
void Task1 (void *pdata)
{
    INT8U err;
    for (;;)
    {
        OSMboxPend(MboxSem, 0, &err);   /* 获得对资源的访问权  */
        .
        .    /* 任务获得信号量,对资源进行访问  */
        .
        OSMboxPost(MboxSem, (void*)1);  /* 释放对资源的访问权 */
    }
}
 
7) 用邮箱实现延时，而不使用OSTimeDly()

4、消息队列
它可以使一个任务或者中断服务子程序向另一个任务发送以指针方式定义的变量。因具体的应用有所不同，每个指针指向的数据结构变量也有所不同。为了使用μC/OS-II的消息队列功能，需要在OS_CFG.H 文件中，将OS_Q_EN常数设置为1，并且通过常数OS_MAX_QS来决定μC/OS-II支持的最多消息队列数，这个值最小应为2。

消息队列的符号很像多个邮箱。实际上，我们可以将消息队列看作时多个邮箱组成的数组，只是它们共用一个等待任务列表。每个指针所指向的数据结构是由具体的应用程序决定的。消息队列是一个循环的缓冲区，


通过OS_EVENT中的.OSEventPtr域链接到对应的事件控制块


1)建立一个消息队列，OSQCreate()
消息队列一旦建立就不能再删除了
OS_EVENT *OSQCreate (void **start, INT16U size)

2)等待一个消息队列中的消息，OSQPend()
void *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)

3)向消息队列发送一个消息（FIFO），OSQPost()
INT8U OSQPost (OS_EVENT *pevent, void *msg)

4)向消息队列发送一个消息（后进先出LIFO），OSQPostFront()
OSQPostFront()函数和OSQPost()基本上是一样的，只是在插入新的消息到消息队列中时，使用.OSQOut作为指向下一个插入消息的单元的指针，而不是.OSQIn。

INT8U OSQPostFront (OS_EVENT *pevent, void *msg)

5)无等待地从一个消息队列中取得消息, OSQAccept()
void *OSQAccept (OS_EVENT *pevent)

6)清空一个消息队列, OSQFlush()
INT8U OSQFlush (OS_EVENT *pevent)

7)查询一个消息队列的状态，OSQQuery()
INT8U OSQQuery (OS_EVENT *pevent, OS_Q_DATA *pdata)

8)消息队列的使用
1.定义
/*按键队列大小*/
#define 	    KEYQUEUE       2 
MAIN_EXTERN  	void        *KeyMsgArray[KEYQUEUE]; // 按键队列数组
MAIN_EXTERN 	OS_EVENT 	*g_KeyMsg;		// 消息队列信号量定义,用以通知系统有按键命令发送
2.创建
g_KeyMsg  = OSQCreate(&KeyMsgArray[0],KEYQUEUE);// 创建按键命令消息消息队列
3.发送
returnkey=OSQPost(g_KeyMsg,&MsgBack.keyback);
4.接收，每次接收只接收一个值，下次接收时将接收下一个值
PKeyInput = OSQPend(g_KeyMsg,1,&err);

*内存管理
用malloc()和free()两个函数动态地分配内存和释放内存会存在内存碎片。因此，要使用ucos专用的函数
会比较好。如果要在μC/OS-II中使用内存管理，需要在OS_CFG.H文件中将开关量OS_MEM_EN设置为1。
typedef struct
{
    void   *OSMemAddr;
    void   *OSMemFreeList;
    INT32U  OSMemBlkSize;
    INT32U  OSMemNBlks;
    INT32U  OSMemNFree;
} OS_MEM;

OSMemAddr是指向内存分区起始地址的指针 
OSMemFreeList是指向下一个空闲内存控制块或者下一个空闲的内存块的指针
OSMemBlkSize是内存分区中内存块的大小，是用户建立该内存分区时指定的
OSMemNBlks是内存分区中总的内存块数量，也是用户建立该内存分区时指定的
OSMemNFree是内存分区中当前可以得空闲内存块数量。

1) 建立一个内存分区，OSMemCreate()
OS_MEM *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *err)

例：
OS_MEM *CommTxBuf; 
INT8U    CommTxPart[100][32];
CommTxBuf = OSMemCreate(CommTxPart, 100, 32, &err);

2)分配一个内存块，OSMemGet()
显然，应用程序必须知道内存块的大小，并且在使用时不能超过该容量。例如，如果一个内存分区内的内存块为32字节，那么，应用程序最多只能使用该内存块中的32字节。当应用程序不再使用这个内存块后，必须及时把它释放，重新放入相应的内存分区中
值得注意的是，用户可以在中断服务子程序中调用OSMemGet()，因为在暂时没有内存块可用的情况下，OSMemGet()不会等待，而是马上返回NULL指针。
void *OSMemGet (OS_MEM *pmem, INT8U *err)  

3) 释放一个内存块，OSMemPut()
INT8U OSMemPut (OS_MEM  *pmem, void *pblk)  
 
4)查询一个内存分区的状态，OSMemQuery()
可以知道特定内存分区中内存块的大小、可用内存块数和正在使用的内存块数等信息。
struct
{
    void  *OSAddr;     /* 指向内存分区首地址的指针 */
    void  *OSFreeList; /* 指向空闲内存块链表首地址的指针 */
    INT32U OSBlkSize;  /* 每个内存块所含的字节数 */
    INT32U OSNBlks;    /* 内存分区总的内存块数 */
    INT32U OSNFree;    /* 空闲内存块总数 */
    INT32U OSNUsed;    /* 正在使用的内存块总数 */
} OS_MEM_DATA;
 
INT8U OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *pdata)

例：  等待一个内存块
有时候，在内存分区暂时没有可用的空闲内存块的情况下，让一个申请内存块的任务等待也是有用的。但是，μC/OS-II本身在内存管理上并不支持这项功能。如果确实需要，则可以通过为特定内存分区增加信号量的方法，实现这种功能。应用程序为了申请分配内存块，首先要得到一个相应的信号量，然后才能调用OSMemGet()函数。

//定义了程序中使用到的各个变量 
OS_EVENT  *SemaphorePtr;                       
OS_MEM    *PartitionPtr;
INT8U      Partition[100][32];
OS_STK     TaskStk[1000];
 
void main (void)
{
    INT8U err;
    OSInit(); 系统初始化           
    .
    .
    SemaphorePtr = OSSemCreate(100); 用内存分区中总的内存块数来初始化一个信号量
    PartitionPtr = OSMemCreate(Partition, 100, 32, &err); 建立内存分区
    .
    OSTaskCreate(Task, (void *)0, &TaskStk[999], &err); 建立任务
    .
    OSStart();                                                         (6)
}
 
void Task (void *pdata)
{
    INT8U  err;
    INT8U *pblock;
 
    for (;;)
    {
         OSSemPend(SemaphorePtr, 0, &err);当一个任务运行时，只有在信号量有效时
         pblock = OSMemGet(PartitionPtr, &err);得到内存块
         .
         .  /* 使用内存块 */
         .
         OSMemPut(PartitionPtr, pblock);释放得到内存块 
         OSSemPost(SemaphorePtr);释放信号量 
    } 
}


*中断管理
void TIMER1_IRQHandler (void)  
{  
        OS_ENTER_CRITICAL(); 	 //   关中断
	OSIntEnter();告诉内核，进入了中断状态
	LPC_TIM1 -> IR = 1;			/* clear interrupt flag */
        临界区代码 
	OSIntExit(); 告诉内核，离开了中断状态
 	OS_EXIT_CRITICAL();	//   处理完毕，再开中断
}
 

//==============================
//==基于Linux的ARM内核和驱动开发
//==============================

//**********
//bootloader
//**********
*bootloader位置：系统启动后，所有cpu都从cpu厂商预先安排的地址开始运行。
s3c2410是从0x0000000地址开始运行。因此，Flash放在系统的0x0000000地址上，而bootloader又
放在Flash的0x0000000地址，而这样系统启动后，cpu就从flash的0x0000000地址开始运行bootloader
____________________________________________________
|Bootloader|Boot parameters|Kernel|Root filesystems|
----------------------------------------------------
                      Flash
                      
*bootloader移植：因为硬件的不同，因此bootloader需要移植和修改。具体来
说，
芯片级不同：由于cpu的不同，他们的寄存器配置都不同。
板级不同：板卡的硬件是不同的，因此它的地址分配也不同。
外设不同：各外设芯片也不同

*启动流程：是两阶段的启动过程
步骤一：
硬件设备初始化，主要是cpu内部的寄存器
准备了一段RAM内存空间空间，然后拷贝步骤二的代码到这段RAM内存空间中
设置好堆栈，因为C语言的传递参数等需要用到堆栈，所以要预先设置好
跳转到步骤二的C入口节点,即这段RAM内存空间中
1)

|     Rootfilesystem      |
|       kernel            |      
|.........................|           拷贝到内存中     ---------------------------
|Bootloader的步骤二代码64K|0x0000400------------------>|Bootloader的步骤二代码64K|
|-------------------------|                            |.........................|
|Bootloader的步骤一代码1K |0x0000000<--执行，硬件初始化---------------------------
---------------------------                                   SDRAM
     Flash
     
2)
|     Rootfilesystem      |
|       kernel            |      
|.........................|                            ---------------------------
|Bootloader的步骤二代码64K|                            |Bootloader的步骤二代码64K|
|-------------------------|                            |.........................|<--跳转到SDRAM中执行
|Bootloader的步骤一代码1K |                            ---------------------------
---------------------------                                   SDRAM
     
步骤二：
初始化本阶段所要用到的硬件设备，主要是板载的硬件，如串口，网卡等
将内核映像和根文件系统映像从flash中拷贝到RAM内存空间中
调用内核
1)                           
|     Rootfilesystem      |
|       kernel            |   
|.........................|                   ---------------------------
|Bootloader的步骤二代码64K|                   |Bootloader的步骤二代码64K|
|-------------------------|                   |.........................|<--执行，板载硬件初始化
|Bootloader的步骤一代码1K |                   ---------------------------
---------------------------                                   SDRAM

2)                           拷贝到内存中
|     Rootfilesystem      |------------------>|     Rootfilesystem      |
|       kernel            |------------------>|       kernel            |<--调用内核      
|.........................|                   ---------------------------
|Bootloader的步骤二代码64K|                   |Bootloader的步骤二代码64K|
|-------------------------|                   |.........................|
|Bootloader的步骤一代码1K |                   ---------------------------
---------------------------                                   SDRAM

3)总之：它需要做的步骤
(1)读Flash
(2)初始化和写SDRAM
(3)关看门狗。初始化时钟，由12MHZ->400MHZ
(4)设置堆栈
(5)初始化本阶段所要用到的硬件设备，主要是板载的硬件，如串口，网卡，USB等,还有写Flash功能，这样可以写内核进去
(6)拷入内核，启动内核

*uboot
1、下载，从ftp://ftp.denx.de/pub/u-boot/ 可以下载uboot的源代码
2、目录结构
board:和开发板有关文件，它支持的每一款开发板都以一个子目录存在。
      例如SMDK2410子目录中就存放2410的支持文件
      里面的文件：
      u-boot.lds 链接脚本，定位生成的代码从哪里开始运行
      flash 板子配置的flash
      lowlevel_init.S 低级的初始化
      smdk2410.c
      config.mk配置文件
      
common:实现uboot支持的指令。如命令bootm,它的实现程序是cmd_bootm.c
cpu：和特定cpu相关的代码，它支持的每一款cpu都以一个子目录存在，例如
     arm920t
     里面的文件：
     start.S 与CPU体系密切相关的汇编代码
     
disk：对磁盘的支持，可以忽略不用看
doc：文档说明cpu和单板如何配置的
drivers：支持的设备的驱动都放在这里，比如各种网卡，串口，USB等
dtt
examples
fs:支持的文件系统
include：使用的头文件，作移植时，需要对这个文件进行修改。
         它里面对各个体系结构都有一个各自的目录，同时还有公共的头文件。 
         里面的configs目录有与开发板相关的配置头文件，每一个开发板对应一个头文件，
         如smdk2410.h，里面包括了该开发板的设备硬件的物理地址。里面的asm目录有与cpu体
         系结构相关的头文件。
Net:与网络协议栈相关的代码，如TFTP协议，RARP协议的实现
Tools：生成Uboot的工具，如mkimage，crc等
3、编译，即Makefile，它分为两个步骤
1)执行每种board相关的配置
2)编译生成uboot.bin文件
(1)选择要使用的board,即开发板
make mini2440_config说明使用的开发板是mini2440
具体可从makefile文件中可知
mini2440_config：unconfig
  xxxxxxxxxxxNULL s3c24x0
  
(2)编译生成uboot.bin
make CROSS_COMPILE=arm-linux-
指定交叉工具链，并开始编译uboot了。编译完成后，会生成uboot.bin文件
注意：一套交叉工具链不一定能编译所有东西，比如4.3.3可以编译Linux内核，
和文件系统。
但是，不能编译这个uboot，这个uboot只能用3.4.5来编译

4、常用命令
目前tq2440的uboot默认集成了多个操作的程序，按下
->q 退出命令集
然后，就可以输入uboot的命令了
->menu回到刚才的菜单命令

1)help看当前单板所支持的所有命令
 ? xx 看具体xx命令的说明
2)
(1)
printenv查看所有环境变量，printenv xx,查看特定的xx的环境变量
例：
Uboot>printenv
显示 
   ipaddr=192.168.1.1
   ethaddr=12:34:56:78:9A:BC
   ....
Uboot>printenv ipaddr
显示
    ipaddr=192.168.1.1    
(2)
  setenv添加，修改，删除环境变量
setenv name 123添加环境变量name,值是123
setenv name 456修改环境变量值为456
setenv name删除环境变量
(3)
  saveenv保存环境变量，将所有环境变量及其值存入flash中

例：如果需要开发板一启动后就下载tftp，则需要配置环境变量bootcmd配置参数，bootm一启动后执行的地址
setenv bootcmd tftp 31000000 uImage \; bootm 31000000 这个环境变量
 其中" \; "是连接符，并且前后有空格，这个必须要加，表示两个命令。
saveenv 

3)tftp通过网络下载文件
(1)
先配置网络参数
setenv ethaddr 12:34:56:78:9A:BC 设置mac地址
setenv ipaddr  192.168.1.1 设置本机地址
setenv serverip 192.168.1.254指定tftp服务器地址

完了之后，ping一下服务器端：
Ping 192.168.1.7
...
host 192.168.1.7 is alive
(2)
tftp 32000000 uImage 把刚才设置的TFTP服务器中根目录下的uimage镜像通过tftp
读入到开发板的0x32000000处

4)loadb通过串口下载在pc机的文件到板子上(一般不用串口下载，因为文件太大了，一般使用网络或者USB来下载)
loadb 32000000 板子开始阻塞，等待下载数据

继续在securityCRT选择菜单传送->发送文件，协议使用Kermit。
把pc机的该文件发送到板子上
5)
(1)
md显示内存区的内容
md 32000000 
(2)
mm修改内存中的内容，改后地址自动递增
mm 32000000 
它会一次一下的让我们输入新的值，要结束不再改了就按一下空格+回车
6)flash操作
(1)
flinfo查看flash扇区信息
结果
1:SST SST39VF1601它的型号 (16Mbit,即Flash大小是2MByte大小,uniform
 sector size各扇区固定大小)
SIze: 2MB in 32 sectors 分为32个扇区
Sectur Start Addresses:
 xxxx分别指出每个扇区的起始地址
(2)protect Flash的写保护
protect off all关闭所有扇区的写保护
protect on all打开所有扇区的写保护
protect off a  b关闭从a扇区到b扇区的写保护  
protect on a  b打开从a扇区到b扇区的写保护
protect on 0  1ffff从0到第二个扇区的结束地址，即第三个扇区的起始地址-1
，即头两个扇区开启写保护
注意，如果不是最后的地址，如1fff0，则会报错
(3)erase擦除flash扇区。我们；要写数据进去时，必须要先擦除它。因为Flash写入数据时，只能写0，不能写1。因此
要先插除，即先全部置1

erase 30000起始地址 1effff最后一个扇区的结束地址
(4)cp,内存之间，内存与flash，flash之间数据拷贝的方法。记得实际拷贝时，要先插除，再拷贝
cp 31000000 50000 d0000,将内存地址31000000的数据，长度为0xd0000,
拷贝到Flash地址50000中
cp 2000    30080000  1000

7)程序执行
go 30000 跳转到这个地址，开始执行程序
bootm同go一样，不同的地方是他要求这个被执行的程序要有一个头，头的格式
由bootm来规定，里面包含一些信息，比如操作系统，程序入口地址，程序压缩方法。bootm先检测头，再运行
程序
           --------
           | 头   |
 ------     ------
|zImage|   |zImage| 
 ------     ------
  go        bootm
先使用tool/mkimage.exe工具，将uboot镜像加上头信息，再用
bootm 30000000执行
这个头用工具mkimage可以生成
  
8)bdinfo显示开发板的信息，如内存地址和大小，时钟频率，MAC地址等

5、工作流程  
1)bootloader的工作模式有两种，启动模式和下载模式
启动模式是系统启动后，自动从flash中将linux加载到ram中，然后启动等步骤
下载模式是调试使用，可以在系统启动时手动操作，将文件下载到板子上
2)启动流程，看bootloader链接文件board/smdk2410/u-boot.lds,看到链接顺序
中第一个链接文件cpu/arm920t/start.o,打开文件
即第一阶段文件：
cpu/arm920t/start.s汇编文件，入口是_start
各命令他实际的实现代码都是do_xx,如go命令，它的实现代码是do_go
第二阶段文件：
lib_arm/board.c中，start_armboot是整个程序中C语言开始的函数，

6、移植
1)板级设备的配置
配置文件在include/configs/smdk2410.h，移植时就要改这个头文件
#define CONFIG_ARM920T 1 CPU的类型
#define CONFIG_S3C2410 1 芯片类型
#define CONFIG_SMDK2410 1 开发板的类型
#define USE_920T_MMU 1 使用MMU虚拟内存管理，ARM9以上才使用这个功能
#undef  CONFIG_USE_IRQ不使用中断，绝大部分bootloader都使用轮询来驱动
硬件，而不是中断。
#define CFG_MALLOC_LEN (CFG_ENV_SIZE+128*1024)分配的malloc的堆的大小
#deifne CFG_GBL_DATA_SIZE 128数据段的大小
#define CONFIG_DRIVER_CS8900 1 使用CS8900网卡
#define CS8900_BASE 0x19000300 网卡CS8900的基地址
#define CONFIG_Serial1 1 使用串口1
#define CONFIG_BAUDRATE 115200 波特率
#define CONFIG_COMMANDS \  指uboot支持的命令，可额外添加命令，如ping
        (CONFIG_CMD_DFL |\ 也可注释不用的命令
         CFG_CMD_CACHE  |\
         。。。。
        )
#define CONFIG_BOOTDELAY 3自启动等待时间
#define CONFIG_BOOTARGS内核启动参数
"root=ramfs devfs=mount console=ttySA0,9600"
环境变量初始值
#define CONFIG_ETHADDR 08:00:3e:26:0a:5b
#define CONFIG_NETMASK 255.255.255.0
#define CONFIG_IPADDR  10.0.0.110
#define CONFIG_SERVERIP 10.0.0.1

#define CONFIG_BOOTCOMMAND "tftp;bootm"//启动uboot后，自主启动的命令是什么
#define CFG_PROMPT "SMDK2410#" 命令提示符
#define PHYS_SDRAM_1 0X30000000内存起始地址是SDRAM Bank #1
#define PHYS_SDRAM_1_SIZE 0x40000000内存大小是4M
#define CGF_LOAD_ADDR 0X33000000默认启动地址，如果bootm后面不跟启动地址时，以这个地址为准
#define CFG_BAUDRATE_TABLE{9600,19200，...}可用的波特率
#define CONFIG_NR_DRAM_BANKS 1 有一片SDRAM
#define CFG_FLASH_BASE 0x0000000 指Flash的基地址，即从0地址开始

2)移植步骤
(1)
移植时，找支持该开发板的uboot。然后，最好先选最相近的Uboot，先
要选MCU相同的Uboot,如2440。如果没有，就选MPU相同的,如2440使用的核是ARM920T，而smdk2410也是用这个核
(2)在顶层的Makefile文件中，为本开发板添加新的配置选项
例如
mini2440_config: unconfig
  @./mkconfig $(@:_config=)arm arm920t mini2440 NULL S3C24x0
注意，第二行空格要用TAB键开始  
其中
  arm:CPU架构
  arm920t:CPU类型，对应cpu/arm920t目录，这个名字不能改
  mini2440:开发板型号自己取的，对应board/mini2440目录，如果没有的话要自己创建一个
  NULL:开发者
  S3C24x0:片上系统SOC
  unconfig:把从前的配置信息清除
  (@:_config=):即是mini2440_config
  mkconfig是执行脚本文件
  
(3)在board目录中创建一个属于该开发板的目录，并添加相应的文件和修改
mkdir -p board/mini2440
cp -rf board/smdk2410/* board/mini2440 把所有的文件拷贝到新创建的文件中
并对里面的文件进行移植修改
(4)复制开发板的配置文件到新开发板中smdk2410.h,再修改
cp include/configs/smdk2410.h include/configs/mini2440.h注意这个名字
要与开发板一样
并对里面的配置进行移植修改
(5)选择板级配置
make mini2440_config说明使用的开发板是mini2440
即是执行Makefile中的
mini2440_config: unconfig
  @./mkconfig $(@:_config=)arm arm920t mini2440 NULL S3C24x0
  
(6)编译uboot
make CROSS_COMPILE=arm-linux-
编译成功后，可得到uboot映像

7、移植例子
1)
源文件在ftp://ftp.denx.de/pub/u-boot/
解压
tar xjvf u-boot-1.1.6.tar.bz2
2)在board目录中创建一个属于该开发板的目录，并添加相应的文件和修改
(1)
cd u-boot-1.1.6/board/
mkdir TX2440
cp -rf smdk2410/* mini2440 把所有的文件拷贝到新创建的文件中
cd TX2440
mv smdk2410.c TX2440.c
(2)修改TX2440里面的Makefile的28行
COBJS := TX2440.o flash.o//原先smdk2410.o改为TX2440.o

3)复制开发板的配置文件到新开发板中smdk2410.h,再修改
cp include/configs/smdk2410.h include/configs/TX2440.h

3)在uboot顶层的Makefile文件中，为本开发板添加新的配置选项
TX2440_config: unconfig
  @./mkonfig $(@:_config=)arm arm920t TX2440 NULL S3C24x0
注意，第二行空格要用TAB键开始 

4)选择板级配置
make TX2440_config说明使用的开发板是TX2440
如果出现Configuring for TX2440 board ..说明设置正确了
5)编译uboot
make CROSS_COMPILE=arm-linux-
编译成功后，可得到uboot.bin映像 

6)下面还有很多内容，涉及具体移植的修改，暂时不做了。完了后需要重新编译，生成uboot.bin
注意驱动的不同：在drivers目录中放置各设备的驱动程序，各种驱动程序一般都是从linux里面直接拷过来的，但是
有几点不同的地方，需要修改。
uboot的驱动不是采用中断，发送和接受都是用轮询的方法来处理
uboot是一个单任务的程序


7)我们对uboot的移植做的所有修改，可以列出来集合成一个补丁，予以发布
u-boot-1.1.6_tq2440.patch
打补丁方法
cd u-boot-1.1.6
patch < ../u-boot-1.1.6_tq2440.patch
具体补丁内容，在补丁文件里面有指示，打开补丁文件u-boot-1.1.6_tq2440.patch
---表示原来的代码
+++表示修改后的代码
具体补丁打的位置，文件中头两行有指示 u-boot-1.1.6/board/mini2440/mini2440.c...
由于目前路径本身就在uboot里面，因此要忽略上面的u-boot-1.1.6/ ,具体即忽略掉第一个之前的路径名，用p1表示
patch -p1 < ../u-boot-1.1.6_tq2440.patch

//********
//内核移植
//********
//*************
//内核体系结构
//*************
1、
为Source Insight添加汇编文件的支持
Options->Document Options->选C Source File,添加*.s;*.S;->点击close
与cpu相关的汇编文件一般都在arch\arm\
include\asm-arm
project->synchronize files同步项目的索引，这样子等下在右边的框里面，就能通过输入文件名，进行
模糊查找了

2、系统组成
用户应用程序
  ||
GNU的C库       用户空间
            ----------
系统调用接口
  ||
内核
  ||                  内核空间
与体系结构相关代码   -----------

通过系统调用，和硬件中断，能够完成从用户空间跳到内核空间

3、Linux内核架构
   系统调用接口(内核与用户程序交互的接口)
             ||
 进程管理(创建，调度，删除) 
 内存管理(虚拟地址和物理地址的转换) 
 网络协议栈
 虚拟文件系统(隐藏各文件系统的具体实现细节，为文件系统操作提供统一的接口)
            ||
 硬件体系结构相关代码
 设备驱动   

4、内核文件构成
            |解压代码|              |uboot header|
            ---------               --------------
--------    |压缩后  |              |            |
Vmlinux|    |Vmlinux |              |    zImage  | 
--------    ---------               --------------
Vmlinux      zImage                    uImage

uImage:它的uboot头包含了压缩信息，crc校验信息，os信息等
zImage的解压代码：Head.s,misc.s
在文件arch/arm/boot/compressed/中
vmlinux:
1)
第一部分是启动代码部分，内核启动时前面的这部分代码也是汇编代码，用于配置cpu内核的寄存器，初始化环境等
在文件arch/arm/kernel/head.o
2)
第二部分是vmlinux-main,它就是主体
driver/built-in.o 所有选择的编译到内核的驱动执行文件.o，全部链接成一个built-in.o
mm/built-in.o 类似
等等
3)
kallsyms.o一些符号表

5、内核启动流程
1)内核的配置过程
(1)看.conf文件
例如DM9000网卡，看他的配置项
CONFIG_DM9000=y 说明内核支持这个设备
不设置CONFIG_DM9000，说明不支持
CONFIG_DM9000=m，说明它编译成一个驱动模块，以后可以动态加载
(2)配置关联图形
 
.conf文件==配置了DM9000这个项，就在这个.h文件中定义了这个宏===
|         =>include/linux/autoconf.h(#define CONFIG_DM9000 1)==>c源码：CONFIG_DM9000的宏
|
|=========>include/config/auto.conf,定义CONFIG_DM9000是y，还是M <=====被最顶层Makfile文件包含
                      ||
                      ||
       子目录Makefile：drivers/net/makefile：
     obj_y+=xxx.o 说明这个模块在配置选项中是设为*的，即最终会编译到内核中去
     obj_m+=xxx.o 说明这个模块在配置选项中是设为M的，即最终会被编译成可加载的驱动模块xxx.ko 
例：obj-$(CONFIG_DM9000)+= dm9000.o变量， CONFIG_DM9000被定义成y，则会最终会编译到内核中去。
被定义成M的，即最终会被编译成可加载的驱动模块 
如果没有定义，则不会被使用
 (3)几种Makefile的区别
顶层Makefile：它是所有Makefile的核心，总控制内核的编译，连接
.config:顶层配置文件，所有makefile文件(顶层目录，及各级子目录)都是根据.config来决定具体使用哪些文件   
arch/arm/Makefile：对应的体系结构的makefile，它定义了哪些体系结构(如arm体系结构)相关的文件参与内核的生成。
                   他被顶层Makefile所包含
scripts/Makefile.* 通用规则脚本
各级子目录下的Makefile(如drivers/net/makefile):他们很简单，接收上层Makefile的控制，只是用来编译自己的设备文件

①子目录Makefile：drivers/net/makefile：
     obj_y+=xxx.o 说明这个模块在配置选项中是设为*的，即最终会编译到内核中去
     obj_m+=xxx.o 说明这个模块在配置选项中是设为M的，即最终会被编译成可加载的驱动模块xxx.ko 
     
2)具体启动流程
(1)
arch/arm/boot/compressed/start.S解压缩
(2)
arch/arm/kernel/head.s调用真正的内核，在这个汇编中配置cpu内核的寄存器，初始化环境等
连接脚本arch/arm/kernel/vmlinux.lds
具体步骤：
①处理uboot传进来的参数，判断是否支持这个cpu，判断是否支持这个单板，uboot启动内核时，会将机器ID传给内核
②创建页表
③使能MMU

(3)切换到C语言程序init\Main.c文件
设置启动参数
asmlinkage void_init start_kernel(void)
{
。。。
}
具体步骤
①初始化各设备，中断等等
②输出内核版本信息
③处理uboot传进来的启动参数:具体包括内存多大，内存起始地址，命令行参数
setup_arch(),setup_command_line()

(4)
kernel_thread(kernel_init,NULL,CLONE_FS|CLONE_SIGHAND)启动kernel_init线程
①挂接根文件系统
②给flash规划分区，哪里放uboot，哪里放kernel，哪里放yaffs2。这个分区在代码里面应该写死掉
在arch/arm/plat-s3c24xx里面写死掉

(5)init_post 执行应用程序
这个应用程序打开/dev/console,最后调用第一个应用程序,切换到用户应用程序 
run_init_process("/sbin/init"); 具体步骤： 
①用函数sys_open(/dev/console)打开这个文件，(void) sys_dup(0)复制sys_open函数，也表示再打开一个这个文件，
(void) sys_dup(0);再复制打开一个这个文件。这三个函数的意思是
即打开三个/dev/console，这个文件终端具体用于标准输出和标准输入，标准错误信息。在这个 
例子中，是serial0。 

注意：以下这几个程序执行成功后，都是一直循环着的，只有发生错误，才会返回。然后由下一个程序执行
②如果有参数指定需要启动特定的应用程序，则启动run_init_process(execute_command);其中 
命令行参数execute_command 就是指定的要执行的应用程序，由uboot传入 
③如果没有指定，则启动这里的应用程序run_init_process("/sbin/init"); 
④如果上一个程序执行错误，则依次执行run_init_process("/etc/init"); 
⑤如果上一个程序执行错误，则依次执行run_init_process("/bin/init"); 
⑥如果上一个程序执行错误，则依次执行run_init_process("/bin/sh");
  
其实，这些都是到busybox的链接，/sbin/init->../bin/busybox  

(6)内核结构图
start_kernel
  setup_arch 处理uboot传进来的启动参数:具体包括内存多大，内存起始地址
  setup_command_line处理uboot传进来的命令行参数
  rest_init  解析uboot传入的启动参数
    kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);启动kernel_init线程
      即调用kernel_init函数，
        prepare_namespace
          mount_root 挂接根文件系统  
        init_post 执行应用程序 
          run_init_process    

(7)init程序里面有个配置文件，指定了后续要执行哪些程序，这里面就是放了你自己做的应用程序
busybox->init_mian
  parse_inittab，里面打开/etc/inittab文件，里面指定了启动什么应用程序，应用程序什么时候执行
  new_init_action(ASKFIRST执行时机,"-/bin/sh"执行的应用程序,"/dev/tty2"终端);执行应用程序
  
    
①读取配置文件，解析配置文件
parse_inittab，里面打开/etc/inittab文件，里面指定了启动什么应用程序，应用程序什么时候执行
它的格式:<id>:<runlevels>:<action>:<process>
id:即变成/dev/id,用于终端stdin,stdout,stderr
runlevels:忽略
action：执行时机
process:应用程序或脚本

②根据配置文件，来启动执行用户的程序
new_init_action(ASKFIRST执行时机,"-/bin/sh"执行的应用程序,"/dev/tty2"终端);执行应用程序
做的事情：
创建一个init_action结构，填充
struct init_action
{ 
struct init_action *next;用于链表
int action;执行时机
pid_t pid;进程号
char command[INIT_BUFFS_SIZE];执行的应用程序
char terminal[CONSOLE_NAME_SIZE];终端
};

把这个结构放入init_action_list链表

③开始运行这一类的动作，即从链表中一个个取出来这些节点进行执行
run_actions(SYSINIT);//SYSINIT这个任务是系统初始化
  waitfor(a,0);执行一个应用程序，等待它，直到他执行完毕
    run(a);创建进程，这个子进程即执行的用户应用程序(即<process>)
    waitpid(runpid,&status,0);等待它执行结束
  delete_init_action(a);执行完毕，从init_action_list链表中删除这个节点  
run_actions(WAIT);
run_actions(ONCE);对于这一类程序，进程不会等待它执行结束
    run(a);创建进程，这个子进程即执行的用户应用程序(即<process>)
    waitpid(runpid,&status,0);等待它执行结束
while(1)
{
run_actions(RESPAWN);
   if(a->pid==0)
   {
     a->pid-run(a);运行子进程a
     打印:please press Enter to active this console
     等待回车
     创建子进程
   }   
run_actions(ASKFIRST);
   if(a->pid==0)
   {
     a->pid-run(a);
   }
wpid=wait(NULL);//等待子进程的退出
while(wpid>0)  
{
  a->pid=0;//退出后，将进程号清空
} 
}

④启动应用程序条件如下
/dev/console打开终端，但如果没有定位它的id，即指定它的stdin,stdout,stderr。这会自动转向定位到/dev/null
init应用本身，即busybox->init
调用配置文件/etc/inittab，得到里面指定的应用程序
应用程序使用一些库需要链接，比如c库



5、内核源代码：
它采用树形结构组织，把同一个功能的文件都放到同一个子目录下。它的唯一的
官方下载地址是www.kernel.org

6、文件的结构
arch(经常用到):存放体系结构相关的代码，内核所支持的每种CPU，再该目
录下都有对应的子目录。每个子目录内有分解为boot,mm,kernel等子目录，
分别控制系统引导，内存管理，系统调用等
block:部分块设备的驱动程序
crypto:放加密，压缩，CRC校验算法
documentation:放内核的文档说明
drivers(经常用到):设备驱动
fs：存放各种文件系统的实现代码，每种文件对应一个目录
    devpts虚拟文件系统
    ext2,fat,
    isofs:光盘的文件系统
include:内核所需要的头文件都在这里
    linclude/linux:存放与平台无关的头文件
    其它不同的目录：每种头文件对应一个目录
lib：库文件代码
mm：实现内存管理中，与体系结构无关的部分
net:网络协议
samples:一些范例
scripts:配置内核的脚本,即make menuconfig
security:安全模块
sound:声音模块
user:cpio命令的实现，这个命令是用来制作根文件系统的命令
virt:内核虚拟机

7、内核配置与编译
内核可以定制
1)清除临时文件，中间文件，配置文件
make clean(常用)删除生成的文件，如.o文件，保留配置的.config文件
make mrproper删除生成的文件，如.o文件，和.config文件
make distclean删除生成的文件，如.o文件，和.config文件，以及编译器生成
              的备份文件和补丁文件

2)确定目标系统的软件硬件配置情况：如CPU类型，网卡类型，需要使用的网络
协议等

3)make menuconfig配置内核
通常我们导入一个已有的配置文件，然后再修改一下。ARM的配置文件在
arch/arm/configs/里面有各种配置文件

4)创建依赖
make dep ARCH=arm CROSS_COMPILE=arm-linux-

5)编译内核make zImage,生成的文件再arch/arm/boot/目录下。它只能编译
小于512K的内核文件
如果要编译大于512k的，且用于x86的机器，用make bzImage
要显示编译的信息make zImage V=1


8、驱动开发：
驱动的开发放在这里，而不放在Linux内核移植时，是因为内核移植时只是构建一个最小系统，保存最
基本的驱动，如串口驱动。

1)编译驱动文件make modules
2)安装驱动文件make modules_install(有些简单的驱动文件不需要这一步)
它其实就是一个cp命令，把内核中生成的驱动文件即ko文件，拷贝到文件系统
中，它的路径由自己指定的
make modules_install INSTALL_MOD_PATH=/.....
例如：
它是生成驱动文件到_install文件夹中，在这个文件夹中include目录是头文件，lib目录是
应用程序执行时需要依赖的库文件，main目录是帮助文件，sbin目录是执行文件(这个具体看Make文件
的配置，不一定是这样子的)
3)
将apps/_install/sbin中的所有执行文件复制到root_2.6.25.8/sbin中
将apps/_install/lib中的所有*.so*文件复制到root_2.6.25.8/lib中

4)制作init ramdisk
mkinitrd initrd-2.6.25.8 2.6.25.8
就会产生initrd-2.6.25.8文件
版本号是否存在，可以从/lib/modules目录知道

9、内核模块开发：模块开发是我们驱动开发的最主要的方式，因为模块即是对内核的一种功能扩充，这样的好处就是
我们可以在不用重编译内核的情况下，对内核功能进行扩充。
(例如，在windows下，如果要安装一个驱动，就要重新安装操作系统，并且重启，这是非常麻烦的)
例如：我们原先内核没有usb驱动，把usb驱动作为一个模块，插入到内核中去，这样子就内核就集成了usb驱动，就可以直
接使用usb设备了。以后驱动都是用模块的方式来做


Linux有一种内核模块机制，内核编译时，某些组件模块本身不被编译进内核，
而是当系统开始运行时，内核根据需要动态的添加组件。
与普通应用程序的对比：应用程序从main开始执行任务，执行完成后从内存中消失，而内核模块是
    先在内核中注册自己以便服务于将来的某个请求，然后一直在内核中，以后有调用时再调用。最后
    手动卸载，才从内核中卸载掉

程序结构
例：
#define __KERNEL__
#define MODULE//如果是编译成模块，就必须要加这个；如果是编译成内核，就必须不能加这个

#include<linux/init.h>
#include<linux/module.h>
#include<linux/kernel.h>
static int hello_init(void)
{
  printk(KERN_WARNING"Hello,world\n");
}
static void hello_exit(void)
{
  printk(KERN_INFO"Goodbye,world");
}
module_init(hello_init);
module_exit(hello_exit);
1)
(1)
模块加载函数(必需)：在程序中安装这个模块，然后当系统自动启动时，会自动调用该函数。
安装模块的语法是用module_init宏来指定
模块卸载函数(必需)：例如module_exit(hello_exit);

(2)
printk：在内核中打印，它只能在内核中使用，而printf只能在应用程序中使用
它的优先级：<linux/kernel.h>中定义了8种优先级，它由高到低分别为
KERN_EMERG 即0，弹出后系统崩溃
KERN_ALERT 即1，需要立即执行
KERN_CRIT  即2  严重情况
KERN_ERR   即3，错误情况
KERN_WARNING 即4，有问题的警告
KERN_NOTICE  即5，正常情况，但仍然值得注意
KERN_INFO    即6，普通信息
KERN_DEBUG   即7，调试信息

没有指定，则默认使用4这个级别。
不管什么级别，它都会打印到/var/log/messages这个文件中

控制台优先级配置：相应的优先级的信息，它打印到相应的优先级的屏幕中
它在/proc/sys/kernel/printk文件中进行配置
6  4  1  7
表示：纯字符界面下(不是我们现在的图形Linux界面)控制台屏幕级别6，这样优先
      级比6低的信息，就不会打印到控制台上
      默认信息级别4
      

2)编译文件
(1)在Linux主机下，方法一直接编译：要使用gcc -c 来编译模块
  需要通过gcc -I xxx/include来指定头文件，并且这个头文件一定要通过make 编译后的
(2)在Linux主机下，方法一通过Makefile编译：用make命令来编译内核模块，生成hello.ko文件，这
  个就是内核模块文件

3)在板子上，安装内核模块文件hello.ko
加载insmod hello.ko
卸载rmmod  hello(只有当使用计数为0时，才可以被卸载。它通过lsmod看used by就知道了)
查看lsmod
加载modprobe hello  它与insmod的区别是，它会自动先查找/lib/modules/xx/modules.dep文件，
查看这个hello模块依赖的其它模块，如果有，就先加载这个依赖模块，最后再加载这个hello模块

以下几个宏用来维护使用计数：
MOD_INC_USE_COUNT加1
MOD_DEC_USE_COUNT减1
MOD_IN_USE非0时，就返回真

4)模块可选信息
许可证声明：宏MODULE_LICENSE用来告知内核，该模块带有一个许可证，没有这样的说明，当加载
模块时，内核会有警告
MODULE_LICENSE("GPL");说明使用GPL许可证
作者声明：MODULE_AUTHOR("xx");
模块描述: MODULE_DESCRIPTION("xx");
模块版本：MODULE_VERSION("xx");
模块别名：MODULE_ALIAS("xx");

5)模块参数:用于在加载模块时，传递参数给模块
把变量声明为模块参数
module_param(参数名，参数类型，参数访问权限)
参数类型：bool,int,charp字符串型
权限：
S_IRUGO:任何用户都对/sys/module中出现的该参数有读权限
S_IWUSR:允许root用户修改/sys/module中出现的该参数

例：
int a=3;//有初始化也可以
char *st;
module_param(a,int,S_IRUGO);
module_param(st,charp,S_IRUGO);
定义了两个模块参数

安装内核：
insmod hello.ko a=14 charp="dds"

6)内核符号导出：/proc/kallsyms记录了内核中所有导出的符号的名字和地址
(1)
hello.c内核模块
。。。
static int __init hello_init()//注意，两个横杆
{
  int res=add_integer(1,2);
}

static void __exit hello_exit()
{
  int res=sub_integer(2,1);
}

(2)
calculate.c内核模块
。。。
int add_integer(int a,int b)
{...}
int sub_integer(int a,int b)
{...}

//无论针对于变量，还是函数，如果需要别的模块能够使用，就必须予以导出，类似于声明
EXPORT_SYMBOL(add_integer);
EXPORT_SYMBOL(sub_integer);

EXPORT_SYMBOL_GPL(xx);导出包含有GPL许可证的模块

(3)
因为存在模块依赖，安装方法
make
insmod calculate.ko
insmod hello.ko 

7)常见问题
版本不匹配：要安装的内核模块与当前正在运行的内核是相互依赖的，他们的版本也要一样，如
果不一致时，会出现如下错误
disagrees about version of symbol struct_module 
insmod:error inserting 'hello.ko':-1 invalid module format

查看目前正在运行的内核版本，即宿主机的Linux的版本：uname -r

要安装的内核模块版本，即板子的版本：查看编译模块的makefile文件，有显示
KDIR:= /lib/modules/2.5.25.8/build 这里指定了编译的内核模块的源代码的版本，
它的版本号在内核源代码的makefile文件
VERSION=2
PATCHLEVEL=6
SUBLEVEL=25
EXTRAVERSION=8

宿主机的版本如果和板子的版本不一致时，是不能用的
解决方法：
①modprobe --force-modversion强行插入到内核模块中
②换正确的内核模块，内核模块版本是由它的内核代码决定的，不是自己随便改一下版本号就可以的。
③直接修改板子版本的版本号

8)2.4与2.6以上的内核模块的对比：2.4版本编译出来的内核模块是xx.o文件，而2.6以上编译出来的内核
模块是x.ko文件


//****************
//安装交叉编译工具
//****************
1、安装arm-linux-gcc 
D:\TQ2440配套光盘\TQ2440_CD\Linux资源\Linux平台开发工具包包含了支持EABI技术
的交叉编译器，制作文件系统的工具

EABI-4.3.3_EmbedSky_20100610.tar.bz2是交叉编译工具
1)在Linux下创建/home/opt/EmbedSky文件夹，sudo chown 777 opt
2)通过cuteFtp,将EABI-4.3.3_EmbedSky_20100610.tar.bz2复制到/home/opt/EmbedSky
3)tar xvfj EABI-4.3.3_EmbedSky_20100610.tar.bz2 -C / 就将文件解压到/opt/EmbedSky/4.3.3/
目录下了，它会自动创建这个目录，而无需手动创建，今后这个目录就用来管理源码了
-C 表示指出解压路径
总共解压出着三个编译器
EABI-4.3.3(即文件/opt/EmbedSky/4.3.3)用于编译内核,qtopia
crosstools_3.4.5_softfloat(即文件/opt/EmbedSky/crosstools_3.4.5_softfloat/gcc-3.4.5-glibc-2.3.6/arm-linux)
用于编译uboot和Linux的内核的相关文件    
mkyaffsimage编译文件系统(即文件/usr/local/sbin/mkyaffsimage)用于编译yaffs文件系统

4)设置系统变量，使刚安装的交叉编译器生效
(1)对于redhat可以在这里设
gedit /etc/profile
if [ "$EUID"="0" ]; then
        ...
添加一条：注意，前面一定要用Tab键
	pathmunge /opt/EmbedSky/4.3.3/bin
然后在终端输入source /etc/profile重新编译文件	
重启计算机

(2)对于ubuntu可以在这里设
在环境变量PATH中添加路径,使得可以直接运行目录下的这个程序，而无需指定位置
export PATH=$PATH:/opt/EmbedSky/4.3.3/bin

为了不要每次使用时都收工设置环境变量，在/etc/environment文件中修改PATH的值
PATH="...:/opt/EmbedSky/4.3.3/bin"

重启计算机

5)使用arm-linux-gcc -v来看是否配置成功

6)如果需要使用crosstools_3.4.5_softfloat，环境变量需要设置
/opt/EmbedSky/crosstools_3.4.5_softfloat/gcc-3.4.5-gl用ibc-2.3.6/arm-linux
注意：有两个交叉编译器，使用EABI_4.3.3的交叉编译器和使3.4.5的交叉编译器，分别编译出来的
程序只能在对应的文件系统和内核中使用(对应的文件系统：/lib/目录下使用的是这种编译器的/lib/库
中的内容，然后busybox也是用这种编译器编译的；
对应的内核：使用的是这种编译器编译出来的内核镜像)
如果需要使用3.4.58的编译器编译内核镜像，就需要取消内核配置单中关于EABI的选项，然后还要再单独
制作3.4.5的文件系统

7)已安装了mkyaffsimage编译文件系统，输入mkyaffs,然后按两次tab键，如果安装成功，会列出
mkyaffs开头的各个命令

//************
//移植编译内核
//************
*Linux内核2.6.25.8

1、获取Linux内核源码
1)Linux内核我这里有两个，版本号为
D:\TQ2440配套光盘\TQ2440_CD\Linux资源\Linux源码包\2.6.30.4，正式移植用
D:\TQ2440配套光盘\TQ2440_CD\Linux资源\Linux源码包\2.6.25.8，测试移植用
D:\TQ2440配套光盘\TQ2440_CD\Linux资源\Linux源码包\2.6.13，测试AV转接模块用
这里我使用2.6.25.8版本

2、解压内核源码
将它移到Linux的/home/opt/EmbedSky目录中

使用解压命令
tar xvfj linux-2.6.25.8_20100601.tar.bz2 -C /

3、如果有需要，可以打补丁。打补丁是我们对uboot的移植做的所有修改，可以列出来集合成一个补丁，予以发布
u-boot-1.1.6_tq2440.patch
打补丁方法
cd u-boot-1.1.6
patch < ../u-boot-1.1.6_tq2440.patch
具体补丁内容，在补丁文件里面有指示，打开补丁文件u-boot-1.1.6_tq2440.patch
---表示原来的代码
+++表示修改后的代码
具体补丁打的位置，文件中头两行有指示 u-boot-1.1.6/board/mini2440/mini2440.c...
由于目前路径本身就在uboot里面，因此要忽略上面的u-boot-1.1.6/ ,具体即忽略掉第一个之前的路径名，用p1表示
patch -p1 < ../u-boot-1.1.6_tq2440.patch

4、添加对ARM的支持
进入到内核源码/opt/EmbedSky/linux-2.6.25.8,打开文件Makefile
在第193行和194行，将原先
ARCH ?= (SUBARCH)
CROSS_COMPILE ?=
改为
ARCH =arm
CROSS_COMPILE =arm-linux-
原因：指明体系结构为arm，采用的交叉编译器为arm-linux-，这一步一定要改完再执行make menuconfig，否则，用的是x86的make，打开的配置单不是arm的。


5、修改平台输入时钟频率,以满足TQ2440的频率
打开内核源码opt/EmbedSky/linux-2.6.25.8/arch/arm/mach-s3c2440/mach-smdk2440.c 
在328行，将原先频率16.9344MHZ改为12MHZ,因为ARM使用外部12MHZ的时钟晶振
static void _init smdk2440_map_io(void)
{
  //s3c24xx_init_clocks(16934400);
    s3c24xx_init_clocks(12000000);
}

6、制作自己的TQ2440配置单
原因：一开始内核不存在.config文件，无法进行编译，只有用户按自己需求配置
好内核并保存配置单为.config后，才可编译。
1)进入
cd opt/EmbedSky/linux-2.6.25.8
make menuconfig ARCH=arm进行配置，进入配置菜单界面(如果刚才Makefile有配置，则不用加ARCH=arm)
2)使用配置单文件
在opt/EmbedSky/linux-2.6.25.8/arch/arm/configs/s3c2440_defconfig
该配置单定义了所有s3c440的cpu相关的配置选项，，但有一些是我们不需要的或者是需要
修改的，我们可以在这个基础上进行配置

方法一：
make menuconfig
选择Load an Alternate Configuration File选项
输入路径地址arch/arm/configs/s3c2410_defconfig
Save an Configuration选项，保存为.config

方法二：
copy arch/arm/configs/s3c2410_defconfig .config

3)注意，没有提示的其他选项不用去改
回到住菜单，进入System Type选项
将这几个选项分别进行配置，按y选择，按n取消选择,按下M作为一个模块，所谓模块就是作为一个驱动程序，
然后事后再编写驱动程序予以加载，/可以搜索配置项，？显示该配置项的详细信息
ARM system type->
  (x)Samsung S3C2410,....  
S3C2410Machines-->进入
  [*]SMDK2410/A9M2410  选择
  []IPAQ H1940  取消选择
  []Acer N30    取消选择
  []Simtec Electronics BAST(EB2410ITX)取消选择
  []NexVision OTOM Board 取消选择
  []AML M5900 Series取消选择
  []Thorcom VR1000 取消选择
  []QT2410取消选择
S3C2412 Machines-->进入，取消所有选择
S3C2440 Machines-->进入,只选择
  [*]SMDK2440
  [*]SMDK2440 with S3C2440 CPU module 
S3C2442 Machines-->进入，取消所有选择   
S3C2443 Machines-->进入，取消所有选择

4)在配置单中添加自己的信息
General setup-->进入，只选择
  [*]Prompt for development and/or incomplete code/drivers
  (-EmbedSky)Local version-append to kernel release  移动到这一行，按下Enter键，
  进行修改，然后输入-EmbedSky
  [*]System VIPC
  (17)Kernel log buffer size选择17
  -*-Namespaces support
     Choose SLAB allocator进入
         选择(x)SLUB(Unqueued Allocator),按下空格键予以选择这一项，选完后，
         会出现x
         
5)选择是否支持EABI         
Kernel Features-->进入
  [*]Use the ARM EABI to compile the kernel
  [*]Allow old ABI binaries to run....
  
6)添加对NFS文件系统的支持
(1)
File Systems-->
  Network File Systems-->
    <*>NFS client support
    [*]Root file system on NFS  
(2)    
在.config配置文件中，添加这一行
CONFIG_CMDLINE="root=/dev/nfs(支持nfs文件系统) rw(可读写) nfsroot=192.168.4.7:/opt/EmbedSky/root_2.6.25.8 
ip=192.168.4.20 (这个ip是Linux启动之后的ip地址，不是uboot里面定义的ip地址) 
console=ttySAC0(指定控制台使用串口0) mem=64M(内存大小64M)"   

或者在
Boot options-->
  (root=/dev/nfs(支持nfs文件系统) rw(可读写) nfsroot=192.168.4.7:/opt/EmbedSky/root_2.6.25.8 
ip=192.168.4.20 (这个ip是Linux启动之后的ip地址，不是uboot里面定义的ip地址) 
console=ttySAC0(指定控制台使用串口0) mem=64M(内存大小64M))....
这样改也可以的 
  
7)保存配置单
Save an Alternate Configuration File
保存为.config文件，这样编译系统时，会调用该文件

8)修改配置单
每次只需完#make distclean命令之后，或者想直接使用制作好的配置文件，在PC的Linux
端执行#cp config_EmbedSky .config，然后再编译或进入配置单进行修改


9)详细配置单需要修改地方如下所示
General setup，该配置单下包括了内核的一些基本设置，配置时加入的功能有

System V IPC：支持system V的进程间通信对象；
Classic RCU：经典RCU(read-copy-update)支持，这是一种高级互斥机制；
(17) Kernel log buffer size (16 => 64KB, 17 => 128KB)：内核日志缓冲区大小为128kb；
Optimize for size：内核大小优化，在编译时采用-O2；
Choose SLAB allocator (SLUB (Unqueued Allocator))：采用高速缓存管理（slab分配器）的高级版本SLUB；
Enable loadable module support，该配置单设置是否使用模块加载，在本配置单下选择：
Module unloading：模块可卸载，使得模块可以随时卸载和添加，当然一些不允许卸载的模块除外。
Enable the block layer，这个选项不选，因为设备中没有块设备，不需要使用块设备层，NAND flash直
                        接通过IO口和几个控制引脚控制，也不需要块设备层。
System Type：该项是一些与平台相关的选项，选择以下几项：
ARM system type (Samsung S3C2410, S3C2412, S3C2413, S3C2440,S3C2443)：选择所支持的ARM类型，这里针对开发板选择支持
                                        三星S3C2410, S3C2412, S3C2413, S3C2440,S3C2443。
ADC common driver support：与ADC与触摸屏驱动有关，选上；
Force UART FIFO on during boot process：在内核解压时保持串口打开，可用于检测内核解压的情况；
(0) S3C UART to use for low-level messages：选择输出底层信息的串口，根据开发板情况，选择0号串口；
(0) Space between gpio banks：设置GPIO bank之间的空间，用于防止访问越界，选择后会占用一部分存储空间，这个设置为0，
                                         注意编写程序，一般不会越界，可以节省存储空间；
S3C2440 Machines
       SMDK2440
       SMDK2440 with S3C2440 CPU module
选择S3C2440 Machines下的这两项，使得内核支持SMDK2440，SMDK2440是三星公司的官方设计参考，一般都采用这种参考。
Bus support：该选项选择总线类型，这个不选，没有合适的。
Kernel Features：该选项设置内和特性，选择以下几项：
Memory split (3G/1G user/kernel split)：内存分配，一般保持该默认配置，即1G给内核空间，3G给用户空间；
Use the ARM EABI to compile the kernel：采用EABI技术编译内核，由于我们的交叉编译器支持EABI，选择该项；
(4096) Low address space to protect from user allocation：设置低端内存大小，按默认。
Boot options：引导时的相关选项，保持默认。
CPU Power Management：CPU电源管理，保持默认。
Floating point emulation：浮点仿真，保持默认。
Userspace binary formats：用户空间二进制模式，这里选择
Kernel support for ELF binaries，即采用ELF格式，ELF是可执行连接格式，是UNIX系统实验室作为应用程序二进制接口
                                而开发和发布的。
Power management options：电源管理选项，这里不选，我们的设备要保持长时间工作，无需睡眠。
Networking support：网络设置，选择配置如下：
Networking options->
       Unix domain sockets：使用UNIX套接字；
       TCP/IP networking：TCP/IP网络；
       IP: kernel level autoconfiguration：内核自动配置IP；
IP: DHCP support ：允许本机根文件系统通过NFS（网络文件系统）挂载到其他计算机上，实现远端访问。
Wireless：无线设置，暂时保持默认，以后修改。
Device Drivers：设备驱动，保持默认，做驱动时会进行修改。
File systems：文件系统配置，选择内容如下：
DOS/FAT/NT Filesystems->
       VFAT (Windows-95) fs suppor：支持挂载windows的文件系统；
       (437) Default codepage for FAT：设置FAT文件系统允许代码页大小；
       (iso8859-1) Default iocharset for FAT：设置FAT文件系统采用的字符类型。
Pseudo filesystems->
Virtual memory file system support (former shm fs)：采用虚拟内存文件系统(Tmpfs)；
Userspace-driven configuration filesystem：使用configfs，该文件系统与sysfs功能相反。
Miscellaneous filesystems：这个先不做选择，制作yaffs2文件系统后再处理。
Network File Systems->
       NFS client support->
              NFS client support for NFS version 3：使用第三版NFS；
              Root file system on NFS：允许通过NFS挂载根文件系统。
Partition Types：划分类型，这里不选择。
Native language support->
       (iso8859-1) Default NLS Option;
       Codepage 437 (United States, Canada)
       Simplified Chinese charset (CP936, GB2312)
       NLS ISO 8859-1  (Latin 1; Western European Languages)
       NLS UTF-8
给出了支持的语言及字符集类型
Kernel hacking：该项大部分是便于内核开发使用的，选择以下几项：
(1024)Warn for stack frames larger than (needs gcc 4.4)：设置堆栈报警极限大小；
S3C UART to use for low-level debug：底层是用的UART端口号。
Security options：不做配置。
Cryptographic API：一些加密和校验码的设置，选择如下：
Cryptographic algorithm manager：启用加密技术必须选择这项；
ECB support：ECB支持；
CRC32c CRC algorithm：启用CRC32c算法；
AES cipher algorithms：启用AES加密算法；
ARC4 cipher algorithm：启用ARC4加密算法；
Hardware crypto devices：启用硬件加密设备；
Library routines：一些库函数选择，选择如下：
CRC ITU-T V.41 functions
CRC32 functions
CRC7 functions

6、修改机器码
在内核文件arch/arm/mach-s3c2440/mach-smdk2440.c中的 MACHINE_START(S3C2440,”SMDK2440”)中要使用
该机器码，同时在TQ2440的uboot中设定了机器码为168，所以在内核这里需要修改机器码，否则就不能启动。
打开文件opt/EmbedSky/linux-2.6.25.8/arch/arm/tools/mach-types，找到这一行 
s3c2440 ARCH_S3C2440 S3C2440 168  这里原先362改为168


7、编译镜像
1)输入make zImage ARCH=arm CROSS_COMPILE=arm-linux-进行编译，编译结束后，就会在opt/EmbedSky/linux-2.6.25.8/arch/arm/boot/
目录下生成一个zImage镜像，然后将其下载到Windows系统，添加后缀名为zImage.bin，下载
到开发板中即可
运行开发板，会出现这样的界面提示即可
Linux version 2.6.25.8

2)
make zImage ARCH=arm CROSS_COMPILE=arm-linux- (如果在Makefile上已经配置了，就不用再加这个选项)
make uImage ARCH=arm CROSS_COMPILE=arm-linux- ,uImage与zImage的区别是，在zImage的基础上，对镜像再加上文件头的生成，
     类似于uboot中bootm执行时，比go要多添加对uboot镜像文件头的检测。
     
3)针对Linux2.6.30.4内核，如果编译时出现
make  zImage的时候出现 ：multiple definition of 's3c_device_dm9000'

解决:
打开 arch/arm/mach-s3c2440/Makefile文件，注释掉 obj-$(CONFIG_ARCH_SMDK2440) +=mach-smdk2440.o

     
//******************
//移植驱动和文件系统
//******************
1、移植NandFlash：在内核里面已经有NandFlash的驱动了，需要修改一下就可以使用
修改对nand的分区信息。要让内核知道nand flash的分区信息，设置成跟bootloader一致。另外，分区信息
只能通过代码自己写死
1)
(1)
即将NAND flash分为3个分区，名称分别为uboot，kernel和yaffs2，偏移量分别为0，2M和5M，
大小分别为256kb，3M和251M，注意：大小必须为128KB的整数倍。至于为什么这样分区，
是和uboot相关的。

打开opt/EmbedSky/linux-2.6.25.8/arch/arm/plat-s3c24xx/common-smdk.c，修改以下几项
static struct mtd_partition smdk_default_nand_part[]=
{
  [0]=
  {
    .name  ="EmbedSky_Board_uboot",
    .offset=0x00000000,
    .size  =0x00040000,
  },
  [1]=
  {
    .name  ="EmbedSky_Board_kernel",
    .offset=0x00200000,  //或者用MTDPART_OFS_APPEND即是紧接着上一个分区的意思
    .size  =0x00300000,
  },
  [2]=
  {
    .name  ="EmbedSky_Board_yaffs2",
    .offset=0x00500000,
    .size  =MTDPART_SIZ_FULL,
  }
}


打开opt/EmbedSky/linux-2.6.30.4/arch/arm/plat-s3c24xx/common-smdk.c，修改以下函数的所有宏定义中的改值
static struct mtd_partition smdk_default_nand_part[]=
{
  [0]=
  {
    .name  ="EmbedSky_Board_uboot",
    .offset=0x00000000,
    .size  =0x00040000,
  },
  [1]=
  {
    .name  ="EmbedSky_Board_kernel",
    .offset=0x00200000,
    .size  =0x00300000,
  },
  [2]=
  {
    .name  ="EmbedSky_Board_yaffs2",
    .offset=0x00500000,
    .size  =MTDPART_SIZ_FULL,
  }
}


其中修改的值的确定，由NAND flash芯片手册查询相关数据，经计算得到，如下（其中HCLK=100Hz）：
tacls>CLE或ALE建立时间最小值*HCLK 
twrph0>nWE或nRE的持续时间最小值*HCLK-1
twrph1>写数据起作用时间*HCLK-1
//修改读写匹配时间
static struct s3c2410_platform_nand smdk_nand_info=
{
  .tacls=10,
  .twrph0=25,
  .twrph1=10,
  ....
}

(2)
这里不采用NAND flash的软件ECC校验码，因为在初始化的时候，uboot中有校验码，然后在后
面yaffs2文件系统移植的时候，要选上采用S3C2440硬件校验码。

打开opt/EmbedSky/linux-2.6.25.8/drivers/mtd/nand/s3c2410.c文件
大概在文件的699行左右
打开opt/EmbedSky/linux-2.6.30.4/drivers/mtd/nand/s3c2410.c文件
大概在文件的752行左右
static void s3c2410_nand_init_chip()
{
  最后几行
  else
  {
     chip->ecc.mode=NAND_ECC_NONE;//NAND_ECC_SOFT;将原先的值NAND_ECC_SOFT进行修改
  }
}

2)添加对应的驱动配置：
输入make menuconfig,选中和不选中的选项如下所示，其它的不用管
(1)
Device Drivers-->
  <*>Memory Technology Device(MTD) support-->启用MTD支持，这是使用
  NAND flash的前提，也是使用JAFFS2文件系统的前提

     [*]MTD partitioning support我们要对NAND flash进行分区，选中这一项；
     <> RedBoot partition table parsing
     [] Command line partition table parsing
     <*>Direct char device access to MTD devices允许字符设备访问MTD设备
     -*-Common interface to block layer for MTD translation layers块设备层向MTD传输层接口，该项默认必须选上
     <*>Caching block device access to MTD devices允许缓存块设备访问MTD设备，JAFFS2为文件系统服务
     <*>NAND Device Support--->
        <*>NAND Flash support for S3C2410/S3C2440 soc使内核支持S3C2440 NAND flash
        []S3C2410 NAND Hardware ECC采用S3C2410的硬件ECC
        
(2)保存配置单
Save an Alternate Configuration File
保存为.config文件，这样编译系统时，会调用该文件
        
(3)编译镜像
1)输入make zImage进行编译，编译结束后，就会在opt/EmbedSky/linux-2.6.25.8/arch/arm/boot/
目录下生成一个zImage镜像，然后将其下载到Windows系统，添加后缀名为zImage.bin，下载
到开发板中即可
运行开发板，会出现这样的界面提示即可
NAND device:Manufacturer ID:...(Samsung NAND 128MiB 3,3v 8-bit)括号里面的提示
..
0x00000000-0x00040000:"EmbedSky_Board_uboot"
0x00060000-0x00260000:"EmbedSky_Board_kernel"
0x00260000-0x04260000:"EmbedSky_Board_yaffs2"

2、移植文件系统
根文件系统是Linux启动时使用的第一个文件系统，没有根文件系统，Linux就没法启动

*Linux有多种文件系统，如ext2,ext3,vfat,jffs,ramfs,nfs,yaffs等它使用虚拟文件系统VFS为
各文件系统提供统一管理的应用编程接口
基于NorFlash的文件系统:jffs,jffs2
基于NandFlash的文件系统:yaffs(仅支持小页512Bytes的闪存),yaffs2(仅小页512Bytes，大页2KB的闪存)
Cramfs:支持NorFlash，NandFlash。但是他是只读的。一般实际使用时，都是一些数据参数等固化在这里的flash
Ramdisk:它划分一部分大小模拟作为一个文件系统，里面存放经常被访问，而又无需更改的文件。
Initramfs:从Linux2.6以后的内核开始使用这个机制，它是ramdisk的升级版，当这个块用完后，它可以
          自动增加内存来使用
NFS网络文件系统：主要用于开发调试时。如果是使用Flash的文件系统，这样根文件每修改一次，Flash就
          需要重新烧写一次，Flash容易坏。而使用NFS，他把网络上的另一台机器的文件当做自己的文件，
          这样在宿主机上建立一个根文件系统，开发板的Linux挂载该文件系统，这样任何更改都只需要在
          宿主机上更改一下就可以直接用，就不用频繁烧写Flash，然后重启开发板了  
              

*移植yaffs根文件系统
1)移植yaffs文件系统
(1)获取yaffs源码补丁
在D:\TQ2440配套光盘\TQ2440_CD\Linux资源\Linux源码包\文件系统\cvs-root.tar.gz
复制到Linux下的/home/opt/EmbedSky中

(2)在内核中添加对yaffs的支持：YAFFS（Yet Another Flash File System）是专门为NAND Flash
存储器设计的嵌入式文件系统

解压补丁tar xvfz cvs-root.tar.gz  ,得到目录cvs
cd cvs/yaffs2/
./patch-ker.sh c /opt/EmbedSky/linux-2.6.25.8执行补丁脚本，打补丁到内核中
此时，在/opt/EmbedSky/linux-2.6.25.8/fs/目录下，可以看到添加了一个名为yaffs2的目录，同时
这个目录下的Makefile文件和Kconfig文件也添加了yaffs2的配置和编译条件

(3)make menuconfig添加对应的驱动配置：
Device Drivers-->
  <*>Memory Technology Device(MTD) support-->
     <*>NAND Device Support-->
        <*>NAND Flash support for S3C2410/S3C2440 Soc
File system->
  <>Second extended fs support
  <>Ext3 journalling file system support
  <>Kernel automounter support
  <>Kernel automounter version 4 support(also supports v3)
  <>Filesystem in Userspace support
  CD-ROM/DVD Filesystems-->
    <*>ISO 9660 CDROM file system support
    []Microsoft Joliet CDROM extensions
    []Transparent decompression extension
    <>UDF file system support
  DOS/FAT/NT Filesystems-->
    <*>MSDOS fs support
    <*>VFAT(Windows-95)fs support
    (437)Default codepage for FAT
    <>NTFS file system support
    Pseudo filesystems-->
      [*]Virtual memory file system support(formet shm fs)
      []Tmpfs POSIX Access Control Lists
      <*>Userspace-driven configuration filesystem
    Miscellaneous filesystems-->
      <*>YAFFS2 file system support添加内核对yaffs2的支持
      -*-512 byte/page devices支持512字节/页的设备
      []Use older-style on-NAND data format with pageStatus byte
      []Lets Yafs do its own ECC
      -*-2048 byte(or larger)/page devices支持2048字节(2KB)/页的设备
      [*]Autoselect yaffs2 format自动选择yaffs2的形式，照应上面两个不同页大小设备的情况
      []Disable lazy loading
      []Turn off wide tnodes
      []Force chunk erase check
      []Cache short names in RAM
   -*-Native language support-->
      <*>Codepage 437(United States,Canada)
      <*>Simplified Chinese charset(CP936,GB2312)
      <*>NLS ISO 8859-1(Latin 1;Western European Languages)
      <*>NLS UTF-8      

(4)
配置好之后，保存配置单，重新编译内核镜像，此时，内核已经支持yaffs2文件系统了

2)利用BusyBox建立根文件系统:其中一个功能是，自动创建等下Linux下运行的命令的执行文件，这样就省得自己写了。
因此，他就是一个工具集
(1)文件在D:\TQ2440配套光盘\TQ2440_CD\Linux资源\Linux源码包\文件系统\busybox-1.13.0.tar.bz2
下载到Linux的/home/opt/EmbedSkey中
注意：当以前是用哪个编译器编译内核的，现在也要用这个来编译文件系统，以及文件系统中的所有
程序，本移植是用4.3.3

(2)解压busybox
tar xvfj busybox-1.1.13.0.tar.bz2 -C /opt/EmbedSky

(3)
进入/opt/EmbedSky/busybox-1.13.0,打开文件Makefile
ARCH ?= (SUBARCH)
CROSS_COMPILE ?=
改为
ARCH =arm
CROSS_COMPILE =arm-linux-

(4)在/opt/EmbedSky/busybox-1.13.0中
输入make menuconfig，进入配置单(如果打不开，有可能是termail太小了，拉大一点再试)
Busybox Settings-->
  General Configuration-->
    Buffer allocation polic(Allocate with Malloc)-->添上这个
    [*]Show verbose applet usage messages
    [*]Store applet usage messages in compressed form
    [*]Support--install[-s] to install applet links at running
    [*]Enable locale support(system needs locale for this to work)
    [*]Support for --long-options
    [*]Use the devpts filesystem for Unix98 PTYs
    [*]Support writing pidfiles
    [*]Runtime SUID/SGID configuration via /etc/busybox.conf
    [*]Suppress warning message if /etc/busybox.conf is not readable
    (/proc/self/exe)Path to BusyBox executable
  Build Options-->
    [*]Buile BusyBox as a static binary(no shared libs)使用静态链接库
    [*]Build with Large File Support(for accessing files>2GB)
  Installation Options-->
    [*]Don't use/usr因为我们只想将它装在自己创建的根文件系统中，而不是宿主机的根文件中去。因此，这个
       选项可以避免busybox被安装到宿主系统的/usr目录下，破坏宿主系统
       Applets links(as soft-links)-->
    (./_install)BusyBox installation prefix指定这样编译出来的执行文件命令要安装到哪里去，这里先指定这个地方，
     等下再拷贝到制作出来的根文件系统中去
  Busybox Library Tuning-->
    (6)Minimum password length
    (2)MD5:Trade Bytes for Speed
    [*]Faster/proc scanning code
    [*]Command line editing
    (1024)Maximum length of input
    [*] vi-style line editing commands
    (15)History size
    [*]History saving
    [*]Tabl completion
    [*]Fancy shell prompts
    (4)Copy buffer size,in kilobytes
    [*]Use ioctl names rather than hex values in error messages
    [*]Support infiniband HW
Linux Module Utilities-->
    (/lib/modules)Default directory containing modules
    (modules.dep)Default name of modules.dep
    []Simplified modutils
      [*]insmod
      [*]rmmod
      [*]lsmod
      [*]modprobe
      --Options common to multiple modutils
      []Support ersion 2.2/2.4 Linux kernels
      [*]Support tainted module checking with new kernels
      [*]Support for module aliases file
      [*]Support for module.symbols fileLinux System Utilities-->
      
退到主菜单，选择Save Configuration to an Alternate File选项，保存文件名为config_EmbedSky,
以及再保存为.config文件，这个文件是编译busybox时默认读取的配置文件
退出后，选择yes修改配置                   

(5)将/opt/EmbedSky/busybox-1.13.0/networking/libiproute/iptunnel.c文件，
注释掉//#include <netinet/ip.h>

(6)编译并安装busybox
①输入
make ARCH=arm CROSS_COMPILE=arm-linux-(如果Makefile指定了，就不用加ARCH了)
生成/opt/EmbedSky/busybox-1.13.0/busybox目录

②安装：
mkdir /opt/EmbedSky/busybox-1.13.0/_install
make install CONFIG_PREFIX=/opt/EmbedSky/busybox-1.13.0/_install
生成一个/opt/EmbedSky/busybox-1.13.0/_install目录，里面有bin,sbin,usr,linuxrc
查看一下文件详细信息，发现他们的命令执行程序都只是链接文件，真正调用的程序是busybox
cd bin
ll tftp -l
lrwxrwxrwx 1 root root 7 Feb 24 23:41 tftp -> busybox
说明这个Linux的命令执行程序tftp只是链接文件，真正调用的程序是busybox。同时，通过这个程序的第一个参数
名字tftp，得到本次要调用tftp执行程序

③检查这次有没有安装好，看一下有没有
cd /opt/EmbedSky/busybox-1.13.0/_install/sbin/init这个链接，如果有，就说明安装好了。
因为当在系统启动时，内核通过这个init链接才会转到用户空间，或应用程序来运行
 
3)构建文件系统
Linux-2.6.25.8和Linux-2.6.30.4的内核可以用相同的文件系统，他们之间主要部分是相同的，只是
驱动模块不同而已

(1)建立一个opt/EmbedSky/root_2.6.25.8目录，复制/opt/EmbedSky/busybox-1.13.0/_inatall目录
里面的
bin放命令,sbin放命令,usr用户信息文件,linuxrc(Linux的启动脚本，一个shell文件)过来
新建dev,etc,home,lib,mnt,opt,proc,root,sddisk,sys,tmp,udisk,var,web目录
在usr目录下，建立一个lib,share目录

mkdir -p /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8
cp -rf /opt/EmbedSky/busybox-1.13.0/_inatall/* .
mkdir -p dev etc home/sky lib mnt opt proc root sddisk sys tmp udisk usr/lib usr/share var web

(2)完善dev目录：设备驱动程序放在这，以文件编程的形式控制
不管是字符设备，还是块设备等驱动程序，都以文件的方式来提供接口给用户使用。用户要访问和操作该设备，
只要类似于读，写，控制文件即可。
需要创建dev/console,dev/null这两个设备文件，这样子在系统启动时，系统使用mdev，而mdev调用
init进程来启动。如果不创建这两个设备文件，文件系统启动时会出现错误信息Warning:unable to oprn an
initial console.
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/dev
mknod -m 666(权限) console(设备文件名) c(类型是字符型的文件) 5(主设备号) 1(次设备号)设备文件需要用mknod创建
mknod -m 666 null c 1 3

(3)完善etc目录
用来存放系统的配置文件
①fstab文件：系统挂载文件系统列表，指明需要挂载的文件系统
挂载哪个设备    挂载地方    系统类型
#device		mount-point	type	options		dump	fsck order
proc		/proc		proc	defaults		0	0
tmpfs		/tmp		tmpfs	defaults		0	0
sysfs		/sys		sysfs	defaults		0	0
tmpfs		/dev		tmpfs	defaults		0	0
var		/dev		tmpfs	defaults		0	0
ramfs		/dev		ramfs	defaults		0	0

②group文件：用户系统组配置文件
root:*:0:
daemon:*:1:
bin:*:2:
sys:*:3:
adm:*:4:
tty:*:5:
disk:*:6:
lp:*:7:lp
mail:*:8:
news:*:9:
uucp:*:10:
proxy:*:13:
kmem:*:15:
dialout:*:20:
fax:*:21:
voice:*:22:
cdrom:*:24:
floppy:*:25:
tape:*:26:
sudo:*:27:
audio:*:29:
ppp:x:99:
500:x:500:sky
501:x:501:sky

③inittab文件：系统init进程配置文件  
里面使用的tq2440_serial0的意义：在s3c24xx系列芯片里面串口驱动是使用tq2440_serial作为设备名
(在2.6.25.8中在drivers/serial/s3c2440.c文件的949行，在2.6.30.4中在drivers/serial/samsung.c文件的888行,
已经将其修改为tq2440_serial了)，同时板子又是使用串口0作为控制台，所以使用tq2440_serial0
# /etc/inittab
::sysinit:/etc/init.d/rcS
tq2440_serial0::askfirst:-/bin/sh
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r


修改这个文件属性chmod 777 inittab

④shadow文件:当使用passwd命令时需要该文件参与
内容为空

⑤passwd文件：账户密码文件
root::0:0:root:/:/bin/sh
ftp::14:50:FTP User:/var/ftp:
bin:*:1:1:bin:/bin:
daemon:*:2:2:daemon:/sbin:
nobody:*:99:99:Nobody:/:
sky:$1$8GIZx6d9$L2ctqdXbYDzkbxNURpE4z/:502:502:Linux User,,,:/home/sky:/bin/sh

⑥
profile:用户环境配置文件
# Ash profile 
# vim: syntax=sh

# No core files by default
#ulimit -S -c 0 > /dev/null 2>&1

USER="`id -un`"
LOGNAME=$USER
PS1='[\u@\h \W]# '
PATH=$PATH

HOSTNAME=`/bin/hostname`

export USER LOGNAME PS1 PATH

⑦
mdev.conf:mdev设备配置文件，因为从2.6.18版本开始linux放弃使用devfs而采用udev(mdev是udev的简化版本)，
这里该 文件可以是空，也可以按照一定规则编写，这里添加了自动挂载和卸载SD卡和U盘得脚本文件在其中
sd[a-z]*[0-9]		0:0	0660	@(mount -t vfat -o iocharset=utf8 /dev/$MDEV /udisk)
sd[a-z]*[0-9]		0:0	0660	*(umount /udisk)
mmcblk[0-9]*p[0-9]	0:0	0660	@(mount -t vfat -o iocharset=utf8 /dev/$MDEV /sddisk)
mmcblk[0-9]*p[0-9]	0:0	0660	*(umount /sddisk)
这里挂载两个设备：
当SD卡插入时自动挂载SD卡到“/sddisk”目录上,挂载后，在/dev目录下显示设备名为mmcblk0p1
当U盘插入时自动挂载到U盘到"/udisk"目录上,挂载后，在/dev目录下显示设备名为sda1

注意：
有些U盘插入后，在/dev目录下显示为sda,这时就要写成sd[a-z]
有些SD卡插入后，在/dev目录下显示为mmcblk0,这时就要写成mmcblk[0-9]

注意：
设iocharset=utf8，在QT中查看U盘或者SD卡时，能够看到中文文件和目录，但是在串口终端访问
U盘或者SD卡时就不能看到中文了
设iocharset=cp936，在串口终端访问U盘或者SD卡时，能够看到中文文件和目录，但是在QT中查
看U盘或者SD卡时就不能看到中文了

⑧
resolv.conf:DNS配置文件，访问外网时需要DNS的信息
nameserver 202.96.128.166

⑨
init.d目录：启动文件目录，存放了系统启动时配置以及自动加载的进程
init.d/rcS:系统启动时，自动加载的程序项
#!/bin/sh


PATH=/sbin:/bin:/usr/sbin:/usr/bin
runlevel=S
prevlevel=N
umask 022
export PATH runlevel prevlevel

#
#	Trap CTRL-C &c only in this shell so we can interrupt subprocesses.
#
//加载关于mdev的使用
mount -a
mkdir -p /dev/pts
mount -t devpts devpts /dev/pts
echo /sbin/mdev > /proc/sys/kernel/hotplug
mdev -s
mkdir -p /var/lock

/bin/hostname -F /etc/sysconfig/HOSTNAME

改变文件权限
chmod 777 rcS
注意，一定要改变权限，不然启动板子时会出现
cannot run 'etc/init.d/rcs':permission denie 错误
⑩rc.d目录：存放一些自启动所需要调用的脚本
rc.d/init.d/httpd:存放自启动所要调用的脚本

#!/bin/sh

base=boa

# See how we were called.
case "$1" in
  start)
		/sbin/$base
        ;;
  stop)
	pid=`/bin/pidof $base`
	if [ -n "$pid" ]; then
		kill -9 $pid
	fi
        ;;
esac

exit 0

⑾boa目录：天嵌所特有的目录，用来存放web服务器的配置脚本
boa/boa.conf:boa WEB服务器配置文件

⑿sysconfig目录：存放了名为HOSTNAME的文件，该文件内容为
         EmbedSky，这个就是[root@EmbedSky/]里面
sysconfig/HOSTNAME:主机名称文件
EmbedSky

(4)home目录：存放用户文件的目录，建立一个sky目录，这个目录就是刚才的etc目录passwd文件里面的
用户sky的目录
chmod 777 home/sky这样子在使用ftp发送数据时，才可以操作该目录

/*
mime.types:系统密码文件
net.conf:网络配置文件
*/

(5)lib目录：放的库文件，即是程序库文件以及内核模块，直接从交叉编译器的库文件目录中拷贝过来
arm-none-linux-gnueabi工具链：现在的系统调用，都是基于eabi接口规范的，即实现的原理，或中间使用的寄存器都是基于这个规范的
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8
cp -f /opt/EmbedSky/4.3.3/arm-none-linux-gnueabi/libc/armv4t/usr/lib/*.so* lib Ca

rm -f lib/libwv* lib/libuniconf*删除PPP拨号软件相应的库，不需要。

(6)mnt目录：挂载U盘等外设，这里面建立两个目录udisk,sd,用来挂载U盘和SD卡

(7)opt目录：附加的软件套件，用来保存Qt的相关目录
(8)proc目录：内核与用户交互的接口,内核可以把信息反映给用户，同时用户也可以通过这个接口改变内核的配置
(9)root：root用户主目录，空着        
(10)sys：系统信息与控制(总线，设备以及驱动程序)的虚拟文件系统，mdev可能会在下面
         建立某些文件，空着，以便动态产生。比如usb总线挂了哪些设备，pci总线挂了哪些设备等
(11)tmp：存放临时文件，空着。
(12)web:存放web服务器的相关文件的目录，直接从天嵌的文件系统中复制过来
(13)var:系统日志
(14)usr/bin：非用户必备的二进制文件。这里复制了tq的几个数据传输文件，以方便传输数据
①
从天嵌提供的文件2.6.30.4中复制用于串口传输文件的命令到我们要移植的文件系统中
rm -f /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/usr/bin/rx
cd /home/opt/EmbedSky/root_qt_4.5_2.6.30.4/usr/bin
cp -f rb rx rz sb sz /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/usr/bin

②rz,sz实现使用超级终端的zmodem进行接收和发送文件的功能，使用方法：在串口终端中
$rz，
   然后右击打开zmodem,就可以向开发板发送文件
$sz filename 发送指定的文件 

4)关闭看门狗
linux-2.6.30.4/drivers/watchdog/s3c2410_wdt.c文件中，修改
#define CONFIG_S3C2410_WATCHDOG_ATBOOT (0)//原先1，表示开启看门狗，这里予以关闭
#define CONFIG_S3C2410_WATCHDOG_DEFAULT_TIME(30)喂狗时间

5)编译生成文件系统
cd /opt/EmbedSky/opt/EmbedSky
mkyaffs2image root_2.6.25.8 root_2.6.25.8.bin
注意：如果NandFlash是64MB，用mkyaffsimage_2工具，如果NandFlash是256MB，用
mkyaffs2image工具。这个工具在从前安装交叉编译器时就一起安装了，在/usr/local/sbin目录下

6)启动后，先成功加载内核，然后成功加载文件系统，给出这个提示
Please press Enter to activate this console
按下Enter键之后
[root@EmbedSky/]#
可以接收linux指令


*移植2.6.30.4文件系统
1)
Linux-2.6.30.4内核已经添加对NFS的支持了，并且宿主机Linux添加NFS文件服务端
sudo /etc/init.d/nfs-kernel-server start
2)利用BusyBox建立根文件系统,同上
3)构建文件系统
(1)建立一个opt/EmbedSky/root_2.6.30.4目录，复制/opt/EmbedSky/busybox-1.13.0/_inatall目录
里面的bin,sbin,usr,linuxrc(Linux的启动脚本，一个shell文件)过来
新建dev,etc,home,lib,mnt,opt,proc,root,sddisk,sys,tmp,udisk,var,web目录
在usr目录下，建立一个lib,share目录

mkdir -p /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8
cp -rf /opt/EmbedSky/busybox-1.13.0/_inatall/* .
mkdir -p dev etc home/sky lib mnt opt proc root sddisk sys tmp udisk usr/lib usr/share var usr/bin
         usr/lib usr/sbin lib/modules
(2)完善dev目录：设备驱动程序放在这，以文件编程的形式控制
需要创建dev/console,dev/null这两个设备文件,同上面文件系统一样         
mknod -m 666(权限) console(设备文件名) c(类型是字符型的文件) 5(主设备号) 1(次设备号)设备文件需要用mknod创建
mknod -m 666 null c 1 3

(3)完善etc目录：etc目录下的文件一般各个根文件系统的都是一样的，不会去更改，因此直接找其他的文件系统复制过来
即可，这里同上面

4)关闭看门狗
linux-2.6.30.4/drivers/watchdog/s3c2410_wdt.c文件中，修改
#define CONFIG_S3C2410_WATCHDOG_ATBOOT (0)//原先1，表示开启看门狗，这里予以关闭
#define CONFIG_S3C2410_WATCHDOG_DEFAULT_TIME(30)喂狗时间

5)编译内核模块
我们开始在Linux中只是编译了内核，还要再编译内核模块(即配置选项中为M的)。内核驱动模块文件即
是*.ko文件，我们在内核中挂载的驱动模块就是它
cd opt/EmbedSky/linux-2.6.25.8
make modules ARCH=arm CROSS_COMPILE=arm-linux-

6)安装内核模块：我们刚编译好的内核模块，即.ko文件，它现在还存放在内核源代码中的。这个内核安装，实际只是一个
拷贝的过程，把它拷贝到文件系统的指定地方中去
make modules_install ARCH=arm INSTALL_MOD_PATH=/opt/EmbedSky/root_2.6.25.8/
安装完成后，进入文件系统
cd /opt/EmbedSky/root_2.6.25.8/lib/modules/,里面有一个目录，即是内核的版本
,进去之后cd /opt/EmbedSky/root_2.6.25.8/lib/modules/linux-2.6.25.8/
产生很多文件和目录
cd kernel/drivers/char/ 就可以看到内核模块了


*移植Initramfs文件系统
1)、配置Linux内核，支持Initramfs文件系统
(1)
cd opt/EmbedSky/linux-2.6.25.8
(2)
Linux 中make menuconfig ARCH=arm
General setup-->
  [*]Initial RAM filesystem and RAM disk(initramfs/initrd) support
他把根文件系统和Linux内核做成一个文件，因此配置时需要告诉内核根文件系统的路径
  (/opt/EmbedSky/root_2.6.25.8)Initramfs source file(s)

  
2)、进入制作好的根文件系统中，执行软链接
(1)
  cd /opt/EmbedSky/root_2.6.25.8/
(2)  
  ln -s ./bin/busybox init
  
  结果，在/opt/EmbedSky/root_2.6.25.8/路径下，产生一个init执行程序
  
3)、修改启动命令参数
(1)
  cd opt/EmbedSky/linux-2.6.25.8
  vi .config
(2)在.config文件中  
  CONFIG_CMDLINE="console=ttySAC0 mem=64M"
  
(3)重新编译内核
make zImage ARCH=arm CROSS_COMPILE=arm-linux-
编译内核        
生成zImage-ramfs


*一步步完全手动移植文件系统
1)最小的根文件系统：
/dev/console,/dev/null
busybox->init
/etc/inittab
配置文件中指定的程序
c库

(1)、利用BusyBox建立根文件系统，同上。完成后，就构造好了busybox->init
(2)创建dev/console,dev/null这两个设备文件
mkdir -p dev
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/dev
mknod -m 666(权限) console(设备文件名) c(类型是字符型的文件) 5(主设备号) 1(次设备号)设备文件需要用mknod创建
mknod -m 666 null c 1 3
(3)创建etc/inittab文件
mkdir -p etc
vi inittab
# /etc/inittab
console::askfirst:-/bin/sh
修改这个文件属性chmod 777 inittab
(4)安装c库，即glibc，同上
mkdir -p lib
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8
cp -f /opt/EmbedSky/4.3.3/arm-none-linux-gnueabi/libc/armv4t/usr/lib/*.so* lib Ca
只拷贝动态库，不考贝静态库文件

rm -f lib/libwv* lib/libuniconf*删除PPP拨号软件相应的库，不需要。

(5)编译生成文件系统
cd /opt/EmbedSky/opt/EmbedSky
mkyaffs2image root_2.6.30.4.gzz root_2.6.30.4.gzz.bin
注意：如果NandFlash是64MB，用mkyaffsimage_2工具，如果NandFlash是256MB，用
mkyaffs2image工具。这个工具在从前安装交叉编译器时就一起安装了，在/usr/local/sbin目录下

最小根文件系统已经完成

2)完善根文件系统
(1)添加proc目录
①
mkdir -p proc
内核提供了一个虚拟的文件系统，proc文件系统，用于内核与用户交互的接口,内核可以
把信息反映给用户，同时用户也可以通过这个接口改变内核的配置

②挂载proc文件系统
vi etc/inittab

# /etc/inittab
::sysinit:/etc/init.d/rcS
console::askfirst:-/bin/sh

③
vi etc/init.d/rcS
mount -t proc none /proc
mount -a

改变文件权限
chmod 777 rcS

④vi etc/fstab
#device mount-point type options dump fsck order
proc     /proc      proc defaults      0    0


⑤例：板子运行后，在板子上
cd /proc/1
ls -l fd
可以看到
lrwx---- .../dev/console 标准输入
lrwx---- .../dev/console 标准输出
lrwx---- .../dev/console 标准错误

ps
PID USER VSZ   STAT COMMAND
1    0   2072  s     init

cat /proc/mounts查看目前板子上挂载了多少文件系统
rootfs / rootfs rw 0 0
/dev/root / yaffs rw, relatime 0 0   挂载根文件系统
none /proc proc rw,relatime 0 0      挂载proc文件系统

(2)dev目录：对里面存放设备的驱动，但是一个一个驱动加很麻烦。
我们这里使用mdev机制，自动创建/dev/设备节点。mdev机制在busybox已经有提供了
①
mkdir -p /sys
②vi etc/fstab 挂载sysfs虚拟文件系统，它是用来系统信息与控制(总线，设备以及驱动程序)的
虚拟文件系统，mdev可能会在下面建立某些文件，空着，以便动态产生。

#device mount-point type options dump fsck order
proc     /proc      proc  defaults      0    0
sysfs    /sys       sysfs defaults      0    0
tmpfs    /dev       tmpfs defaults      0    0

③
vi etc/init.d/rcS
mount -t proc none /proc
mount -a
mkdir /dev/pts
mount -t devpts devpts /dev/pts
echo /sbin/mdev > /proc/sys/kernel/hotplug  这个hotplug是热拔插技术，当插入U盘时，会自动的动态
       加载某个驱动，内核会调用hotplug,这就会指向mdev,程序就会自动创建设备节点
mdev -s 奖原先就有的设备节点创建出来

④下载到板子上
ls /dev
就可以看到一大堆设备文件驱动，这些都是mdev为我们创建的

cat /proc/mounts查看目前板子上挂载了多少文件系统
rootfs / rootfs rw 0 0
/dev/root / yaffs rw,relatime  0 0   挂载根文件系统
none /proc proc rw,relatime 0 0      挂载proc文件系统
sysfs /sys sysfs rw,relatime 0 0
tmpfs /dev tmpfs rw,relatime 0 0
devpts /dev/pts devpts rw,relatime,mode=600 0 0

*NFS文件系统
1)制作完成最小的文件系统之后，进行网络配置
(1)在板子上进行网络配置
ifconfig eth0 up
ifconfig，接上网线
ifconfig eth0 192.168.0.33  要与window，linux处于同一个网段，且地址不能冲突

(2)在windows进行设置：
windows防火墙是否关闭？主菜单------控制面板------windows防火墙------关闭
关闭无线网卡

(3)虚拟机
Network Adapter设为Bridged桥接

(4)在Linux进行设置
①
关闭linux的防火墙
Redhat使用
service iptables stop 
ubuntu使用
sudo ufw disable
②安装NFS服务端，重启NFS服务

(5)在板子上手工挂接：从flash上启动根文件系统，再用命令挂接NFS
启动内核后，使用命令挂接
mkdir /mnt
mount -t nfs 192.168.0.29:/opt/EmbedSky/opt/EmbedSky/root_2.6.30.4.gzz /mnt -o nolock

(6)可以在服务器端编辑程序，在板子上运行程序了

(7)卸载挂接文件
umount /mnt


3、移植串口驱动
原串口驱动中，内核只支持两个串口UART0，UART1，而UART2的驱动原先是针对红外接口的，
不是串口驱动，这里将它改为串口驱动  
1)
修改内核源码arch/arm/mach-s3c2440/mach-smdk2440.c
static struct s3c2410_uartcfg smdk2440_uartcfgs[] __initdata = {
        [0] = {
                .hwport      = 0,
                .flags       = 0,
                .ucon        = 0x3c5,
                .ulcon       = 0x03,
                .ufcon       = 0x51,
        },
        [1] = {
                .hwport      = 1,
                .flags       = 0,
                .ucon        = 0x3c5,
                .ulcon       = 0x03,
                .ufcon       = 0x51,
        },
        /* IR port */
        [2] = {
                .hwport      = 2,
                .flags       = 0,
                .ucon        = 0x3c5,
                .ulcon       = 0x03,//改这里
                .ufcon       = 0x51,
        }
};
修改了ULCON2寄存器值，代表发送与接收每帧的数据位数为8位。
2)
修改drivers/serial/s3c2410.c文件
static int s3c24xx_serial_startup(struct uart_port *port)
{
	struct s3c24xx_uart_port *ourport = to_ourport(port);
	int ret;

	dbg("s3c24xx_serial_startup: port=%p (%08lx,%p)\n",
	    port->mapbase, port->membase);

	if(port->line == 2)
	{
		s3c2410_gpio_cfgpin(S3C2410_GPH6, S3C2410_GPH6_TXD2);
		s3c2410_gpio_pullup(S3C2410_GPH6, 1);

		s3c2410_gpio_cfgpin(S3C2410_GPH7, S3C2410_GPH7_RXD2);
		s3c2410_gpio_pullup(S3C2410_GPH7, 1);
	}

	rx_enabled(port) = 1;

	ret = request_irq(RX_IRQ(port),
			  s3c24xx_serial_rx_chars, 0,
			  s3c24xx_serial_portname(port), ourport);

	if (ret != 0) {
		printk(KERN_ERR "cannot get irq %d\n", RX_IRQ(port));
		return ret;
	}

	ourport->rx_claimed = 1;

	dbg("requesting tx irq...\n");

	tx_enabled(port) = 1;

	ret = request_irq(TX_IRQ(port),
			  s3c24xx_serial_tx_chars, 0,
			  s3c24xx_serial_portname(port), ourport);

	if (ret) {
		printk(KERN_ERR "cannot get irq %d\n", TX_IRQ(port));
		goto err;
	}

	ourport->tx_claimed = 1;

	dbg("s3c24xx_serial_startup ok\n");

	/* the port reset code should have done the correct
	 * register setup for the port controls */

	return ret;

 err:
	s3c24xx_serial_shutdown(port);
	return ret;
}


修改串口设备名
static struct uart_driver s3c24xx_uart_drv = {
	.owner		= THIS_MODULE,
	.dev_name	= "tq2440_serial",
	.nr		= 3,
	.cons		= S3C24XX_SERIAL_CONSOLE,
	.driver_name	= S3C24XX_SERIAL_NAME,
	.major		= S3C24XX_SERIAL_MAJOR,
	.minor		= S3C24XX_SERIAL_MINOR,
};

3)make menuconfig配置
Device Drivers-->
  Character devices-->
    Serial drivers-->
      <>8250/16550 and compatiible serial support
        ***Non-8250 serial port support***
      <*>Samsung SOC serial support
      [*]support for console on samsung soc serial port
      <*>samsung s3c2440/s3c2442 serial port support
保存为.conf文件
make zImage编译镜像,得到zImage.bin文件，下载到开发板上

4)编译serial_test的串口测试程序
(1)
D:\TQ2440配套光盘\TQ2440_CD\Linux资源\Linux源码包\apps_20100601.tar.bz2
复制到Linux的/home/opt/EmbedSky中
(2)tar xvfj apps_20100601.tar.bz2 -C /，然后源码包就解压到/opt/EmbedSky/apps/目录下
(3)
Serial_Test源码：用于测试串口的程序
使用make,可以生成可执行方法
(4)
将文件
/opt/EmbedSky/apps/serial_test/serial_test可执行文件复制到文件系统
/opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/sbin中

将文件
/opt/EmbedSky/apps/serial_test/tq2440_serial.cfg复制到
/opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/etc/中

tq2440_serial.cfg文件保存了串口的参数：波特率，串口号，数据位，停止位，奇偶校验位。
当需要使用某个串口时，设置该文件为相应信息即可。这个文件默认配置是：串口3波特率
115200，数据位8，停止位1，无奇偶校验位

在文件系统/opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/etc/tq2440_serial.cfg中进行配置一下，
配置与pc机的串口通讯。使用默认提供的即可

在系统即启动后，串口serial0用来与PC机的console连接，作基本操作。用串口serial2与pc机作
串口通讯实验
(5)
制作文件系统，下载到开发板中

5)测试串口程序
串口serial0,serial1,serial2都是开发板上实际存在的物理串口，serial0通过串口线与pc机的console互连，serial1和serial2是
扩展串口，需要连接到串口扩展板上，再连到pc机上，做串口调试试验。
注意：请问做那个linux step by step教程里step12一定需要串口扩展板吗
答：没有模块，可以不用做这个试验；
或者短路对应串口的2、3脚，然后自发自收，不过自发自收就要写一个串口测试程序了
（在光盘的apps_20100601.tar.bz2中有串口测试程序的源码的）。

(1)简单串口测试，在busybox中有一个getty命令，用来配置串口参数，并且切换串口的
①
serial0直接与console连接，用来控制板子的Linux系统的
②
在serial0中输入
getty /dev/s3c2440_serial2 115200就是把控制台切换为serial2,并且波特率设为115200
③
通过串口扩展板，再引串口serial2与pc连接
④
在控制台上输入root,既可以切换串口了

(2)使用serial_test作串口实验


4、移植网卡驱动
1)获取驱动源码：
在Linux2.6.25.8/drivers/net/dm9000.c文件中时网卡驱动，它的版本为1.3版本，并不适合网卡
芯片DM9000E，而我们开发板就是使用这个芯片，所以我们要找到linux-2.6.24版本，用它的网卡
驱动，它的版本是1.2，可以使用。我们把它替换掉2.6.25版本网卡驱动，就可以使用网卡了

2)修改驱动源码
(1)修改arch/arm/plat-s3c24xx/common-smdk.c
...
#include <asm/plat-s3c24xx/pm.h>
添加
#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
#include <linux/dm9000.h>
#endif
...
#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
/* DM9000 */
static struct resource s3c_dm9k_resource[] = {
    [0] = {
        .start = S3C2410_CS4,       /* ADDR2=0锛板朵娇ㄨ涓板 */
        .end   = S3C2410_CS4 + 3,
        .flags = IORESOURCE_MEM,
    },
    [1] = {
        .start = S3C2410_CS4 + 4,   /* ADDR2=1锛浼杈版朵娇ㄨ涓板 */
        .end   = S3C2410_CS4 + 4 + 3,
        .flags = IORESOURCE_MEM,
    },
    [2] = {
        .start = IRQ_EINT7,         /* 涓?*/
        .end   = IRQ_EINT7,
        .flags = IORESOURCE_IRQ,
    }

};

/* for the moment we limit ourselves to 16bit IO until some
 * better IO routines can be written and tested
*/

static struct dm9000_plat_data s3c_dm9k_platdata = {
    .flags      = DM9000_PLATF_16BITONLY,
};

static struct platform_device s3c_device_dm9k = {
    .name       = "dm9000",
    .id     = 0,
    .num_resources  = ARRAY_SIZE(s3c_dm9k_resource),
    .resource   = s3c_dm9k_resource,
    .dev        = {
        .platform_data = &s3c_dm9k_platdata,
    }
};
#endif /* CONFIG_DM9000 */
...
static struct platform_device __initdata *smdk_devs[] = {
	&s3c_device_nand,
//	&smdk_led4,
//	&smdk_led5,
//	&smdk_led6,
//	&smdk_led7,
#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
	&s3c_device_dm9k,
#endif    
};
...
(2)修改drivers/net/dm9000.c
...
#include <asm/io.h>
#if defined(CONFIG_ARCH_S3C2410)
#include <asm/arch-s3c2410/regs-mem.h>
#endif
...
#define DM9000_IRQ_FLAGS	(IRQF_SHARED | IRQF_TRIGGER_HIGH)
#elif defined(CONFIG_ARCH_S3C2410)
#define DM9000_IRQ_FLAGS	(IRQF_SHARED | IRQF_TRIGGER_RISING)
#else
DM9000_IRQ_FLAGS	IRQF_SHARED
#endif
...
#if defined(CONFIG_ARCH_S3C2410)//注意，要加这个定义
	unsigned int oldval_bwscon;		/* ㄦヤ瀛BWSCON瀵瀛ㄧ?*/
	unsigned int oldval_bankcon4;		/* ㄦヤ瀛S3C2410_BANKCON4瀵瀛ㄧ?*/
#endif
...
#if defined(CONFIG_ARCH_S3C2410)
	/* 璁剧疆Bank4: 荤嚎瀹藉害涓?6, 浣胯nWAIT?*/
	oldval_bwscon = *((volatile unsigned int *)S3C2410_BWSCON);
	*((volatile unsigned int *)S3C2410_BWSCON) = (oldval_bwscon & ~(3<<16)) \
		| S3C2410_BWSCON_DW4_16 | S3C2410_BWSCON_WS4 | S3C2410_BWSCON_ST4;

	/* 璁剧疆BANK3堕村? */
	oldval_bankcon4 = *((volatile unsigned int *)S3C2410_BANKCON4);
	*((volatile unsigned int *)S3C2410_BANKCON4) = 0x1f7c;
#endif
...
#if defined(CONFIG_ARCH_S3C2410)
	printk("Now use the default MAC address: 10:32:54:76:98:ba\n");
	ndev->dev_addr[0] = 0x10;
	ndev->dev_addr[1] = 0x32;
	ndev->dev_addr[2] = 0x54;
	ndev->dev_addr[3] = 0x76;
	ndev->dev_addr[4] = 0x98;
	ndev->dev_addr[5] = 0xba;
#endif
...
#if defined(CONFIG_ARCH_S3C2410)
	/* ㈠瀵瀛ㄥョ?*/
	*((volatile unsigned int *)S3C2410_BWSCON) = oldval_bwscon;
	*((volatile unsigned int *)S3C2410_BANKCON4) = oldval_bankcon4;
#endif
...
3)配置内核
进入/Linux-2.6.25.8/make menuconfig
Networking-->
  [*]Networking support
     Networking options-->
       <>Packet socket
       <*>Unix domain socket
       <>PF_KEY sockets
       [*]TCP/IP networking
       []IP:multicasting
       []IP:advanced router
       [*]IP:kernel level autoconfiguration
       [*]IP:DHCP support
       []IP:BOOTP support
       []IP:PARP support 
Device Drivers-->
  [*]Network device support-->
     [*] Ethernet(10 or 100Mbit)-->
     -*- Generic Media Independent Interface device support
     <*>DM9000 support
     (4)DM9000 maximum debug level
保存为.config

将Linux内核下载到开发板上  

4)DM9000网卡配置
(1)
进入root_2.6.25.8/etc/init.d/rcS
ifconfig lo 127.0.0.1设置本地回环设备IP地址，缺省值
net_set & 调用网络配置文件

/etc/rc.d/init.d/httpd start 启动web服务器的代码

(2)进入/etc/rc.d/init.d/
chmod 777 httpd

(3)
①在sbin目录下创建一个文件root_2.6.25.8/sbin/net_set  

#!/bin/sh

echo Try to bring eth0 interface up ...>/dev/tq2440_serial0

#source /etc/nettype.conf注释掉
if [ -f /etc/net.conf ] ; then
	source /etc/net.conf

	if [ $NETTYPE -eq 1 ] ; then
		ifconfig eth0 down
		ifconfig eth0 hw ether $MAC
		echo ifconfig eth0 hw ether $MAC >/dev/tq2440_serial0
		ifconfig eth0 $IPADDR netmask $NETMASK up
		echo ifconfig eth0 $IPADDR netmask $NETMASK up >/dev/tq2440_serial0
		route add default gw $GATEWAY
		echo add default gw $GATEWAY >/dev/tq2440_serial0
	elif [ $NETTYPE -eq 2 ] ; then
		source /etc/wifi.conf
		ifconfig eth0 down
		ifconfig wlan0 $IPADDR netmask $NETMASK up
		echo ifconfig wlan0 $IPADDR netmask $NETMASK up >/dev/tq2440_serial0
		route add default gw $GATEWAY
		echo route add default gw $GATEWAY >/dev/tq2440_serial0
		iwconfig wlan0 essid "$NETNAME" key "$PASSWORD"
		echo iwconfig wlan0 essid "$NETNAME" key "$PASSWORD" >/dev/tq2440_serial0
	fi
else

	ifconfig eth0 hw ether 10:23:45:67:89:ab
	ifconfig eth0 192.168.1.6 netmask 255.255.255.0 up
	route add default gw 192.168.1.2
	echo ifconfig eth0 hw ether 10:23:45:67:89:ab >/dev/tq2440_serial0
	echo ifconfig eth0 192.168.1.6 netmask 255.255.255.0 up >/dev/tq2440_serial0
	echo route add default gw 192.168.1.2 >/dev/tq2440_serial0
fi

echo Done > /dev/tq2440_serial0

②chmod 777 net_set 

(4)创建文件root_2.6.25.8/etc/net.conf用于存放网络配置相关信息
IPADDR=192.168.1.6
NETMASK=255.255.255.0
GATEWAY=192.168.1.2
MAC=10:23:45:67:89:ab

5)构建web服务器，移植boa软件
(1)
将D:\TQ2440配套光盘\TQ2440_CD\Linux资源\web服务器\boa-0.94.13.tar.gz上传到
/home/opt/EmbedSky中

解压：tar xvfz boa-0.94.13.tar.gz -C /opt/EmbedSky
(2)
cd /opt/EmbedSky/boa-0.94.13/src
./configure
进行编译

(3)修改/opt/EmbedSky/boa-0.94.13/src/Makefile文件
CC=gcc
CPP=gcc -E
改为
CC=arm-linux-gcc
CPP=arm-linux-g++ -E


修改/opt/EmbedSky/boa-0.94.13/src/boa.c文件
注释掉这几行
/*
if(setuid(0)!=-1)
{
DIE("icky Linux kernel bug!");
}
*/  

修改/opt/EmbedSky/boa-0.94.13/src/compat.h文件
把120行中，这句话
#define TIMEZONE_OFFSET(foo) foo##->tm_gmtoff
改为
#define TIMEZONE_OFFSET(foo) foo->tm_gmtoff

(4)编译和优化
make
生成这个可执行文件/opt/EmbedSky/boa-0.94.13/src/boa
arm-linux-strip boa 优化这个执行文件，去除boa中的调试信息

6)构建web服务器，移植cgic库
(1)
将D:\TQ2440配套光盘\TQ2440_CD\Linux资源\web服务器\cgic205.tar.gz上传到
/home/opt/EmbedSky中

解压：tar xvfz cgic205.tar.gz -C /opt/EmbedSky

(2)
cd /opt/EmbedSky/opt/EmbedSky/cgic205
修改文件/opt/EmbedSky/opt/EmbedSky/cgic205/Makefile

CC=arm-linux-gcc  //原来是CC=gcc
AR=arm-linux-ar   //原来是AR=ar
RANLIB=arm-linux-ranlib  //原来是RANLIB=ranlib
STRIP =arm-linux-strip

cp libcgic.a /opt/EmbedSky/4.3.3/arm-none-linux-gnueabi/libc/armv4t/lib
cp cgic.h /opt/EmbedSky/4.3.3/arm-none-linux-gnueabi/libc/usr/include
//这句一定要加，不然会报arm-linux-gcc -g编译器未找到的错误
@echo libcgic.a is in /opt/EmbedSky/4.3.3/arm-none-linux-gnueabi/libc/armv4t/lib. cgic.h is in /opt/EmbedSky/4.3.3/arm-none-linux-gnueabi/libc/usr/include.

$(CC) $(CFLAGS) cgictest.o -o cgictest.cgi ${LIBS}  //gcc改成$(CC)$(CFLAGS)

$(CC) $(CFLAGS) capture.o -o capture ${LIBS}//gcc改成$(CC)$(CFLAGS)
$(STRIP) capture

(3)编译和压缩
/home/opt/EmbedSky/cgic205
make编译
arm-linux-strip capture压缩

7)配置boa软件
(1)
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8
mkdir -p web etc/boa
cp /opt/EmbedSky/boa-0.94.13/src/boa /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/sbin
cp /opt/EmbedSky/boa-0.94.13/boa.conf /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/etc/boa
(2)修改boa.conf 文件
(3)从天嵌做好的文件系统的etc/mime.types文件拷贝到
/opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/etc

8)配置cicg库
cd /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/web
mkdir cgi-bin
cp /opt/EmbedSky/cgic205/capture /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/web/cgi-bin
cp /opt/EmbedSky/cgictest.cgi /opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/web/cgi-bin


5、USB驱动移植
1)USB设备的配置，使开发板能够读取U盘
(1)
cd /opt/EmbedSky/opt/EmbedSky/Linux2.6.25.8
make menuconfig
Device Drivers-->
  SCSI device support-->
    <*>SCSI device support
    [*]legacy/proc/scsi/support
    <*>SCSI disk support
    <*>SCSI CDROM support
  [*]HID Devices-->
    <*>USB Human Interface Device(full HID)support
    [*]/dev/hiddev raw HID device support
  [*]USB support-->
    <*>Support for Host-side USB
    [*]USB device filesystem
    [*]USB device class-devices(DEPRECATED)
    <*>OHCI HCD support
    <*> USB Mass support  

(2)
下载到开发板上，启动系统。提示....this console.
按下Entetr进入文件系统
插入USB盘，提示
scsi 1:0:0:0 Direct-Access...
sda:sda1  注意这个提示，有则成功了，同时要把这个设备挂接

FAT:utf8 is not a ...说明不支持中文
输入
mount /dev/sda1 /mnt/udisk/ 挂接设备
ls /mnt/udisk/ 访问设备
umount /mnt/udisk/  卸载设备

2)把整个开发板变成一个U盘，插入PC机后，可以读写开发板
把USB下载口当做U盘的口
(1)修改文件arch/arm/mach-s3c2440/mach-smdk2440.c
#include <asm/plat-s3c24xx/udc.h>

static void EmbedSky_udc_pullup(enum s3c2410_udc_cmd_e cmd)
{
        printk(KERN_DEBUG "EmbedSky udc: pullup(%d)\n",cmd);
	        switch (cmd)
	        {
	                case S3C2410_UDC_P_ENABLE :
	                        s3c2410_gpio_setpin(S3C2410_GPG12, 1);
	                        break;
	                case S3C2410_UDC_P_DISABLE :
	                        s3c2410_gpio_setpin(S3C2410_GPG12, 0);
	                        break;
	                case S3C2410_UDC_P_RESET :
	                        break;
		        default:
	                        break;
	        }
}

static struct s3c2410_udc_mach_info EmbedSky_udc_cfg = {
	.udc_command		= EmbedSky_udc_pullup,
};
static struct platform_device *smdk2440_devices[] __initdata = 
{
        &s3c_device_iis,
	&s3c_device_usbgadget,
}

static void __init smdk2440_machine_init(void)
{
        s3c2410_gpio_setpin(S3C2410_GPG12, 0);
        s3c2410_gpio_cfgpin(S3C2410_GPG12, S3C2410_GPIO_OUTPUT);
	s3c24xx_udc_set_platdata(&EmbedSky_udc_cfg);
}

(2)make menuconfig
加入对UDC设备的支持，以及文件系统的支持(以模块的形式)
Device Drivers-->
  [*]USB Gadget Support-->
     USB Peripheral Controller-->
           注意，这个要进入，里面选择S3C2410 USB Device Controller项目
     <*> S3C2410 udc debug messages   
 上面两项未选，运行时会编译下载运行，发现错误
insmod:cannot insert '/lib/g_file_storage.ko': No Such device  
       
     <M> USB Gadget Drivers
     <M> File-backed Storage Gadget


     
编译出Linux镜像文件     

(3)
编译出来刚刚以模块形式配置的文件系统的驱动模块
cd /opt/EmbedSky/opt/EmbedSky/Linux-2.6.25.8/
make modules SUBDIRS=drivers/usb/gadget/ 

在内核源码生成drivers/usb/gadget/g_file_storage.ko驱动模块，复制到 
/opt/EmbedSky/opt/EmbedSky/root_2.6.25.8/lib/目录下面  

编译出文件系统镜像文件

(4)运行系统后，输入
insmod /lib/g_file_storage.ko file=/dev/mtdblock2 removable=1
出现故障:
g_file_storage: unknown relocation:40
insmod:cannot insert '/lib/g_file_storage.ko':invalid module format

(5)
上查资料，发现是由于EABI-4.3.3的编译器比2.6.26.5新，在编译连接程序时两者的有些参数不兼容导致的问题。
    修改include/asm-arm/elf.h：
    ....
    #define R_ARM_JUMP24    29
    #define R_ARM_V4BX      40  /* Jasper add */
    修改arch/arm/kernel/module.c中 apply_relocate()函数实现：
    switch (ELF32_R_TYPE(rel->r_info)) {
    ....
    case R_ARM_V4BX:  /* Jasper add */

        /* Preserve Rm and the condition code. Alter 

         * other bits to re-code instruction as

         * MOV PC,Rm.
         */
        *(u32 *)loc &= 0xf000000f;
        *(u32 *)loc |= 0x01a0f000;
        break;

    default:

         ....

    }

    完成修改后，重编内核和模块，成功加载。

    # insmod g_file_storage.ko file=/dev/mtdblock2 stall=0 removable=1
    g_file_storage gadget: File-backed Storage Gadget, version: 7 August 2007
    g_file_storage gadget: Number of LUNs=1
    g_file_storage gadget-lun0: ro=0, file: /dev/mtdblock2

    

    但连接PC时配置USB失败，还是通过网络，修改drivers/usb/gadget/file_storage.c

    在start_transfer()函数中增加一个延时：

    int     rc;

    udelay(800);

    ...

    

    至此，完全成功！在PC windows侧发现存储设备，格式化，拷贝文件。

    在设备侧，验证文件：

    # mount -t vfat /dev/mtdblock2 ./mnt/
    Unable to load NLS charset cp437
    FAT: codepage cp437 not found
    mount: mounting /dev/mtdblock2 on ./mnt/ failed: Invalid argument

    此问题是由于内核不支持437字库导致，配置内核支持相关：

    File systems  --->

        -*- Native language support  --->

            <*>   Codepage 437 (United States, Canada)

    重编译内核，加载启动。

    # mount  /dev/mtdblock2 /mnt       
    # cd mnt/
    # ls
    sst.c
    
(6)注意，一定要系统完全启动后，才能插入开发板的USB线，不然电脑会蓝屏重启
insmod /lib/g_file_storage.ko file=/dev/mtdblock2 removable=1 以yaffs2文件系统的分区
作为开发板U盘的存储器

(7)将U盘插入开发板上的USB口上
insmod /lib/g_file_storage.ko file=/dev/sda1 removable=1
以这个U盘作为开发板U盘的存储器	


6、LCD移植
1)添加LCD的显示
(1)设置LCD时钟，
修改drivers/video/s3c2410fb.c文件
static void s3c2410fb_activate_var(struct fb_info *info)
{
  struct s3c2410fb_mach_info *mach_info = fbi->dev->platform_data;
  struct s3c2410fb_display *default_display = mach_info->displays +
						    mach_info->default_display;
						    
  //	fbi->regs.lcdcon1 |=  S3C2410_LCDCON1_CLKVAL(clkdiv);
	fbi->regs.lcdcon1 |=  S3C2410_LCDCON1_CLKVAL(default_display->setclkval);						    
	
}

修改include/asm-arm/arch-s3c2410/fb.h文件，在40行
unsigned setclkval; /*clkval*/

(2)修改LCD参数设置
修改arch/arm/mach-s3c2440/mach-smdk2440.c文件
static struct s3c2410fb_display smdk2440_lcd_cfg __initdata = {

	.lcdcon5	= S3C2410_LCDCON5_FRM565 |
			  S3C2410_LCDCON5_INVVLINE |
			  S3C2410_LCDCON5_INVVFRAME |
			  S3C2410_LCDCON5_PWREN |
			  S3C2410_LCDCON5_HWSWP,

	.type		= S3C2410_LCDCON1_TFT,

#if defined(CONFIG_FB_S3C24X0_T240320)
	.width		= 240,
	.height		= 320,

	.pixclock	= 100000, /* HCLK 100 MHz, divisor 4 */
	.setclkval	= 0x4,
	.xres		= 240,
	.yres		= 320,
	.bpp		= 16,
	.left_margin	= 3,	/* for HFPD*/
	.right_margin	= 6,	/* for HBPD*/
	.hsync_len	= 1,	/* for HSPW*/
	.upper_margin	= 2,	/* for VFPD*/
	.lower_margin	= 1,	/* for VBPD*/
	.vsync_len	= 1,	/* for VSPW*/

#elif	defined(CONFIG_FB_S3C24X0_S320240)
	.width		= 320,
	.height		= 240,

	.pixclock	= 80000, /* HCLK 100 MHz, divisor 3 */
	.setclkval	= 0x3,
	.xres		= 320,
	.yres		= 240,
	.bpp		= 16,
	.left_margin	= 15,	/* for HFPD*/
	.right_margin	= 5,	/* for HBPD*/
	.hsync_len	= 8,	/* for HSPW*/
	.upper_margin	= 5,	/* for VFPD*/
	.lower_margin	= 3,	/* for VBPD*/
	.vsync_len	= 15,	/* for VSPW*/

#elif	defined(CONFIG_FB_S3C24X0_W320240)
	.width		= 320,
	.height		= 240,

	.pixclock	= 80000, /* HCLK 100 MHz, divisor 3 */
	.setclkval	= 0x3,
	.xres		= 320,
	.yres		= 240,
	.bpp		= 16,
	.left_margin	= 28,	/* for HFPD*/
	.right_margin	= 24,	/* for HBPD*/
	.hsync_len	= 42,	/* for HSPW*/
	.upper_margin	= 6,	/* for VFPD*/
	.lower_margin	= 2,	/* for VBPD*/
	.vsync_len	= 12,	/* for VSPW*/

#elif	defined(CONFIG_FB_S3C24X0_TFT480272)
	.width		= 480,
	.height		= 272,

	.pixclock	= 40000, /* HCLK 100 MHz, divisor 1 */
	.setclkval	= 0x4,
	.xres		= 480,
	.yres		= 272,
	.bpp		= 16,
	.left_margin	= 19,	/* for HFPD*/
	.right_margin	= 10,	/* for HBPD*/
	.hsync_len	= 30,	/* for HSPW*/
	.upper_margin	= 4,	/* for VFPD*/
	.lower_margin	= 2,	/* for VBPD*/
	.vsync_len	= 8,	/* for VSPW*/

#elif	defined(CONFIG_FB_S3C24X0_TFT640480)
	.width		= 640,
	.height		= 480,

	.pixclock	= 40000, /* HCLK 100 MHz, divisor 1 */
	.setclkval	= 0x1,
	.xres		= 640,
	.yres		= 480,
	.bpp		= 16,
	.left_margin	= 40,	/* for HFPD*/
	.right_margin	= 67,	/* for HBPD*/
	.hsync_len	= 31,	/* for HSPW*/
	.upper_margin	= 5,	/* for VFPD*/
	.lower_margin	= 25,	/* for VBPD*/
	.vsync_len	= 1,	/* for VSPW*/

#elif	defined(CONFIG_FB_S3C24X0_TFT800480)
	.width		= 800,
	.height		= 480,

	.pixclock	= 40000, /* HCLK 100 MHz, divisor 1 */
	.setclkval	= 0x1,
	.xres		= 800,
	.yres		= 480,
	.bpp		= 16,
	.left_margin	= 15,	/* for HFPD*/
	.right_margin	= 47,	/* for HBPD*/
	.hsync_len	= 95,	/* for HSPW*/
	.upper_margin	= 9,	/* for VFPD*/
	.lower_margin	= 5,	/* for VBPD*/
	.vsync_len	= 1,	/* for VSPW*/

#elif	defined(CONFIG_FB_S3C24X0_TFT800600)
	.width		= 800,
	.height		= 600,

	.pixclock	= 40000, /* HCLK 100 MHz, divisor 1 */
	.setclkval	= 0x1,
	.xres		= 800,
	.yres		= 600,
	.bpp		= 16,
	.left_margin	= 15,	/* for HFPD*/
	.right_margin	= 47,	/* for HBPD*/
	.hsync_len	= 95,	/* for HSPW*/
	.upper_margin	= 9,	/* for VFPD*/
	.lower_margin	= 5,	/* for VBPD*/
	.vsync_len	= 1,	/* for VSPW*/

#elif defined(CONFIG_FB_S3C24X0_TFT1024768)
	.width		= 1024,
	.height		= 768,

	.pixclock	= 40000, /* HCLK 100 MHz, divisor 1 */
	.setclkval	= 0x3,
	.xres		= 1024,
	.yres		= 768,
	.bpp		= 16,
	.left_margin	= 199,	/* for HFPD*/
	.right_margin	= 15,	/* for HBPD*/
	.hsync_len	= 15,	/* for HSPW*/
	.upper_margin	= 1,	/* for VFPD*/
	.lower_margin	= 1,	/* for VBPD*/
	.vsync_len	= 1,	/* for VSPW*/

#endif
};

修改drivers/video/Kconfig
修改1798行
config FB_S3C24X0
	tristate "S3C24X0 LCD framebuffer support"

修改1815行
choice
	prompt "LCD select"
	depends on FB_S3C24X0
	help
	   S3C24x0 LCD size select

config FB_S3C24X0_S320240
	boolean "3.5 inch 320x240 Samsung LCD"
	depends on FB_S3C24X0
	help
	   3.5 inch 320x240 Samsung LCD

config FB_S3C24X0_W320240
	boolean "3.5 inch 320x240 WanXin or ChiMei LCD"
	depends on FB_S3C24X0
	help
	   3.5 inch 320x240 WanXin or ChiMei LCD

config FB_S3C24X0_T240320
	boolean "3.5 inch 240X320 Toshiba LCD"
	depends on FB_S3C24X0
	help
	   3.5 inch 240x320 Toshiba LCD

config FB_S3C24X0_TFT480272
	boolean "4.3 inch 480X272 TFT LCD"
	depends on FB_S3C24X0
	help
	   4.3 inch 480X272 TFT LCD

config FB_S3C24X0_TFT640480
	boolean "VGA 640x480"
	depends on FB_S3C24X0
	help
	   VGA 640x480

config FB_S3C24X0_TFT800480
	boolean "7 inch 800x480 TFT LCD"
	depends on FB_S3C24X0
	help
	   7 inch 800x480 TFT LCD

config FB_S3C24X0_TFT800600
	boolean "10.4 inch 800x600 TFT LCD"
	depends on FB_S3C24X0
	help
	   10.4 inch 800x480 TFT LCD

config FB_S3C24X0_TFT1024768
	boolean "VGA 1024x768"
	depends on FB_S3C24X0
	help
	   VGA 1024x768

endchoice

修改drivers/video/Makefile文件
obj-$(CONFIG_FB_S3C24X0)  +=  s3c2410fb.o

(3)制作开机图片
修改drivers/video/logo/logo_linux_clut224.ppm文件
右击->图像->模式->索引
生成优化色板，  颜色数：必须要选为224
颜色抖动：普通

右击->文件->另存为->保存为.ppm格式的文件->选为Ascii格式，替换原文件，
保存到目录drivers/video/logo/

修改drivers/video/logo/Kconfig
第26行
config LOGO_LINUX_CLUT224
	bool "Standard 224-color Linux logo"
        depends on LOGO&&FB_S3C24X0_S320240||FB_S3C24X0_W320240
	default y

config LOGO_LINUX_A104_CLUT224
	bool "Standard 224-color Linux logo for A104"
	depends on LOGO && FB_S3C24X0_TFT800600 
	default y

config LOGO_LINUX_S70_CLUT224
	bool "Standard 224-color Linux logo for S70"
	depends on LOGO && FB_S3C24X0_TFT800480 
	default y

config LOGO_LINUX_VGA_CLUT224
	bool "Standard 224-color Linux logo for VGA640480"
	depends on LOGO && FB_S3C24X0_TFT640480 
	default y

config LOGO_LINUX_W43_CLUT224
	bool "Standard 224-color Linux logo for W43"
	depends on LOGO && FB_S3C24X0_TFT480272 
	default y

config LOGO_LINUX_W35_CLUT224
	bool "Standard 224-color Linux logo for W35 or S35"
	depends on LOGO && FB_S3C24X0_S320240 || FB_S3C24X0_W320240
	default y

config LOGO_LINUX_T35_CLUT224
	bool "Standard 224-color Linux logo for T35"
	depends on LOGO && FB_S3C24X0_T240320 
	default y
	
修改drivers/video/logo/Makefile文件
第6行
obj-$(CONFIG_LOGO_LINUX_CLUT224)	+= logo_linux_clut224.o
obj-$(CONFIG_LOGO_LINUX_A104_CLUT224)	+= logo_linux_a104_clut224.o
obj-$(CONFIG_LOGO_LINUX_S70_CLUT224)	+= logo_linux_s70_clut224.o
obj-$(CONFIG_LOGO_LINUX_VGA_CLUT224)	+= logo_linux_vga_clut224.o
obj-$(CONFIG_LOGO_LINUX_W43_CLUT224)	+= logo_linux_w43_clut224.o
obj-$(CONFIG_LOGO_LINUX_W35_CLUT224)	+= logo_linux_w35_clut224.o
obj-$(CONFIG_LOGO_LINUX_T35_CLUT224)	+= logo_linux_t35_clut224.o


修改drivers/video/logo/logo.c文件
第26行
extern const struct linux_logo logo_linux_clut224;
extern const struct linux_logo logo_linux_w35_clut224;
extern const struct linux_logo logo_linux_t35_clut224;
extern const struct linux_logo logo_linux_w43_clut224;
extern const struct linux_logo logo_linux_vga_clut224;
extern const struct linux_logo logo_linux_s70_clut224;
extern const struct linux_logo logo_linux_a104_clut224;

77行
if (depth >= 8) {
#ifdef CONFIG_LOGO_LINUX_CLUT224
		/* Generic Linux logo */
		logo = &logo_linux_clut224;
#endif
#ifdef CONFIG_LOGO_LINUX_W35_CLUT224
		/* Generic Linux logo */
		logo = &logo_linux_w35_clut224;
#endif
#ifdef CONFIG_LOGO_LINUX_W43_CLUT224
		/* Generic Linux logo */
		logo = &logo_linux_w43_clut224;
#endif
#ifdef CONFIG_LOGO_LINUX_T35_CLUT224
		/* Generic Linux logo */
		logo = &logo_linux_t35_clut224;
#endif
#ifdef CONFIG_LOGO_LINUX_VGA_CLUT224
		/* Generic Linux logo */
		logo = &logo_linux_vga_clut224;
#endif
#ifdef CONFIG_LOGO_LINUX_S70_CLUT224
		/* Generic Linux logo */
		logo = &logo_linux_s70_clut224;
#endif
#ifdef CONFIG_LOGO_LINUX_A104_CLUT224
		/* Generic Linux logo */
		logo = &logo_linux_a104_clut224;
#endif

(4)配置内核
Device Drivers-->
  Graphics suuport-->
    <*>Support for frmae buffer devices-->
      [*]Enable firmware EDID
      [*]Enable Video Mode Handling Helpers
      <*>S3C24X0 LCD framebuffer support
         LCD select()-->
             选3.5 inch 320*240 WanXin LCD
    Console display driver support-->
      <*>Video mode selection support
      <*>Framebuffer Console support    
      
2)背光控制:即是控制LCD_PWREN脚，即控制LCDCON5寄存器的PWREN位是控制LCD是否输出，当为0时LCD不
输出，此时LCD_PWREN脚为低，此时就关闭LCD背光。当为1时LCD输出，此时LCD_PWREN脚为高，此时
就开启LCD背光。 
(1)修改linux-2.6.25.8/drivers/video/s3c2410fb.c文件
        void __iomem *regs = fbi->io;
	u_long flags;
	local_irq_save(flags);

	fbi->regs.lcdcon5  = __raw_readl(regs + S3C2410_LCDCON5);
	switch( blank_mode )
	{
		case 0:
			fbi->regs.lcdcon5 &= ~S3C2410_LCDCON5_PWREN;
			printk(KERN_INFO "Turn off The LCD Backlight\n");
			break;
		case 1:
			fbi->regs.lcdcon5 |= S3C2410_LCDCON5_PWREN;
			printk(KERN_INFO "Turn on The LCD Backlight\n");
			break;
		default:
			break;
	}   
	__raw_writel(fbi->regs.lcdcon5, regs + S3C2410_LCDCON5);    

	local_irq_restore(flags);

	return 0;
	
(2)编写LCD背光控制程序
①
backlight.c文件
/*************************************

NAME:backlight.c
COPYRIGHT:www.embedsky.net

*************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <linux/fb.h>

int main(int argc, char **argv)
{
	int turn;
	int fd;
	if ( argc == 1 )
	{
		fprintf(stderr, "\nUsage: backlight on|off !\n\n");
		exit(1);
	}

	fd = open("/dev/backlight", O_RDWR);
	if (fd < 0) {
		perror("open BackLight device !");
		exit(1);
	}

	if ( strcmp(argv[1], "on" ) == 0)
		turn = 1;
	else if ( strcmp(argv[1], "off" ) == 0)
		turn = 0;
	else 
	{
		fprintf(stderr, "\nUsage: backlight on|off !\n\n");
		exit(1);
	}

	ioctl(fd, turn);
	close(fd);
	return 0;
}

Makefile文件
CROSS=arm-linux-

all: backlight

backlight:backlight.c
	$(CROSS)gcc -o backlight backlight.c
	$(CROSS)strip backlight
clean:
	@rm -vf backlight *.o *~

②   
make
生成这个可执行文件backlight

③cp backlight  root_2.6.25.8/sbin/

(3)系统运行时
打开背光backlight on
关闭背光backlight off


7、触摸屏驱动移植
1)添加驱动补丁
(1)
复制EmbedSky_ts.c文件到Linux-2.6.25.8/drivers/input/touchscreen
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Copyright (c) 2004 Arnaud Patard <arnaud.patard@rtp-net.org>
 * iPAQ H1940 touchscreen support
 *
 * ChangeLog
 *
 * 2004-09-05: Herbert P枚tzl <herbert@13thfloor.at>
 *	- added clock (de-)allocation code
 *
 * 2005-03-06: Arnaud Patard <arnaud.patard@rtp-net.org>
 *      - h1940_ -> s3c2410 (this driver is now also used on the n30
 *        machines :P)
 *      - Debug messages are now enabled with the config option
 *        TOUCHSCREEN_EmbedSky_DEBUG
 *      - Changed the way the value are read
 *      - Input subsystem should now work
 *      - Use ioremap and readl/writel
 *
 */  

#include <linux/autoconf.h>
#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/input.h>
#include <linux/init.h>
#include <linux/serio.h>
#include <linux/delay.h>
#include <asm/io.h>
#include <asm/irq.h>

#include <linux/platform_device.h>


#include <asm/plat-s3c/regs-adc.h>
#include <asm/arch/regs-gpio.h>
#include <asm/arch/ts.h>
#include <asm/hardware/clock.h>

/* For ts.dev.id.version */
#define S3C2410TSVERSION	0x0101

#define WAIT4INT(x)  (((x)<<8) | \
		     S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | S3C2410_ADCTSC_XP_SEN | \
		     S3C2410_ADCTSC_XY_PST(3))

#define AUTOPST	     (S3C2410_ADCTSC_YM_SEN | S3C2410_ADCTSC_YP_SEN | S3C2410_ADCTSC_XP_SEN | \
		     S3C2410_ADCTSC_AUTO_PST | S3C2410_ADCTSC_XY_PST(0))

#define DEBUG_LVL    KERN_DEBUG

/*
 * Definitions & global arrays.
 */


static char *EmbedSky_ts_name = "EmbedSky TouchScreen";

/*
 * Per-touchscreen data.
 */

struct EmbedSky_ts {
	struct input_dev *dev;
	long xp;
	long yp;
	int count;
	int shift;
	char phys[32];
};

static struct EmbedSky_ts ts;
static void __iomem *base_addr;

static inline void EmbedSky_ts_connect(void)
{
	s3c2410_gpio_cfgpin(S3C2410_GPG12, S3C2410_GPG12_XMON);
	s3c2410_gpio_cfgpin(S3C2410_GPG13, S3C2410_GPG13_nXPON);
	s3c2410_gpio_cfgpin(S3C2410_GPG14, S3C2410_GPG14_YMON);
	s3c2410_gpio_cfgpin(S3C2410_GPG15, S3C2410_GPG15_nYPON);
}

static void touch_timer_fire(unsigned long data)
{
  	unsigned long data0;
  	unsigned long data1;
	int updown;

  	data1 = readl(base_addr+S3C2410_ADCDAT0);
  	data0 = readl(base_addr+S3C2410_ADCDAT1);

 	updown = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) && (!(data1 & S3C2410_ADCDAT0_UPDOWN));

 	if (updown) {
 		if (ts.count != 0) {
 			ts.xp >>= ts.shift;
 			ts.yp >>= ts.shift;

#ifdef CONFIG_TOUCHSCREEN_EmbedSky_DEBUG
 			{
 				struct timeval tv;
 				do_gettimeofday(&tv);
				printk("Touch screen info:");	
 				printk(DEBUG_LVL "T: %06d, X: %03ld, Y: %03ld\n", (int)tv.tv_usec, ts.xp, ts.yp);
 			}
#endif

 			input_report_abs(ts.dev, ABS_X, ts.xp);
 			input_report_abs(ts.dev, ABS_Y, ts.yp);

 			input_report_key(ts.dev, BTN_TOUCH, 1);
 			input_report_abs(ts.dev, ABS_PRESSURE, 1);
 			input_sync(ts.dev);
 		}

 		ts.xp = 0;
 		ts.yp = 0;
 		ts.count = 0;

 		writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, base_addr+S3C2410_ADCTSC);
 		writel(readl(base_addr+S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, base_addr+S3C2410_ADCCON);
 	} else {
 		ts.count = 0;

 		input_report_key(ts.dev, BTN_TOUCH, 0);
 		input_report_abs(ts.dev, ABS_PRESSURE, 0);
 		input_sync(ts.dev);

 		writel(WAIT4INT(0), base_addr+S3C2410_ADCTSC);
 	}
}

static struct timer_list touch_timer =
		TIMER_INITIALIZER(touch_timer_fire, 0, 0);

static irqreturn_t stylus_updown(int irq, void *dev_id, struct pt_regs *regs)
{
	unsigned long data0;
	unsigned long data1;
	int updown;

	data1 = readl(base_addr+S3C2410_ADCDAT0);
	data0 = readl(base_addr+S3C2410_ADCDAT1);

	updown = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) && (!(data1 & S3C2410_ADCDAT0_UPDOWN));

	/* TODO we should never get an interrupt with updown set while
	 * the timer is running, but maybe we ought to verify that the
	 * timer isn't running anyways. */

	if (updown)
		touch_timer_fire(0);

	return IRQ_HANDLED;
}


static irqreturn_t stylus_action(int irq, void *dev_id, struct pt_regs *regs)
{
	unsigned long data0;
	unsigned long data1;

	data1 = readl(base_addr+S3C2410_ADCDAT0);
	data0 = readl(base_addr+S3C2410_ADCDAT1);

	ts.xp += data0 & S3C2410_ADCDAT0_XPDATA_MASK;
	ts.yp += data1 & S3C2410_ADCDAT1_YPDATA_MASK;
	ts.count++;

        if (ts.count < (1<<ts.shift)) {
		writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST, base_addr+S3C2410_ADCTSC);
		writel(readl(base_addr+S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START, base_addr+S3C2410_ADCCON);
	} else {
		mod_timer(&touch_timer, jiffies+1);
		writel(WAIT4INT(1), base_addr+S3C2410_ADCTSC);
	}

	return IRQ_HANDLED;
}

static struct clk	*adc_clock;

/*
 * The functions for inserting/removing us as a module.
 */

static int __init EmbedSky_ts_probe(struct device *dev)
{
	struct EmbedSky_ts_mach_info *info;

	info = ( struct EmbedSky_ts_mach_info *)dev->platform_data;

	if (!info)
	{
		printk(KERN_ERR "Hm... too bad : no platform data for ts\n");
		return -EINVAL;
	}

#ifdef CONFIG_TOUCHSCREEN_EmbedSky_DEBUG
	printk(DEBUG_LVL "Entering EmbedSky_ts_init\n");
#endif

	adc_clock = clk_get(NULL, "adc");
	if (!adc_clock) {
		printk(KERN_ERR "failed to get adc clock source\n");
		return -ENOENT;
	}
	clk_enable(adc_clock);

#ifdef CONFIG_TOUCHSCREEN_EmbedSky_DEBUG
	printk(DEBUG_LVL "got and enabled clock\n");
#endif

	base_addr=ioremap(S3C2410_PA_ADC,0x20);
	if (base_addr == NULL) {
		printk(KERN_ERR "Failed to remap register block\n");
		return -ENOMEM;
	}


	/* Configure GPIOs */
	EmbedSky_ts_connect();

	if ((info->presc&0xff) > 0)
		writel(S3C2410_ADCCON_PRSCEN | S3C2410_ADCCON_PRSCVL(info->presc&0xFF),\
			     base_addr+S3C2410_ADCCON);
	else
		writel(0,base_addr+S3C2410_ADCCON);


	/* Initialise registers */
	if ((info->delay&0xffff) > 0)
		writel(info->delay & 0xffff,  base_addr+S3C2410_ADCDLY);

	writel(WAIT4INT(0), base_addr+S3C2410_ADCTSC);

	/* Initialise input stuff */
	memset(&ts, 0, sizeof(struct EmbedSky_ts));
	//init_input_dev(&ts.dev);
	ts.dev = input_allocate_device();
	ts.dev->evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);
	ts.dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT(BTN_TOUCH);
	input_set_abs_params(ts.dev, ABS_X, 0, 0x3FF, 0, 0);
	input_set_abs_params(ts.dev, ABS_Y, 0, 0x3FF, 0, 0);
	input_set_abs_params(ts.dev, ABS_PRESSURE, 0, 1, 0, 0);

	sprintf(ts.phys, "ts0");

	ts.dev->private = &ts;
	ts.dev->name = EmbedSky_ts_name;
	ts.dev->phys = ts.phys;
	ts.dev->id.bustype = BUS_RS232;
	ts.dev->id.vendor = 0xDEAD;
	ts.dev->id.product = 0xBEEF;
	ts.dev->id.version = S3C2410TSVERSION;

	ts.shift = info->oversampling_shift;

	/* Get irqs */
	if (request_irq(IRQ_ADC, stylus_action, SA_SAMPLE_RANDOM, "s3c2410_action", ts.dev))
	{
		printk(KERN_ERR "EmbedSky_ts.c: Could not allocate ts IRQ_ADC !\n");
		iounmap(base_addr);
		return -EIO;
	}
	if (request_irq(IRQ_TC, stylus_updown, SA_SAMPLE_RANDOM,
			"s3c2410_action", ts.dev)) {
		printk(KERN_ERR "EmbedSky_ts.c: Could not allocate ts IRQ_TC !\n");
		iounmap(base_addr);
		return -EIO;
	}
/*
 *	for debug regs
 */
#ifdef CONFIG_TOUCHSCREEN_EmbedSky_DEBUG
	unsigned long debug_regs;
	debug_regs = 0;
	debug_regs = readl(base_addr+S3C2410_ADCCON);
	printk("S3C2410_ADCCON:0x%08lx\n",debug_regs);
	debug_regs = readl(base_addr+S3C2410_ADCTSC);
	printk("S3C2410_ADCTSC:0x%08lx\n",debug_regs);
	debug_regs = readl(base_addr+S3C2410_ADCDLY);
	printk("S3C2410_ADCDLY:0x%08lx\n",debug_regs);
#endif

	printk(KERN_INFO "%s successfully loaded\n", EmbedSky_ts_name);

	/* All went ok, so register to the input system */
	input_register_device(ts.dev);

	return 0;
}

static int EmbedSky_ts_remove(struct device *dev)
{
	disable_irq(IRQ_ADC);
	disable_irq(IRQ_TC);
	free_irq(IRQ_TC,ts.dev);
	free_irq(IRQ_ADC,ts.dev);

	if (adc_clock) {
		clk_disable(adc_clock);
		//clk_unuse(adc_clock);
		clk_put(adc_clock);
		adc_clock = NULL;
	}

	input_unregister_device(ts.dev);
	iounmap(base_addr);

	return 0;
}

static struct device_driver EmbedSky_ts_driver = {
       .name           = "EmbedSky-ts",
       .bus            = &platform_bus_type,
       .probe          = EmbedSky_ts_probe,
       .remove         = EmbedSky_ts_remove,
};


int __init EmbedSky_ts_init(void)
{
	return driver_register(&EmbedSky_ts_driver);
}

void __exit EmbedSky_ts_exit(void)
{
	driver_unregister(&EmbedSky_ts_driver);
}

module_init(EmbedSky_ts_init);
module_exit(EmbedSky_ts_exit);

MODULE_AUTHOR("Arnaud Patard <arnaud.patard@rtp-net.org>");
MODULE_DESCRIPTION("EmbedSky touchscreen driver");
MODULE_LICENSE("GPL");

(2)
复制ts.h文件到Linux-2.6.25.8/include/asm-arm/arch-s3c2410 
/* linux/include/asm/arch-s3c2410/ts.h
 *
 * Copyright (c) 2005 Arnaud Patard <arnaud.patard@rtp-net.org>
 *
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 *
 *  Changelog:
 *     24-Mar-2005     RTP     Created file
 *     03-Aug-2005     RTP     Renamed to ts.h
 */

#ifndef __ASM_ARM_TS_H
#define __ASM_ARM_TS_H

struct EmbedSky_ts_mach_info {
       int             delay;
       int             presc;
       int             oversampling_shift;
};

void __init set_EmbedSky_ts_info(struct EmbedSky_ts_mach_info *hard_EmbedSky_ts_info);

#endif /* __ASM_ARM_TS_H */

(3)
复制clock.h到Linux-2.6.25.8/include/asm-arm/hardware下
/*
 *  linux/include/asm-arm/hardware/clock.h
 *
 *  Copyright (C) 2004 ARM Limited.
 *  Written by Deep Blue Solutions Limited.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef ASMARM_CLOCK_H
#define ASMARM_CLOCK_H

struct device;

/*
 * The base API.
 */


/*
 * struct clk - an machine class defined object / cookie.
 */
struct clk;

/**
 * clk_get - lookup and obtain a reference to a clock producer.
 * @dev: device for clock "consumer"
 * @id: clock comsumer ID
 *
 * Returns a struct clk corresponding to the clock producer, or
 * valid IS_ERR() condition containing errno.  The implementation
 * uses @dev and @id to determine the clock consumer, and thereby
 * the clock producer.  (IOW, @id may be identical strings, but
 * clk_get may return different clock producers depending on @dev.)
 */
struct clk *clk_get(struct device *dev, const char *id);

/**
 * clk_enable - inform the system when the clock source should be running.
 * @clk: clock source
 *
 * If the clock can not be enabled/disabled, this should return success.
 *
 * Returns success (0) or negative errno.
 */
int clk_enable(struct clk *clk);

/**
 * clk_disable - inform the system when the clock source is no longer required.
 * @clk: clock source
 */
void clk_disable(struct clk *clk);

/**
 * clk_use - increment the use count
 * @clk: clock source
 *
 * Returns success (0) or negative errno.
 */
int clk_use(struct clk *clk);

/**
 * clk_unuse - decrement the use count
 * @clk: clock source
 */
void clk_unuse(struct clk *clk);

/**
 * clk_get_rate - obtain the current clock rate (in Hz) for a clock source.
 *		  This is only valid once the clock source has been enabled.
 * @clk: clock source
 */
unsigned long clk_get_rate(struct clk *clk);

/**
 * clk_put	- "free" the clock source
 * @clk: clock source
 */
void clk_put(struct clk *clk);


/*
 * The remaining APIs are optional for machine class support.
 */


/**
 * clk_round_rate - adjust a rate to the exact rate a clock can provide
 * @clk: clock source
 * @rate: desired clock rate in Hz
 *
 * Returns rounded clock rate in Hz, or negative errno.
 */
long clk_round_rate(struct clk *clk, unsigned long rate);
 
/**
 * clk_set_rate - set the clock rate for a clock source
 * @clk: clock source
 * @rate: desired clock rate in Hz
 *
 * Returns success (0) or negative errno.
 */
int clk_set_rate(struct clk *clk, unsigned long rate);
 
/**
 * clk_set_parent - set the parent clock source for this clock
 * @clk: clock source
 * @parent: parent clock source
 *
 * Returns success (0) or negative errno.
 */
int clk_set_parent(struct clk *clk, struct clk *parent);

/**
 * clk_get_parent - get the parent clock source for this clock
 * @clk: clock source
 *
 * Returns struct clk corresponding to parent clock source, or
 * valid IS_ERR() condition containing errno.
 */
struct clk *clk_get_parent(struct clk *clk);

#endif


2)修改文件，添加对触摸屏的支持
(1)
Linux-2.6.25.8/drivers/input/touchscreen/Kconfig 
config EmbedSky_TOUCHSCREEN
        tristate "EmbedSky touchscreen"
        depends on ARCH_S3C2410 && INPUT && INPUT_TOUCHSCREEN
	select SERIO
        help
          To compile this driver as a module, choose M here: the
          module will be called EmbedSky_ts.ko.

config TOUCHSCREEN_EmbedSky_DEBUG
	boolean "EmbedSky touchscreen debug messages"
	depends on EmbedSky_TOUCHSCREEN
	help
	  Select this if you want debug messages

endif

(2)
修改Linux-2.6.25.8/drivers/input/touchscreen/Makefile
添加
obj -$ (CONFIG_EmbedSky_TOUCHSCREEN) += EmbedSky_ts.o    

(3)Linux-2.6.25.8/include/linux/interrupt.h 
static inline
unsigned long __deprecated deprecated_irq_flag(unsigned long flag)
{
	return flag;
}

#define SA_INTERRUPT		deprecated_irq_flag(IRQF_DISABLED)
#define SA_SAMPLE_RANDOM	deprecated_irq_flag(IRQF_SAMPLE_RANDOM)
#define SA_SHIRQ		deprecated_irq_flag(IRQF_SHARED)
#define SA_PROBEIRQ		deprecated_irq_flag(IRQF_PROBE_SHARED)
#define SA_PERCPU		deprecated_irq_flag(IRQF_PERCPU)

#define SA_TRIGGER_LOW		deprecated_irq_flag(IRQF_TRIGGER_LOW)
#define SA_TRIGGER_HIGH		deprecated_irq_flag(IRQF_TRIGGER_HIGH)
#define SA_TRIGGER_FALLING	deprecated_irq_flag(IRQF_TRIGGER_FALLING)
#define SA_TRIGGER_RISING	deprecated_irq_flag(IRQF_TRIGGER_RISING)
#define SA_TRIGGER_MASK		deprecated_irq_flag(IRQF_TRIGGER_MASK)


(4)添加触摸屏设备和配置信息
Linux-2.6.25.8/arch/arm/mach-s3c2440/mach-smdk2440.c文件
#include <asm/arch/ts.h>

//touch screen
struct platform_device s3c_device_ts = {
	.name		  = "EmbedSky-ts",
	.id		  = -1,
};

#if	defined(CONFIG_FB_S3C24X0_TFT800600)
static struct EmbedSky_ts_mach_info EmbedSky_ts_info = {
	.delay = 10000,
	.presc = 200,
	.oversampling_shift = 4,
};
#elif	defined(CONFIG_FB_S3C24X0_S800480)
static struct EmbedSky_ts_mach_info EmbedSky_ts_info = {
	.delay = 10000,
	.presc = 200,
	.oversampling_shift = 4,
};
#else
static struct EmbedSky_ts_mach_info EmbedSky_ts_info = {
	.delay = 10000,
	.presc = 49,
	.oversampling_shift = 2,
};
#endif

static struct platform_device *smdk2440_devices[] __initdata = {
&s3c_device_ts,
}

static void __init smdk2440_machine_init(void)
{
s3c_device_ts.dev.platform_data = &EmbedSky_ts_info;
}	


3)添加TSDEV补丁
(1)
添加补丁文件Linux-2.6.25.8/drivers/input/tsdev.c

(2)修改Linux-2.6.25.8/drivers/input/Kconfig
config INPUT_TSDEV
	tristate "Touchscreen interface"
	---help---
	  Say Y here if you have an application that only can understand the
	  Compaq touchscreen protocol for absolute pointer data. This is
	  useful namely for embedded configurations.

	  If unsure, say N.

	  To compile this driver as a module, choose M here: the
	  module will be called tsdev.

config INPUT_TSDEV_SCREEN_X
	int "Horizontal screen resolution"
	depends on INPUT_TSDEV
	default "1024"

config INPUT_TSDEV_SCREEN_Y
	int "Vertical screen resolution"
	depends on INPUT_TSDEV
	default "768"
	
(3)修改Linux-2.6.25.8/drivers/input/Makefile
obj-$(CONFIG_INPUT_TSDEV)	+= tsdev.o

4)配置内核
Device Drivers-->
  Input device support-->
    <*>Touchscreen interface
    <*>Event interface
    <> Event debugging
    [*]Touchscreens->
       <*>EmbedSky touchscreen
       [] EmbedSky touchscreen debug messages
配置后，保存，编译镜像文件

5)添加Qte
(1)
简单方法是复制天嵌提供的文件系统root2.6.13/opt 替换现有root2.6.25.8/opt  
复制天嵌提供的文件系统root2.6.13/root 替换现有root2.6.25.8/root

注意，4.3.3编译器只能编译Qtopia-2.2.0版本的      		
  
(2)创建root2.6.25.8/bin/qtopia执行文件
#!/bin/sh

export set HOME=/root
export set QTDIR=/opt/qt
export set QPEDIR=/opt/qtopia
export set KDEDIR=/opt/kde
export set QWS_KEYBOARD="USB:/dev/input/event1"
export set QWS_MOUSE_PROTO="TPanel:/dev/touchscreen/0"
#export set QWS_MOUSE_PROTO="USB:/dev/input/mouse0"
export set PATH=$QPEDIR/bin:$PATH
export set LD_LIBRARY_PATH=$QTDIR/lib:$QPEDIR/lib
$QPEDIR/bin/qpe > /dev/null 2>/dev/null

(3)修改root2.6.25.8/etc/init.d/rcS,添加
ln -s /dev/ts0 /dev/h3600_tsraw

qtopia &

(4)复制root2.6.13/lib/libjpeg.so.62,  libpng12.so.0,  libuuid.so.1这三个文件，替换到
 root2.6.25.8/lib/中
 
 重新制作文件系统

8、声卡驱动
1)修改文件,添加uda1341驱动
添加Linux-2.6.25.8/sound/oss/EmbedSky_uda1341.c文件
 
修改 
Linux-2.6.25.8/sound/oss/Kconfig
config EmbedSky_SOUND
	tristate"EmbedSky UDA1341 driver"
	depends on ARCH_S3C2410 
	default y
	help
	   To compile this driver as a module, choose M here:the module will
	   be called EmbedSky_uda1341.ko. 
 
修改 
Linux-2.6.25.8/sound/oss/Makefile
obj -$(CONFIG_EmbedSky_SOUND) += EmbedSky_uda1341.o

2)修改内核对DMA的支持
Linux-2.6.25.8/arch/arm/plat-s3c24xx/dma.c
第829行
s3c2410_dma_ctrl(chan->number[DMACH_LOW_LEVEL,S3C2410_DMAOP_STOP]);
第918行
s3c2410_dma_ctrl(chan->number[DMACH_LOW_LEVEL,S3C2410_DMAOP_STOP]);

3)配置内核
Device Drivers-->
  Sound-->
    <*>Sound card support
    Open Sound System-->
      <*>Open Sound System(DEPRECATED)
      <*>EmbedSky UDA1341 driver

4)
测试时，输入cat /dev/dsp > /tmp/abc.wav进行录音测试
输入cat /tmp/abc.wav > /dev/dsp播放录音

9、RTC驱动移植
1)
添加RTC设备到设备初始化列表中
修改Linux-2.6.25.8/arch/arm/mach-s3c2440/mach-smdk2440.c
static struct platform_device *smdk2440_devices[] __initdata=
{
  &s3c_device_rtc,
};      

2)配置内核
Device Drivers-->
  <*>Real Time Cloclk-->
     [*] Set system time from RTC on startup and resume
     (rtc0) RTC used to set the system time
     [*] /sys/class/rtc/rtcN(sysfs)
     [*] /proc/driver/rtc (procfs for rtc0)
     [*] /dev/rtcN(character devices)
     <*> Smasung S3C series SOC RTC
     
3)文件让系统启动后能同步设置好RTC
root2.6.25.8/etc/init.d/rcS
hwclock -s
ifconfig lo 127.0.0.1

4)启动系统后
date  显示时间
date -s 020416102009 设置时钟
hwclock -w保存设置

10、看门狗驱动移植
1)
修改drivers/watchdog/s3c2410_wdt.c文件
#define CONFIG_S3C2410_WATCHDOG_ATBOOT (1) 启动看门狗
#define CONFIG_S3C2410_WATCHDOG_DEFAULT_TIME (30) 喂狗时间
2)
Device Drivers-->
  [*]Watchdog Timer Support-->
     <*>S3C2410 Watchdog      
3)
提供喂狗的应用程序
apps/EmbedSky_wdg/EmbedSky_wdg.c文件，修改Makefile文件

Make指令,生成可执行文件EmbedSky_wdg

chmod 777 EmbedSky_wdg

复制到root2.6.25.8/sbin/中

4)修改root2.6.25.8/etc/init.d/rcS
EmbedSky_wdg &  启动看门狗喂狗应用程序
ifconfig 127.0.0.1

11、SD卡驱动移植
1)打补丁
下载补丁 s3c_mci.patch
打补丁 patch -pl < s3c_mci.patch

2)添加SD设备到列表
修改Linux-2.6.25.8/arch/arm/mach-s3c2440/mach-smdk2440.c
static struct platform_device *smdk2440_devices[] __initdata=
{
  &s3c_device_sdi,
};   

修改Linux-2.6.25.8/drivers/mmc/host/s3cmci.c，
第1090行
//dbg(host,dbg_conf,"...").\n
//host->real_rate/...;
第1246行
//ret=-EBUSY;
//goto probe_free_irq_cd;

3)配置内核
Device Drivers-->
  <*>MMC/SD card support-->
     <*>MMC block device driver
     [*]Use bounce buffer for simple hosts
     <*>Samsung S3C24xx SD/MMC Card Interface support

4)启动系统时，挂载SD卡
mount /dev/mmcblk0p1 /mnt/sd/

12、移植IIC总线
IIC总线主要用来挂载EEPROM
1)
配置内核
Device Drivers-->
  <*>I2C support-->
    <*>I2C device interface
       I2C Hardware Bus support-->
           <*>S3C2410 I2C Driver
2)
include/linux/i2c-dev.h
3)  
应用程序
apps/IIC_RW/i2c_rw.c文件，修改Makefile文件
Make指令,生成可执行文件i2c_rw    

chmod 777 i2c_rw

复制到root2.6.25.8/sbin/中        

 
//********
//驱动开发
//********

//*******************
//Linux内存管理子系统
//*******************
*Linux内存管理：管理内存的分配，回收
1、三个地址
逻辑地址：写程序后，转换为汇编代码，汇编代码中出现的地址
  |
  v
虚拟地址又名线性地址：在arm的体系中，它的寻址控件是4G，0x00000000-0xffffffff
  |
  v
物理地址：是最终实际的地址，cpu要在地址总线上找数据，最终就要通过这个地址来找
转换方法：
逻辑地址->段式内存管理单元->线性地址->页式内存管理单元->物理地址

2、x86机器的段式管理和页式管理
1)段式管理(16位的cpu为例)
(1)
它有20位的地址线，它的寻址范围是2的20次方，即1M的内存空间。
16位的cpu他用来存放地址的寄存器(IP,SP...)只有16位，因此只能访问65536个存储单元，即64k。
所以cpu就采用了内存分段的管理模式，并在cpu内部加入了段寄存器。16位的cpu把1M内存空间分为若干个逻辑段，每段
的要求如下：
逻辑段得起始地址(段地址)必须是16的倍数，即最后4个二进制位必须全为0
逻辑段的最大容量为64k
------
|....|
|----|
|32K |
|----|
|64K |--->这个位置是基地址+偏移50K，本次即0+50K，即段基地址+段内偏移地址
|----|
1M的存储器     

段基地址保存到基地址寄存器中， 段内偏移地址保存到偏移地址寄存器中。
物理地址=段基地址*16+段偏移地址   

段基地址：都是xxxxxxxxxxxxxxxx0000,由于后面四位都为0，因此保存的时候只保存前面16位，
          这样子寄存器也保存的下来。等下换算的时候再添加，即段基地址*16即可  
          
(2)几个段寄存器
CS+IP：用于访问代码的，CS指向存放程序的段基址，IP指向下一条要执行的指令的偏移量
SS+IP：堆栈段访问，SS指向基地址，SP指向栈顶。DS+BX访问数据段,ES+BX访问附加段等

2)段式管理(32位的cpu)：它的工作模式有两种实模式，和保护模式。一般是工作在保护模式下。在实模式下，与16位的
是一样的，在保护模式下，每个段基地址32位，最大容量为4G。
段寄存器是作为段选择器，真正的段基地址放在内存中。它的寻址方式如下所示
----------
|段选择器|            偏移量寄存器
----------                 |
   |     访问权限          |
   |->  |段基地址|--------相加------>|实际地址|
        ----------                   ----------
          内存                         4GB线性地址

3)页式管理   
(1)       
线性地址被分为固定大小的一块块，这个也被称为页。例如32位的机器，线性地址最大支持4G，如果用4KB为一页，它就
被分为2的20次方线性地址页。
物理页：实际的物理内存有可能没有4G那么大，它把实际的物理内存也分成很多页，称为物理页。它的实际长度什么的与
线性地址页是完全一样的 

(2)分页管理，采用两级管理机构
线性地址页-->页式管理单元映射-->物理页 
32位线性地址可以分为3个部分，第一部分10位，第二部分10位，第三部分12位 
线性地址
       31          22  21      12  11             0
       |  目录        |    页表   |         偏移  |  
       --------------------------------------------  
           |                 |               |  
cr3寄存器-相加->|存放页表|-相加->|这个页表|-相加->|存放这个数据|   
存放页目录      |的基地址|       |项中存放|       |的物理地址  |
的基地址        ---------        |物理页的|       --------------
                  页目录         |基地址  |          物理页
                                 ----------
                                   页表
cr3寄存器：在创建一个进程时，它的页表，页目录等的位置都会自动保存到进程上下文中，当掉用这个进程时，它的
这些地址会存放到cr3寄存器中。这样即可知，在进程切换时，cr3寄存器会自动不断更新这个值                                   
每个物理页的大小:从偏移地址可知是12位，即2的12次方，即4K。
同理，线性地址可寻址范围是2的32次方，即4G

3、linux的内存管理
Linux的逻辑地址即是等于线性地址，即说明它不用分段管理了。   
它的分页管理，采用四级管理机构
cr3->页全局目录->页上级目录->页中间目录->页表->物理页               

*Linux进程地址空间
Linux采用虚拟内存管理技术，这样每个进程都有3G的独立的进程地址空间，即用户只可以对这3G的虚拟地址空间
进行操作和访问，而不用管也不能看到实际物理地址，物理地址由操作系统自动调度。而且，在进程切换时，它的
用户空间也在变化(即它的页表，页目录等页式转换信息在变)

因为Linux可以有4G的内存空间，因此它将虚拟地址分为用户空间和内核空间，用户空间0-3G，是0-0xbfffffff。
内核空间是3G-4G,即1G。用户只能访问用户空间，只能在极特殊情况下通过系统调用方法访问内核空间

做内核开发时，一定要清楚这几个存储位置：未初始化的全局变量存在数据段上，初始化的全局变量存在bss段上，
malloc的存在堆上，局部变量以及函数等在栈上。在做内核开发时，很容易出现栈溢出。例如，定义一个数组char a[100],
它这是直接定义在栈上的，这个就比较大了，然后，如果这个函数被递归调用，就会使这个分配的栈越来越大，这样
就会出现栈溢出。解决的方法是使用malloc来分配

1)内核内存分配
(1)小块内存分配
在应用程序中，是使用malloc函数进行动态内存分配，而在Linux内核中，是使用kmalloc动态分配内存
#include<linux/slab.h>
void *kmalloc(size_t size,int flags)
size:要分配的内存大小
flags:分配标志，它控制kmalloc的行为
      GFP_KERNEL:进程上下文中，请求分配内存，如果分配不到，就睡眠，分配地址(16M-896M)
      FGP_ATOMIC:在中断处理中分配内存，从不睡眠。要么成功，要么失败，都会立即返回值
      _GFP_DMA:分配用于DMA传输的内存，它要求必须在16M以下的物理地址中进行分配
      _GFP_HIGHMEM:分配高端内存，必须在896M以上的物理地址中进行分配
      
释放空间；kfree();
      
(2)按页分配
如果要分配的内存模块较大，比如几k，按页分配会比较好
get_zeroed_page(unsigned int flags)分配一个页得内存空间，即4K。给这个页清零，返回指向这个页的指针
或者get_free_page也是一样，分配一个页得内存空间，即4K。给这个页清零

_get_free_page(unsigned int flags)分配一个页得内存空间，即4K。不对这个页清零，返回指向这个页的指针
_get_free_pages(unsigned int flags,unisigned int order)分配一些连续的页的内存空间。不对这个页清零，
                                  返回指向这个内存区域的指针
_get_dma_pages(unsigned int flags,unisigned int order)分配一些连续的页的内存空间。不对这个页清零，
                                  用于dma的传输，返回指向这个内存区域的指针                                  
flags:分配标志，与上面一样
      GFP_KERNEL:进程上下文中，请求分配内存，如果分配不到，就睡眠，分配地址(16M-896M)
      FGP_ATOMIC:在中断处理中分配内存，从不睡眠。要么成功，要么失败，都会立即返回值
      _GFP_DMA:分配用于DMA传输的内存，它要求必须在16M以下的物理地址中进行分配
      _GFP_HIGHMEM:分配高端内存，必须在896M以上的物理地址中进行分配    

释放页：如果释放的页与刚才分配的页不相等，会系统错误
void free_page(unsigned long addr)
参数addr是分配时得到的首地址
void free_pages(unsigned long addr,unsigned long order) 

*Linux内核地址空间 
它是由内核负责映射的，并不会跟着进程切换而改变，它是固定的
高端内存：物理内存896MB以上的部分成为高端内存
3G                                   4G
直接映射区|动态映射区|KMAP区|固定映射区
---------------------------------------
直接映射区：这个区域的线性地址=3G+物理地址
动态映射区：这个区域的地址由内核函数vmalloc来进行动态分配，它的线性地址连续的，但是物理地址不一定连续，它
            的物理地址可能处于低端内存，也可能处于高端内存
永久内存映射区(KMAP):对于896MB以上的物理高端内存，可以使用该区域来访问，访问方法
            1.先使用alloc_page(_GFP_HIGHMEM)分配高端内存页
            2.然后使用kmap函数将分配到的高端内存映射到该区域 
---------
| PKMP  |  ---->| 896MB |
---------       ---------
|  3G   |       |       |
|-------|       ---------     
虚拟地址          物理地址  
固定映射区：它所有项目的映射都是已经固定好了的，他每个地址项都服务于特定的用途，如ACPI_BASE等。
以后比如要使用ACPI服务，就访问ACPI基地址，这时只要找到固定映射区里面的那个虚拟地址既可以了                                             

*内核链表
在内核include/linux/list.h中有提供链表的操作函数。
内核链表结构,它是双向循环链表
struct list_head
{
  struct list_head *next,*prev;
}
1、传统链表与内核链表区别
传统链表：|data|next|--->|data|next|  当前节点的指针域，指向下一个节点的头部地址
内核链表：|struct list_head| <==>|data|struct list_head| <==>|data|struct list_head|
               /\                                                            ||
                ==============================================================
|data|struct list_head| 当前节点的指针域里面包含两个指针*next它指向下一个节点的list_head结构，
           *prev它指向前一个节点的list_head结构
他与传统链表不同的地方是，它的指针域没有数据类型，这样其实就与实际data域数据类型无关了，这样可以兼容
所有类型了     
即传统链表是在链表节点中包含数据，而内核链表是在数据结构中包含链表节点
传统链表
struct list_node
{
  struct list_node *next;
  elemtype data;
};
当前节点指向下一个节点list_node

内核链表
struct elemtype
{
 char *data;
 struct list_head list;
};
当前链表的节点list_head指向下一个节点的list_head
      
2、内核链表的使用
struct student
{
  char name[100];
  int num;
  struct list_head list;
};
struct student *pstudent;
struct student *tmp_student;
struct list_head student_list;
struct list_head *pos;

1)
INIT_LIST_HEAD(list_head *head),里面做的工作即是初始化一个新链表，它的next,prev都指向它自己

2)创建节点
struct student *pstudent
pstudent=kmalloc(sizeof(struct student)*5,GFP_KERNEL);//创建数组
memset(pstudent,0,sizeof(struct student)*5);

3)插入节点
list_add(struct list_head *new,struct list_head *head)，new是要插入的新节点，head是指当前链表中的一个点，
这个作用是在当前链表点后面插入一个新节点      
list_add_tail(struct list_head *new,struct list_head *head)作用是在链表尾上插入一个节点 

4)删除节点
for(i=0;i<5;i++)//注意，这个遍历不能用list_for_each,不然会内核出错
     list_del(struct list_head *entry)要entry是要删除的节点
kfree(entry);

5)提取数据结构中的数据
这个节点的总数据类型是struct h;
struct h
-----------
|data     |
-----------
|list_head| 
-----------
  当前节点
list_entry(ptr,type,member),ptr是指向当前节点list_head的指针。type是指外部结构的类型，即struct h。
member是指指针域list_head在总体节点上，它所对应的成员名。
结果返回指向当前节点的指针
例：list_entry(ptr,struct student,memberlist)

6)遍历
list_for_each(struct list_head *pos,struct list_head *head) ,head是要遍历的链表的链表头，pos用来保存找到的
节点
使用：
struct list_head *entry;
struct list_head cshead;
list_for_each(entry,&cshead);

例：
list_for_each(pos,&student_list)
{
  tmp_strudent= list_entry(pos,struct student,list);
}


3、示例
#ifndef __KERNEL__
#  define __KERNEL__
#endif
#ifndef MODULE
#  define MODULE
#endif

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/list.h>


MODULE_LICENSE("GPL");

struct student
{
    char name[100];
    int num;
    struct list_head list;
};

struct student *pstudent;
struct student *tmp_student;
struct list_head student_list;
struct list_head *pos;

int mylist_init()
{
	int i = 0;
	
	INIT_LIST_HEAD(&student_list);
	
	pstudent = kmalloc(sizeof(struct student)*5,GFP_KERNEL);
	memset(pstudent,0,sizeof(struct student)*5);
	
	for(i=0;i<5;i++)
	{
	        sprintf(pstudent[i].name,"Student%d",i+1);
		pstudent[i].num = i+1; 
		list_add( &(pstudent[i].list), &student_list);
	} 
	
	
	list_for_each(pos,&student_list)//这个其实是一个内核函数的调用，本质就是一个for循环
	{
		tmp_student = list_entry(pos,struct student,list);
		printk("student %d name: %s\n",tmp_student->num,tmp_student->name);
	}
	
	return 0;
}


void mylist_exit()
{	
	int i ;
	
	for(i=0;i<5;i++)
	{
		list_del(&(pstudent[i].list));     
	}
	
	kfree(pstudent);
}

module_init(mylist_init);
module_exit(mylist_exit);


*内核定时器
内核的时间，即linux系统的时间，是由时钟中断来维护的。在x86上，默认1000HZ。每次中断后，有一个全局变量jiffies
就自动加1，因此，jiffies记录了自linux启动后，时钟中断发生的次数，驱动就可以利用这个来计算不同事件之间的时间间隔
例：延时执行
unsigned long =jiffies+jit_delay*HZ
while(jiffies<j){do nothing}  延时jit_delay秒，不做事情

内核定时器：内核的驱动程序中比较有用，用于设置某个函数在以后的一个时间点做什么事情，创建后它只会执行一次
内核定时器被组织成一个双向链表，结构如下
struct timer_list
{
  struct list_head entry;供内核使用不用管，用于创连链表，因为所有定时器都要被串成一串定时器链表
  unsigned long expires;超时的jiffies的值，即指定的执行时间
  void (*function)(unsigned long);超时处理函数
  unsigned long data;超时处理函数参数
  struct tvec base *base;内核使用，不用管
};

1、使用
1)初始化定时器队列结构
void init_timer(struct timer_list *timer);

然后，自己设置expires，函数，函数处理参数的值

例：
struct timer_list timer;

void timer_fucntion(int para){..}

init_timer(&timer);
timer.data=5;
timer.expires=jiffies+(20*HZ);
timer.function=timer_function;
add_timer(&timer);

2)启动定时器
void add_timer(strcut timer_list *timer);

3)在定时器开始超时之前将它删除。当定时器超时工作后，系统会自动将它删除
int del_timer(strcut timer_list *timer);


//*******************
//Linux进程管理子系统
//*******************
*Linux进程控制
进程有专用的内核空间堆栈，而且它有一个task_struct数据结构，即进程控制块。有了它，进程才接收内核的调度
有独立的用户空间：
有独立的用户空间？--是->进程
       |否
   有用户空间
  是        否
  |         |
用户线程   内核线程
因此，用户线程是没有独立的用户空间，但是有共享的空间
内核线程是完全没有用户空间(没有内核进程这种东西的)

1、进程描述：进程，线程都是用task_struct来表示，他们比较重要的，而且共同都具有的具体描述如下
task_struct
{
 pid 进程号，或者用户线程号，内核线程号
 volatile long state进程状态
    TASK_RUNNING(就绪态，和执行态)进程正被执行，或处于就绪，可以执行。当进程刚被创建后，就处于这个状态
    TASK_INTERRUPTIBLE(可中断的阻塞态)处于阻塞中，待条件符合后就被唤醒，或者也可以被信号或中断唤醒
    TASK_UNINTERRUPTIBLE(不可中断的阻塞态)处于阻塞中，待条件符合后就被唤醒，但不可以被其它进程通过信号或中断唤醒
    TASK_KILLABLE在Linux2.6.25新引入的进程阻塞态，类似于(不可中断的阻塞态)，但是可以被SIGKILL(杀死进程信号)唤醒
    TASK_STOPPED(挂起状态)当接收到SIGSTOP,和SIGTSTP等信号时，就挂起。直到接收到SIGCONT信号后，重新回到就绪态
    TASK_TRACED处于被调试状态，比如可以用gdb来调试进程
    TASK_DEAD(退出状态)进程退出时(调用do_exit)
    
 int exit_stat进程退出时，最后处于的状态
    EXIT_ZOMBIE僵死进程，表明进程已终止了，但资源还没有回收
    EXIT_DEAD僵死撤销状态，表明进程已终止了，并且资源也回收了
    
 struct mm_struct *mm 指向进程用户空间描述的指针，如果内核线程，因为他没有用户空间，因此为空
 unsigned int policy进程的调度策略
 int prio优先级，优先数越低优先级越高。0-MAX_RT_PRIO-1(即100)用于实时进程，MAX_RT_PRIO-MX_PRIO-1(即140)用于
         非实时进程
 int static_prio静态优先级
 struct sched_rt_entity rt
        用rt->time_slice用于计算时间片，系统使用分时的时间片运算方法，分到的时间片有多大由这里定义               
}

2、task_struct位置：当创建一个新的进程时，我们会在内核空间中分配两个连续的物理页面(即8k)
对于Linux2.4版本
-----------------------------------------------------------
|7K用于作为进程内核空间的堆栈|1K,用于存放task_struct结构体|
-----------------------------------------------------------
对于Linux2.6版本
-----------------------------------------------------------
|7K用于作为进程内核空间的堆栈|1K,用于存放thread_info结构体|thread_info--指针->指向真正的task_struct结构体
-----------------------------------------------------------
内核使用current指针，指向当前正在运行的进程的task_struct


3、全局指针current；在系统运行时，指针current指向当前正在cpu内运行的进程或线程的task_struct

4、进程创建和撤销
1)创建
vfork()      fork()  用户空间
---|-----------|---------------
   |           |
sys_vfork() sys_fork()系统空间
   |           | 
   |-----------|-------------|-->do_fork()-->copy_process()
                             |
sys_clone(),kernel_thread()--|

2)撤销
exit()                           用户空间
---|---------------------------
   |--sys_exit()------->do_exit()系统空间

*Linux进程调度
1、调度策略：调度策略与进程联系在一起的，即进程使用一种作为自己的调度策略，而不是整个系统都是用这种策略
SCHED_NORMAL(SCHED_OTHER)普通的分时进程
SCHED_FIFO先进先出的实时进程
SCHED_RR时间片轮转的实时进程
SCHED_BATCH批处理进程
SCHED_IDLE只在系统空闲时才能被调度执行的进程

它总的又分成两个类，
CFS调度类，即公平调度类(在kernel/sched_fair.c中实现)用于以下调度策略SCHED_NORMAL，SCHED_BATCH,SCHED_IDLE
实时调度类(在kernel/sched_rt.c中实现)用于以下调度策略SCHED_FIFO，SCHED_RR

它的调度策略有两个：
下一个进程，谁的优先级高，就选谁。
如果里面同时存在公平调度进程，和实时调度进程。所有实时调度进程优先级一定比公平调度进程高，即都是先调用实时调度进程。
至于实时调度进程之间的优先级比较，由pick_next_task(rq)函数自己处理

2、调度时机：调度发生的时间，kernel/shedule.c/的schedule()函数来完成调度的。因此，即是指schedule()函数什么时候被调用
调度的发生有两种方式
1)主动式调度：在内核，一个进程在运行过程中，主动调用schedule()函数。例如一个进程要睡眠，它把自己挂起后，主动
  调用schedule(),产生调度工作，让别的进程使用CPU
例：
  current->state=TASK_INTERRUPTIBLE
  schedule();
  
2)被动式(抢占)：
    Linux2.4:支持用户抢占
    Linux2.6:支持用户抢占，内核抢占    
(1)用户抢占：从系统调用返回用户空间时，或从中断处理返回用户空间时。即是从内核从内核空间即将返回用户空间时，如果
need_resched标志被设置，就会重新调用schedule()，此时就发生抢占    

(2)内核抢占：在2.4内核中，进程/线程一旦运行于内核空间时，它就可以一直进行，直到主动放弃或者时间片耗尽为止。
在2.6内核中，更高优先级的进程/线程可以抢占正在内核空间运行的低优先级进程/线程

①某些情况，不允许内核抢占：
内核正在进行中断处理，这时schedule()会对此作出判断，不会抢占，并且打印出错信息
内核正在进行中断上下文处理中
进程有spinlock自旋锁，或者writelock/readlock读写锁等，不能抢占，如果抢占了，会造成死锁
进程本身正在执行schedule()，不能抢占

②为了在以上几种情况下内核不会发生抢占，在thread_info结构中，使用了一个变量内核抢占计数preempt_count,
当进入上面几种状态时，preempt_count加1，表示不允许抢占。当退出上面几种状态时，preempt_count减1。总体来说，
值大于0表示不允许抢占，值为0，表示可以抢占。
而且，need_resched标志被设置，才可以进行抢占

③内核抢占发生时间：
中断处理返回内核空间
当内核代码再一次有可抢占性的时候，如解锁或使能软中断等

④调度标志TIF_NEED_RESCHED
提供了一个need_resched标志来表明是否需要重新执行一次调度，当某个进程耗尽它的时间片时，或者优先级更高的进程
进入可执行状态的时候，都会设置这个标志 


3、调度步骤：即schedule()的流程
清理当前运行中的进程
选择下一个要运行的进程：通过pick_next_task分析
设置新进程的运行环境
进程上下文切换

*系统调用
一般情况下在内存空间中被分为用户空间和内核空间，用户进程一般情况下不能访问内核，包括内核中的数据和函数。但是有
两个特殊的情况，一个是中断，一个是系统调用。内核中有一些用于实现各种系统功能的函数，然后这些函数专门用于给用户
进程使用。 然后用户进程通过系统调用，使用这些函数
区别：普通的函数调用由函数库(如C库，线程库等)或者用户自己来提供(即自己写的函数)，运行在用户态。
      而系统调用由内核实现，运行于内核态

也提供了一些C库函数，它封装了系统调用。这样，就可以直接使用库函数进行系统调用了 

系统调用在arch/arm/include/asm/unistd.h     

1、系统调用工作原理：
应用程序先用一个适当的值来填充寄存器，这个值其实就是系统调用编号
使用一个汇编指令跳转到相应的内核的某一个固定的位置
然后内核根据刚才应用程序填充的寄存器的这个值来找到相应的函数，来执行该函数

1)适当的值
在arch/arm/include/asm/unistd.h中，可以知道Linux为每一个系统调用都分配了一个唯一的编号，称作系统调用号，如
#define _NR_restart_syscall (_NR_SYSCALL_BASE+0)
#define _NR_exit (_NR_SYSCALL_BASE+1)
#define _NR_fork (_NR_SYSCALL_BASE+2)
#define _NR_read (_NR_SYSCALL_BASE+3)

2)特殊的指令
使用SWI(已重命名为SVC指令)(软中断指令)，使ARM产生一个软中断，让Linux系统进入内核中的某一个固定位置。

3)固定的内核位置
在ARM中，这个位置是ENTRY(vector_swi)(在<entry-common.S>汇编程序中)

4)相应的函数
内核根据应用程序传过来的系统调用号，从系统调用表sys_call_table中找到相应的内核函数(calls.S文件)
CALL(sys_restart_syscall)
CALL(sys_exit)
CALL(sys_fork_wrapper)

5)
arm-none-linux-gnueabi工具链：现在的系统调用，都是基于eabi接口规范的，即实现的原理，或中间使用的寄存器都是基于这个规范的

2、添加系统调用
添加新的内核函数,来完成这个系统调用的工作和功能
更新头文件unistd.h，分配新的系统调用号
针对这个新函数更新系统调用表call.S

例：
1)在kernel/sys.c中添加内核函数
一般添加到最末尾
asmlinkage int sys_add(int a,int b)//asmlinkage使用栈传递参数
{return a+b;}

2)在arch/arm/include/asm/unistd.h中添加如下代码
#define _NR_add (_NR_SYSCALL_BASE+363)//注意，要添加到最后一个
/*
*the following swis are arm private.
*/
...

3)在arch/arm/kernel/calls.S汇编代码中添加代码，指向新实现的系统调用函数
同样，添加到最后一行
CALL(sys_add)

4)重新编译内核
make zImage ARCH=arm CROSS_COMPILE=arm-linux-

5)写调用的应用程序
#include<stdio.h>
#include<linux/unistd.h>
main()
{
 int result;
 result=syscall(363,1,2);//361是系统调用号，1和2只是普通的函数参数
 printf("result=",result);
}

arm-linux-gcc -static -o test.exe test.c
拷贝到文件系统中去

在板子中运行./test.exe

*proc文件系统：是内核态和用户态交互的机制，即可以查看内核状态，和配置内核
1、各目录作用
apm 高级电源管理信息
bus 总线以及总线上的设备
devices可用的设备信息
driver以及启用的驱动程序
interrupts中断信息
ioports端口使用信息
version内核版本

它的作用：
它对每个文件都规定了严格的权限，是可读，可写，为哪些用户读，哪些用户写等等
它是文件，可以查看。它也可以有子目录
它可以自己编写内核程序，作为一个文件，添加到/proc目录下
文件内容都是动态创建的，不存在于磁盘上，而是在内存中

2、编写程序
内核描述
struct proc_dir_entry
{
 ..
 read_proc_t *read_proc;
 write_proc_t *write_proc;
}
1)
创建文件
struct proc_dir_entry *create_proc_entry(const char *name,mode_t mode,struct proc_dir_entry *parent)
参数：
name:要创建的文件名
mode:要创建的文件的属性，默认0755
parent:这个文件的父目录，例如要创建的这个文件是位于proc/某个子目录a，中，那这个子目录a就是该文件的父目录

2)
创建目录
struct proc_dir_entry *proc_mkdir(const char *name,struct proc_dir_entry *parent)
参数：
name:要创建的目录名
parent:这个目录的父目录，例如要创建的这个目录b是位于proc/某个子目录a，中，那这个子目录a就是该目录b的父目录。
       如果没有子目录，则直接使用NULL

3)删除目录或文件
void remove_proc_entry(const char *name,struct proc_dir_entry *parent)
参数：
name:要删除的目录或文件名
parent:这个文件的父目录，例如要创建的这个文件是位于proc/某个子目录a，中，那这个子目录a就是该文件的父目录

4)读写
让用户可以读写添加的proc文件
read_proc
write_proc

5)读操作
int read_func(char *buffer,char **stat,off_t off,int count,int *peof,void *data)
参数：
buffer:读的数据放在buffer里，最大不超过PAGE_SIZE
stat:不用
off:偏移量，表示从哪里开始读
count:用户要取的字节数
peof:读到文件尾时，需要把*peof置1
data:不用

6)写操作
int write_func(struct file *file, const char *buffer,unsigned long count,void *data)
参数：
file:该proc文件对应的file结构，一般忽略
buffer:要写的数据放在buffer里
count:要写的数据的字节数
data:不用

7)实现流程
(1)调用create_proc_entry创建一个文件proc_dir_entry
(2)操作这个文件proc_dir_entry：read_proc,mode,owner,size,write_proc等

例：
struct proc_dir_entry *our_proc_file;

把helloworld,传给procfs_name文件，即这样子，传给用户
int procfile_read(char *buffer,char **stat,off_t off,int count,int *peof,void *data)
{
sprintf(buffer,"helloworld\n");
}

int proc_init()
{
//1.创建文件
our_proc_file=create_proc_entry(procfs_name,0644,NULL);
//2.为文件赋值
out_proc_file->read_proc=procfile_read;
out_proc_file->owner=THIS_MODULE;
out_proc_file->mode=S_IFREG|S_IRUGO;
out_proc_file->uid=0;
out_proc_file->gid=0;
out_proc_file->size=37;
return 0;
}


(3)参照内核模块开发步骤

//******************
//HelloWorld驱动程序
//******************
可以参考 内核模块开发 小节
1、在内核源码中创建一个驱动文件Linux-2.6.30.4/drivers/char/EmbedSky_hello_gzz.c
/*************************************

NAME:hello-c.c
COPYRIGHT:www.embedsky.net

*************************************/
#define __KERNEL__
#define MODULE

#include <linux/fs.h>
#include <linux/miscdevice.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <mach/irqs.h>
#include <mach/regs-gpio.h>
#include <mach/hardware.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("guozhenzhen");
MODULE_DESCRIPTION("this is tq2440 helloworld First module test");
MODULE_VERSION("1.0.0.0");

static int __init EmbedSky_hello_init(void)
{
	printk("<I>\n  Hello,EmbedSky\n");
	printk("<I>\n This is first driver program.\n\n");
	return 0;	
}

static void __exit EmbedSky_hello_exit(void)
{
	printk("<I>\n   Exit\n");
	printk("<I>\n Goodbye Embedsky\n\n");
}

module_init(EmbedSky_hello_init);
module_exit(EmbedSky_hello_exit);

注意：对于Linux2.6.25.8的内核，这三个头文件存放的路径是
#include <asm/irqs.h>
#include <asm/arch/regs-gpio.h>
#include <asm/hardware.h>

而对于Linux2.6.30.4的内核，它的存放路径在
#include <mach/irqs.h>
#include <mach/regs-gpio.h>
#include <mach/hardware.h>

这个的实际头文件是在
Linux2.6.30.4/arch/arm/mach-s3c2410/include/mach/hardware.h


2、在内核源代码中添加对hello驱动的支持
在本目录下
1)修改kconfig文件，这个文件用于make menuconfig 的配置
添加
config TQ2440_HELLOGZZ
	tristate "TQ2440 Hello Driver"
	depends on ARCH_S3C2440
	help
		EmbedSky TQ2440 Hello.
2)修改Makefile文件，添加
obj-$(CONFIG_TQ2440_HELLOGZZ)  +=  EmbedSky_hello_gzz.o

3)回到住文件夹中
配置内核
输入 make menuconfig ARCH=arm	
Device Drivers-->
	Character devices-->
		<M>TQ2440 Hello Driver //将其选择为M
输入make zImage ARCH=arm CROSS_COMPILE=arm-linux-进行生成内核镜像，将其烧写到开发板中

3、输入make modules进行编译模块，这时，就生成了课执行文件
EmbedSky_hello_gzz.ko

4、
将Linux内核文件下载到开发板上，然后启动内核
将EmbedSky_hello_gzz.ko存放入文件系统中
1)
方法一：
make modules_install INSTALL_MOD_PATH=/opt/EmbedSky/opt/EmbedSky/root_2.6.30.4.gzz/test/
然后在目录中
/opt/EmbedSky/opt/EmbedSky/root_2.6.30.4.gzz/test/lib/modules/2.6.30.4-EmbedSky/kernel/drivers/char/
就拷贝了这个文件EmbedSky_hello_gzz.ko

而且，这样子把所有的驱动文件都能拷贝过来了

2)
方法二：
cp EmbedSky_hello_gzz.ko /opt/EmbedSky/opt/EmbedSky/root_2.6.30.4.gzz/test/
在该目录下就有了这个驱动文件了


//***************
//GPIO口驱动程序
//***************
2440板子，用GPB5，GPB6，GPB7，GPB8寄存器来控制4个LED灯，低电平时亮，高电平时灭
在Linux-2.6.30.4/drivers/leds/leds-s3c24xx.c中有该led灯的驱动程序，
在Linux-2.6.30.4/arch/arm/plat-s3c24xx/common-smdk.c文件中有该驱动的注册信息
1)屏蔽掉原有的led灯注册信息
Linux-2.6.30.4/arch/arm/plat-s3c24xx/common-smdk.c
/*LED devices*/
#if 0   //用于屏蔽
static struct s3c24xx_led_platdata smdk_pdata_led4...
...
&smdk_pdata_led7,
},
};
#endif


5、导入NFS文件系统。
1)制作完成最小的文件系统之后，进行网络配置
(1)在板子上进行网络配置
ifconfig eth0 up
ifconfig，接上网线
ifconfig eth0 192.168.0.33  要与window，linux处于同一个网段，且地址不能冲突

(2)在windows进行设置：
windows防火墙是否关闭？主菜单------控制面板------windows防火墙------关闭
关闭无线网卡

(3)虚拟机
Network Adapter设为Bridged桥接

(4)在Linux进行设置
①
关闭linux的防火墙
Redhat使用
service iptables stop 
ubuntu使用
sudo ufw disable
②安装NFS服务端，重启NFS服务

(5)在板子上手工挂接：从flash上启动根文件系统，再用命令挂接NFS
启动内核后，使用命令挂接
mkdir /mnt
mount -t nfs 192.168.0.29:/opt/EmbedSky/opt/EmbedSky/root_2.6.30.4.gzz /mnt -o nolock

(6)可以在服务器端编辑程序，在板子上运行程序了

(7)卸载挂接文件
umount /mnt


2)
通过
insmod EmbedSky_hello_gzz.ko 加载驱动模块
rmmod EmbedSky_hello_gzz.ko 卸载驱动模块	

6、例子说明：
内核的源码树目录下一般都会有两个文件：Kconfig和Makefile。
http://blog.sina.com.cn/s/blog_4a377e150100c896.html

【具体步骤】
1).首先保证已经有驱动源文件了：as352x_afe_charger.c
放在和其他你所要添加的模块放在一个目录下，此处是drivers\i2c\chips下。

2).在drivers\i2c\chips\makefile中，添加：
obj-$(CONFIG_AS352X_AFE_CHG) += as352x_afe_charger.o

3).在drivers\i2c\chips\Kconfig
中，添加如下内容：
----------------------------------------------
config AS352X_AFE_CHG
tristate "AS352X AFE Charger Driver"
depends on I2C_AS352X && AS352X_AFE
help
   If you say yes here you get support for AS352X AFE Charger.

   This driver can also be built as a module. If so, the module
   will be called AS352X AFE Charger.
----------------------------------------------
解释如下:
(1)AS352X_AFE_CHG是自己定义的名字，当然要尽量保证有意义。
同时，你会注意到，在上面的makefile中添加的
obj-$(CONFIG_AS352X_AFE_CHG) += as352x_afe_charger.o
中的CONFIG_AS352X_AFE_CHG，是CONFIG_加上我们在kconfig下写的config变量。
这两个要匹配，才能实现你在menconfig定义的结果，传递到makefile中，
以便决定编译的时候是如何编译：不编译/编译进内核/编译成模块

(2)tristate 表示我此处添加的模块，可以
在make ARCH=arm menuconfig中看到的，选择之后:
* 编译到内核中
M 编译成模块，即生成XXX.ko
不选中，就不编译该文件
(3)depends on I2C_AS352X && AS352X_AFE
是前面自己找到的，表示此编译选项只有当I2C_AS352X 和AS352X_AFE都选中，才会出现。
当然，如果此模块不依赖于其他模块，则不需要加上这个depends on了。

【附录】
1).如果设置成M，module模式，则要用
make ARCH=arm
编译出as352x_afe_charger.ko

而
make ARCH=arm uImage
只能编译内核，而不编译模块。
		

//************
//内核异常分析
//************
程序在内核中运行时，如果出现问题，运气好的话会出现Oops信息显示。例如应用程序中使用了空指针，或非法指针
(小于0xc0000000以下的地址，即3G以下的地址)，还有其它一些异常，都会出现这个问题，产生问题后，分析的步骤
查看错误原因提示
调用栈(对照反汇编代码)
查看寄存器
1、查看错误原因提示，它的Oops信息格式如下
Unable to handle kernel paging request at virtual address f899b670这个是错误原因提示，在这里是访问了一个无效
                                                                  的虚拟地址f899b670
printing eip:

//==============================
//==基于Linux的ARM应用程序的开发
//==============================        
//***********
//C++程序设计
//***********
//********
//面向对象
//********
*类基本结构
1.类定义：注意，和结构体一样，需要加分号
class clock
{
  public:外部接口
    void settime(int newh,int newm,int news);
    void settime2(int newh=0,int newm=0,int news=0);//带缺省行参 
    void settime(double newh=0);//这个是重载函数 
    void showtime();
  protected:本类，和继承类可以访问
    保护成员 
  private:本类中的函数访问
    int hour,minute,second;
};
2.成员数据
  可以通过成员函数，对类的成员数据进行访问

3.成员函数使用：
1)内联成员函数有两种方法，
(1)一种在类里面声明的时候，就予以实现，它是这样做的
class clock
{
  public:外部接口
    void settime(int newh,int newm,int news)//定义时，就直接实现了
    {
       hour=2;
    }
  protected:本类，和继承类可以访问
    保护成员 
  private:本类中的函数访问
    int hour,minute,second;
};

(2)在类里面定义，在类外面声明
class clock
{
  public:外部接口
    void settime(int newh,int newm,int news);//定义时，就直接实现了
   
  protected:本类，和继承类可以访问
    保护成员 
  private:本类中的函数访问
    int hour,minute,second;
};
inline void clock::settime(int newh,int newm,int news)//定义时，就直接实现了
{
       hour=2;
}

2)先在类里面声明，再在类外实现，如下所示
class clock
{
  public:外部接口
    void settime(int newh,int newm,int news);//定义时，就直接实现了
   
  protected:本类，和继承类可以访问
    保护成员 
  private:本类中的函数访问
    int hour,minute,second;
};

void clock::settime(int newh,int newm,int news)
{
  hour=1;
  minute=2;
  second=3;
}

void showtime()
{
}

4.类的对象
1)声明:
clock *myclock=new clock;

2)
类的成员的使用：
(1)在类内，直接就可以使用了，例如
class clock
{
  public:
    void settime(int newh,int newm,int news);
   
  protected:
    
  private:
    int hour=1,minute=2,second=3;
    hour=second;//类内使用
};

(2)在类外，通过myclock.hour的格式使用public属性的变量或函数
   同时通过这些函数来使用private属性的变量或函数
class clock
{
  public:
    void settime(int newh,int newm,int news);
    void inttt()
    {
       tt=second;
       minute=5;
    }
   
    int hour=1,minute=2,second=3;  
  private:
    int tt;   
};

①
访问public属性的变量
myclock.hour=myclock.minute;
访问public属性的函数
myclock.settime(1,2,3);

②
访问private属性的成员
myclock.inttt();

③注意：不能访问protected成员

5.类与结构体的区别
类中的成员默认是私有的，而结构体中的成员默认是公有的


6.构造函数：对象被创建时赋初值使用的，它在对象创建时由系统自动调用该函数，因此不用程序再
  调用构造函数

    　1).构造函数的命名必须和类名完全相同。
      2).构造函数的功能主要用于生成对象时它自动初始化.它没有返回值,也不能用void来修饰.
      这就保证了它不仅什么也不用自动返回,而且根本不能有任何选择.而其他方法都有返回值.即使是      void返回值
      3).构造函数不能被直接调用,必须通过new运算符在创建对象时才会自动调用；而一般的方法是在      程序执行到它的时候被调用的. 
      例如：
      (1)无参数构造函数 
      class FindDialog
      {
         plublic:
           FindDialog()
           {
              a=1;
              b=2;
              c=3;
           }
      } 


      ①方法一
      //声明张三这个人     
      //为张三初始化它的默认参数，这个是无参数的
      FindDialog *Zhangsan = new FindDialog; 

      ②另外一种方法
      FindDialog a;

      (12)有参数构造函数 
      class FindDialog
      {
         plublic:
           FindDialog(int x,int y,int z)
           {
              a=x;
              b=y;
              c=z;
           }
      } 

      ①
      //为张三初始化它的默认参数，这个是有参数的
      FindDialog *Zhangsan = new FindDialog(1,2,3); 
      
      ②另外一种方法
      FindDialog a(1,2,3);

      4).当一个类只定义了私有的构造函数，将无法通过new关键字来创建其对象，因此，构造函数必须      用public，或protected。 
      当一个类没有定义任何构造函数，编译器会为其自动生成一个默认的无参的构造函数。
      5)构造函数允许是内联函数，重载函数，或待缺省形参值的函数
7.析构函数
      有些在类中，如果需要动态申请空间，最好放到构造函数里面。然后再用完之后，在析构函数中
把它释放。如果没有声明，编译器自动生成一个
class point
{
   public:       
       point(int xx=0,int yy=0)
       {
         x=xx;
         y=yy;
       }
       ~point()析构函数
       {
         
       }
   private:
       int x,y;    
};

8.类中包含类
组合类的构造函数就需要写成组合的构造函数的形式，
要注意它的子类有构造函数，它本身的类也有构造函数，他们之间的参数传递
因此初始化时，要同时对子类对象初始化，也要对自己本身初始化。

执行时构造函数顺序：先初始化子类构造函数->再初始化本类构造函数
析构函数顺序相反

如果调用缺省的无参的构造函数，那么调用的子类的构造函数也是缺省的那个无参的

1)简单传参数的例子
class part
{
  public:
    part(int i);
};

class whole
{
  public:
    whole(int i,int j,int k);
  private:
    part one,two;
    int c;  
};

实现
方法一：
whole::whole(int i,int j,int k):two(i),one(j)
{
  c=k;
}
方法二：
whole::whole(int i,int j,int k):two(i),one(j),c(k)
{  
}

调用
whole(1,2,3);

或者直接使用,使用的是默认创建的无参数的构造函数
whole();

①通过赋值，i=1,j=2,k=3
②i,j两个参数复制给part子类one,two,用于创建构造函数
i-复制->two
j-复制->one
③初始化本类构造函数
c=k

2)
class point
{
  private:
     float x,y;
  public:
     point(float a,float b);
     float getx();
     float gety();   
}

class zhixian
{
  private:
     point p1,p2;
     double dist;
     double d;
     double price;//求运费使用
  public:
     zhixian(point a,point b);
     double getzhixian()
     {
        return dist;
     }   
}

3)这时，组合类的构造函数就需要写成组合的构造函数的形式，
要注意它的子类有构造函数，它本身的类也有构造函数，他们之间的参数传递
因此初始化时，要同时对子类对象初始化，也要对自己本身初始化。

执行时构造函数顺序：先初始化子类构造函数->再初始化本类构造函数
析构函数顺序相反

如果调用缺省的无参的构造函数，那么调用的子类的构造函数也是缺省的那个无参的


(1)point类的构造函数是这个
point(float a=0,float b=0)
{
  x=a;
  y=b;
}

(2)
本类名::本构造函数名(本类所需的子类成员作为形参，本类成员作为形参):子类1(参数1),子类2(参数2)...
{
  初始化
}

zhixian的成员有这几个
子类的成员： point p1,p2;这是两个子类对象
本类的成员： double dist;,它其实是直接求的，因此本类不需要用作形参
             double d,price；本类成员


zhixian::zhixian(point a,point b,double d,double p):p1(a),p2(b)
{
  dist=d;
  price=p;
}
①对象成员的形参要分别传递给不同的对象成员
a--->传递给p1,调用拷贝构造函数，初始化point类得对象p1
b--->传递给p2,调用拷贝构造函数，初始化point类得对象p2
②本类成员的形参d,p,初始化本类的这两个值
dist=d;
price=p;


(3)调用
void main()
{
  point myp1(1,1),myp2(4,5);//初始化两个点
  //两个点作为实参传递给zhixian的构造函数，
  ①它会先传递myp1,myp2两个实参，作为拷贝构造函数给zhixian(point a,point b)
     myp1--拷贝->a
     myp2--拷贝->b
  ②a,b两个参数调用拷贝构造函数给point子类p1,p2,用于创建构造函数
     a--拷贝->p1
     b--拷贝->p2
  ③初始化本身的构造函数   
  zhixian myd(myp1,myp2);
  
}
     
9.前向引用声明：类应该先声明后使用，但是如果需要在某个类得声明之前，就要引用该类，就应该进行前向引用声明
类似于基础类型的extern
例：
class b;前向引用声明
class a
{
  public:
    void f(b it);
};
class b
{
  public:
    void g(a ad);
};

10、
this指针，指的是本类

*拷贝构造函数：它形参为本类的对象引用
用一个对象给另外一个对象赋值的时候，这就需要拷贝构造函数。如果没有显示的定义拷贝构造函数，那么
编译器将会自己生成一个，它会用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的
对应数据成员
1、作用一是用本类的另外一个对象来初始化自己类型
类似于这个
Int a=3;
int b=a;用a的值来初始化b

例子：
class point
{
   public:       
       point(int xx=0,int yy=0)
       {
         x=xx;
         y=yy;
       }
       point(point &p)拷贝构造函数
       {
         x=p.x;
         y=p.y;
       }
   private:
       int x,y;    
};

调用:a初始化时，把b拷贝过来初始化a
point *b=new point(1,2);
point *a=new point(b);

原理：
(1)初始化b对象
b.x=1;  b.y=2;
(2)把b当传引用:传引用相当于给对象b取别名
point &p=b;传引用相当于给对象b取别名p
此时
p.x即代表b.x的意思；
p.y即代表b.y的意思；

(3)对象a初始化时
a.x=p.x,即1
a.y=p.y,即2

2、作用二如果函数的形参是类，调用函数时，实参赋给形参，系统就自动调用拷贝构造函数
类似于这个
void fun(int b)
{...}

void main()
{
  int a=2;  
  fun(a);调用拷贝构造函数
}
作用就是a=2, 分配一个内存b,将a的值拷贝到b中
b=2

例如：
void fun(point p)
{...}

void main()
{
  point a(1,2);
  fun(a);调用拷贝构造函数
}

3、作用三函数的返回值如果是类对象时，系统自动调用拷贝构造函数
point fun()
{
  point a(1,2);
  return a;
}

void main()
{
  point b;
  b=fun();
}


*类模板
函数重载是写多个函数，但是它的函数名是一样的。

而函数模板是如果函数的所有内容都是一样的，只是它的类型不一样，就可以直接
使用函数模板写一个函数既可以了，对于数据类型，用一个type来代替它。然后在使用的时候，根据
调用者的不同类型的参数，实例化一个不同的模板函数出来使用即可
template <class T>
T mymax(T a,T b)
{return a>b? a: b;}
int main()
{
mymax('t','V');
mymax(10,12.5);
}

类模板是里面数据成员的类型不同，里面的内容是一样的,其中类型包括系统定义的类型，以及用户
定义的类型(结构，枚举，类)
template<模板参数表>

例：
1)
template<class T>用T来代替具体类型,以后凡是有遇到类型的地方，都会用它来代替
class complex
{
   private: 
            T real;
            T image;
   public:
            complex(void);无形参的构造函数
            T putelem(T a=0,T b=0)//在类里面定义成员函数
            {...}         
    ....        
};

2)
在类外面定义成员函数
template<class T>
T complex<T>::realcomplex()
{...}

在类外面定义构造函数
template<class T>//注意，在每实现一个函数，就需要这样子加一下
complex<T>::complex(void)
{
  haveValue=0;
}


3)
使用,即有将模板实例化为一个具体的类的作用
complex<double>s1,s2;
s1.realcomplex();


*类的继承
1、派生类声明
class 子类: 继承方式 父类
{
...
}
一般子类继承父类成员。子类的成员名页可以覆盖父类的成员名，对这个成员进行改造。可以
重新创建新的成员

2、继承方式:public,protected,private
决定了子类里面成员和成员函数对父类的访问
决定了子类生成的对象对父类的成员以及成员函数的访问
1)public继承
子类里面，可以访问父类的public,protected成员，但不能访问private成员
子类生成的对象可以访问父类的public成员
class A
{
  public:
    int a;
  protected:
    int b;
  private:
    int c;    
};

class B: public A
{
  public: 
    int d;   
    void func()
    {
      d=a;//子类成员访问父类public成员
      d=b;//子类成员访问父类protected成员
    }
};

B classb;
classb=A.a;//子类对象访问父类public成员

2)protected继承
子类里面，可以访问父类的public,protected成员，而且它都降级为protected身份。子类不能访问父类private成员
子类生成的对象不可以访问父类的任何成员

3)private继承
子类里面，可以访问父类的public,protected成员，而且它都降级为private身份。子类不能访问父类private成员
子类生成的对象不可以访问父类的任何成员
class A
{
  public:
    int a;
    void move()
    {c=1;}
    
  protected:
    int b;
  private:
    int c;    
};

class B: public A
{
  public: 
    int d;   
    void move()//只能通过这样子调用
    {
      A::move();
    }
    void func()
    {
      d=a;//子类成员访问父类public成员
      d=b;//子类成员访问父类protected成员
    }
};

B classb;
classb.move();//这样子使用

3、多种继承方式
1)
单继承：从一个父类继承
多继承：从多个父类继承
class 子类：继承方式1 父类1，继承方式2 父类2
{
 ..
}

多重派生：父类派生出多个子类
多层派生：派生出子孙类

2)继承时的构造函数
构造函数不被继承，子类的构造函数只需要初始化子类自己的成员即可，父类的成员由父类
自己的构造函数来完成
(1)单继承：
子类::子类构造函数名(父类所需要的形参，本类所需要的形参):父类名(参数)
{
初始化本类成员
}

(2)多继承
子类::子类构造函数名(父类1所需要的形参，..父类n所需要的形参，本类所需要的形参):父类名1(参数),父类名2(参数)
{
初始化本类成员
}

(3)多继承，同时还有类包含类的构造函数
子类::子类构造函数名(父类1所需要的形参，..父类n所需要的形参，本类包含类1所需要的形参，..本类包含类n所需要的形参,本类所需要的形参):父类名1(参数),父类名n(参数),
包含类1(参数),包含类n(参数)
{
初始化本类成员
}

3)虚基类
(1)二义性问题
class A
{
  public:
    void f();
};
class B
{
  public:
    void f();
    void g();
};

class C:public A,public B
{
  public:
    void g();
    void h();
};

void main()
{
  C c1;
  c1.f();//具有二义性了，不知是A的，还是B的
  c1.g();不具有二义性
}

解决方法：
方法一：用类名来定
c1.A::f();  或 c1.B::f()调用成员函数
c1.B::b调用成员对象
方法二：
class C:public A,public B
{
  public:
    void g();
    void h();
    void f()
    {B::f();}
};

c1.f();即是调用B.f();

但是这两种方法不能解决冗余的问题

(2)虚基类
多重继承中，多个子类共同继承一个父类，而产生的二义性
class B
{
  public:
    int b;
}
class B1:public B
{
  public:
    int b1;
}
class B2:public B
{
  public:
    int b2;
}

class C:public B1,public B2
{
  public:
    int f();
  private:
    int d;  
}

void main()
{
  C c;
  c.b;//产生二义性
}

结构如下
B--->B1---->C
 |-->B2---|
虚基类：
class B1:virtual public B
class B2:virtual public B
这样，等下 
c.b即是只产生一个B类.b的数值

(3)虚基类的构造函数使用
直接或间接继承虚基类的子类，它的构造函数都要给出对虚基类的构造函数的调用
B1(int a):B(a);
B2(int b):B(b);
C(int a,int b,int c):B1(a),B2(b),B(c);

4、父类与子类的对象相互引用
class B
{};
class D:public B
{};
D d;
B b;
1)b=d;这样可以，把b有的用d的成员初始化，b没有的d中的成员，就丢掉。d=b不行
2）
B &p;
p=d;可以
3)
B *p;
p=d;可以




*多态性：使用同一个功能，针对不同的调用对象，使用不同的处理方法
例如：选课功能，针对本科生的选课，和针对研究生的选课是不一样的
1、静态多态性：在编译时，程序就知道要调用哪个函数了，即静态绑定函数。
1)函数重载：多个函数使用同一个函数名，它的参数和函数体不一样，然后程序启动时，编译器根据不同
的函数参数，就知道具体要调用哪个函数了
2)运算符重载：整形+整形，与复数+复数 所调用的机制是不同的
例如：基本类型的+，系统已经提供了。
复数类型的+，complexa+complexb，系统没有，只有自己写一个这个的函数类，这个类名是"+"，进行重载。
这样子，系统在编译时，会自动调用这个"+"类

(1)重载规则：
不能重载下面几个运算符:. .* :: ?:
只能重载现有的运算符，不能自己创造
不能改变运算符的结合性和优先级
不能改变操作数个数
经重载的运算符，其中至少要有一个是自定义类型

(2)重载有两种方法，一重载为类成员函数
class complex//复数声明
{
  public:
    complex(double r=0.0,double i=0.0)构造函数
    {
       real=r;
       image=i; 
    }
    complex operator +(double c2);//+重载为成员函数
    complex operator +(complex c2);//+重载为成员函数
    complex operator -(complex c2);//-重载为成员函数 
    void display();
  private:
    double real;//复数实部
    double image;//复数虚部
}

定义
complex::complex::
  operator +(complex c2)
{
  complex c;
  c.real=c2.real+real;
  c.imag=c2.imag+imag;
  return complex(c.real,c.imag);
}

使用
complex a,b(2,3),c;
double d;
c=a+b;即是a.operator +(b)把这个重载的函数返回给c
c=a+d;即是a.operator +(d)把这个重载的函数返回给c


(3)重载为友元函数

2、动态多态性：编译时还不知，只有等到执行时，才知道具体使用哪个函数，即动态绑定函数
1)虚函数
(1)
在函数前面加上virtual
虚函数只能用来说明类声明中的原型，不能用在函数实现时
虚函数有继承性，如果在父类中声明了虚函数，在子类中如果它的函数名与参数什么的完全一样，(析构函数函数名可以不同)那无论是否显式声明，它也是虚函数。但建议显式声明，这样好看。
调用方式：它通过父类指针或应用，执行时会根据指针指向的对象的类，决定调用哪个函数
例：
class B0父类
{
  public:
    virtual void display()这是一个虚函数
    {..}
};

class B1:public B0
{
  public:
    void display()
    {..}
};

class D1:public B0
{
  public:
    void display()
    {..}
};

void fun(B0*ptr)
{
  ptr->display();
}

void main()
{
  B0 b0,*p;
  B1 b1;
  D1 d1;
  p=&b0; 指向父类
  fun(p);调用父类函数
  p=&b1; 指向b1类
  fun(p);调用b1类函数
  p=&d1; 指向d1类
  fun(p);调用d1类函数
}

(2)使用指针声明的对象
析构函数通常都声明为虚函数，当用指针声明对象空间之后，只有用delete才能释放空间
void finish()
{
  B *classp=new B;
  delete p;
}

①使用一般方法声明的对象
class Base
{
  public:
    Bawse(){cout<<"construct in Base";}
    ~Base(){cout<<"destruct in Base";}//析构函数
};
class Subclass:public Base
{
  public:
    Subclass(){cout<<"construct in Subclass";}
    ~Subclass(){cout<<"destruct in Subclass";}//析构函数
}

void main()
{
  cout<<"first"
  Base bc;
  cout<<"second"
  Subclass sc;
}
打印信息
first
//构造函数
construct in Base

second
construct in Base
construct in Subclass

//析构函数
destruct in Subclass
destruct in Base
destruct in Base

②使用指针声明的对象
class Base
{
  public:
    Bawse(){cout<<"construct in Base";}
    ~Base(){cout<<"destruct in Base";}//析构函数
};
class Subclass:public Base
{
  public:
    Subclass(){cout<<"construct in Subclass";}
    ~Subclass(){cout<<"destruct in Subclass";}//析构函数
}

void main()
{
  cout<<"first"
  Base *bc=new Base;
  cout<<"second"
  Subclass *sc=new Subclass;
}
打印信息
first
//构造函数
construct in Base

second
construct in Base
construct in Subclass

没有析构函数，因为它是用指针来声明的，只有调用delete,它才能析构

③使用虚函数来声明析构函数
class Base
{
  public:
    Bawse(){cout<<"construct in Base";}
    virtual ~Base(){cout<<"destruct in Base";}//析构函数
};
class Subclass:public Base
{
  public:
    Subclass(){cout<<"construct in Subclass";}
    virtual ~Subclass(){cout<<"destruct in Subclass";}//析构函数
};

void test(Base *x)
{
  delete x;
}

void main()
{
  cout<<"first"
  Base *bc=new Base;
  cout<<"second"
  Subclass *sc=new Subclass;
  test(bc);
  test(sc);  
}

打印信息
first
//构造函数
construct in Base

second
construct in Base
construct in Subclass

destruct in Base
destruct in Subclass
destruct in Base

2)纯虚函数与抽象类:暂时无法实现的函数，在基类里面声明为纯虚函数，留给子类去实现
抽象类只能作为基类来使用，且不能声明抽象类的对象

没有函数体的称为纯虚函数virtual 函数名(参数表)=0;
含有纯虚函数的类称为抽象类
class 类名
{
  virtual 函数名(参数表)=0;
};

例如：
class B0
{
  public:
    virtual void display()=0;纯虚函数
};

class B1:public B0
{
  public:
    void display()
    {..}
};

class D1:public B0
{
  public:
    void display()
    {..}
};


void fun(B0*ptr)
{
  ptr->display();
}

//不能指向抽象类
void main()
{
  B0 *p;
  B1 b1;
  D1 d1;
  p=&b1; 指向b1类
  fun(p);调用b1类函数
  p=&d1; 指向d1类
  fun(p);调用d1类函数
}


*C++中的static
1、static用来修饰类中的成员变量时，由该类生成的所有实例，都共用这个变量
，也就是值只能有一个
1)声明
classA
{
  public:
    static int i;
}；
2)
必须要在类外进行初始化
int A::i = 0;

3)使用
int j=A::i;
 
2、static用来修饰类的成员函数时，成员函数里面的成员变量必须全部为静态
成员变量,或静态成员函数
不能使用this指针
1)声明
classA
{
  public:
    static int foo();
}；

2)实现
A::foo()
{
  c=b;
}

3)使用
用对象调用
A a;
a.foo();
用指针调用
A *xp=new A;
xp->foo();
直接用类调用(普通的成员函数不能这样调用)
A::foo();

delete xp;


*const的使用
一般用来代替#define
1)定义成员常量
class A
{
  const int COUNT;
};
2)定义成员函数
(1)定义函数的返回值是常量，其实不常用
const int foo();

(2)定义函数本身，该函数不修改成员变量，页不能调用其它非const成员函数

int foo() const
{return i;}

*C,C++混合编程，c++的程序要用C编译
如果C++中有用到类的成员函数，则需要转换成成员函数
C++中的普通成员函数，也需要用extern "C"{}包含


//=========================
//==基于Linux的Androaid开发
//=========================        
//=========================
//JAVA程序设计
//=========================
//*********
//java基础
//*********
新建Hello文件

public class Hello
{
    public static void main(String args[])
    {
       System.out.println("Hello world");
    }
}

javac Hello.java
java Hello

1.类
所有程序一定要被类所管理，而且
public class主类定义:类名称必须要和文件名称保持一致，在一个*.java之中只能有一个public class程序
class一般类定义:类名称可以和文件名称不一致，但生成的是程序名称是class定义的名称。
在一个*.java程序之中可以同时存在多个class定义，编译之后会生成多个不同的*.class执行程序

2.主方法
主方法表示的是一个程序起点，要放在主类中，主方法定义格式
public static void main(String args[])
3.系统输出
System.out.println("Hello world");有换行
System.out.print("Hello world");无换行
4.classpath
PATH:指向可以执行命令的程序路径
CLASSPATH:指向所有*.class文件的路径
//*********
//面向对象
//*********
*类
1.
class 类名称
{
   属性变量;
   方法;
}

2.
声明并实例化对象
1）类名称 对象名称 = new 类名称();
2)
类名称 对象名称 = null;
对象名称 = new 类名称();

例子：
//类名称
class person
{
    int age;//类的属性
    String name;
    //类的方法
    public void tell()
    {
        System.out.println("name:"+name+"age:"+age);
    }
}


public class Hello
{
    public static void main(String args[])
    {
       System.out.println("Hello world");
       person per = new person();//声明并实例化对象 
       per.age = 12;
       per.name = "lisi";
       per.tell();
    }
}

3.封装性
//类名称
class person
{
    private int age;//类的属性
    private String name;
    //类的方法
    public void setName(String s)
    {
       name = s;
    }
    public String getName()
    {
        return name;
    }
    public void tell()
    {
        System.out.println("name:"+name+"age:"+age);
    }
}


public class Hello
{
    public static void main(String args[])
    {
       System.out.println("Hello world");
       person per = new person();//声明并实例化对象 
       per.setName("lisi");
       System.out.println(per.getName());
       per.tell();
    }
}

4.构造方法：是实例化对象的时候就马上被调用。构造方法的名称要和类名称一样，而且该方法没有返回类型
一个类中，系统至少会存在一个构造方法，他是否有用
1)无参构造方法
//类名称
class person
{
    private int age;//类的属性
    private String name;    
    //类的方法
    public void setName(String s)
    {
       name = s;
    }
    public String getName()
    {
        return name;
    }
    public void tell()
    {
        System.out.println("name:"+name+"age:"+age);
    }
    //构造方法
    public person()
    {
        System.out.println("Hello gouzao");
    }
}

public class Hello
{
    public static void main(String args[])
    {
       person per = new person();//声明并实例化对象 
       per.setName("lisi");
       System.out.println(per.getName());
       per.tell();
    }
}

2)有参构造方法
//类名称
class person
{
    private int age;//类的属性
    private String name;    
    //类的方法
    public void setName(String s)
    {
       name = s;
    }
    public String getName()
    {
        return name;
    }
    public void tell()
    {
        System.out.println("name:"+name+"age:"+age);
    }
    //构造方法
    public person(int a,String str)
    {
        System.out.println("Hello gouzao");
        age = a;
        name = str;
    }
}


public class Hello
{
    public static void main(String args[])
    {
       person per = new person(11,"zhangsan");//声明并实例化对象 
       per.tell();
    }
}

3）构造方法重载
//类名称
class person
{
    private int age;//类的属性
    private String name;    
    //类的方法
    public void setName(String s)
    {
       name = s;
    }
    public String getName()
    {
        return name;
    }
    public void tell()
    {
        System.out.println("name:"+name+"age:"+age);
    }
    //构造方法
    public person(int a,String str)
    {
        System.out.println("Hello gouzao");
        age = a;
        name = str;
    }
    //构造方法重载
    public person(int a)
    {
        System.out.println("Hello gouzao2");
        this.age = a;        
    }
}


public class Hello
{
    public static void main(String args[])
    {
       person per = new person(13);//声明并实例化对象 
       per.tell();
    }
}

4)所有实例化类步骤中，构造方法是最后一步才做的，例如
class a
{
   private age =12;
   public a()
   {
      age = 18;
   }
}

则最后，age = 18;



5.this关键字
1)构造方法的调用
public class person
{
   public person()
   {System.out.println("hello");}
   
   public person(String name)
   {
      this.name=name; 
      this();
   }
   public person(String name,int age)
   {
      this(name);
      this.age=age;  
   }
}
注意：
（1）构造方法实在对象实例化时被默认调用，并且是在调用普通方法之前被调用，所以
使用this()调用构造方法的操作，一点要在构造方法的首行
(2)如上多个构造方法互相调用，那至少要有一个没有this方法

6.static关键字
1)定义属性：变成了全局变量
//类名称
class person
{
    private int age;//类的属性
    private String name; 
    String city="北京";    
    //类的方法
    public void setName(String s)
    {
       this.name = s;
    }
    public void setCity(String s)
    {
       this.city = s;
    }
    public String getName()
    {
        return this.name;
    }
    public void tell()
    {
        System.out.println("name:"+this.name+"age:"+this.age+"city:"+this.city);
    }
    //构造方法
    public person(int a,String str)
    {
        this.age = a;
        this.name = str;
    }
}


public class Hello
{
    public static void main(String args[])
    {
       person per1 = new person(11,"zhangsan");//声明并实例化对象 1
       per1.tell();
       person per2 = new person(12,"li4");//声明并实例化对象 1
       per.tell();
    }
}
这时，如果要更改类person中city的地点为福建，那么
per1.setCity("福建");
per2.setCity("福建");
这样浪费资源。

因此，对于city属性来说，他是公共的资源，加上static
class person
{
    private int age;//类的属性
    private String name; 
    static String city="北京";
    public void setCity(String s)
    {
       city = s;//静态变量city,不能使用this
    }
     。。。。
    
}
per1.setCity("福建");之后，所有的per2,等等都会自动改为"福建"了
但是，由对象per1来修改，是不合适的，正确方法要由类来修改
person.city = "福建";

注意：
(1)static静态属性不是在堆中，而是在全局数据区
(2)最好要使用类来修改person.city = "福建";
(3)他可以在没有实例化对象之前，就由类修改

2)定义方法：变成了全局方法
静态方法public static void setCity(String s)
//类名称
class person
{
    private int age;//类的属性
    private String name; 
    private static String city="北京";    
    //类的方法
    public void setName(String s)
    {
       this.name = s;
    }
    public static void setCity(String s)
    {
       city = s;//静态变量city,不能使用this
    }
    public static String getCity()
    {
       return city;//静态变量city,不能使用this
    }
    public String getName()
    {
        return this.name;
    }
    public void tell()
    {
        System.out.println("name:"+this.name+"age:"+this.age+"city:"+this.city);
    }
    //构造方法
    public person(int a,String str)
    {
        this.age = a;
        this.name = str;
    }
}


public class Hello
{
    public static void main(String args[])
    {
       person.setCity("福建");
    }
}

注意：
(1)static定义的方法，里面不能使用非static的属性,或者非static的方法，不可以使用this
(2)非static定义的方法，里面可以使用static的方法或属性


实际上使用static方法的原因：
(1)在没有实例化时，可以执行类的某些操作
(2)数据共享

3)主方法:一个程序的开始点
public class test
{
public static void main(String args[])
{print();}
public static void print()
{...}
}
可以使用

public class test
{
public static void main(String args[])
{new this.print();}
public void print()
{...}
}
可以使用

所以主方法的各个关键字原因：
public 所有程序都可以访问主方法
static:此方法可以由类直接调用，例如执行程序时java testDemo,他自动调用主方法
void:主方法是一切程序的开始，没有返回值
main:方法入口函数
String args[]:运行时参数

注意：
(1)不可以这样用
class Demo 
{ 
public static void main(String[] args) 
{ 
static int q=2; 
System.out.println("Hello World!"); 
} 
} 
只能这样用
class Demo 
{ 
static int q=2; 
public static void main(String[] args) 
{ 
System.out.println("Hello World!"); 
} 
} 
静态变量不可以,非静态的可以. 静态的最好用类名调用,写在方法中就无法用类来调用了

(2)mian方法有些不一样，不能直接看做static方法

7.匿名对象
public class neibu
{    
    public static void main(String args[])
    {
       new person(11,"z3").tell();       
    }    
}
8.内部类:一个类里面包含其他类
1）
//类名称
class out
{
   private String msg="hello";
   class in
   {
      private void print()
      {System.out.println(msg);}
   }
   public void fun()
   { 
      in inner=new in();
      inner.print();
   }
}


public class neibu
{    
    public static void main(String args[])
    {
       out Outer=new out();
       Outer.fun();  
    }    
}

其他类直接使用内部类
out.in inner=new out().new in();
inner.print();

private class in(){},这样内部类in只能被外部类使用，不能被其他类使用

2）使用static定义的内部类：表示为"外部类"，只能访问外部类之中的static类型的操作
class out
{
   private static String msg="hello";
   static class in
   {
      private void print()
      {System.out.println(out.msg);}
   }
   public void fun()
   { 
      in inner=new in();
      inner.print();
   }
}

使用
out.in inner=new out.in();
in.print();

9.继承
继承父类class b extends out
可以通过super()调用父类的构造方法
子类不能访问父类的私有成员
this关键字:代表本类的东西


10.覆写:子类继承父类，如果子类需要重新定义和父类一样的方法或属性名称，就需要覆写
1)方法覆写：子类定义了和父类方法名称，返回值类型，参数类型和个数完全相同的函数
（1）
class b extends out
{
   //复写方法
   public void fun()
   {System.out.println("hello b");}
}
(2)被子类复写的方法不能币父类更严格的控制权限
(3)当一个子类复写了父类方法的时候，子类如果想要调用父类的该方法，要用super.fun();
class b extends a
{
   //复写方法
   public void fun()
   {
     super.fun(); 
     System.out.println("hello b");
   }
}
（4）使用private定义的方法，无法复写的

11.final关键字：表示一个总结器的概念，可以定义类，方法，变量
定义的类不能有子类了
定义的方法不能被子类复写
定义的变量就变成常量了，必须设默认值
public static final String INFO="hello world";这个是全局常量

12.多态性
方法的多态性：重载与复写
对象的多态性：父子类，
1)
  （向上转型）子类对象变为父类对象:父类 父类对象=子类对象
例如：
class a
{   
   public void fun()
   {System.out.println("hello a");}
}

class b extends a
{   
   public void fun()
   {System.out.println("hello b");}
}

public class neibu 
{    
    public static void main(String args[])
    {
       a aa=new b();
       aa.fun();
       
    }    
}
打印"hello b"
使用的时候，因为b类的函数fun将a类复写了

2)
  （向下转型）父类对象变为子类对象:子类 子类对象=（子类）父类对象
例如：
public class neibu 
{    
    public static void main(String args[])
    {
       a aa=new b();
       b bb=(b)aa;强制将a转为b类
       bb.fun();
    }    
}
打印"hello b"

(2)
public class neibu 
{    
    public static void main(String args[])
    {
       a aa=new a();
       b bb=(b)aa;
       bb.fun();
    }    
}
报错，因为无法知道a与b类之间的关系，因此无法强制将a转为b类

(3)
当需要调用子类自己特殊定义方法的时候，才如此转型，
例如：子类需要调用自己的getStr方法
class a
{   
   public void fun()
   {System.out.println("hello a");}
}

class b extends a
{   
   public void fun()
   {System.out.println("hello b");}
   public void getStr()
   {System.out.println("hello c");}
}

public class neibu 
{    
    public static void main(String args[])
    {
       a aa=new b();
       b bb=(b)aa;
       bb.getStr();
    }   
}

(4)判断是否可以转型
if(aa对象 instanceof b类)   返回bool

(5)因此在实际中，一般都是在父类就扩充新函数了，而不用在子类扩充，子类只需要复写即可，这样就不用向下转换了
class a
{   
   public void fun()
   {System.out.println("hello a");}
   public void getStr()
   {System.out.println("hello c");}
   public a(String name,int age)
   {
      this.name=name;
      this.age=age;   
   } 
}

class b extends a
{   
   public void fun()
   {System.out.println("hello b");} 
   super(name,age);  
   public void getStr()
   {System.out.println(super.getStr()+"hello d");}
}

public class neibu 
{    
    public static void main(String args[])
    {
       a aa=new b();
       aa.getStr();
    }   
}
打印hello chello d


13.抽象类：在实际程序开发中，一个类去继承另外一个已经实现好的类可能性不大，一般都是继承抽象类或实现接口


抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类
子类(如果不是抽象类)则必须复写抽象类之中的全部抽象方法
抽象类的对象可以使用对象的向上转型方式，通过子类来进行实例化操作
//抽象类
abstract class A
{
   private String info="hello world A";
   public void print()
   {System.out.println(info);}
   public abstract void get();//只声明，没有方法体
}

class B extends A
{
   public void get()//复写抽象类的抽象方法
   {
      System.out.println("hello world B");
   }
}

public class test
{
   public static void main(String args[])
   {
       A a=new B();//向上转型
       a.print();
       a.get(); 
    }
}

注意：
抽象类可以包含构造方法 
抽象类可以没有抽象方法，但是还是不能直接实例化


14.接口
接口是一种特殊的类，如果一个类定义时全部由抽象方法和全局常量所组成，那这个类就是
接口用interface定义

接口必须有子类，使用implements继承，一个子类能继承多个接口
子类(如果不是抽象类)则必须复写接口之中的全部抽象方法
接口的对象可以使用对象的向上转型方式，通过子类来进行实例化操作
一个接口不能继承抽象类，却可以同事继承多个接口
class 子类 [extends 父类] [implements 接口1，接口2...]{}
例如：
//接口
interface A
{
   public static final String INFO="Hello world";
   public abstract void print();
}
interface B
{
   public abstract void get();
}
abstract class C
{
   public abstract void fun();
}
//同事实现2个接口
class X extends C implements A,B
{
   public void fun(){System.out.println("hello c");};
   public void print(){System.out.println("hello a");};
   public void get(){System.out.println(INFO);};
}

public class test
{
   public static void main(String args[])
   {
       A a=new X();//向上转型
       B b=new X(); 
       C c=new X(); 
       a.print();
       b.get(); 
       c.fun();
    }
}

2）接口的两种定义方式
完全定义
interface A
{
   public static final String INFO="Hello world";
   public abstract void print();
}
简化定义
interface A
{
   String INFO="Hello world";
   void print();
}

接口的访问权限只有一种,public

3）接口继承接口
//同事继承2个接口
interface D implements A,B
{
   public abstract void printD();
}

class X implements D
{
   public void printD(){System.out.println("hello d");};
   public void print(){System.out.println("hello a");};
   public void get(){System.out.println(INFO);};
}

4）接口的作用：制定操作标准
相关例子可以参考android的控件事件处理接口,也可以看下例子
interface Fruit
{
   public void eat();
}

class Apple implements Fruit
{
   public void eat(){System.out.println("吃苹果");}
}

class Orange implements Fruit
{
   public void eat(){System.out.println("吃橘子");}
}

public class neibu 
{    
    public static void main(String args[])
    {
       Fruit eaten=new Apple();
       eaten.eat(); 
       Fruit eatb=new Orange();
       eatb.eat();
    }    
}

5）工厂设计模式Factory
但是现在以上程序有一个问题，就是接口A->子类B,这样比较直接，但是耦合太强，不
利于维护，需要修改为一个三层设计模式
//接口
interface Fruit
{
  public void eat();
}
class Apple implements Fruit
{
   public void eat()
   {System.out.println("eat Apple");}
}
class Orange implements Fruit
{
   public void eat()
   {System.out.println("eat Orange");}
}

//中间层类
class Factory
{
   public static Fruit getInstance(String className)
   {
      if("apple".equals(className))
          return new Apple();
      else if("orange".equals(className))
          return new Orange();  
      else
          return null;    
   }
}

public class test
{
   public static void main(String args[])
   {
       Fruit eats = Factory.getInstance("orange");//向上转型
       eats.eat();
    }
}

6）这个与我们android的控件事件处理接口原理一样,代理设计模式
//操作主题，就是吃东西的行为
interface Fruit
{
   public void eat();
}

//真正要吃苹果的类
class Apple implements Fruit
{
   public void eat(){System.out.println("吃苹果");}
}

//代理吃苹果，就是帮忙先处理苹果信息，然后给Apple类吃
class QieApple implements Fruit
{
   private Fruit fruit=null;
   //指定真正要操作的类
   public QieApple(Fruit fruit)
   {
      this.fruit=fruit;
   }
   //先做准备
   public void prepare()
   {
      System.out.println("削皮，切苹果");
   }
   //吃完后，帮处理的事情
   public void destroy()
   {
      System.out.println("丢苹果核");
   }
   public void eat()
   {
      prepare();
      this.fruit.eat();
      destroy();
   }
}


public class neibu 
{    
    public static void main(String args[])
    {
       //通过代理吃苹果类，操作真实吃苹果类，但是对外人看来，就是操作Apple类
       //而如果没有代理吃苹果类的帮助，真实Apple类是无法完成的
       Fruit eaten=new QieApple(new Apple());
       eaten.eat();        
    }    
}


15.匿名内部类
interface Message//定义了一个接口
{
  public void print();//抽象方法
}

class Demo
{
  //接收接口对象
  public static void get(Message msg)
  {
     msg.print();
  }
}

public class niming
{
  public static void main(String args[])
  {
     Demo.get(new Message()//匿名内部类
    {
        print()
        {
           System.out.println("hello world");
        }
    });
  }
}

16.Object类
定义了一个类，如果没有默认继承任何一个父类的话，就默认继承Object类
因此以后如果一个操作可能接受说有类的对象，那么就要用Object作为参数
复写Object类的三个方法
1)取得对象信息public String toString();
public String toString()
{return "name:"+this.name;}
2)对象比较public boolean equals(Object obj);
从前，String类的equals方法，就是复写了对象object类的equals方法。但是在Object类之中，他是比较两个对象的内存
因此per1.equals(per2)是flase,per1.equals(per1)是true
因此需要复写equals方法
Public boolean equals(Object obj)
{
   if(this==obj)
     return true;
   else if(obj==null)
     return false;
   //不是本类对象
   if(!(obj instanceof person))
     return false;
   //因为name,age属性在person类中定义，而object类没有，因此只能向下转型
   person per= (Person) obj;
   if(this.name.equals(per.name) && this.age==per.age)
      return true;
   else 
      return false;
}
3)取得哈希码public int hashCode()
4)使用Object接收所有的引用数据类型
Object类可以接收所有类的对象，包括数组，接口，类

17.包装类
将字符串变为int型
String str="11";
int res=Integer.parseInt(str);

将字符串变为double型
String str="1.1";
double res=Double.parseDouble(str);

将int型变为字符串
int num=100;
String str=num+"";
或者
String str=String.valueOf(num);


*数组
1.声明并实例化数组对象
1）数据类型 名称[] = new 数据类型[长度];
2)
数据名称 名称[] = null;
名称 = new 数据类型[长度];

public class Hello
{    
    public static void main(String args[])
    {
       int data[] = new int[3];	
       int i;
       person per = new person(13);//声明并实例化对象 
       per.tell();
       for(i=0;i<data.length;i++)
   	   System.out.println(i);
    }
}
3)直接初始化
int data[] = new int[]{0,1,2};

4)作为方法的参数传递，数组的传递是传地址
public class Hello
{    
    public static void main(String args[])
    {
       int data[] = new int[]{1,2,3};	
       //int i;
       //person per = new person(13);//声明并实例化对象 
       //per.tell();  
       prt(data);     
    }
    public static void prt(int data[])
    {
	int i;
        for(i=0;i<data.length;i++)
            System.out.println(i);
    }
}

5)返回值是数组
public static int[] stat(int temp[])
{
   int result[] = new int [4];
   result[0] = temp[0];
   result[1] = temp[1];
   result[2] = temp[2];
   result[3] = temp[3];
   return result;
}

6)与数组有关的操作方法
(1)数组排列
int data[] = new data[]{1,2,3,4};
java.util.Array.sort(data);//排序	
（2）数组拷贝：从一个数组中拷贝部分内容到另一个数组中
例如：
    A：1，2,3,4,5,6
    B：11,12,13,14,15,16
最终数组A变为1,2,13,14,15,6
System.arraycopy(B[从数组B],2[的第二个位置],A[拷贝到数组A],2[的第二个位置],3[拷贝3个字]);

2.二维数组
1）初始化
数据类型 名称[][] = new 数据类型[行数][列数];
数据类型 名称[][] = new 数据类型[][]{{x,x}，{x,x}，{x,x}};

3.对象数组
类 对象名称[] = new 类[长度];
例如：
Person per = new Person[3];
per[0] = new Person("zhang3",10);
per[1] = new Person("li4",11);
per[0] = new Person("w5",12);


类 对象名称[] = new 类[实例化对象，实例化对象];
Person per = new Person[]{new Person("zhang3",10),new Person("li4",11),new Person("w5",12)};

*String:是一个类
实例化：
String str1 = "Hello";
String str2 = new String("Hello");
字符串比较是否相等str1.equals(str2);//判断两个字符串是否相等

*异常处理
1.
public class except
{
   public static void main(String args[])
   {
       try
       { 
           int result=10/0;
           System.out.println("result="+result); 
        }
        catch(Exception e)
        {
           //提示异常信息
           e.printStackTrace();
        }  
        finally
        {
           //不管出没出来异常，都执行
           //对于finally的实际应用必须结合之后的异常处理格式来看
           System.out.println("result over"); 
        } 
        System.out.println("end result");
   }
}

2.throws抛出异常：表示此方法中不进行异常处理，而交给被调用处处理
1）
class mymath
{
   //表示所有的异常都抛回给被调用处处理
   public int div(int x,int y) throws Exception
   {
      return x/y;
   }
}
public class except
{
   public static void main(String args[])
   {       
      try
      {
         System.out.println("result="+new mymath().div(Integer.parseInt(args[0]),Integer.parseInt(args[1])));          
      }
      catch(Exception e)
      {
           //提示异常信息
           e.printStackTrace();
      }  
   }
} 

2）主方法还可以继续进行异常抛出
public static void main(String args[]) throws Exception
{       
      System.out.println("result="+new mymath().div(Integer.parseInt(args[0]),Integer.parseInt(args[1])));
}

3.throw：用户手工抛出实例化对象,即自己做异常信息
try
{
     System.out.println("result="+new mymath().div(Integer.parseInt(args[0]),Integer.parseInt(args[1])));  
     throw new Exception("抛着玩");        
}
catch(Exception e)
{
      //提示异常信息
      e.printStackTrace();
} 

4.异常处理的标准格式:finally,throw绝不是没有用处的，推荐使用这样的格式处理
try,catch,finnaly,throws,throw一起使用
1)
class mymath
{
   //表示所有的异常都抛回给被调用处处理
   public int div(int x,int y) throws Exception
   {
      System.out.println("计算开始");//资源打开	
      try
      {
          return x/y;
      }
      catch(Exception e)
      {
          throw e;//自己向上抛出异常，不自己处理异常  
      }
      finally//出现异常或没有出现异常，都一点要关闭资源
      {
      	   System.out.println("计算结束");//资源关闭
       }
   }
}
public class except
{
   public static void main(String args[])
   {       
      try
      {
         //处理收到的异常
         System.out.println("result="+new mymath().div(Integer.parseInt(args[0]),Integer.parseInt(args[1])));  
         //throw new Exception("抛着玩");        
      }
      catch(Exception e)
      {
           //提示异常信息
           e.printStackTrace();
      }  
   }
} 
 
*包
1.包：将多人开发的不同功能的文件进行分割，包其实就是不同的文件夹
1)
package cn.csdn.demo
class message
{}
public class hello
{
   public static void main(String args[])
   {      
      
      System.out.println("hello java");
   }
} 
那类名称是package cn.csdn.demo.hello,而在程序编译时，也需要将*.class文件保存到
包之中，为了方便，也就提供了一个打包的编译操作
javac -d . hello.java

其中
-d表示：依据package定义，生成文件目录
. 表示: 在当前目录下生成

执行：java cn.csdn.demo.hello
在实际程序中，没有包的程序是不存在的    

2).包的导入：import
package cn.csdn.util;
class message
{
   public String getinfo()
   { 
       return "message";
   }
}


package cn.csdn.test;
import cn.csdn.util.*;
public class test
{
   public static void main(String args[])
   {
      message msg=new message();
      System.out.println("name="+msg.getinfo());
   }
}

javac -d . message.java
javac -d . test.java

出错，因为：
public class:文件名和类名要保持一致，在一个文件中只能存在一个public class定义，
             并且可以被别的包访问
class:文件名和类名可以不一致，文件中可以有多个类名，并且类只能在这个包里面访问

所以要改为
package cn.csdn.util;
public class message
{
   public String getinfo()
   { 
       return "message";
   }
}

3).以上程序在编译时需要区别包编译的顺序，很麻烦
自动连编的执行操作：将本目录下的所有*.java文件自动编译
javac -d . *.java

4).如果其他的包里面有相同的类名
package cn.csdn.info;
public class message
{
   public String getstr()
   { 
       return "messagestr";
   }
}
这个时候，要使用message类，必须使用类的全名
import cn.csdn.util.*;
import cn.csdn.info.*;
cn.csdn.util.message msg=new cn.csdn.util.message();


*访问控制权限
              private    default   protected   public
同一包同一类    true       true      true       true
同一包不同类    false      true      true       true
不同包的子类    false      false     true       true
不同包的非子类  false      false     false      true  
现在一般只是private用作属性，public用作方法，其他两种已经淘汰


//*********
//高级模式
//*********
*可变参数：想方法中传递参数个数可变的参数
public static main(String args[])
{
fun("AA","BBB","CC");
或者
Object arg[]={"AA","BBB","CC"};
fun(arg)
}

//输入任意多个数据，使用数组表示
public static void fun(Object...args)
{
  for(int i=0;i<args.length;i+)
  {...}
}
*多线程
多进程是程序资源只有一块，在同一时间段有几个程序共同运行，但是在同一
时间点，只有一个程序在运行。
1.实现多线程方法通过Runnable接口
1）各个线程有自己的资源
package cn.csdn.thread;
//线程主体类
class mythread implements Runnable
{
  private int ticket=50; 
  
  //线程主方法
  public void run()
  {
    for(int x=0;x<50;x++)
    {
       if(ticket>0)
         System.out.println(Thread.currentThread().getName()+"  run="+(ticket--));
    }
  }
}



public class thread
{
   public static void main(String[] args)
   {
      //实例化三个线程接口类
      mythread mt1=new mythread();
      mythread mt2=new mythread();
      mythread mt3=new mythread();
      //启动三个线程
      new Thread(mt1).start();
      new Thread(mt2).start();
      new Thread(mt3).start();      
   }
}

2)个线程共享一个资源
使用匿名内部类操作
public class thread
{
   public static void main(String[] args)
   {
      //实例化三个线程接口类
      mythread mt=new mythread();
      //启动三个线程
      new Thread(mt,"线程1").start();//同时赋予线程名字
      new Thread(mt,"线程2").start();
      new Thread(mt,"线程3").start();      
   }
}
使用普通方法操作
public static void main(String[] args)
{
      //实例化三个线程接口类
      mythread mt=new mythread();
      //启动三个线程
      Thread t1= new Thread(mt,"线程1");
      Thread t2= new Thread(mt,"线程2");
      Thread t3= new Thread(mt,"线程3"); 
      t1.start(); 
      t2.start();
      t3.start();    
}

2）
线程操作方法：
得到线程名称Thread.currentThread().getName();
线程休眠Thread.sleep(毫秒)

3）线程优先级
设置优先级：Thread.setPriority(优先级);
一共有10，而且有三个常量来定义Thread.MAX_PRIORITY（即10）,Thread.NORM_PRIORITY
（即5),Thread.MIN_PRIORITY（即1）
取得优先级：Thread.getPriority(); 取得主线程优先级Thread.currentThread().getPriority()

public static void main(String[] args)
{
      //实例化三个线程接口类
      mythread mt=new mythread();
      //启动三个线程
      Thread t1= new Thread(mt,"线程1");
      Thread t2= new Thread(mt,"线程2");
      Thread t3= new Thread(mt,"线程3"); 
      t3.setPriority(10);
      t2.setPriority(7);
      t1.setPriority(1);
      t1.start(); 
      t2.start();
      t3.start();    
}

2.线程同步与死锁:同步进行过多有可能会出现死锁问题
1)
//线程主体类
class mythread implements Runnable
{
  private int ticket=50; 
  
  //线程主方法
  public void run()
  {
    for(int x=0;x<50;x++)
    {
       if(ticket>0)
         System.out.println(Thread.currentThread().getName()+"  run="+(ticket--));
    }
  }
}

public class thread
{
   public static void main(String[] args)
   {
      //实例化三个线程接口类
      mythread mt=new mythread();
      //启动三个线程
      new Thread(mt,"线程1").start();//同时赋予线程名字
      new Thread(mt,"线程2").start();
      new Thread(mt,"线程3").start(); 
      new Thread(mt,"线程4").start();
      new Thread(mt,"线程5").start();      
   }
}
这时，虽然有作if(ticket>0)判断，但还是会出现负数的。这是因为多个线程同时读
这个判断时，此时是大于0的。但是一起操作之后，就出现负数了。
因此，需要加锁
(1)同步代码块
//线程主体类
class mythread implements Runnable
{
  private int ticket=5; 
  
  //线程主方法
  public void run()
  {
    for(int x=0;x<5;x++)
    {
       synchronized(this)
       {
         if(ticket>0)
         {           
           //Thread.sleep(1000); 
           System.out.println(Thread.currentThread().getName()+"  run="+(ticket--));
          }
        }
    }
  }
}

(2)同步方法
//线程主体类
class mythread implements Runnable
{
  private int ticket=5; 
  
  //线程主方法
  public void run()
  {
    for(int x=0;x<5;x++)
    {
       this.sale();
    }
  }

  //同步方法
  public synchronized void sale()
  {
     if(ticket>0)
     {           
        //Thread.sleep(1000); 
        System.out.println(Thread.currentThread().getName()+"  run="+(ticket--));
      }
  }
}


*泛型
1.泛型的基础定义
1)泛型的定义
例如以下例子：
class point
{
  private Object x;
  private Object y;
  public void setx(Object x)
  {
    this.x=x;
  }
  public void sety(Object y)
  {
    this.y=y;
  }
  public Object getx()
  {
    return this.x;
  }
  public Object gety()
  {
    return this.y;
  }
}

public class fang
{
  public static void main(String args[])
  {
    point p=new point();
    p.setx(10);//利用自动装箱操作int->Integer->Object
    p.sety("东经10.2"); 
    int x=(Integer)p.getx();//取出数据变为Integer,自动拆箱
    String y=(String)p.gety();
    System.out.println("x="+x+" y="+y);
  }
}

但是有一个问题，
public static void main(String args[])
{
    point p=new point();
    p.setx(10);//利用自动装箱操作int->Integer->Object
    p.sety("东经10.2"); 
    int x=(Integer)p.getx();//取出数据变为Integer,自动拆箱
    int y=(Integer)p.gety();
    System.out.println("x="+x+" y="+y);
}
编译通过，但是运行就会报错，导致程序不安全。因此，针对有可能输入的不同
的类型，就需要先编写不同的程序来对应了

这时，就需要泛型定义，然后具体类型就由外部指定，来代替自定义的类型。
class point<T>//T是自己定义的标识符号
{
  private T x; //x的类型由T指定，即由外部指定
  private T y;
  public point(T x,T y)//通过构造方法设置
  {
     ...
  }
  public void setx(T x)
  {
    this.x=x;
  }
  public void sety(T y)
  {
    this.y=y;
  }
  public T getx()
  {
    return this.x;
  }
  public T gety()
  {
    return this.y;
  }
}

public class fang
{
  public static void main(String args[])
  {
    point<Integer> p=new point<Integer>(); //由外部指定类的类型为Integer类型
    p.setx(10);//利用自动装箱操作int->Integer
    p.sety(12); 
    int x=p.getx();//,自动拆箱
    int y=p.gety();
    System.out.println("x="+x+" y="+y);
  }
}
减少了类型强制转换的操作代码，而且如果内容有错误，在编译时就会报错，不会在运行
时出错，程序较安全
例如：
public class fang
{
  public static void main(String args[])
  {
    point<Integer> p=new point<Integer>(); //由外部指定类的类型为Integer类型
    p.setx(10);//利用自动装箱操作int->Integer
    p.sety("东经10.2"); 
    int x=p.getx();//,自动拆箱
    int y=p.gety();
    System.out.println("x="+x+" y="+y);
  }
}
直接编译就过不去。


2）.同时指定多个泛型
class point<T,K>
{
  private T x;
  private T y;
  private K value;
  public void setx(T x)
  {
    this.x=x;
  }
  public void sety(T y)
  {
    this.y=y;
  }
  public T getx()
  {
    return this.x;
  }
  public T gety()
  {
    return this.y;
  }
  public void setvalue(K value)
  {
    this.value = value;
  }
  public K getvalue()
  {
    return this.value;
  }
}

public class fang
{
public static void main(String args[])
{
    point<Integer,String> p=new point<Integer,String>();
    p.setx(10);//利用自动装箱操作int->Integer->Object
    p.sety(32); 
    int x=p.getx();//取出数据变为Integer,自动拆箱
    int y=p.gety();
    p.setvalue("Hello earth");
    System.out.println(p.getvalue()+",x="+x+" y="+y);    
}
}


3)泛型的安全警告
最好在定义中就设置泛型类型point<Integer,String> p=new point<Integer,String>();，
但也可以不制定类型，如point p=new point();
但是编译时会出现警告，但是可以工作，实际上所有的泛型信息将被擦除，然后系统自动
用Object类型代替。

实际编写中不要这样作


3.通配符
1)
泛型对象进行引用传递时，类型必须一致。
例如：
class point<T,K>
{
  private T x;
  private T y;
  private K value;
  public void setx(T x)
  {
    this.x=x;
  }
  public void sety(T y)
  {
    this.y=y;
  }
  public T getx()
  {
    return this.x;
  }
  public T gety()
  {
    return this.y;
  }
  public void setvalue(K value)
  {
    this.value = value;
  }
  public K getvalue()
  {
    return this.value;
  }
}

public class fang
{
   public static void main(String args[])
   {
       //使用Integer,String作为泛型类型
       point<Integer,String> p=new point<Integer,String>();
       p.setx(10);//利用自动装箱操作int->Integer
       p.sety(32); 
       int x=p.getx();//自动拆箱
       int y=p.gety();
       p.setvalue("Hello earth");  
       fun(p);        
   }
   public static void fun(point<Object,Object> temp)
   {
       System.out.println(temp.getvalue()+",x="+temp.getx()+" y="+temp.gety()); 
   }
}
由于类型point<Integer,String>，与point<Object,Object不一致，无法转换


2)如果类型不一致，需要用<?>来表示
public static void fun(point<?,?> temp)
{
   System.out.println(temp.getvalue()+",x="+temp.getx()+" y="+temp.gety()); 
}

但是，他只适合用来作输出使用，不能进行修改，例如
point<?,?> p=new point<Integer,String>();
p.setx(10);
会报错

4.受限制的泛型
1)设置上限:类型可以是所制定的类型，或是他的子类
<? extends 类>
范围上限设置为Number,所以只能接受数字类型
public static void fun(point<? extends Number,?> temp)

2）设置下限：类型可以是所制定的类型，或是他的父类，直至Object类型
<? super 对象>
范围下限设置为Stringr,所以只能接受String类型，或Object类型
public static void fun(point<? super String,?> temp)

5.泛型与子类继承的限制：他与类不一样，只能完全一致才能实例化，不能用子类实例化，
例如 point<Integer,String> p=new point<Integer,String>();

4.定义泛型接口
//定义泛型接口
interface info<T>
{
  public T getvar();
}

//方式一实现泛型接口
class point<T> implements info<T>//T是自己定义的标识符号
{
  private T x; //x的类型由T指定，即由外部指定
  private T y;
   
  public void setx(T x)
  {
    this.x=x;
  }
  public void sety(T y)
  {
    this.y=y;
  }
  public T getx()
  {
    return this.x;
  }
  public T gety()
  {
    return this.y;
  }
  //实现接口函数
  public T getvar()
  {
     return this.x;
  }
}

//方式二实现泛型接口
class point2<T> implements info<String>//T是自己定义的标识符号
{
  private T x; //x的类型由T指定，即由外部指定
  private T y;
   
  public void setx(T x)
  {
    this.x=x;
  }
  public void sety(T y)
  {
    this.y=y;
  }
  public T getx()
  {
    return this.x;
  }
  public T gety()
  {
    return this.y;
  }
  //实现接口函数
  public String getvar()
  {
     return "Hello"+this.x;
  }
}

public class fang
{
  public static void main(String args[])
  {
    point2<Integer> p=new point2<Integer>(); //里面设为Integer类型
    p.setx(10);//利用自动装箱操作int->Integer
    p.sety(12);   
    int x=p.getx();//自动拆箱
    int y=p.gety();
    fun(p);    
  }
  public static void fun(point2<?> p)
  {        
    System.out.println("x="+p.getx()+" y="+p.gety()+" res="+p.getvar());
  }
}

5.泛型方法
1）
class Demo
{
  //定义泛型方法
  public <T> T fun(T t)
  {
    return t;
  }
}

Demo d=new Demo();
String str=d.fun("Hello");  传字符串
int i=d.fun(12);传数字

2)通过泛型方法返回泛型类的实例
class Info<T extends Number>//制定上限只能是数字类型
{
  private T var;
  public void setvar(T var)
  {
    this.var=var;
  } 
  public T getvar()
  {
    return this.var;
  }
}

public class fang
{
   public static void main(String args[])
   {       
       Info<Integer> i= fun2(30);
       System.out.println("i="+i.getvar());      
   }
   //其中<T extends Number>表示泛型，Info<T>是返回值
   public static <T extends Number> Info<T> fun2(T param)
   {
       Info<T> temp=new Info<T>();//根据传入的数据类型实例化Info
       temp.setvar(param);
       return temp;   
   }
}


3)使用泛型统一传入参数的类型 
public class fang
{
   public static void main(String args[])
   {       
       Info<Integer> i1=new Info<Integer>();  
       Info<Integer> i2=new Info<Integer>();
       i1.setvar(13);
       i2.setvar(22); 
       add(i1,i2);  
   }
   //其中<T >表示泛型，void是无返回值
   public static <T> void add(Info<T> i1, Info<T> i2)
   {
       System.out.println("add="+i1.getvar()+i2.getvar());  
   }
}

6.泛型数组
使用泛型方法，也可以传递或返回一个泛型数组
public static main(String args[])
{
  Integer i[]=fun(1,2,3);
  fun2(i);
}

public static <T> T[] fun(T...arg)//接受可变参数
{
  return arg;//返回泛型数组
}
//输出泛型数组
public static <T> void fun2(T param[])
{
  for(T t:param)
  {System.out.println(t);}
}


7.泛型的嵌套设置
class point<T,K>
{
  private T x;
  private T y;
  private K value;
  public void setx(T x)
  {
    this.x=x;
  }
  public void sety(T y)
  {
    this.y=y;
  }
  public T getx()
  {
    return this.x;
  }
  public T gety()
  {
    return this.y;
  }
  public void setvalue(K value)
  {
    this.value = value;
  }
  public K getvalue()
  {
    return this.value;
  }
}

class Info<T>
{
  private T var;
  public void setvar(T var)
  {
    this.var=var;
  } 
  public T getvar()
  {
    return this.var;
  }
}

public static void main(String args[])
{
      //将point作为Info的泛型类型
      Info<point<Integer,String>> d = null;
      point<Integer,String> p =null;//point制定两个泛型类型
      //实例化point对象
      p=new point<Integer,String>();
      p.setx(10);
      p.sety(32); 
      p.setvalue("Hello earth"); 
      //在Info类中设置point类的对象 
      d = new Info<point<Integer,String>>();
      d.setvar(p);
      System.out.println("x="+d.getvar().getx()+" y="+d.getvar().gety()
      +" res="+d.getvar().getvalue());   
}

*常用类库
1.StringBuffer字符串数组
在频繁的修改字符串内容时，他的性能比String要高
1)字符串连接操作
public class Stringbuffer
{
   public static void main(String args[])
   {
      StringBuffer buf=new StringBuffer();
      buf.append("Hello ");
      buf.append("World").append("!!!");//添加字符串
      buf.append("\n");
      buf.append("数字=").append(1).append("\n");//添加数字
      buf.append("字符=").append('c').append("\n");//添加字符
      buf.append("布尔=").append(true);//添加布尔值
      System.out.println(buf);
   }
}

2）通过引用传递的方式修改内容
public class Stringbuffer
{
   public static void main(String args[])
   {
      StringBuffer buf=new StringBuffer();
      buf.append("Hello ");
      buf.append("World").append("!!!");//添加字符串
      buf.append("\n");
      buf.append("数字=").append(1).append("\n");//添加数字
      buf.append("字符=").append('c').append("\n");//添加字符
      buf.append("布尔=").append(true).append("\n");;//添加布尔值
      //System.out.println("Hello");
      fun(buf);
      System.out.println(buf);
   }
   public static void fun(StringBuffer buf)
   {
      buf.append("msdn\n");
   }
}

2.Runtime类：每启动一个java程序，就启动了一个JVM进程，每一个进程都对应了一个Runtime实例
Runtime run= Runtime.getRuntime();//得到JVM进程
System.out.println(run.maxMemory());//得到最大内存量

2)通过Runtime类运行本机的可执行程序
   public static void main(String args[])
   {
      Runtime run= Runtime.getRuntime();//得到JVM进程
      Process p=nulll;//定义进程变量
      try
      {
         p=run.exec("notepad.exe");//调用本机笔记本程序
      } 
      catch(Exception e)
      {
         e.printStackTrace();
      }
      try
      {
         Thread.sleep(5000);//让此线程存活5秒
       } 
      catch(Exception e)
      {
         e.printStackTrace();
      }
      p.destroy();//结束此进程,即关闭笔记本
   }   

3.国际化程序：即一个程序可以自动按系统专为各个国家语言
程序根据不同的语音环境找到不同的资源文件，之后从里面提取内容，资源文件里的内容
都是key->value形式保存的，所以在读取时通过key找到value即可

Locale类：表示本地。每个国家多有一个唯一的ISO编码，使用这个类就可以得到编码
ResourceBundle:根据Locale指定的区域来选择需要的资源文件。此类是专门完成属性
文件读取的，读取时直接制定文件名称即可
1)新建资源文件Message.properties
info=HELLO  其中，info是key,HELLO是value
例如
import java.util.*;
public class classdemo
{
  public static void main(String args[])
  {
      //找到资源文件
      ResourceBundle rb= ResourceBundle.getBundle("Message");
      //从资源文件中取得内容，key是info
      System.out.println("well="+rb.getString("info"));      
  }
}

2)国际化程序
(1)定义三个资源文件，同事制定好此资源文件对应的语音编码
中文 Message_zh_CN.properties
英文 Message_en_US.properties
法文 Message_fr_FR.properties
(2)根据Locale所指区域的ISO的不同，得到不同的资源文件的内容
import java.util.*;
public class classdemo
{
  public static void main(String args[])
  {
      Locale zhloc=new Locale("zh","CN");//表示中国
      Locale enloc=new Locale("en","US");//表示英国
      Locale frloc=new Locale("fr","FR");//表示法国 
      //找到中文资源文件，需要制定中国的Locale对象
      ResourceBundle zhrb= ResourceBundle.getBundle("Message",zhloc);
      ResourceBundle enrb= ResourceBundle.getBundle("Message",enloc);
      ResourceBundle frrb= ResourceBundle.getBundle("Message",frloc);
      //从资源文件中取得内容，key是info
      System.out.println("cn="+zhrb.getString("info")+" en="+
enrb.getString("info")+" fr="+frrb.getString("info"));      
  }
}

4.大数操作:
使用BigInteger操作大数
使用BigDecimal制定小数的保留位数：完成大的小数操作
正常数只能放在long型中，如果再大的数，就放在大数里面

5.对象克隆技术：对象的复制
//实现Clone接口，表示可以被克隆
class person implements Cloneable
{
   private String name;
   public person(String name)
   {
     this.name=name;
   }
   public void setName(String name)
   {
     this.name=name;
   }
   public String getName()
   {
     return this.name;
   }
   //复写clone方法
   public Object clone() throws CloneNotSupportedException
   {
      return super.clone();//具体克隆由父类完成
   }
}

public class classdemo
{
   public static void main(String args[]) throws Exception
   {
      person p1=new person("zhang3");
      person p2=(person)p1.clone();
      p2.setName("li4");
      System.out.println("old="+p1.getName()+" new="+p2.getName()); 
   }
}

6.比较器：对对象进行排序:import java.util.*;
1)Arrays类：数组操作类，进行数组查找，填充，排序等
int temp[] = {3,4,5,7,9,1,2,6,8} ;	// 声明一个整型数组
Arrays.sort(temp) ;		// 进行排序的操作
2）Comparable接口
public interface Comparable<T>
{
  public int compareTo(T t);
}
他的compareTo方法的返回值有三个
1表示大于
-1表示小于
0表示相等

例如：
//类继承泛型接口，数据类型使用实例化的student类
class student implements Comparable<student>
{
   private String name;
   private int age;
   private float score;
   public student(String name,int age,float score)
   {
     this.name=name;
     this.age=age;
     this.score=score;
   }
   public void setName(String name)
   {
     this.name=name;
   }
   public String getName()
   {
     return this.name;
   }
   public String toString()
   {
     return this.name+" "+this.age+" "+this.score;
   }
   //复写compareTo方法,实现排序
   public int compareTo(student stu)
   {
      if(this.score>stu.score)
         return -1;
      else if(this.score<stu.score)
         return 1;
      else
      {
         if(this.age>stu.age)
           return 1;
         else if(this.age<stu.age)
           return -1;
         else 
           return 0;  
      }   
   }
}

public class classdemo
{
   public static void main(String args[]) throws Exception
   {
      //使用匿名类初始化 
      student stu[]={new student("z3",20,90.0f),new student("l4",22,90.0f),
new student("w5",20,99.0f),new student("z6",20,70.0f),
new student("q7",22,100.0f),};
      java.util.Arrays.sort(stu);//进行排序操作
      for(int i=0;i<stu.length;i++)
      {
         System.out.println(stu[i]);
      } 
   }
}

3) Comparator接口：如果在类建立的初期没有实现Comparable接口，要在以后再对类进行
排序，就需要使用Comparator接口
public interface Comparator<T>
{
  public int compare(T t1,T t2);
  boolean equals(Object obj);
}

例如：
import java.util.*;
//普通student类，没有排序功能
class student
{
   private String name;
   private int age;
   private float score;
   public student(String name,int age,float score)
   {
     this.name=name;
     this.age=age;
     this.score=score;
   }
   public void setName(String name)
   {
     this.name=name;
   }
   public String getName()
   {
     return this.name;
   }
   public float getscore()
   {
     return this.score;
   }
   public float getage()
   {
     return this.age;
   }
   public String toString()
   {
     return this.name+" "+this.age+" "+this.score;
   }
   public boolean equals(Object obj)
   {
      if(this==obj)
         return true;
      else if(!(obj instanceof student))
         return false;
      student stu= (student) obj;
      if(stu.name.equals(this.name))
         return true;
      else
         return false;  
   }
}

//做一个类，实现排序接口
class stucompare implements Comparator<student>
{
  public int compare(student stu1,student stu2)
  {
      if(stu1.getscore()>stu2.getscore())
         return -1;
      else if(stu1.getscore()<stu2.getscore())
         return 1;
      else
      {
         if(stu1.getage()>stu2.getage())
           return 1;
         else if(stu1.getage()<stu2.getage())
           return -1;
         else 
           return 0;  
      }   
   }
  //因为object类已经有了equals方法，因此不用再复写
}

public class classdemo
{
   public static void main(String args[]) throws Exception
   {
      //使用匿名类初始化 
      student stu[]={new student("z3",20,90.0f),new student("l4",22,90.0f),
new student("w5",20,99.0f),new student("z6",20,70.0f),
new student("q7",22,100.0f),};
      //制定好排序的比较器，进行排序操作
      java.util.Arrays.sort(stu,new stucompare());
      for(int i=0;i<stu.length;i++)
      {
         System.out.println(stu[i]);
      } 
   }
}

7.观察者设计模式
import java.util.*;
class house extends Observable//继承这个类表示房子可以被观察
{
   private float price;//价钱
   public house(float price)
   {this.price=price;}
   public float getprice()
   {
     return this.price;
   }
   //每一次修改时都应该引起观察者的注意
   public void setprice(float price)
   {
      super.setChanged();//设置好变化点
      super.notifyObservers(price);//价格被改变
      this.price = price;
   }
   public String toString()
   {
      return "房子="+this.price;
   }
}

//观察者类继承接口
class houseobserver implements Observer
{
   private String name;//观察者名字
   //设置每一个观察者名字
   public houseobserver(String name)
   {
     this.name=name;
   }
  
   public void update(Observable o,Object arg)
   {
      System.out.println("1."+o);//打印o对象的toString字符串
      System.out.println("2."+arg);//新的单价
      System.out.println(this.name+"观察到新价格:"+((Float)arg).floatValue());
   }
}

public class observer
{
   public static void main(String args[])
   {
      house h=new house(200);//新建房子
      houseobserver buy1=new houseobserver("张三1");//新建购房者
      houseobserver buy2=new houseobserver("张三2");//新建购房者
      houseobserver buy3=new houseobserver("张三3");//新建购房者  
      //允许者三个人观察
      h.addObserver(buy1);
      h.addObserver(buy2);
      h.addObserver(buy3);
      System.out.println(h);//输出房子价格
      h.setprice(330);//修噶房子价格
      System.out.println(h);//输出房子价格
   }
}

输出
房子=200.0
1.房子=200.0
2.330.0
张三3观察到新价格:330.0
1.房子=200.0
2.330.0
张三2观察到新价格:330.0
1.房子=200.0
2.330.0
张三1观察到新价格:330.0
房子=330.0


8.正则表达式
1）
例子：
import java.util.regex.Pattern;
public class observer
{
   public static void main(String args[])
   {
      String str="123456789";
      //正则匹配规则 
      if(Pattern.compile("[0-9]+").matcher(str).matches())
      {
         System.out.println("由数字组成");
      } 
      else
      {
         System.out.println("不是由数字组成");
      }
   }
}

或则拆分写
String str="1982-7-21";
String pat="\\d{4}-\\d{2}-\\d{2}"定义正则规范
Pattern p=Pattern.compile(pat);//实例化Pattern类
Matcher m=p.matcher(str);//实例化验证类
if(m.matches())//如果验证通过


2）String类对正则的支持
String str1 = "A1B22C333D4444E55555F".replaceAll("\\d+","_") ;
boolean temp = "1983-07-27".matches("\\d{4}-\\d{2}-\\d{2}") ;
String s[] = "A1B22C333D4444E55555F".split("\\d+") ;
System.out.println("字符串替换操作：" + str1) ;
System.out.println("字符串验证：" + temp) ;
System.out.print("字符串的拆分：") ;
for(int x=0;x<s.length;x++){
	System.out.print(s[x] + "\t") ;

3)对特殊符号的拆分，例如"|"
String s[] = info.split("\\|") ;


9.定时调度：在主程序运行时，又启动了一个线程，这个线程每隔一段时间，定时运行一次
schedule()方法，每隔固定时间运行一次,如果上一次出现延时，下一次不延时
scheduleAtFixedRate()如果上一次出现延时，下一次自动也延时

例子：
import java.util.TimerTask;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Timer;
class timetask extends TimerTask//任务调度类
{
  public void run()
  {
    SimpleDateFormat sdf=null;//打印时间的格式
    sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
    System.out.println("时间："+sdf.format(new Date()));
  }
}
public class observer
{
   public static void main(String args[])
   {
      Timer t=new Timer();//建立Timer类对象
      timetask task=new timetask();//定义任务
      t.schedule(task,1000,2000);//1秒后，开始每隔2s执行一次任务
   }
}

2)实现计时与倒计时
public class timerTask extends Activity{ 
  
    private int recLen = 11; 
    private TextView txtView; 
    Timer timer = new Timer(); 
  
    public void onCreate(Bundle savedInstanceState){ 
        super.onCreate(savedInstanceState); 
           
        setContentView(R.layout.timertask); 
        txtView = (TextView)findViewById(R.id.txttime); 
           
        timer.schedule(task, 1000, 1000);       // timeTask 
    }    
  
    TimerTask task = new TimerTask() { 
        @Override 
        public void run() { 
  
            runOnUiThread(new Runnable() {      // UI thread 
                @Override 
                public void run() { 
                    recLen--; 
                    txtView.setText(""+recLen); 
                    if(recLen < 0){ 
                        timer.cancel(); 
                        txtView.setVisibility(View.GONE); 
                    } 
                } 
            }); 
        } 
    }; 
}


10.时间函数
1)获取当前时间
Date now = new Date();
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");//可以方便地修改日期格式
String hehe = dateFormat.format( now ); 

2)java设定一个日期时间，加几分钟（小时或者天）后得到新的日期
     public static String addDateMinut(String day, int x)//返回的是字符串型的时间，输入的
    //是String day, int x
     {   
            SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");// 24小时制  
    //引号里面个格式也可以是 HH:mm:ss或者HH:mm等等，很随意的，不过在主函数调用时，要和输入的变
    //量day格式一致
            Date date = null;   
            try {   
                date = format.parse(day);   
            } catch (Exception ex) {   
                ex.printStackTrace();   
            }   
            if (date == null)   
                return "";   
            System.out.println("front:" + format.format(date)); //显示输入的日期  
            Calendar cal = Calendar.getInstance();   
            cal.setTime(date);   
            cal.add(Calendar.MINUTE, x);// 24小时制   
            date = cal.getTime();   
            System.out.println("after:" + format.format(date));  //显示更新后的日期 
            cal = null;   
            return format.format(date);   
      
        }  

在主函数中进行调用，简单举例
public static void main(String[] args) throws ParseException
{
System.out.println(addDateMinut("2013-08-29 08:16:36",1));

}



10.回调以及事件注册机制
软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调和异步调用。
同步调用：一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；
回 调：一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；
异步调用：一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。

1)回调
有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2
但是有一个问题，小李类与老王类都是同一个线程，因此小李不能做太耗时的操作，小李要创建一个独立线程来做耗时操作
第一步
package com.example.huidiao;
/** 
 * 此接口为联系的方式，不论是电话号码还是联系地址，作为 
 * 老板老王都必须要实现此接口 
 * @author Administrator 
 * 
 */  
public interface CallBackInterface {
	public void execute(int value);  
}

第二步，底层小李的员工类
/** 
 * 员工类小李，必须要记住，这是一个底层类，底层是不了解上层服务的 
 * @author Administrator 
 * 
 */  
public class Employee {
	private CallBackInterface callBack=null;
	//老板老王告诉小李联系电话，也就是注册
	public void setCallBack(CallBackInterface callBack){  
        this.callBack = callBack;  
    }  
	//老板提出1+2等于几的问题，调用这个方法，让小李计算
	public void doSome(int k,int j) throws InterruptedException
	{  
		int value;	
        //1.开始干活了  
        for(int i=0;i<100;i++){  
            Log.i("EV_JNI","第【" + i + "】事情干完了！"); 
            //Thread.sleep(1000);小李类与老王类都是同一个线程，因此小李不能做太耗时的操作，小李要创建一个独立线程来做耗时操作
        }  
        value=k+j;
          
        //2.告诉老板老板老王干完了  
        callBack.execute(value);  
    }  
}

第三步，老板老王类
/** 
 * 老板老王是作为上层应用身份出现的，下层应用（员工）小李是不知道 
 * 有哪些方法，因此他想被下层应用（员工）调用必须实现此接口 
 * @author Administrator 
 * 
 */  
public class Boss implements CallBackInterface {  
	  
	@Override  
	public void execute(int value) {  
		//System.out.println("收到了！！" + System.currentTimeMillis());  
		txt.setText("value="+value);  
	}  
}  

第四步，使用
btn.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				Employee emp = new Employee();  
				//将回调对象老板（上层对象）传入，注册  
		        emp.setCallBack(new Boss());  
		        //老板问小李1+2等于多少
		        try {
					emp.doSome(1,2);					
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}  
			}
		});

		
		
2)实际使用回调
有主UI很忙，他没有时间盯着出货机构干活，然后他告诉底层货道，当干完出货这些事情后，告诉他出货的结果。
需要使用到回调机制
第一步、底层出货机构的类
    public class Caller {  
        private MyCallInterface callInterface;  
          
        public Caller() {  
        }  
          
        public void setCallFunc(MyCallInterface callInterface) {  
            this.callInterface = callInterface;  
        }  
          
        public void call() {  
            callInterface.printName();  
        }  
    }  
	
第二步、出货机构与上层UI的接口
    public interface MyCallInterface {  
        public void  printName(String json);  
    }  
	
第三步、上层UI类
    public class Test {  
        public static void main(String[] args) {  
            Caller caller = new Caller();  //实例化底层出货机构的类
//注册监听事件，实际是把Client类都当成一个参数handler,传handler给底层call类			
            caller.setCallFunc(new Client());  
            caller.call();  //通知底层出货类，进行出货操作
        }  
    }  	
	
监听类，当出货完成事件触发时，底层出货类会向UI层传递json包
    public class Client implements MyCallInterface {  
      
        @Override  
        public void printName(String json) {  
            System.out.println("This is the client printName method"+json);  
        }  
    } 

第四步、出货完成时，底层出货类向UI层传递json包	
public void EV_callBack(String json_msg)
	{
		//这里是JSON包 该处是通过handler发送消息的方式发送到主线程处理结果的，开发者可以选择自己的方式进行处理。
		//但是千万不要在此函数里做过多的处理。以免jni调用出错 或者 拖慢速度	
		if(this.callInterface != null)//说明已经注册了
		{
				this.callInterface.printName(json_msg);
		}
	}

	
	
3）事件注册：他是回调的升级作法，好处是可以在不同的activity里面注册不同的监听器，以及注册多个监听器。
我们普通的控件就是使用事件注册机制
以"开门"和"关门"为例,为对象"门"实现自定义的事件处理;
STEP1:定义底层事件类DoorEvent,它继承EventObject类;
import java.util.EventObject;
public class DoorEvent extends EventObject
{
  private String doorState = ""; //表示门的状态,取值"开"和"关";
  public DoorEvent(Object source, String doorState)
  {
    super(source);
    this.doorState = doorState;
  }
  public void setDoorState(String doorState)
  {
    this.doorState = doorState;
  }
  public String getDoorState()
  {
    return this.doorState;
  }
}
STEP2:模拟实现事件源类底层DoorManager,用于触发事件和广播通知事件;它使用一个Collection类型的对象类存储所有注册进来的事件监听器对象;
import java.util.*;
public class DoorManager
{
  private Collection listeners; //存储所有注册进来的事件监听器对象;
  public void addDoorListener(DoorListener listener) //把一个事件监听器对象注册进来到链表去;
  {
    if(this.listeners == null)
    {
      this.listeners = new HashSet();
    }
    this.listeners.add(listener);
  }
  public void removeDoorListener(DoorListener listener) //移除一个已经注册的链表的事件监听器对象;
  {
    if(this.listeners != null)
    {
      this.listeners.remove(listener);
    }
  }
  protected void fireDoorOpened()  //触发开门事件
  {
    if(this.listeners != null)
    {
      DoorEvent event = new DoorEvent(this, "open");//实例化底层Door类
      notifyListeners(event);
    }
  }
  protected void fireDoorClose()  //触发关门事件
  {
    if(this.listeners != null)
    {
      DoorEvent event = new DoorEvent(this, "close");
      notifyListeners(event);
    }
  }
  private void notifyListeners(DoorEvent event)
  {
	//把注册的两条listener类都实例化，然后出发调用doorEvent接口，用来通知上层UI系统：事件发生了，
	  你调用相应的监听处理函数吧。这个作用相当于例子1)回调里面的
	  //2.告诉老板老板老王干完了  callBack.execute(value);  
    Iterator iter = this.listeners.iterator();
    while(iter.hasNext())
    {
      DoorListener listener = (DoorListener)iter.next();
      listener.doorEvent(event);
    }
  }
}
STEP3:定义上层事件监听器接口DoorListener,它继承接口EventListener;
import java.util.EventListener;
public interface DoorListener extends EventListener
{
  public void doorEvent(DoorEvent event);
}
STEP4:定义上层事件监听器类DoorListener1和DoorListener2,它们两都分别实现接口DoorListener;
public class DoorListener1 implements DoorListener
{
  public void doorEvent(DoorEvent event)
  {
    if(event.getDoorState() != null && event.getDoorState().equals("open"))
    {
      System.out.println("门1打开");
    }
    else
    {
      System.out.println("门1关闭");
    }
  }
}
public class DoorListener2 implements DoorListener
{
  public void doorEvent(DoorEvent event)
  {
    if(event.getDoorState() != null && event.getDoorState().equals("open"))
    {
      System.out.println("门2打开,同时打开走廊里面的灯");
    }
    else
    {
      System.out.println("门2关闭,同时关闭走廊里面的灯");
    }
  }
}

至此,事件处理模型中涉及到的事件对象类、事件监听器类、事件源类,这三个参与者都已经实现;很明显,这是Observer(观察者)模式的一个具体应用;最后就是应用,只写个测试程序即可:
public class DoorTest
{
  public static void main(String []args)
  {
    DoorManager manager = new DoorManager();
    manager.addDoorListener(new DoorListener1()); //给"门1"增加事件监听器;
    manager.addDoorListener(new DoorListener2()); //给"门2"增加事件监听器;
    manager.fireDoorOpened(); //开门;
    System.out.println("我已经进来了");
    manager.fireDoorClose();  //关门;
  }
}	

运行DoorMain

门1打开 
门2打开，同时打开走廊的灯
我已经进来了
门1关闭
门2关闭，同时关闭走廊的灯

*IO文件操作
java.io.*;
1.File类
例如：新建文件
1)
import java.io.*;

public class io
{
  public static void main(String args[])
  {
    File f=new File("D:\\Android\\javaprj\\test.txt");//实例化文件对象
    try
    {
    	f.createNewFile();
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
  }
}
但是windows中使用:"\"
Linux中使用:"/"
为了保持JAVA的可移植性，使用自动分割符
File f=new File("D:"+File.separator+"Android"+File.separator+"javaprj"+File.separator+"test.txt");//实例化文件对象

2)    
删除文件：
if(f.exists())//判断文件存在
   f.delete();

3）创建文件夹
File f=new File("D:"+File.separator+"Android"+File.separator+"javaprj"+File.separator+"test");//实例化文件对象
f.mkdir();

4)列出指定名录中的全部文件
(1)使用list以字符串数组的形式返回
File f=new File("C:"+File.separator+"androaidprj");
     String str[]=f.list();//列出给定目录中的内容
     for(int i=0;i<str.length;i++)
     {
        System.out.println("list="+str[i]);
     } 
列出文件名
(2)使用listFile以File数组的形式返回
File f=new File("C:"+File.separator+"androaidprj");
     File str[]=f.listFiles();//列出给定目录中的内容
     for(int i=0;i<str.length;i++)
     {
        System.out.println("list="+str[i]);
     } 
会连文件完整路径一起列出


5)判断给定路径是否目录
if(f.isDirectory())

6)要求列出制定目录的所有内容，即如果是目录，连子目录一起列出
import java.io.*;
public class io
{
  public static void main(String args[])
  {
     File f=new File("C:" + File.separator);
     print(f);     
  }
  //递归调用
  public static void print(File file)
  {
     if(file!=null)
     { 
        if(file.isDirectory())
        { 
          File f[] = file.listFiles();
          for(int i=0;i<f.length;i++)
          {
              System.out.println("list="+f[i]);
              //因为给的路径有可能是目录
              print(f[i]);
           }
        } 
        //如果是文件
        else
        {
           System.out.println("list="+file);
        }  
     }
  } 
}

7)手机中添加日志文件
<!--往sdcard中写入数据的权限 -->
	<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
	 <!--在sdcard中创建/删除文件的权限 -->
	<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"></uses-permission>

/**
 * 追加文件：使用FileWriter
 */
public static void AppendLogFile(String content) 
{
	final String SDCARD_DIR=File.separator+"sdcard"+File.separator+"logs";
	final String NOSDCARD_DIR=File.separator+"logs";
	String  sDir =null;
	File fileName=null;
	SimpleDateFormat tempDate = new SimpleDateFormat("yyyy-MM-dd" + " "  
			+ "hh:mm:ss:SSS"); //精确到毫秒 
	String datetime = tempDate.format(new java.util.Date()).toString();  
	String cont=datetime+content+"\n";
	
	try {
		  //首先判断sdcard是否插入
		  String status = Environment.getExternalStorageState();
		  if (status.equals(Environment.MEDIA_MOUNTED)) 
		  {
			 sDir = SDCARD_DIR;;
		  } 
		  else
		  {
			  sDir = NOSDCARD_DIR;
		  }
		  File dirName = new File(sDir);
		 //如果目录不存在，则创建目录
		 if (!dirName.exists()) 
		 {  
			//按照指定的路径创建文件夹  
			dirName.mkdirs(); 
		 }
		 
		 fileName=new File(sDir+File.separator+"log.txt");         	
		//如果不存在，则创建文件
		if(!fileName.exists())
		{  
		  fileName.createNewFile(); 
		}  
		//打开一个写文件器，构造函数中的第二个参数true表示以追加形式写文件
		FileWriter writer = new FileWriter(fileName, true);
		writer.write(cont);
		writer.close();
	} catch (Exception e) {
		e.printStackTrace();
	}
}	

2.读取文件功能RandomAccessFile
文件打开模式r,w,rw
1）写文件
File f=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.txt");
     //读写模式，如果文件不存在则自动创建
     RandomAccessFile rd= new RandomAccessFile(f,"rw");
     //一个一个字节的写
     String name="zhang 3"; 
     rd.writeBytes(name);//写入字符串
     int age=12;
     rd.writeInt(age);//数字
     rd.close();
2）读文件
RandomAccessFile rd= new RandomAccessFile(f,"r");
     
     String name=null; 
     int age=0;     
     byte b[]=new byte[8];
     //读字符串
     for(int i=0;i<b.length;i++)
     {
       b[i]=rd.readByte();
     }
     name=new String(b); 
     //读数字
     //age=rd.readInt();


3.字节流与字符流
所有数据都以流的方式来操作的，输入流用来读取数据，输出流用来保存数据。流中保存的
实际都是字节文件
1）字节流
（1）OutputStream输出流
File f=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.txt");
     //读写模式，如果文件不存在则自动创建
     OutputStream out=new FileOutputStream(f);
     //一个一个字节的写
     String str="\r\nhellozhang 3"; 
     //只能输出byte数组，所以将字符串便问数组
     byte b[]=str.getBytes(); 
     out.write(b);//写入字符串     
     int age=12;
     out.write(age);//写入数据  
     out.close();

追加写入
OutputStream out=new FileOutputStream(f,true);

(2)InputStream输人流
File f=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.txt");
     //读写模式，如果文件不存在则自动创建
     InputStream in=new FileInputStream(f);
     //一个一个字节的写
     String str=null; 
     //根据文件大小开辟数组空间
     byte b[]=new byte[(int)f.length()]; 
     in.read(b);//读取字符串
     str=new String(b);
     System.out.println("str="+str);
     in.close();


(3)或者，按字节读取
//根据文件大小开辟数组空间
byte b[]=new byte[(int)f.length()]; 
int len=0;
int temp=0;
while((temp=input.read())!=-1)//表示还没有读完,-1表示读完了
{
	b[len++] = (byte)temp ;		// 读取内容
}

2）字符流：一个字符等于两个字节
字符流比字节流操作好的地方是，直接可以读写字符串，不用转成字节数组
（1)write写
//读写模式，如果文件不存在则自动创建
     Writer out=new FileWriter(f);
     //一个一个字节的写
     String str="\r\nhellozhang 7"; 
     out.write(str);//写入字符串     
     int age=12;
     out.write(age);//写入数据  
     out.close();
追加写入
Writer out=new FileWriter(f,true);

注意：有一个问题点，就是Java FileWriter 默认是用（ISO-8859-1 or US-ASCII）西方编码的，总之不是UTF-8的，但是实际
使用发现转为utf-8无效，只有写入时转为gbk编码，才可以正确使用。
因此写入中文会乱码
写入中文不会乱码方法：FileOutputStream后面加上true是追加写入，(实际在写日志的时候，发现频繁)

输出UTF-8的文件： 
OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(fileName, true),Charset.forName("gbk"));
或者 
Writer out = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(fileName, true),Charset.forName("gbk")));
或者
String filePath = "/sdcard/utf8_file.txt";
int BUFFER_SIZE = 8192;
BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(
		fileName, true),Charset.forName("gbk")), BUFFER_SIZE);
out.write(cont);//写入字符串  
out.close();

读入中文不会乱码方法
BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), Charset.forName("gbk")),BUFFER_SIZE);

(2)read读
File f=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.txt");
     
     //读写模式，如果文件不存在则自动创建
     Reader in=new FileReader(f);
     //一个一个字节的写
     String str=null; 
     //根据文件大小开辟数组空间
     char b[]=new char[(int)f.length()]; 
     in.read(b);//读取字符串
     str=new String(b);
     System.out.println("str="+str);
     in.close();

(3)或者，按字节读取
//根据文件大小开辟数组空间
char b[]=new char[(int)f.length()]; 
int len=0;
int temp=0;
while((temp=input.read())!=-1)//表示还没有读完,-1表示读完了
{
	b[len++] = (byte)temp ;		// 读取内容
}

3)字符流与字节流的区别：在内存与硬盘交互，都是以字节流进行的，字符流只是文件
操作

4）字节转换为字符流的类
只要字节的输入，输出都可以用字符的输入，输出操作

（1）字节流转为字符流写操作
//字节流转为字符流
     Writer out=new OutputStreamWriter(new FileOutputStream(f));     
     String str="\r\nhellozhang 7"; 
     //以字符流的方式来写字节流 
     out.write(str);//写入字符串  
  
（2）字节流转为字符流读操作
     //字节流转为字符流
     Reader in=new InputStreamReader(new FileInputStream(f));
     //一个一个字节的写
     String str=null; 
     //根据文件大小开辟数组空间
     char b[]=new char[(int)f.length()]; 
     in.read(b);//读取字符串
     str=new String(b);
     System.out.println("str="+str);
     in.close();

5)InputStream,String,File相互转化
1. String --> InputStream
InputStream String2InputStream(String str){
   ByteArrayInputStream stream = new ByteArrayInputStream(str.getBytes());
   return stream;
}

2. InputStream --> String
String inputStream2String(InputStream is){
   BufferedReader in = new BufferedReader(new InputStreamReader(is));
   StringBuffer buffer = new StringBuffer();
   String line = "";
   while ((line = in.readLine()) != null){
     buffer.append(line);
   }
   return buffer.toString();
}
3、File --> InputStream
InputStream in = new InputStream(new FileInputStream(File));

4、InputStream --> File
public void inputstreamtofile(InputStream ins,File file){
OutputStream os = new FileOutputStream(file);
int bytesRead = 0;
byte[] buffer = new byte[8192];
while ((bytesRead = ins.read(buffer, 0, 8192)) != -1) {
os.write(buffer, 0, bytesRead);
}
os.close();
ins.close();
}

6)InputStream与String,Byte之间互转 
    import java.io.ByteArrayInputStream;  
    import java.io.ByteArrayOutputStream;  
    import java.io.IOException;  
    import java.io.InputStream;  
      
    /**  
     *   
     * @author Andy.Chen  
     * @mail Chenjunjun.ZJ@gmail.com  
     *  
     */  
    public class InputStreamUtils {  
          
        final static int BUFFER_SIZE = 4096;  
          
        /**  
         * 将InputStream转换成String  
         * @param in InputStream  
         * @return String  
         * @throws Exception  
         *   
         */  
        public static String InputStreamTOString(InputStream in) throws Exception{  
              
            ByteArrayOutputStream outStream = new ByteArrayOutputStream();  
            byte[] data = new byte[BUFFER_SIZE];  
            int count = -1;  
            while((count = in.read(data,0,BUFFER_SIZE)) != -1)  
                outStream.write(data, 0, count);  
              
            data = null;  
            return new String(outStream.toByteArray(),"ISO-8859-1");  
        }  
          
        /**  
         * 将InputStream转换成某种字符编码的String  
         * @param in  
         * @param encoding  
         * @return  
         * @throws Exception  
         */  
             public static String InputStreamTOString(InputStream in,String encoding) throws Exception{  
              
            ByteArrayOutputStream outStream = new ByteArrayOutputStream();  
            byte[] data = new byte[BUFFER_SIZE];  
            int count = -1;  
            while((count = in.read(data,0,BUFFER_SIZE)) != -1)  
                outStream.write(data, 0, count);  
              
            data = null;  
            return new String(outStream.toByteArray(),"ISO-8859-1");  
        }  
          
        /**  
         * 将String转换成InputStream  
         * @param in  
         * @return  
         * @throws Exception  
         */  
        public static InputStream StringTOInputStream(String in) throws Exception{  
              
            ByteArrayInputStream is = new ByteArrayInputStream(in.getBytes("ISO-8859-1"));  
            return is;  
        }  
          
        /**  
         * 将InputStream转换成byte数组  
         * @param in InputStream  
         * @return byte[]  
         * @throws IOException  
         */  
        public static byte[] InputStreamTOByte(InputStream in) throws IOException{  
              
            ByteArrayOutputStream outStream = new ByteArrayOutputStream();  
            byte[] data = new byte[BUFFER_SIZE];  
            int count = -1;  
            while((count = in.read(data,0,BUFFER_SIZE)) != -1)  
                outStream.write(data, 0, count);  
              
            data = null;  
            return outStream.toByteArray();  
        }  
          
        /**  
         * 将byte数组转换成InputStream  
         * @param in  
         * @return  
         * @throws Exception  
         */  
        public static InputStream byteTOInputStream(byte[] in) throws Exception{  
              
            ByteArrayInputStream is = new ByteArrayInputStream(in);  
            return is;  
        }  
          
        /**  
         * 将byte数组转换成String  
         * @param in  
         * @return  
         * @throws Exception  
         */  
        public static String byteTOString(byte[] in) throws Exception{  
              
            InputStream is = byteTOInputStream(in);  
            return InputStreamTOString(is);  
        }  
      
    }  	 

4.内存操作流：
ByteArrayInputStream将内容写入到内存中
ByteArrayOutputStream将内存中的数据输出
import java.io.*;
public class io
{
  public static void main(String args[]) throws Exception
  {
     String str="HELLOWORLD";
     //内存输入流,将字符串写入到内存中
     ByteArrayInputStream in = new ByteArrayInputStream(str.getBytes());
     //内存输出流,准备从内存中读取内容
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     int temp = 0;
     while((temp=in.read())!=-1)//读内存中的数据
     {
       char c=(char) temp;//读取的数字变为字符串
       out.write(Character.toLowerCase(c));
     }
     //完了之后，所有的数据都存在了内存输出流中了
     String newstr=out.toString();//取出内容
     System.out.println(newstr);
     try
     {
        in.close();
        out.close();
     }
     catch(IOException e)
     {
        e.printStackTrace();
     }   
      
  }  
}

5.管道流:进行两个线程之间的通讯，一个管道输出流PipedOutputStream，一个管道输入流
PipedInputStream		
例如：
import java.io.*;
class threadsend implements Runnable
{
  //管道输出流
  private  PipedOutputStream out = null;
  public threadsend()
  {
     this.out= new PipedOutputStream();
  }
  public void run()
  {
     String str="Hello world";
     try
     {
       this.out.write(str.getBytes());
     }
     catch(IOException e)
     {
        e.printStackTrace();
     } 
     try
     {
        out.close();
     }
     catch(IOException e)
     {
        e.printStackTrace();
     } 
  }
  //得到此线程的管道输出流
  public PipedOutputStream getOut()
  {
     return this.out;
  }
}

class threadrec implements Runnable
{
  //管道输入流
  private  PipedInputStream in = null;
  public threadrec()
  {
     this.in= new PipedInputStream();
  }
  public void run()
  {
     byte b[]=new byte[1024];
     int len=0;
     try
     {
       len=this.in.read(b);
     }
     catch(IOException e)
     {
        e.printStackTrace();
     } 
     try
     {
        this.in.close();
     }
     catch(IOException e)
     {
        e.printStackTrace();
     } 
     System.out.println("内容:"+new String(b,0,len));
   
  }
  //得到此线程的管道输入流
  public PipedInputStream getIn()
  {
     return this.in;
  }
}
public class io
{
  public static void main(String args[]) throws Exception
  {
      threadsend send=new threadsend(); 
      threadrec rec = new threadrec();
      //管道连接
     try
     {
        send.getOut().connect(rec.getIn());
     }
     catch(IOException e)
     {
        e.printStackTrace();
     } 
     new Thread(send).start();
     new Thread(rec).start();
  }  
}

6.打印流
用于输出信息，包含字节打印流PrintStream,字符打印流PrintWriter,可以打印任何的数据
类型，如小数，整数，字符串等
原先输出用OutputStream,但是输出需要变为byte[],很麻烦
public class io
{
  public static void main(String args[]) throws Exception
  {
      //如果是用FileOutputStream实例化，意味着所有的输出是向文件中
      PrintStream out=new PrintStream(new FileOutputStream(new File("C:" + File.separator+"androaidprj"+ File.separator+"test.txt")));
      out.print("hello 2= "+20);
  }  
}

2）格式化输出
out.print("hello 2=%d ",20);

7.System类对IO的支持
1)System.out输出
OutputStream out = System.out ;		// 此时的输出流是向屏幕上输出
out.write("hello world!!!".getBytes()) ;	// 向屏幕上输出

2)System.err输出错误信息
3)System.in输入
InputStream input = System.in ;	// 从键盘接收数据
StringBuffer buf = new StringBuffer() ;	// 使用StringBuffer接收数据
System.out.print("请输入内容：") ;	// 提示信息
int temp = 0 ;		// 接收内容
while((temp=input.read())!=-1)
{
	char c = (char) temp ;	// 将数据变为字符
	if(c=='\n'){	// 退出循环，输入回车表示输入完成
		break ;
	}
	buf.append(c) ;	// 保存内容
}
System.out.println("输入的内容为：" + buf) ;
input.close() ;	// 关闭输入流

4)使用System.out输出重定向
System.setOut(new PrintStream(new FileOutputStream("d:" + 
File.separator + "red.txt"))) ;	// System.out输出重定向
System.out.print("www.mldnjava.cn") ;	// 输出时，不再向屏幕上输出

5)为System.err设置输出错误重定向
ByteArrayOutputStream bos = null ;		// 声明内存输出流
bos = new ByteArrayOutputStream() ;		// 实例化
System.setErr(new PrintStream(bos)) ;	// 输出重定向
System.err.print("www.mldnjava.cn") ;	// 错误输出，不再向屏幕上输出
System.err.println("李兴华") ;			// 向内存中输出
System.out.println(bos) ;	// 输出内存中的数据

6）System.in输入重定向
System.setIn(new FileInputStream("d:"
+ File.separator + "demo.txt")) ;	// 设置输入重定向
InputStream input = System.in ;	// 从文件中接收数据
byte b[] = new byte[1024]	;// 开辟空间，接收数据
int len = input.read(b) ;	//接收
System.out.println("输入的内容为：" + new String(b,0,len)) ;
input.close() ;	// 关闭输入流

8.BufferedReader类：没有长度限制，可以输入很多内容，以回车结束。这就是键盘
输入的标准格式
//将字节输入流先转为字符流，让字符流放到字符流缓冲区中
      BufferedReader buf=new BufferedReader(new InputStreamReader(System.in));
      String str=null;//接受输入内容
      try
     {
        str=buf.readLine();//读取一行内容 
     }
     catch(IOException e)
     {
        e.printStackTrace();
     } 
     System.out.println("内容:"+str); 


9.Scanner类
import java.util.*;
（1)实现基本数据输入:比BufferedReader更加方便，但是有一个缺点，就是遇到空格，
就结束了。这样，我们就要以换行符"\n"来代替结束操作
Scanner scan=new Scanner(System.in);//从键盘接受数据
System.out.print("输出：");
scan.useDelimiter("\n"); 
String str=scan.next();//接受数据
System.out.print(str);

（2)接受整数，接受小数
scan.nextInt();接受整数
scan.hasNextInt();//判断是否是整数
scan.nextFloat();接受小数
scan.hasNextFloat();//判断是否是小数
例如：
int i = 0 ;
float f = 0.0f ;
System.out.print("输入整数：") ;
if(scan.hasNextInt()){	// 判断输入的是否是整数
	i = scan.nextInt() ;	// 接收整数
}

System.out.print("输入小数：") ;
if(scan.hasNextFloat()){	// 判断输入的是否是小数
	f = scan.nextFloat() ;	// 接收小数
}			

(3)接受日期型数据
Scanner scan = new Scanner(System.in) ;	// 从键盘接收数据
String str = null ;
Date date = null ;
System.out.print("输入日期（yyyy-MM-dd）：") ;
if(scan.hasNext("^\\d{4}-\\d{2}-\\d{2}$")){	// 判断
	str = scan.next("^\\d{4}-\\d{2}-\\d{2}$") ;	// 接收
	try{
		date = new SimpleDateFormat("yyyy-MM-dd").parse(str) ;
	}catch(Exception e){}
	}else{
		System.out.println("输入的日期格式错误！") ;
	}
System.out.println(date) ;

(4)直接从文件中读取信息
File f = new File("D:" + File.separator + "test.txt") ;	// 指定操作文件
Scanner scan = null ;
try{
	scan = new Scanner(f) ;	// 从文件接收数据
}catch(Exception e){}
//因为内容可能比较多行，因此用StringBuffer
StringBuffer str = new StringBuffer() ;
while(scan.hasNext()){
	str.append(scan.next()).append('\n')	;	//	取数据
}
System.out.println("文件内容为：" + str) ;


10.数据操作流DataOutputStream,DateInputStream
使用时要先自定义数据的保存格式，例如报表的格式等，才能读写
public static void main(String args[]) throws Exception
  {
      File f=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.txt");
      //写入
      DataOutputStream out=new DataOutputStream(new FileOutputStream(f));       
      String names[]={"衣服","手套","围巾"};
      int    price[]={92,78,26};
      int    nums[]={14,22,56};
      for(int i=0;i<names.length;i++)
      {
         out.writeChars(names[i]);
         out.writeChar('\t');
         out.writeInt(price[i]);
         out.writeChar('\t');
         out.writeInt(nums[i]);
         out.writeChar('\n');
      } 
      out.close();

      //读取
      DataInputStream in=new DataInputStream(new FileInputStream(f));  
      String na=null;
      int    pr=0;
      int    nm=0; 

      char   temp[]=null;
      int    len=0; 
      char   c=0;
      try
      {
      while(true)
      {
         temp=new char[200];
         len=0; 
         while((c=in.readChar())!='\t')
         {
            temp[len++]=c;
         }
         na=new String(temp,0,len);//读取名字
         pr=in.readInt();//读取价格
         in.readChar();//读取'\t'
         nm=in.readInt();//读取数量
         in.readChar();//读取'\n'      
         System.out.printf("名称:%s,价格:%d,数量:%d\n",na,pr,nm);
      }  
      }
      catch(Exception e)
      {}
      //in.close();      
  }  

得到内容
名称:衣服,价格:92,数量:14
名称:手套,价格:78,数量:22
名称:围巾,价格:26,数量:56


11.合并流：把两个内容合在一起
InputStream is1 = null ;		// 输入流1
InputStream is2 = null ;		// 输入流1
OutputStream os = null ;		// 输出流
SequenceInputStream sis = null ;	// 合并流
is1 = new FileInputStream("d:" + File.separator + "a.txt") ;
is2 = new FileInputStream("d:" + File.separator + "b.txt") ;
os = new FileOutputStream("d:" + File.separator + "ab.txt") ;
sis = new SequenceInputStream(is1,is2) ;	// 实例化合并流
int temp = 0 ;	// 接收内容
while((temp=sis.read())!=-1){	// 循环输出
	os.write(temp) ;	// 保存内容
}
sis.close() ;	// 关闭合并流
is1.close() ;	// 关闭输入流1`
is2.close() ;	// 关闭输入流2
os.close() ;	// 关闭输出流

12.压缩流
ZipOutputStream,ZipFile,ZipInputStream

13.回退流
字节PushbackInputStream,字符PushbackReader，把读进来的某些数据退回到输入流的
缓冲区中

14.字符编码：
iso8859-1:单字节编码，主要用来表示英文
GBK：双字节编码，主要用来表示中文
unicode:用16进制表示编码，java使用这种编码方式
UTF：中文网页中使用
得到本机编码提示
System.out.println(System.getProperty("file.encoding")); 

强制转换编码
File f = new File("D:" + File.separator + "test.txt") ;	// 实例化File类
OutputStream out = new FileOutputStream(f) ;	// 实例化输出流
byte b[] = "中国，你好！".getBytes("ISO8859-1") ;	// 转码操作
out.write(b) ;	// 保存
out.close() ;	// 关闭


15.对象序列化：将一个对象转为一个二进制bit流数据，进行传输用
1)
ObjectOutputStream序列化流
ObjectInputStream反序列化流
但是对于不同版本的JDK,会出现兼容问题，所以加上serialVersionUID常量用来验证版本
是否一致
例如：
//新建可序列化类
class person implements Serializable
{
   private static final long serialVersionUID=1L;//版本号
   private String name;
   public person(String name)
   {
     this.name=name;
   }
   public void setName(String name)
   {
     this.name=name;
   }
   public String getName()
   {
     return this.name;
   }
   
   public String toString()
   {
      return "姓名："+this.name;
   }
}


public static void main(String args[]) throws Exception
  {
      File f=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.txt");//定义保存路径
      //序列化操作
      OutputStream fout=new FileOutputStream(f);//文件输出流
      ObjectOutputStream out=new ObjectOutputStream(fout);//实例化对象输出流
      out.writeObject(new person("张五是士兵"));//将对象序列化
      out.close();

      //反序列化
      InputStream fin=new FileInputStream(f);//文件输入流
      ObjectInputStream in=new ObjectInputStream(fin);//实例化对象输人流
      Object obj= in.readObject();//反序列化对象
      System.out.println(obj);    
  }  


*类集
原先对象数组存在一个长度限制，所以类集就是一个不限长度的动态对象数组，可以方便
向数组中任意添加数据，可以重复
import java.util.*;
接口都支持泛型

1.Collection接口：里面存放的每一个元素都是一个对象，他只是一个父接口，基本不使用

2.List：Collection接口的子接口，里面的内容可以重复
1)例如：
import java.util.*;

public class list
{
   public static void main(String args[])
   {
      //我能增加字符串类型数据上去
      List<String> alllist=new ArrayList<String>();
      alllist.add("Hello");
      alllist.add("World");
      System.out.println(alllist); 
   } 
}

制定位置输出
alllist.add(0,"World");在第一个位置添加内容

2)添加一组数据
public static void main(String args[])
   {
      //我能增加字符串类型数据上去
      List<String> alllist=new ArrayList<String>();
      Collection<String> all=new ArrayList<String>();
      alllist.add("Hello");
      alllist.add("World");
      System.out.println(alllist); 
      //向Collection接口加入内容
      all.add("Hi");
      all.add("zhang 3");
      //把一组内容向集合中加
      alllist.addAll(all);
      System.out.println(alllist);
   } 

制定位置添加一组数据
alllist.addAll(0,all);


3)删除数据
alllist.remove(0);//删除第一个元素
alllist.remove("World");//删除world  

4）输出内容
//从前向后输出
for(int i=0;i<alllist.size();i++) 
{
    System.out.print(alllist.get(i)+",");
}

5）转化成数组
（1）制定数组类型
String str[]= all.toArray(new String[]{});
      //从前向后输出
      for(int i=0;i<str.length;i++) 
      {
        System.out.print(str[i]+",");
      }  
(2)返回对象数组
Object str[]= all.toArray();
      //从前向后输出
      for(int i=0;i<str.length;i++) 
      {
        String temp=(String) str[i];//先向下转型 
        System.out.print(temp+",");
      } 

6）其他几种方法
判断是否为空System.out.println("集合操作前是否为空？" + allList.isEmpty()) ;
字符串查找System.out.println(allList.contains("Hello")?"\"Hello\"字符串存在！" : "\"Hello\"字符串不存在！") ;
List<String> allSub = allList.subList(2,3) ;	// 字符串截取
集合查找，显示位置System.out.println("MLDN字符串的位置：" + allList.indexOf("MLDN")) ;


2.Quere:队列接口，Collection接口的子接口
他使用LinkeList类，用来实现链表
1)
LinkedList<String> link = new LinkedList<String>() ;
link.add("A") ;	// 增加元素
link.add("B") ;	// 增加元素
link.add("C") ;	// 增加元素
System.out.println("初始化链表：" + link) ;
link.addFirst("X") ;	// 在开头增加数据
link.addLast("Y") ;		// 在结尾增加数据
System.out.println("增加头和尾之后的链表：" + link) ;

2)查找表头
System.out.println("1-1、element()方法找到表头：" + link.element()) ;
System.out.println("1-2、找完之后的链表的内容：" + link) ;
System.out.println("2-1、peek()方法找到表头：" + link.peek()) ;
System.out.println("2-2、找完之后的链表的内容：" + link) ;
System.out.println("3-1、poll()方法找到表头：" + link.poll()) ;
System.out.println("3-2、找完之后的链表的内容：" + link) ;

3)输出队列
System.out.print("以FIFO的方式输出：") ;
for(int i=0;i<=link.size()+1;i++){
	System.out.print(link.poll() + "、") ;

4)BlockingQueue 继承了Queue接口
Java提供的线程安全的Queue可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue
线程安全的类 ，指的是类内共享的全局变量的访问必须保证是不受多线程形式影响的。如果由于多线程的访问（比如修改、遍历、查看）而使这些变量结构被破坏或者针对这些变量操作的原子性被破坏，则这个类就不是线程安全的。
(1)这个会抛出异常
add        增加一个元索                     如果队列已满，则抛出一个IIIegaISlabEepeplian异常
remove   移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常
element  返回队列头部的元素             如果队列为空，则抛出一个NoSuchElementException异常

(2)一般用这个，在多线程程序中，队列在任何时间都可能变成满的或空的，这个不会抛出异常
offer       添加一个元素并返回true       如果队列已满，则返回false
poll         移除并返问队列头部的元素    如果队列为空，则返回null
peek       返回队列头部的元素             如果队列为空，则返回null

(3)put方法在队列满时阻塞，take方法在队列空时阻塞
put         添加一个元素                      如果队列满，则阻塞
take        移除并返回队列头部的元素     如果队列为空，则阻塞

(4)
默认情况下，LinkedBlockingQueue的容量是没有上限的（说的不准确，在不指定时容量为Integer.MAX_VALUE，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。
ArrayBlockingQueue在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。
PriorityBlockingQueue是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限，但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。

例如：
 BlockingQueue<File> queue = new ArrayBlockingQueue<File>(  
                FILE_QUEUE_SIZE);  
 Queue<String> queue = new LinkedList<String>();	


2.1加锁synchronized
在编写一个类时，如果该类中的代码可能运行于多线程环境下，那么就要考虑同步的问题。在Java中内置了语言级的同步原语－－synchronized
   一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

     二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

     三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。

     四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

     五、以上规则对其它对象锁同样适用.

举例说明：  
     一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

package ths;

public class Thread1 implements Runnable {  
     public void run() {  
          synchronized(this) {  
               for (int i = 0; i < 5; i++) {  
                    System.out.println(Thread.currentThread().getName() + " synchronized loop " + i);  
               }  
          }  
     }  
     public static void main(String[] args) {  
          Thread1 t1 = new Thread1();  
          Thread ta = new Thread(t1, "A");  
          Thread tb = new Thread(t1, "B");  
          ta.start();  
          tb.start();  
     } 
}

结果：  
     A synchronized loop 0  
     A synchronized loop 1  
     A synchronized loop 2  
     A synchronized loop 3  
     A synchronized loop 4  
     B synchronized loop 0  
     B synchronized loop 1  
     B synchronized loop 2  
     B synchronized loop 3  
     B synchronized loop 4

     二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

package ths;

public class Thread2 {  
     public void m4t1() {  
          synchronized(this) {  
               int i = 5;  
               while( i-- > 0) {  
                    System.out.println(Thread.currentThread().getName() + " : " + i);  
                    try {  
                         Thread.sleep(500);  
                    } catch (InterruptedException ie) {  
                    }  
               }  
          }  
     }  
     public void m4t2() {  
          int i = 5;  
          while( i-- > 0) {  
               System.out.println(Thread.currentThread().getName() + " : " + i);  
               try {  
                    Thread.sleep(500);  
               } catch (InterruptedException ie) {  
               }  
          }  
     }  
     public static void main(String[] args) {  
          final Thread2 myt2 = new Thread2();  
          Thread t1 = new Thread(  new Runnable() {  public void run() {  myt2.m4t1();  }  }, "t1"  );  
          Thread t2 = new Thread(  new Runnable() {  public void run() { myt2.m4t2();   }  }, "t2"  );  
          t1.start();  
          t2.start();  
     } 
}

结果：  
     t1 : 4  
     t2 : 4  
     t1 : 3  
     t2 : 3  
     t1 : 2  
     t2 : 2  
     t1 : 1  
     t2 : 1  
     t1 : 0  
     t2 : 0

     三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。

     //修改Thread2.m4t2()方法：  
     public void m4t2() {  
          synchronized(this) {  
               int i = 5;  
               while( i-- > 0) {  
                    System.out.println(Thread.currentThread().getName() + " : " + i);  
                    try {  
                         Thread.sleep(500);  
                    } catch (InterruptedException ie) {  
                    }  
               }  
          }

     }

结果：

     t1 : 4  
     t1 : 3  
     t1 : 2  
     t1 : 1  
     t1 : 0  
     t2 : 4  
     t2 : 3  
     t2 : 2  
     t2 : 1  
     t2 : 0

     四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

     //修改Thread2.m4t2()方法如下：

     public synchronized void m4t2() {  
          int i = 5;  
          while( i-- > 0) {  
               System.out.println(Thread.currentThread().getName() + " : " + i);  
               try {  
                    Thread.sleep(500);  
               } catch (InterruptedException ie) {  
               }  
          }  
     }

结果：  
     t1 : 4  
     t1 : 3  
     t1 : 2  
     t1 : 1  
     t1 : 0  
     t2 : 4  
     t2 : 3  
     t2 : 2  
     t2 : 1  
     t2 : 0

     五、以上规则对其它对象锁同样适用:

package ths;

public class Thread3 { 
     class Inner { 
          private void m4t1() { 
               int i = 5; 
               while(i-- > 0) { 
                    System.out.println(Thread.currentThread().getName() + " : Inner.m4t1()=" + i); 
                    try { 
                         Thread.sleep(500); 
                    } catch(InterruptedException ie) { 
                    } 
               } 
          } 
          private void m4t2() { 
               int i = 5; 
               while(i-- > 0) { 
                    System.out.println(Thread.currentThread().getName() + " : Inner.m4t2()=" + i); 
                    try { 
                         Thread.sleep(500); 
                    } catch(InterruptedException ie) { 
                    } 
               } 
          } 
     } 
     private void m4t1(Inner inner) { 
          synchronized(inner) { //使用对象锁 
          inner.m4t1(); 
     } 
     private void m4t2(Inner inner) { 
          inner.m4t2(); 
     } 
     public static void main(String[] args) { 
          final Thread3 myt3 = new Thread3(); 
          final Inner inner = myt3.new Inner(); 
          Thread t1 = new Thread( new Runnable() {public void run() { myt3.m4t1(inner);} }, "t1"); 
     Thread t2 = new Thread( new Runnable() {public void run() { myt3.m4t2(inner);} }, "t2"); 
     t1.start(); 
     t2.start(); 
  } 
}

结果：

尽管线程t1获得了对Inner的对象锁，但由于线程t2访问的是同一个Inner中的非同步部分。所以两个线程互不干扰。

     t1 : Inner.m4t1()=4  
     t2 : Inner.m4t2()=4  
     t1 : Inner.m4t1()=3  
     t2 : Inner.m4t2()=3  
     t1 : Inner.m4t1()=2  
     t2 : Inner.m4t2()=2  
     t1 : Inner.m4t1()=1  
     t2 : Inner.m4t2()=1  
     t1 : Inner.m4t1()=0  
     t2 : Inner.m4t2()=0

现在在Inner.m4t2()前面加上synchronized：

     private synchronized void m4t2() {  
          int i = 5;  
          while(i-- > 0) {  
               System.out.println(Thread.currentThread().getName() + " : Inner.m4t2()=" + i);  
               try {  
                    Thread.sleep(500);  
               } catch(InterruptedException ie) {  
               }  
          }  
     }

结果：

尽管线程t1与t2访问了同一个Inner对象中两个毫不相关的部分,但因为t1先获得了对Inner的对象锁，所以t2对Inner.m4t2()的访问也被阻塞，因为m4t2()是Inner中的一个同步方法。

     t1 : Inner.m4t1()=4  
     t1 : Inner.m4t1()=3  
     t1 : Inner.m4t1()=2  
     t1 : Inner.m4t1()=1  
     t1 : Inner.m4t1()=0  
     t2 : Inner.m4t2()=4  
     t2 : Inner.m4t2()=3  
     t2 : Inner.m4t2()=2  
     t2 : Inner.m4t2()=1  
     t2 : Inner.m4t2()=0

第二篇：

synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。  
1. synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：  
public synchronized void accessVal(int newVal);  
synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能

执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行

状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有

一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）

。  
在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成

员变量的访问。  
synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为

synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可

以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供

了更好的解决办法，那就是 synchronized 块。  
2. synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下：  
synchronized(syncObject) {  
//允许访问控制的代码  
}  
synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机

制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。  
对synchronized(this)的一些理解 
一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线

程必须等待当前线程执行完这个代码块以后才能执行该代码块。  
二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized

(this)同步代码块。  
三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)

同步代码块的访问将被阻塞。  
四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个

object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。  
五、以上规则对其它对象锁同样适用

http://hi.baidu.com/sunshibing/blog/item/5235b9b731d48ff430add14a.html 
java中synchronized用法

打个比方：一个object就像一个大房子，大门永远打开。房子里有 很多房间（也就是方法）。

这些房间有上锁的（synchronized方法）， 和不上锁之分（普通方法）。房门口放着一把钥匙（key），这把钥匙可以打开所有上锁的房间。

另外我把所有想调用该对象方法的线程比喻成想进入这房子某个 房间的人。所有的东西就这么多了，下面我们看看这些东西之间如何作用的。

在此我们先来明确一下我们的前提条件。该对象至少有一个synchronized方法，否则这个key还有啥意义。当然也就不会有我们的这个主题了。

一个人想进入某间上了锁的房间，他来到房子门口，看见钥匙在那儿（说明暂时还没有其他人要使用上锁的 房间）。于是他走上去拿到了钥匙

，并且按照自己 的计划使用那些房间。注意一点，他每次使用完一次上锁的房间后会马上把钥匙还回去。即使他要连续使用两间上锁的房间，

中间他也要把钥匙还回去，再取回来。

因此，普通情况下钥匙的使用原则是：“随用随借，用完即还。”

这时其他人可以不受限制的使用那些不上锁的房间，一个人用一间可以，两个人用一间也可以，没限制。但是如果当某个人想要进入上锁的房

间，他就要跑到大门口去看看了。有钥匙当然拿了就走，没有的话，就只能等了。

要是很多人在等这把钥匙，等钥匙还回来以后，谁会优先得到钥匙？Not guaranteed。象前面例子里那个想连续使用两个上锁房间的家伙，他

中间还钥匙的时候如果还有其他人在等钥匙，那么没有任何保证这家伙能再次拿到。 （JAVA规范在很多地方都明确说明不保证，象

Thread.sleep()休息后多久会返回运行，相同优先权的线程那个首先被执行，当要访问对象的锁被 释放后处于等待池的多个线程哪个会优先得

到，等等。我想最终的决定权是在JVM，之所以不保证，就是因为JVM在做出上述决定的时候，绝不是简简单单根据 一个条件来做出判断，而是

根据很多条。而由于判断条件太多，如果说出来可能会影响JAVA的推广，也可能是因为知识产权保护的原因吧。SUN给了个不保证 就混过去了

。无可厚非。但我相信这些不确定，并非完全不确定。因为计算机这东西本身就是按指令运行的。即使看起来很随机的现象，其实都是有规律

可寻。学过 计算机的都知道，计算机里随机数的学名是伪随机数，是人运用一定的方法写出来的，看上去随机罢了。另外，或许是因为要想弄

的确定太费事，也没多大意义，所 以不确定就不确定了吧。）

再来看看同步代码块。和同步方法有小小的不同。

1.从尺寸上讲，同步代码块比同步方法小。你可以把同步代码块看成是没上锁房间里的一块用带锁的屏风隔开的空间。

2.同步代码块还可以人为的指定获得某个其它对象的key。就像是指定用哪一把钥匙才能开这个屏风的锁，你可以用本房的钥匙；你也可以指定

用另一个房子的钥匙才能开，这样的话，你要跑到另一栋房子那儿把那个钥匙拿来，并用那个房子的钥匙来打开这个房子的带锁的屏风。

         记住你获得的那另一栋房子的钥匙，并不影响其他人进入那栋房子没有锁的房间。

         为什么要使用同步代码块呢？我想应该是这样的：首先对程序来讲同步的部分很影响运行效率，而一个方法通常是先创建一些局部变

量，再对这些变量做一些 操作，如运算，显示等等；而同步所覆盖的代码越多，对效率的影响就越严重。因此我们通常尽量缩小其影响范围。

如何做？同步代码块。我们只把一个方法中该同 步的地方同步，比如运算。

         另外，同步代码块可以指定钥匙这一特点有个额外的好处，是可以在一定时期内霸占某个对象的key。还记得前面说过普通情况下钥

匙的使用原则吗。现在不是普通情况了。你所取得的那把钥匙不是永远不还，而是在退出同步代码块时才还。

          还用前面那个想连续用两个上锁房间的家伙打比方。怎样才能在用完一间以后，继续使用另一间呢。用同步代码块吧。先创建另外

一个线程，做一个同步代码 块，把那个代码块的锁指向这个房子的钥匙。然后启动那个线程。只要你能在进入那个代码块时抓到这房子的钥匙

，你就可以一直保留到退出那个代码块。也就是说 你甚至可以对本房内所有上锁的房间遍历，甚至再sleep(10*60*1000)，而房门口却还有

1000个线程在等这把钥匙呢。很过瘾吧。

          在此对sleep()方法和钥匙的关联性讲一下。一个线程在拿到key后，且没有完成同步的内容时，如果被强制sleep()了，那key还一

直在 它那儿。直到它再次运行，做完所有同步内容，才会归还key。记住，那家伙只是干活干累了，去休息一下，他并没干完他要干的事。为

了避免别人进入那个房间 把里面搞的一团糟，即使在睡觉的时候他也要把那唯一的钥匙戴在身上。

          最后，也许有人会问，为什么要一把钥匙通开，而不是一个钥匙一个门呢？我想这纯粹是因为复杂性问题。一个钥匙一个门当然更

安全，但是会牵扯好多问题。钥匙 的产生，保管，获得，归还等等。其复杂性有可能随同步方法的增加呈几何级数增加，严重影响效率。这也

算是一个权衡的问题吧。为了增加一点点安全性，导致效 率大大降低，是多么不可取啊。

synchronized的一个简单例子

public class TextThread {

public static void main(String[] args) { 
   TxtThread tt = new TxtThread(); 
   new Thread(tt).start(); 
   new Thread(tt).start(); 
   new Thread(tt).start(); 
   new Thread(tt).start(); 
} 
}

class TxtThread implements Runnable { 
int num = 100; 
String str = new String();

public void run() { 
   synchronized (str) { 
    while (num > 0) {

     try { 
      Thread.sleep(1); 
     } catch (Exception e) { 
      e.getMessage(); 
     } 
     System.out.println(Thread.currentThread().getName() 
       + "this is " + num--); 
    } 
   } 
} 
}

上面的例子中为了制造一个时间差,也就是出错的机会,使用了Thread.sleep(10)

Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如

何？DD还得对synchronized关键字的作用进行深入了解才可定论。

总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，

synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。

在进一步阐述之前，我们需要明确几点：

A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁DD而且同步方法很可能还会被其

他线程的对象访问。

B．每个对象只有一个锁（lock）与之相关联。

C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

接着来讨论synchronized用到不同地方对代码产生的影响：

假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。

1． 把synchronized当作函数修饰符时，示例代码如下：

Public synchronized void methodAAA()

{

//….

}

这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中

执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了

synchronized关键字的方法。

上边的示例代码等同于如下代码：

public void methodAAA()

{

synchronized (this)      // (1)

{

       //…..

}

}

(1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。DD那个

拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造

成数据混乱：（

2．同步块，示例代码如下：

public void method3(SomeObject so)

{

    synchronized(so)

    { 
       //….. 
    }

}

这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明

确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：

class Foo implements Runnable

{

        private byte[] lock = new byte[0]; // 特殊的instance变量

        Public void methodA() 
        {

           synchronized(lock) { //… }

        }

        //…..

}

注：零长度的byte数组对象创建起来将比任何对象都经济DD查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock

= new Object()则需要7行操作码。

3．将synchronized作用于static 函数，示例代码如下：

Class Foo 
{

    public synchronized static void methodAAA()   // 同步的static 函数 
    { 
        //…. 
    }

    public void methodBBB() 
    {

       synchronized(Foo.class)   // class literal(类名称字面常量)

    } 
}

   代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这

个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。

记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的

目的。P1指的是由Foo类产生的对象。

可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj

在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。

小结如下：

搞清楚synchronized锁定的是哪个对象，就能帮助我们设计更安全的多线程程序。

还有一些技巧可以让我们对共享资源的同步访问更加安全：

1． 定义private 的instance变量+它的 get方法，而不要定义public/protected的instance变量。如果将变量定义为public，对象在外界可以

绕过同步方法的控制而直接取得它，并改动它。这也是JavaBean的标准实现方式之一。

2． 如果instance变量是一个对象，如数组或ArrayList什么的，那上述方法仍然不安全，因为当外界对象通过get方法拿到这个instance对象

的引用后，又将其指向另一个对象，那么这个private变量也就变了，岂不是很危险。 这个时候就需要将get方法也加上synchronized同步，并

且，只返回这个private对象的clone()DD这样，调用端得到的就是对象副本的引用了



synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 
1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 
4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

修饰一个代码块

一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。我们看下面一个例子：
【Demo1】：synchronized的用法

/**
 * 同步线程
 */
class SyncThread implements Runnable {
   private static int count;

   public SyncThread() {
      count = 0;
   }

   public  void run() {
      synchronized(this) {
         for (int i = 0; i < 5; i++) {
            try {
               System.out.println(Thread.currentThread().getName() + ":" + (count++));
               Thread.sleep(100);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
      }
   }

   public int getCount() {
      return count;
   }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
SyncThread的调用：

SyncThread syncThread = new SyncThread();
Thread thread1 = new Thread(syncThread, "SyncThread1");
Thread thread2 = new Thread(syncThread, "SyncThread2");
thread1.start();
thread2.start();
1
2
3
4
5
结果如下：

SyncThread1:0 
SyncThread1:1 
SyncThread1:2 
SyncThread1:3 
SyncThread1:4 
SyncThread2:5 
SyncThread2:6 
SyncThread2:7 
SyncThread2:8 
SyncThread2:9*
当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。 
我们再把SyncThread的调用稍微改一下：

Thread thread1 = new Thread(new SyncThread(), "SyncThread1");
Thread thread2 = new Thread(new SyncThread(), "SyncThread2");
thread1.start();
thread2.start();
1
2
3
4
结果如下：

SyncThread1:0 
SyncThread2:1 
SyncThread1:2 
SyncThread2:3 
SyncThread1:4 
SyncThread2:5 
SyncThread2:6 
SyncThread1:7 
SyncThread1:8 
SyncThread2:9
不是说一个线程执行synchronized代码块时其它的线程受阻塞吗？为什么上面的例子中thread1和thread2同时在执行。这是因为synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联，而上面的代码等同于下面这段代码：

SyncThread syncThread1 = new SyncThread();
SyncThread syncThread2 = new SyncThread();
Thread thread1 = new Thread(syncThread1, "SyncThread1");
Thread thread2 = new Thread(syncThread2, "SyncThread2");
thread1.start();
thread2.start();
1
2
3
4
5
6
这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。

2.当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。 
【Demo2】：多个线程访问synchronized和非synchronized代码块

class Counter implements Runnable{
   private int count;

   public Counter() {
      count = 0;
   }

   public void countAdd() {
      synchronized(this) {
         for (int i = 0; i < 5; i ++) {
            try {
               System.out.println(Thread.currentThread().getName() + ":" + (count++));
               Thread.sleep(100);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
      }
   }

   //非synchronized代码块，未对count进行读写操作，所以可以不用synchronized
   public void printCount() {
      for (int i = 0; i < 5; i ++) {
         try {
            System.out.println(Thread.currentThread().getName() + " count:" + count);
            Thread.sleep(100);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }

   public void run() {
      String threadName = Thread.currentThread().getName();
      if (threadName.equals("A")) {
         countAdd();
      } else if (threadName.equals("B")) {
         printCount();
      }
   }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
调用代码:

Counter counter = new Counter();
Thread thread1 = new Thread(counter, "A");
Thread thread2 = new Thread(counter, "B");
thread1.start();
thread2.start();
1
2
3
4
5
结果如下：

A:0 
B count:1 
A:1 
B count:2 
A:2 
B count:3 
A:3 
B count:4 
A:4 
B count:5
上面代码中countAdd是一个synchronized的，printCount是非synchronized的。从上面的结果中可以看出一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。

指定要给某个对象加锁
【Demo3】:指定要给某个对象加锁

/**
 * 银行账户类
 */
class Account {
   String name;
   float amount;

   public Account(String name, float amount) {
      this.name = name;
      this.amount = amount;
   }
   //存钱
   public  void deposit(float amt) {
      amount += amt;
      try {
         Thread.sleep(100);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
   //取钱
   public  void withdraw(float amt) {
      amount -= amt;
      try {
         Thread.sleep(100);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }

   public float getBalance() {
      return amount;
   }
}

/**
 * 账户操作类
 */
class AccountOperator implements Runnable{
   private Account account;
   public AccountOperator(Account account) {
      this.account = account;
   }

   public void run() {
      synchronized (account) {
         account.deposit(500);
         account.withdraw(500);
         System.out.println(Thread.currentThread().getName() + ":" + account.getBalance());
      }
   }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
调用代码:

Account account = new Account("zhang san", 10000.0f);
AccountOperator accountOperator = new AccountOperator(account);

final int THREAD_NUM = 5;
Thread threads[] = new Thread[THREAD_NUM];
for (int i = 0; i < THREAD_NUM; i ++) {
   threads[i] = new Thread(accountOperator, "Thread" + i);
   threads[i].start();
}
1
2
3
4
5
6
7
8
9
结果如下：

Thread3:10000.0 
Thread2:10000.0 
Thread1:10000.0 
Thread4:10000.0 
Thread0:10000.0
在AccountOperator 类中的run方法里，我们用synchronized 给account对象加了锁。这时，当一个线程访问account对象时，其他试图访问account对象的线程将会阻塞，直到该线程访问account对象结束。也就是说谁拿到那个锁谁就可以运行它所控制的那段代码。 
当有一个明确的对象作为锁时，就可以用类似下面这样的方式写程序。

public void method3(SomeObject obj)
{
   //obj 锁定的对象
   synchronized(obj)
   {
      // todo
   }
}
1
2
3
4
5
6
7
8
当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：

class Test implements Runnable
{
   private byte[] lock = new byte[0];  // 特殊的instance变量
   public void method()
   {
      synchronized(lock) {
         // todo 同步代码块
      }
   }

   public void run() {

   }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
说明：零长度的byte数组对象创建起来将比任何对象都经济DD查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。

修饰一个方法

Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){//todo}; synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将【Demo1】中的run方法改成如下的方式，实现的效果一样。

*【Demo4】：synchronized修饰一个方法

public synchronized void run() {
   for (int i = 0; i < 5; i ++) {
      try {
         System.out.println(Thread.currentThread().getName() + ":" + (count++));
         Thread.sleep(100);
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
}
1
2
3
4
5
6
7
8
9
10
Synchronized作用于整个方法的写法。 
写法一：

public synchronized void method()
{
   // todo
}
1
2
3
4
写法二：

public void method()
{
   synchronized(this) {
      // todo
   }
}
1
2
3
4
5
6
写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。

在用synchronized修饰方法时要注意以下几点： 
1. synchronized关键字不能继承。 
虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下： 
在子类方法中加上synchronized关键字

class Parent {
   public synchronized void method() { }
}
class Child extends Parent {
   public synchronized void method() { }
}
1
2
3
4
5
6
在子类方法中调用父类的同步方法

class Parent {
   public synchronized void method() {   }
}
class Child extends Parent {
   public void method() { super.method();   }
} 
1
2
3
4
5
6
在定义接口方法时不能使用synchronized关键字。
构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。 
修饰一个静态的方法

Synchronized也可修饰一个静态方法，用法如下：

public synchronized static void method() {
   // todo
}
1
2
3
我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。我们对Demo1进行一些修改如下：

【Demo5】：synchronized修饰静态方法

/**
 * 同步线程
 */
class SyncThread implements Runnable {
   private static int count;

   public SyncThread() {
      count = 0;
   }

   public synchronized static void method() {
      for (int i = 0; i < 5; i ++) {
         try {
            System.out.println(Thread.currentThread().getName() + ":" + (count++));
            Thread.sleep(100);
         } catch (InterruptedException e) {
            e.printStackTrace();
         }
      }
   }

   public synchronized void run() {
      method();
   }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
调用代码:

SyncThread syncThread1 = new SyncThread();
SyncThread syncThread2 = new SyncThread();
Thread thread1 = new Thread(syncThread1, "SyncThread1");
Thread thread2 = new Thread(syncThread2, "SyncThread2");
thread1.start();
thread2.start();
1
2
3
4
5
6
结果如下：

SyncThread1:0 
SyncThread1:1 
SyncThread1:2 
SyncThread1:3 
SyncThread1:4 
SyncThread2:5 
SyncThread2:6 
SyncThread2:7 
SyncThread2:8 
SyncThread2:9
syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。

修饰一个类

Synchronized还可作用于一个类，用法如下：

class ClassName {
   public void method() {
      synchronized(ClassName.class) {
         // todo
      }
   }
}
1
2
3
4
5
6
7
我们把Demo5再作一些修改。 
【Demo6】:修饰一个类

/**
 * 同步线程
 */
class SyncThread implements Runnable {
   private static int count;

   public SyncThread() {
      count = 0;
   }

   public static void method() {
      synchronized(SyncThread.class) {
         for (int i = 0; i < 5; i ++) {
            try {
               System.out.println(Thread.currentThread().getName() + ":" + (count++));
               Thread.sleep(100);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
      }
   }

   public synchronized void run() {
      method();
   }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
其效果和【Demo5】是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。

总结：

A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

 

3.set:Collection接口的子接口，里面的内容不可以重复，所有的重复内容是靠hashCode()
和equals()两个方法区分的，将这两个方法复写
他使用的子类
1)散列存放：HashSet,本身没有顺序
Set<String> all=new HashSet<String>();
      all.add("1");
      all.add("2"); 
      all.add("3");
      System.out.println(all);
会输出3,1,2
他输出的打印顺序与我们添加的顺序不一样，是随机排序的


2)有序存放: TreeSet所有内容可以自由排序
Set<String> all=new TreeSet<String>();
      all.add("1");
      all.add("3"); 
      all.add("2");
      System.out.println(all);

会输出123

他会自动排序输出的打印

3)针对类，没有相应的大小区别，如何排序打印
import java.util.*;
class Person implements Comparable<Person>//继承排序接口
{
	private String name ;
	private int age ;
	public Person(String name,int age){
		this.name = name ;
		this.age = age ;
	}
	public String toString(){
		return "姓名：" + this.name + "；年龄：" + this.age ;
	}
        //实例化排序规则接口方法
        public int compareTo(Person per)
        {
           //按年龄比较
           if(this.age>per.age)
              return 1;
           else if(this.age<per.age) 
              return -1;
           else
              //return 0; 
              //年龄相同时，调用String的compareTo方法，比较名字
              return this.name.compareTo(per.name); 
        }  
};
public class list
{
   public static void main(String args[])
   {
      Set<Person> allSet = new TreeSet<Person>() ;
	allSet.add(new Person("张三",30)) ;
	allSet.add(new Person("李四",31)) ;
	allSet.add(new Person("王五",32)) ;
	allSet.add(new Person("王五",32)) ;
	allSet.add(new Person("王五",32)) ;
	allSet.add(new Person("赵六",33)) ;
	allSet.add(new Person("孙七",33)) ;
	System.out.println(allSet) ;
   } 
}

4）使用HashSet不按顺序排列，又要取消重复的对象
import java.util.*;
class Person
{
	private String name ;
	private int age ;
	public Person(String name,int age){
		this.name = name ;
		this.age = age ;
	}
	public String toString(){
		return "姓名：" + this.name + "；年龄：" + this.age ;
	}
        //复写方法，完成对象比较是否是同一个对象
        public boolean equals(Object obj)
       {
      	if(this==obj)
       	    return true;
     	else if(!(obj instanceof Person))
            return false;
      	Person per= (Person) obj;
        //名字和年龄一样，则是重复 
      	if(per.name.equals(this.name)&&per.age==this.age)
            return true;
     	else
            return false;  
        }
        //复写这个，进行唯一验证编码
        public int hashCode()
        {
            return this.name.hashCode()*this.age;//自己创建一个编码
        }
};
public class list
{
   public static void main(String args[])
   {
      Set<Person> allSet = new HashSet<Person>() ;
	allSet.add(new Person("张三",30)) ;
	allSet.add(new Person("李四",31)) ;
	allSet.add(new Person("王五",32)) ;
	allSet.add(new Person("王五",32)) ;
	allSet.add(new Person("王五",32)) ;
	allSet.add(new Person("赵六",33)) ;
	allSet.add(new Person("孙七",33)) ;
	System.out.println(allSet) ;
   } 
}

4.SortedSet:排序接口，Collection接口的子接口，使用比较器排序
SortedSet<String> allSet = new TreeSet<String>() ;	// 
allSet.add("A") ;	// 增加内容
allSet.add("B") ;	// 增加内容
allSet.add("C") ;	// 增加内容
allSet.add("C") ;	// 增加内容
allSet.add("C") ;	// 增加内容
allSet.add("D") ;	// 增加内容
allSet.add("E") ;	// 增加内容
System.out.println("第一个元素：" + allSet.first()) ;
System.out.println("最后一个元素：" + allSet.last()) ;
System.out.println("headSet元素：" + allSet.headSet("C")) ;
System.out.println("tailSet元素：" + allSet.tailSet("C")) ;
System.out.println("subSet元素：" + allSet.subSet("B","D")) ;

5.Iterator:输出接口，用于输出集合中的内容，从前到后依次输出
1）
SortedSet<String> allSet = new TreeSet<String>() ;
allSet.add("1");
        allSet.add("3"); 
        allSet.add("2"); 
	//输出集合内容
        Iterator<String> iter= allSet.iterator();//输出接口实例化
        while(iter.hasNext())
        {
           System.out.println(iter.next());
        }  

2）删除当前内容
//输出集合内容
        Iterator<String> iter= allSet.iterator();//输出接口实例化
        while(iter.hasNext())
        {
           String str= iter.next();
           if("2".equals(str)) //如果元素是2时，删除这个元素
               iter.remove();
           else 
               System.out.println(str);
        } 
在使用这个输出时，不要再用集合中的元remove方法，只能使用Iterator接口中的remove
方法

6.ListIterator:是Iterator的子接口，可以双向输出
一定要先由前到后输出后，再由后到前输出才可以。而且，只有List接口才可以随后用
这个方法
1）
List<String> all = new ArrayList<String>() ;
all.add("hello") ;
all.add("_") ;
all.add("world") ;
ListIterator<String> iter = all.listIterator() ;
System.out.print("由前向后输出：") ;
while(iter.hasNext()){
	String str = iter.next() ;
	System.out.print(str + "、") ;
}
System.out.print("\n由后向前输出：") ;
while(iter.hasPrevious()){
	String str = iter.previous() ;
	System.out.print(str + "、") ;
}

2）增加以及替换元素
while(iter.hasNext()){
	String str = iter.next() ;
	System.out.print(str + "、") ;
	iter.set("LI - " + str) ;	// 修改内容
}
System.out.print("\n由后向前输出：") ;
iter.add("LXH");
while(iter.hasPrevious()){
	String str = iter.previous() ;
	System.out.print(str + "、") ;
}

7.Enumeration:输出枚举内容：因为有Iterator方法，这个已不用
1）使用foreach方法
List<String> all = new ArrayList<String>() ;
all.add("hello") ;
all.add("_") ;
all.add("world") ;
//使用字符串方式输出集合全部内容
for(String str:allSet)
{
   System.out.println(str);
}

8.Map:里面存放的每一个元素都是一对对象，以key->value形式保存
Map.Entry接口保存一个key->value的内容，一个Map接口里面保存多个
    Map.Entry接口实例,这样就相当于保存了多个key->value对象了
1)HashMap:无排序
例如：
//其中key,value类型为String
Map<String,String> allSet = new HashMap<String,String>() ;
//增加内容
allSet.put("1","a");
allSet.put("3","b"); 
allSet.put("2","c"); 
//如果判断有这个key值
if(allSet.containsKey("2"))
{
    //根据key取出内容
    String val=allSet.get("2"); 
    System.out.println(val);
} 
//如果判断有这个Value值
if(allSet.containsValue("c"))
{}
//输出全部内容
Set<String> keys=allSet.keySet();//得到全部的key　
Collection<String> keys=allSet.values();//得到全部的value
Iterator<String> iter=keys.iterator();
//输出全部的key
while(iter.hasNext()) 
{
   System.out.println(iter.next());
}

2)TreeMap:有排序，如果自定义的类要作为key的话，需要实现Comparable接口
TreeMap默认是按升序排，也可以指定排序的比较器。遍历的时候按升序遍历。
Map<String,String> allSet = new TreeMap<String,String>() ;

3)LinkedHashMap:有排序，保存了记录的插入顺序，先插入的先遍历到

3）四种引用类型
之前的map都是强引用，即如果内存不足，会报错也不会释放空间。
也可以使用弱引用，即如果内存不足，会释放空间。
例如：弱引用
//其中key,value类型为String
Map<String,String> map = new WeakHashMap<String,String>() ;
//增加内容,这些内容是临时定义的，不使用的话有可能被回收
map.put(new String("mldn"),new String("www.mldn.cn")) ;
map.put(new String("zhinangtuan"),new String("www.zhinangtuan.net.cn")) ;
map.put(new String("mldnjava"),new String("www.mldnjava.cn")) ;
System.gc() ;	// 马上强制性进行垃圾的收集操作
map.put(new String("lxh"),new String("lixinghua")) ;
System.out.println(map) ;


4）Map的输出：因为他是一对值，因此不能直接用Iterator输出
最终以Collection形式输出，只是以Map.Entry作为操作类型
（1）
//增加内容
        map.put("1","a");
        map.put("3","b"); 
        map.put("2","c"); 
        //输出内容
        Set<Map.Entry<String,String>> allset=map.entrySet();  //实例化
        Iterator<Map.Entry<String,String>> iter=allset.iterator();
        while(iter.hasNext())
        {
            Map.Entry<String,String> me=iter.next();
            System.out.println(me.getKey()+"--"+me.getValue());
        } 
(2)
//第一种：普遍使用，二次取值  
  System.out.println("通过Map.keySet遍历key和value：");  
  for (String key : map.keySet()) {  
   System.out.println("key= "+ key + " and value= " + map.get(key));  
  }  
    
  //第二种  
  System.out.println("通过Map.entrySet使用iterator遍历key和value：");  
  Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();  
  while (it.hasNext()) {  
   Map.Entry<String, String> entry = it.next();  
   System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());  
  }  
    
//第三种：推荐，尤其是容量大时
  System.out.println("通过Map.entrySet遍历key和value");  
  for (Map.Entry<String, String> entry : map.entrySet()) {  
   System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());  
  } 

（3）自定义类,以String为key,输出内容
class Person
{
	private String name ;
	private int age ;
	public Person(String name,int age){
		this.name = name ;
		this.age = age ;
	}
	public String toString(){
		return "姓名：" + this.name + "；年龄：" + this.age ;
	}        
};

Map<String,Person> map = new HashMap<String,Person>() ;
//增加内容
        map.put("1",new Person("张三",30)) ;
	map.put("2",new Person("李四",31)) ;
	map.put("3",new Person("王五",32)) ;
	map.put("4",new Person("王五",32)) ;
	map.put("5",new Person("王五",32)) ;
	map.put("6",new Person("赵六",33)) ;
	map.put("7",new Person("孙七",33)) ; 
        System.out.println(map.get("4"));//按key输出

（4）自定义类,以类为key,输出内容:需要类中复写equals,hashCode方法
class Person
{
	private String name ;
	private int age ;
	public Person(String name,int age){
		this.name = name ;
		this.age = age ;
	}
	public String toString(){
		return "姓名：" + this.name + "；年龄：" + this.age ;
	} 
        //复写方法，完成对象比较是否是同一个对象
        public boolean equals(Object obj)
       {
      	if(this==obj)
       	    return true;
     	else if(!(obj instanceof Person))
            return false;
      	Person per= (Person) obj;
        //名字和年龄一样，则是重复 
      	if(per.name.equals(this.name)&&per.age==this.age)
            return true;
     	else
            return false;  
        }
        //复写这个，进行唯一验证编码
        public int hashCode()
        {
            return this.name.hashCode()*this.age;//自己创建一个编码
        }       
};

Map<Person,String> map = new HashMap<Person,String>() ;
map.put(new Person("张三",30),"1") ;
map.put(new Person("李四",31),"2") ;
System.out.println(map.get(new Person("李四",31)));//按key输出

(5).原先的Map内容，他的key是不能重复的，一旦重复，会被替换。如果需要key重复，
需要使用IdentityHashMap类
Map<Person,String> map = new IdentityHashMap<Person,String>() ;

9.SortedMap:存放一对值的排序接口，按照key排序，使用比较器排序
SortedMap<String,String> map = null ;
map = new TreeMap<String,String>() ;	// 通过子类实例化接口对象
map.put("D、jiangker","http://www.jiangker.com/") ;
map.put("A、mldn","www.mldn.cn") ;
map.put("C、zhinangtuan","www.zhinangtuan.net.cn") ;
map.put("B、mldnjava","www.mldnjava.cn") ;

System.out.print("第一个元素的内容的key：" + map.firstKey()) ;
System.out.println("：对应的值：" + map.get(map.firstKey())) ;
System.out.print("最后一个元素的内容的key：" + map.lastKey()) ;
System.out.println("：对应的值：" + map.get(map.lastKey())) ;
System.out.println("返回小于指定范围的集合：") ;
for(Map.Entry<String,String> me:map.headMap("B、mldnjava").entrySet()){
	System.out.println("\t|- " + me.getKey() + " --> " + me.getValue()) ;
}
System.out.println("返回大于指定范围的集合：") ;
for(Map.Entry<String,String> me:map.tailMap("B、mldnjava").entrySet()){
	System.out.println("\t|- " + me.getKey() + " --> " + me.getValue()) ;
}
System.out.println("部分集合：") ;//A截取到C
for(Map.Entry<String,String> me:map.subMap("A、mldn","C、zhinangtuan").entrySet()){
	System.out.println("\t|- " + me.getKey() + " --> " + me.getValue()) ;
}


10.Collections类：与Collection接口没有直接的关系，但是他有各个集合的操作方法。
在实际中，用的不多

11.Stack类：完成堆栈操作
Stack<String> s = new Stack<String>() ;
s.push("A") ;	// 入栈
s.push("B") ;	// 入栈
s.push("C") ;	// 入栈
System.out.print(s.pop() + "、") ;

12.Properties:属性类
import java.util.*;
import java.io.*;
public class proper
{
   public static void main(String args[])
   {
      Properties pro=new Properties();//创建属性对象
      //设置属性
      pro.setProperty("BT","bbett");
      pro.setProperty("BK","bbekk"); 
      pro.setProperty("AT","aaett");
      //得到属性
      System.out.println(pro.getProperty("BK"));
      //得到属性，如果没有找到属性，设置他的默认值
      System.out.println(pro.getProperty("TT","ttac"));
      //保存到属性文件中
      File file=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.properties"); 
      try
      {
         pro.store(new FileOutputStream(file),"area info");  
      }
      catch(Exception e)
      {
         e.printStackTrace();
      }
      //从文件中读取属性
      try
      {
         pro.load(new FileInputStream(file));  
      }
      catch(Exception e)
      {
         e.printStackTrace();
      }
      System.out.println(pro.getProperty("BK"));
      //保存到XML文件中
      File file2=new File("C:" + File.separator+"androaidprj"+ File.separator+"test.xml");
      try
      {
         pro.storeToXML(new FileOutputStream(file2),"area info");  
      }
      catch(Exception e)
      {
         e.printStackTrace();
      } 
      //从XML文件中读取属性
      try
      {
         pro.loadFromXML(new FileInputStream(file2));  
      }
      catch(Exception e)
      {
         e.printStackTrace();
      }
      System.out.println(pro.getProperty("BT")); 
   }
}


*反射机制
1.class类：通过一个对象来找到其所在的类的信息
1）
object类中的getClass方法，通过实例化的对象，调用他的getClass()方法，得到完整的
“包.类”的名称
class类没有构造方法，所以此类的构造方法被实例化了
例如：
package org.demo;
class x
{}

public class classprj
{
   public static void main(String args[])
   {
     x xx=new x();
     System.out.println(xx.getClass().getName());//得到对象所在的类
   }
}

2）
实例化class类对象的方法有三种
通过forName()方法
类.class
对象.getClass()
package org.demo;
class x
{}

public class classprj
{
   public static void main(String args[])
   {
     Class<?> c1=null;
     Class<?> c2=null;
     Class<?> c3=null;
     try
     {
        c1 = Class.forName("org.demo.x");//通过forName()方法实例化
     }
     catch(Exception e)
     {
        e.printStackTrace();
     } 
     c2=new x().getClass();//通过对象.getClass()实例化
     c3=x.class;//通过类.class实例化
     System.out.println(c1.getName()); 
     System.out.println(c2.getName()); 
     System.out.println(c3.getName());  
   }
}

3）class类的作用：他是反射的源头，不光可以取得对象所在类的信息，还可以直接通过
class类的方法，使用new为对象实例化，再通过newInstance
例如：不使用new,也可以通过反射进行对象实例化操作,但是类person必须使用无参构造
方法
package org.demo;

class Person
{
	private String name ;
	private int age ;
	
        public void setage(int age)
        {
           this.age=age;
        }
        public void setname(String name)
        {
           this.name=name;
        }
        public String getname()
        {
           return this.name;
        }
        public int getage()
        {
           return this.age;
        } 
	public String toString(){
		return "姓名：" + this.name + "；年龄：" + this.age ;
	}  
};

Class<?> c1=null;
     //Class<?> c2=null;
     //Class<?> c3=null;
     try
     {
        c1 = Class.forName("org.demo.Person");//通过forName()方法实例化
     }
     catch(Exception e)
     {
        e.printStackTrace();
     } 
     Person per=null;
     try
     {
        per = (Person)c1.newInstance();//实例化对象
     }
     catch(Exception e)
     {
        e.printStackTrace();
     }
     per.setname("zhang3");
     per.setage(15);
     System.out.println(per); 

2.反射应用，取得类的结构
Constructor表示类中的构造方法
Field表示类中的属性
Method表示类中的方法
例子：
package org.lxh.fan;
interface china
{
  public static final String NATIONAL = "China";
  public static final String AUTHOR = "zzz";
  public void syachina();
  public String sayhello(String name,int age);
}

class person implements china
{
   private String name;
   private int age;
   public person(){}
   public person(String name)
   {this.name=name;}
   public person(String name,int age)
   {
      this.name=name;
      this.age=age;
   }
   public void setname(String name)
   {
      this.name=name;
   }
   public void setage(int age)
   {
      this.age=age;
   }
   public String getname()
   {return this.name;}
   public int getage()
   {return this.age;}
   //复写接口方法
   public void syachina()
   {
      System.out.println("zuozhe:"+AUTHOR+" coun:"+NATIONAL); 
   }
   public String sayhello(String name,int age)
   {
      return name+":hello,my age="+age;
   }
}

1）取得类所实现的全部接口
因为一个类可以同时实现几个接口，所以将以一个数组的形式返回全部接口
public class fan
{
   public static void main(String args[])
   {
      Class<?> c1=null;
      try
      {
        c1 = Class.forName("org.lxh.fan.person");//通过forName()方法实例化
      }
      catch(Exception e)
      {
        e.printStackTrace();
      }
      Class<?> c[]=c1.getInterfaces();//以一个数组的形式返回实现的全部接口
      for(int i=0;i<c.length;i++)
      {
         //输出接口名称
         System.out.println("Inter="+c[i].getName());
      }
   }
}

2）取得类所继承的父类
Class<?> c2=c1.getSuperclass();//取得父类
System.out.println("super="+c2.getName());

3）取得类中的全部构造方法
import java.lang.reflect.*;
(1)
//取得所有的构造方法
      Constructor<?> con[]=c1.getConstructors();
      for(int i=0;i<con.length;i++)
      {
         //输出接口名称
         System.out.println("construct="+con[i]);
      }

(2)具体里面还可以取得该构造方法的
con[i].getModifiers();修饰符
con[i].getName();名称
Class<?> p[]=con[i].getParameterTypes()参数的类型

//自定义输出结构         
      for(int i=0;i<con.length;i++)
      {
         Class<?> p[] = con[i].getParameterTypes(); 
         System.out.println(con[i].getModifiers() + " ") ;// 得到修饰符
	 System.out.println(con[i].getName()) ;	// 取得构造方法的名字
	 System.out.print("(") ;
	 for(int j=0;j<p.length;j++)//参数的类型
	{
		System.out.print(p[j].getName() + " arg" + i) ;
		if(j<p.length-1)
                {
			// 判断此是否是最后一个参数
			System.out.print(",");	// 输出“,”
		}
	}
	System.out.println("){}") ; 
      }

(3)由于这样打印的修饰符为1,2,3，不直观看。因此要把他反编译回来
// 得到修饰符
System.out.println(Modifier.toString(con[i].getModifiers()) + " ") ;

4）取得类中的全部方法
//取得本类的所有方法
      Method m[]=c1.getDeclaredMethods(); 
      for(i=0;i<m.length;i++)
      {         
          Class<?> r = m[i].getReturnType();//得到返回值
          Class<?> r2[] = m[i].getParameterTypes();//得到全部参数的类型  
          // 得到修饰符
          System.out.println(Modifier.toString(m[i].getModifiers()) + " ") ;
          System.out.print(r + " ") ;
	  System.out.print(m[i].getName()) ;
	  System.out.print("(") ;
	  for(int j=0;j<p.length;j++)
          {
		System.out.print(p[j].getName() + " " + "arg" + j) ;
		if(j<p.length-1){
			System.out.print(",") ;
		}
	}
      }

//取得所有类的所有方法
      Method m[]=c1.getMethods(); 

5）取得全部异常信息
Class<?> r = m[i].getExceptionTypes();

6)取得属性信息
Field f[] = c1.getFields() ;	// 取得本类中的公共属性
for(int i=0;i<f.length;i++){
	Class<?> r = f[i].getType() ;	// 得到属性类型
	int mo = f[i].getModifiers() ;	// 得到修饰符的数字
	String priv = Modifier.toString(mo) ; // 还原修饰符
	System.out.print("公共属性：") ;
	System.out.print(priv + " ") ;	
	System.out.print(r.getName() + " ") ;	// 得到属性类型
	System.out.print(f[i].getName()) ;	// 输出属性名称
	System.out.println(" ;") ;
}

Field f[] = c1.getDeclaredFields() ;	// 取得本类中的属性


3.反射的使用方法
1)通过反射调用类中的方法
(1)调用无参数的方法
public static void main(String args[])
   {
      Class<?> c1=null;
      try
      {
        c1 = Class.forName("org.lxh.fan.person");//通过forName()方法实例化
      }
      catch(Exception e)
      {
        e.printStackTrace();
      }
      try
      {
        Method met = c1.getMethod("syachina");//找到syachina方法
        met.invoke(c1.newInstance());//调用方法 
      }
      catch(Exception e)
      {
        e.printStackTrace();
      }
   }

(2)调用有参数的方法
Method met = c1.getMethod("sayhello",String.class,int.class);//找到syachina方法
String rr=null;//设返回值
rr=(String)met.invoke(c1.newInstance(),"aaa",23);//调用方法 
System.out.println(rr);

2）调用类setter以及getter
setter以及getter是属性的访问方法
public static void main(String args[])
   {
      Class<?> c1=null;
      Object obj=null;
      try
      {
        c1 = Class.forName("org.lxh.fan.person");//通过forName()方法实例化
      }
      catch(Exception e)
      {
        e.printStackTrace();
      }
      try
      {
        obj=c1.newInstance();
      }
      catch(Exception e)
      {
        e.printStackTrace();
      }
      System.out.println(initstr("helloo"));
      setter(obj,"name","ppod",String.class); 
      setter(obj,"age",22,int.class); 
      getter(obj,"name");
      getter(obj,"age"); 
   }
   //得到字符串
   public static String initstr(String old)
   {
      return old;
   } 
   //设置属性值
   /**
		Object obj：要操作的对象
		String att：要操作的属性
		Object value：要设置的属性内容
		Class<?> type：要设置的属性类型
	*/ 
   public static void setter(Object obj,String att,Object value,Class<?> type)
   {
      try
      {
      Method met=obj.getClass().getMethod("set"+initstr(att),type);//反射到类的方法
      met.invoke(obj,value);//设置setter的内容，执行函数
      }catch(Exception e){
	 e.printStackTrace() ;
      }
   }
   //得到属性值
   public static void getter(Object obj,String att)
   {
      try
      {
      Method met=obj.getClass().getMethod("get"+initstr(att));//反射到类的方法
      System.out.println(met.invoke(obj));//设置getter的内容，执行函数
      }catch(Exception e){
	 e.printStackTrace() ;
      }
   }

3）操作属性，不需要通过setter以及getter进行复杂操作
在访问属性的时候，必须让这个属性可见
 Class<?> c1=null;
      Object obj=null;
      c1=Class.forName("org.lxh.fan.person");//实例化class对象
      obj=c1.newInstance();
      Field nameField=null;
      Field ageField=null;
      nameField=c1.getDeclaredField("name"); 
      ageField=c1.getDeclaredField("age");
      nameField.setAccessible(true);//将属性设为对外可见 
      ageField.setAccessible(true);//将属性设为对外可见 
      nameField.set(obj,"ddk"); 
      ageField.set(obj,21);
      System.out.println(nameField.get(obj)+" "+ageField.get(obj));

4）操作数组
(1)读取和设置数组数据
int temp[] = {1,2,3} ;// 声明一整型数组
Class<?> c = temp.getClass().getComponentType() ;	// 取得数组的Class对象
System.out.println("类型：" + c.getName()) ;	// 取得数组类型名称
System.out.println("长度：" + Array.getLength(temp)) ;
System.out.println("第一个内容：" + Array.get(temp,0)) ;
Array.set(temp,0,6) ;
System.out.println("第一个内容：" + Array.get(temp,0)) ;

(2)修改数组的大小
 public static void main(String args[]) throws Exception
   {
      int temp[]={1,2,3};
      int newtemp[]=(int [])arrayInc(temp,5);//重新开辟一个数组
      print(newtemp);
      String t[] = {"lxh","mldn","mldnjava"} ;
      String nt[] = (String [])arrayInc(t,8) ;
      print(nt) ;
   }
   public static Object arrayInc(Object obj,int len)
   {
      Class<?> c=obj.getClass().getComponentType();//取得数组的class对象
      Object newobj=Array.newInstance(c,len);//开辟新的大小的数组
      System.arraycopy(obj,0,newobj,0,Array.getLength(obj));//拷贝数组内容
      return newobj; 
   }  
   public static void print(Object obj)
  {	// 数组输出
	Class<?> c = obj.getClass() ;
	if(!c.isArray())
	{	// 判断是否是数组
		return;
	}
	Class<?> arr = c.getComponentType() ;
	System.out.println(arr.getName()+"数组的长度是：" + Array.getLength(obj)) ;	 // 输出数组信息
	for(int i=0;i<Array.getLength(obj);i++){
		System.out.print(Array.get(obj,i) + "、") ;	// 通过Array输出
	}
    }	


5)动态代理机制
从前的是静态代理，即一个代理类只能为一个接口服务。如果有很多接口时，就需要很多代理类。因此需要用动态代理，一个代理类可以为多个接口服务
Proxy类，是专门完成代理的类，可以通过此类为一个或者多个接口动态的生成实现类
newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
loader:类加载器
interfaces得到全部的接口
InvocationHandler得到InvocationHandler接口的子类实例
import java.lang.reflect.*;
interface Subject{
	public String say(String name,int age) ;	// 定义抽象方法say
}
class RealSubject implements Subject{	// 实现接口
	public String say(String name,int age){
		return "姓名：" + name + "，年龄：" + age ;
	}
};
class invo implements InvocationHandler//动态代理
{
  private Object obj;
  public Object bind(Object obj)//绑定一个真实主体类
  {
     this.obj=obj;//绑定一个真实主体类
     //返回动态代理
     return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),this);
  }
  //复写执行动态代理方法
  public Object invoke(Object proxy,Method method,Object[] args) throws Throwable
  {
	Object temp = method.invoke(this.obj,args) ;	// 调用方法
	return temp ;
  }
}

public class proxy
{
	public static void main(String args[])
        {
		Subject sub = (Subject)new invo().bind(new RealSubject());
                String info=sub.say("dds",32);
		System.out.println(info) ;
	}
}

6）动态工厂设计模式
静态工厂设计模式存在问题，如果扩充了一个子类，则就要修改工厂类
(1)动态工厂设计模式：
interface Fruit{
	public void eat() ;	// 吃水果
}
class Apple implements Fruit{
	public void eat(){			// 覆写eat()方法
		System.out.println("** 吃苹果");
	}
};
class Orange implements Fruit{
	public void eat(){
		System.out.println("** 吃橘子") ;
	}
};

class Factory
{
   public static Fruit getInstance(String className)
  {
     Fruit fruit=null;
     try
     {  
         fruit = (Fruit)Class.forName(className).newInstance() ;
     }
     catch(Exception e)
     {
	 e.printStackTrace() ;
     }
     return fruit;
  }
}

public class proxy
{
	public static void main(String args[])
        {
		Fruit f = Factory.getInstance("Apple") ;
		if(f!=null)
               {
			f.eat() ;
		}		
	}
}
以上程序使用时需要完整的包.类路径，还是麻烦。所以，可以通过配置文件来保存这些
完整的类路径

(2)结合属性文件的工厂模式
package org.lxh.demo;
import java.util.*;
import java.io.*;
interface Fruit{
	public void eat() ;	// 吃水果
}
class Apple implements Fruit{
	public void eat(){			// 覆写eat()方法
		System.out.println("** 吃苹果");
	}
};
class Orange implements Fruit{
	public void eat(){
		System.out.println("** 吃橘子") ;
	}
};
class init
{
   public static Properties getpro()
   {
      Properties pro =new Properties();
      File f=new File("C:\\androaidprj\\fruit.properties");
      try
      {
        if(f.exists())
        {
           pro.load(new FileInputStream(f));//读取属性
        } 
      }
      catch(Exception e)
      {
	 e.printStackTrace() ;
      } 
      return pro;
   }
}
class Factory
{
   public static Fruit getInstance(String className)
  {
     Fruit fruit=null;
     try
     {  
         fruit = (Fruit)Class.forName(className).newInstance() ;
     }
     catch(Exception e)
     {
	 e.printStackTrace() ;
     }
     return fruit;
  }
}

public class proxy
{
	public static void main(String args[])
        {
                Properties pro=init.getpro();
		Fruit f = Factory.getInstance(pro.getProperty("apple"));
		if(f!=null)
               {
			f.eat() ;
		}		
	}
}


*枚举Enum:限制取值的范围
1
enum color
{RED,GREEN,BLUE}//RED实际是枚举的名称，默认的编号是0

public class enumprj
{
   public static void main(String args[])
   {
      color c=color.BLUE;//取出蓝色
      System.out.println(c);
      //取得枚举中的所有内容
      for(color cr:color.values())
      {
         System.out.println(cr);
      }      
   }
   public static void print(color co)
   {
       //使用switch
      switch(co)
      {
          case RED:
             System.out.println("red color");
             break;
      }  
   }
}

得到枚举的成员编号cr.ordinal()

2
1)通过普通构造方法设置内容
enum color
{
   RED("红色"),GREEN("绿色"),BLUE("蓝色");
   private color(String name)//枚举限制对象产生
   {
      this.setname(name);
   }
   private String name;
   public void setname(String name)
   {
     this.name=name;
   }
   public String getname()
   {
     return this.name;
   }
}

public class enumprj
{
   public static void main(String args[])
   {
      //color c=color.BLUE;//取出蓝色
      //System.out.println(c);
      //取得枚举中的所有内容
      for(color cr:color.values())
      {
         System.out.println(cr.ordinal()+cr.name()+"--"+cr.getname());
      }       
   }
}

2)通过枚举设置
enum color{
	RED,GREEN,BLUE ;
        private String name;
    public void setname(String name)
    {
        switch(this){	// 判断操作的是那个枚举对象
			case RED:{
				if("红色".equals(name)){
					this.name = name ;	// 允许设置名字
				}else{
					System.out.println("设置内容错误。") ;
				}
				break ;
			}
			case GREEN:{
				if("绿色".equals(name)){
					this.name = name ;	// 允许设置名字
				}else{
					System.out.println("设置内容错误。") ;
				}
				break ;
			}
			case BLUE:{
				if("蓝色".equals(name)){
					this.name = name ;	// 允许设置名字
				}else{
					System.out.println("设置内容错误。") ;
				}
				break ;
			}
		}
		this.name = name ;
    } 
    public String getname(){
		return this.name ;
	}   
}

public class enumprj
{
   public static void main(String args[])
   {
      color c=color.BLUE;//得到蓝色
      c.setname("蓝色");
      System.out.println(c.getname());
         //System.out.println(c.name()+"--"+des.get(c));//根据枚举对象找到枚举内容   
   }
}

3）或者通过反射，得到蓝色的对象
color c=color.valueOf(color.Class,"BLUE");//得到蓝色




3枚举的排序：按序号进行排序的操作
enum Color{
	RED,GREEN,BLUE ;
}
public class ComparableEnum{
	public static void main(String args[]){
		Set<Color> t = new TreeSet<Color>() ;	// 设置类型
		t.add(Color.GREEN) ;	// 加入绿色
		t.add(Color.RED) ;		// 加入红色
		t.add(Color.BLUE) ;		// 加入蓝色
		Iterator<Color> iter = t.iterator() ;
		while(iter.hasNext()){
			System.out.print(iter.next() + "、") ;
		}
	}
};

4类集对枚举的支持
1)EnumMap
import java.util.*;
enum Color{
	RED,GREEN,BLUE ;          
}

public class enumprj
{
   public static void main(String args[])
   {
      Map<Color,String> desc=new EnumMap<Color,String>(Color.class);//实例化对象
      desc.put(Color.RED,"红色") ;
		desc.put(Color.GREEN,"绿色") ;
		desc.put(Color.BLUE,"蓝色") ;
		System.out.println("====== 输出全部的内容 ======") ;
		for(Color c:Color.values()){
			System.out.println(c.name() + " --> " + desc.get(c)) ;
		}
		System.out.println("====== 输出全部的键值 ======") ;
		for(Color c:desc.keySet()){
			System.out.print(c.name() + "、") ;
		}
		System.out.println() ;
		System.out.println("====== 输出全部的内容 ======") ;
		for(String s:desc.values()){
			System.out.print(s + "、") ;
		}
   }
}
2)EnumSet
(1)将全部的集合设置到EnumSet中
import java.util.*;
enum Color{
	RED,GREEN,BLUE ;          
}

public class enumprj
{
   public static void main(String args[])
   {
      EnumSet<Color> es = null ;// 声明一个EnumSet对象
      es=EnumSet.allOf(Color.class);//将枚举的全部类型设置到EnumSet中
      print(es);
   }
   public static void print(EnumSet<Color> temp)//输出
   {
      for(Color c:temp){		//  循环输出EnumSet中的内容
		System.out.print(c + "、") ;
	}
	System.out.println() ;
   }  
}

输出RED,GREEN,BLUE

(2)只设置一个内容到集合中
es=EnumSet.of(Color.BLUE);
输出BLUE

（3）可能有多个类型的枚举对象，但只能放入指定枚举类型的集合
es=EnumSet.noneOf(Color.class);//将枚举的全部类型设置到EnumSet中
      es.add(Color.RED);
      es.add(Color.BLUE);
输出RED,BLUE

(4)只能放入不包含指定枚举类型的集合
es=EnumSet.noneOf(Color.class);//将枚举的全部类型设置到EnumSet中
      es.add(Color.RED);
      es.add(Color.BLUE);
ac=EnumSet.complementOf(es);

输出GREEN

（5）拷贝一个集合的内容
es=EnumSet.noneOf(Color.class);//将枚举的全部类型设置到EnumSet中
      es.add(Color.RED);
      es.add(Color.BLUE);
ac=EnumSet.copyOf(es);

5.枚举实现一个接口
interface Print{
	public String getColor() ;
}
enum Color implements Print{
	RED{
		public String getColor(){
			return "红色" ;
		}
	},GREEN{
		public String getColor(){
			return "绿色" ;
		}
	},BLUE{
		public String getColor(){
			return "蓝色" ;
		}
	} ;
}
public class InterfaceEnumDemo{
	public static void main(String args[]){
		for(Color c:Color.values()){
			System.out.print(c.getColor() + "、") ;
		}
	}
};

6.在枚举中定义抽象方法
enum Color implements Print{
	RED{
		public String getColor(){
			return "红色" ;
		}
	},GREEN{
		public String getColor(){
			return "绿色" ;
		}
	},BLUE{
		public String getColor(){
			return "蓝色" ;
		}
	} ;
	public abstract String getColor() ;
}
public class AbstractMethodEnum{
	public static void main(String args[]){
		for(Color c:Color.values()){
			System.out.print(c.getColor() + "、") ;
		}
	}
};


*Annotation:使用注释的方式加入一些程序的信息
import java.lang.annotation.*;
1.系统内定的Annotation
1)@Override
class Person{
	public String getInfo(){		// 取得信息
		return "这是一个Person类。" ;
	}
};
class Student extends Person{	// 继承此类
	@Override
	public String getinfo(){	// 覆写方法
		return "这是一个Student类。" ;
	}
};
public class OverrideAnnotationDemo01{
	public static void main(String args[]){
		Person per = new Student() ;
		System.out.println(per.getInfo()) ;	// 输出信息
	}
};
此时，有一个问题，如果getInfo不小心写错名字，就不再是复写方法了。而这时编译不会
报错。这就需要@Override，用来指示这个方法是复写父类的方法，如果函数名称写错，
就会报错

2)@Deprecated:表示这个操作已经过时，本身不建议使用，例如旧版本的方法现在不建议使用
(1)方法已过时：
class Demo{
	@Deprecated			// 声明不建议使用的操作
	public String getInfo(){
		return "这是一个Person类。" ;
	}
};
(2)类已过时：
@Deprecated			// 声明不建议使用的操作
class Demo{
	public String getInfo(){
		return "这是一个Person类。" ;
	}
};

3)@SuppressWarnings:已经有警告信息，予以压制不提示
（1）压制一个警告信息
例如泛型，不定义数据类型：
class Demo<T>{
	private T var ;
	public T getVar(){
		return this.var ;
	}
	public void setVar(T var){
		this.var = var ;
	}
};
public class SuppressWarningsAnnotationDemo01{
	@SuppressWarnings("unchecked")//压制一个警告信息
	public static void main(String args[]){
		Demo d = new Demo() ;
		d.setVar("李兴华") ;
		System.out.println("内容：" + d.getVar()) ;
	}
};

(2)压制多个警告信息
@SuppressWarnings({"unchecked","deprecation"})
或者这样写也可以
@SuppressWarnings(value={"unchecked","deprecation"})


2.自定义Annotation
1)设置参数
(1)设置一个参数
@interface annotationparam//定义annotation
{
  String value();//接受设置的内容
}

@annotationparam(value="hhe")
class demo
{}

或者@annotationparam("hhe")

(2)设置两个参数
@interface annotationparam//定义annotation
{
  String value();//接受设置的内容
  String key();
}

@annotationparam(value="hhe",key="dd")

(3)设置参数数组
@interface annotationparam//定义annotation
{
  String[] value();//接受设置的内容 
}

@annotationparam(value={"hhe","dd"})
@annotationparam({"hhe","dd"})

(4)指定默认值
@interface annotationparam//定义annotation
{
  String value() default "dd";//接受设置的内容 
  String key() default "kk";
}

@annotationparam

2)有时候会固定取值范围，需要用枚举
enum name//定义枚举类型
{
   MLS,DDW,KL
}

@interface annotationparam//定义annotation
{
  name value() default name.MLS;//接受设置的内容
}

@annotationparam(value=name.DDW)
class demo
{}

3)有效范围
@Retention(value=RetentionPolicy.RUNTIME)//表示此annotation在运行时有效
@interface annotationparam//定义annotation
{
  name value() default name.MLS;//接受设置的内容
}

三个系统设置的只有Depreacted才是运行时有效，因此通过反射只能取得他

3.通过反射使用
1)得到系统调用的
package lang.xld.bj;
import java.lang.annotation.*;
import java.lang.reflect.*;
enum name//定义枚举类型
{
   MLS,DDW,KL
}

@interface annotationparam//定义annotation
{
  name value() default name.MLS;//接受设置的内容
}

@annotationparam(value=name.DDW)
class demo
{
   @Deprecated
   @SuppressWarnings("unchecked")
   //@Override
   public String tostring()
   {return "hello wk";} 
}

public class anno
{
    public static void main(String args[]) throws Exception
    {
       Class<?> c=Class.forName("lang.xld.bj.demo");//反射类
 
       Method tom=c.getMethod("tostring");//得到类的tostring方法
      Annotation an[]= tom.getAnnotations();//取得全部的Annotation
       for(Annotation a:an)
       {
          System.out.println(a);
       }

    }
}

得到@java.lang.Deprecated()

2)得到自定义的
package lang.xld.bj;
import java.lang.annotation.*;
import java.lang.reflect.*;
enum name//定义枚举类型
{
   MLS,DDW,KL
}

@Retention(value=RetentionPolicy.RUNTIME)//在类执行时有效
@interface annotationparam//定义annotation
{
  String key() default "dlw";
  name value() default name.MLS;//接受设置的内容  
}

@annotationparam(value=name.DDW)
class demo
{
   @Deprecated
   @SuppressWarnings("unchecked")
   //@Override
   @annotationparam(key="pl",value=name.DDW)
   public String tostring()
   {return "hello wk";} 
}

public class anno
{
    public static void main(String args[]) throws Exception
    {
       Class<?> c=Class.forName("lang.xld.bj.demo");//反射类
 
       Method tom=c.getMethod("tostring");//得到类的tostring方法

       Annotation an[]= tom.getAnnotations();//取得全部的Annotation
       for(Annotation a:an)
       {
          System.out.println(a);
       }

       //判断是否是制定的Annotation
       if(tom.isAnnotationPresent(annotationparam.class))
       {
          annotationparam mda=tom.getAnnotation(annotationparam.class);
          String key=mda.key();
          name value=mda.value();
          System.out.println("key="+key+",value="+value);
       }
    }
}

4.其他Annotation
1)@Target制定使用范围
@Target(ElementType.TYPE)//此Annotation只能用在类上
@Retention(value=RetentionPolicy.RUNTIME)//在类执行时有效
@interface annotationparam//定义annotation
{
  String key() default "dlw";
  name value() default name.MLS;//接受设置的内容  
}

@Target({ElementType.TYPE,ElementType.METHOD})//此Annotation能用在类上,方法上

2)@Documented
@Documented
@interface annotationparam//定义annotation
{
  String key() default "dlw";
  name value() default name.MLS;//接受设置的内容  
}

class demo
{
   @Deprecated
   @SuppressWarnings("unchecked")
   //@Override
   /*
   *    @Documented对象开始调用
   */
   @annotationparam(key="pl",value=name.DDW)
   public String tostring()
   {return "hello wk";} 
}

通过javadoc -d doc anno.java生成说明文档

3)@Inherited：这个Annotation是否可以被继承下来
package lang.xld.bj;
import java.lang.annotation.*;
import java.lang.reflect.*;
enum name//定义枚举类型
{
   MLS,DDW,KL
}

@Inherited
@Documented
@Retention(value=RetentionPolicy.RUNTIME)//在类执行时有效
@interface annotationparam//定义annotation
{
  String key() default "dlw";
  name value() default name.MLS;//接受设置的内容  
}

@annotationparam(value=name.DDW)
class demo
{
   @Deprecated
   @SuppressWarnings("unchecked")
   //@Override
   /*
   *    @Documented对象开始调用
   */
   @annotationparam(key="pl",value=name.DDW)
   public String tostring()
   {return "hello wk";} 
}

//子类，也继承了@annotationparam(key="pl",value=name.DDW)
class stu extends demo
{
  public String tostring()
   {return "hello dds";} 
}

public class anno
{
    public static void main(String args[]) throws Exception
    {       
       Class<?> c2=Class.forName("lang.xld.bj.stu");//反射子类
       Annotation an2[]= c2.getAnnotations();//取得全部的Annotation
       for(Annotation a:an)
       {
          System.out.println(a);
       }
       
    }
}

//**********
//数据库编程
//**********
*JDBC概述:Java数据库连接
JDBC-ODBC：性能低，一般情况下不使用
纯JDBC连接：提供的接口标准需要相应的数据库生产商配合实现，他是以一组jar包，或者
            zip包的形式出现，如果要使用，需要配置classpath
网络的JDBC连接:不使用
使用方法：
DriverManager:取得一个数据库的连接
Connection:每一个实例化对象表示一个数据库连接
数据库操作：Statement,PreparedStatement
数据库查询:ResultSet
用存储过程:CallableStatement

*MySql:从www.mysql.com中下载,安装，完了直接打开COnfiguration Wizard。
1.配置：一直下一步->Port Number:写3306->
选择Manual Selected...,
Character Set:选择gbk。（即使用手工方式配置，数据库编码使用gbk）
->
选择打钩Install as windows..,
Service Name:MySQL
选择打钩Launch the MySQL...
选择打钩Include Bin Direc....
->
新建密码:admin
->完成,重启系统

2.连接
cmd->mysql -uroot -padmin
输入?,可以查看所有命令

3.使用
create database 数据库;
drop   database 数据库;
use    数据库;
DROP TABLE user ;	-- 删除表
CREATE TABLE user
(
	id		INT		AUTO_INCREMENT PRIMARY KEY ,
	name		VARCHAR(30)	NOT NULL ,
	password 	VARCHAR(32)	NOT NULL ,
	age		INT		NOT NULL ,
	sex		VARCHAR(2)	DEFAULT '男' ,
	birthday	DATETIME,
    classTime DATETIME NOT NULL DEFAULT getdate()               //针对sql
    classTime TIMESTAMP default (datetime('now', 'localtime')) 	//针对sqlite
) ;

TIMESTAMP：在创建新记录和修改现有记录的时候都对这个数据列刷新。
显示格式：YYYY-MM-DD HH:MM:SS
时间范围:[ '1970-01-01 00:00:00'到'2037-12-31 23:59:59']

DATE：显示格式：YYYY-MM-DD
DATETIME：显示格式：YYYY-MM-DD HH:MM:SS


INSERT INTO user(name,password,age,sex,birthday) VALUES ('李兴华','www.mldn.cn',30,'男','2008-08-27') ;
INSERT INTO user(name,password,age,sex,birthday) VALUES ('李康','www.mldnjava.cn',23,'女','2005-08-27') ;


DELETE FROM user WHERE id=3 ;

UPDATE user SET name='MLDN',age=5,birthday='2000-08-27' WHERE id=4 ;

SELECT name,birthday FROM user ;

SELECT * FROM user WHERE name LIKE '%m%' OR password LIKE '%m%' ;//姓名包含m的

//姓名包含m的,结果从第10条开始，往下选5条
SELECT * FROM user WHERE name LIKE '%m%' OR password LIKE '%m%' LIMIT 10,5 ;

想查看表的样子desc user
查看有多少个数据库show database;
查看目前数据库中有多少张表show tables

*sqllite时间字段添加以及查询
添加
insert into vmc_order_pay
(ordereID,payType,payStatus,RealStatus,smallNote,smallConi,smallAmount,
smallCard,shouldPay,shouldNo,realNote,realCoin,realAmount,debtAmount,realCard,payTime) 
values('0001',0,0,1,1,1,1,1,1,1,1,1,1,
1,1,(datetime('now', 'localtime')))//这个用来添加当前时间

查找时间范围内的数据
例如：要搜索2015-05-20时间的数据，有三种方法
select * FROM [vmc_order_pay] where payTime between '2015-05-19' and '2015-05-21'
select * FROM [vmc_order_pay] where payTime between '2015-05-19 0:0:0' and '2015-05-20 16:45:48'
select * FROM [vmc_order_pay] where payTime between datetime('now','localtime','-1 day')  and datetime('now','localtime','+0 day')


*使用MySql:
import java.sql.*;
1.配置驱动程序到java
从www.mysql.com中下载->Downloads->MySQL Connectors->Connector/J
->mysql-connector-java-5.1.30-bin.jar放到C盘下
->添加ClassPath:C:\mysql-connector-java-5.1.30-bin.jar;
2.程序中加载驱动程序
public class data
{
   //定义mysql的数据库驱动程序
   public static final String DRV="org.gjt.mm.mysql.Driver";
   public static void main(String args[])
   {
      try
      {
          Class.forName(DRV);//加载驱动程序
      }
      catch(Exception e)
      {
         e.printStackTrace();
      }
   }
}


如果出现了以下错误：..ClassNotFoundEx..:org.gjt.mm.mysql.Driver
说明classpath配置出错

3.连接以及关闭数据库
import java.sql.*;
public class data
{
   //定义mysql的数据库驱动程序
   public static final String DBDRV="org.gjt.mm.mysql.Driver";
   // 定义MySQL数据库的连接地址
   public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
   // MySQL数据库的连接用户名
   public static final String DBUSER = "root" ;
   // MySQL数据库的连接密码
   public static final String DBPASS = "admin" ;
   public static void main(String args[])
   {
      Connection conn = null ;		// 数据库连接
	try{
		Class.forName(DBDRV) ;	// 加载驱动程序
	}catch(ClassNotFoundException e){
		e.printStackTrace() ;
	}
	try{
		conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;
	}catch(SQLException e){
		e.printStackTrace() ;
	}
	System.out.println(conn) ;	// 如果此时可以打印表示连接正常
	try{
		conn.close() ;			// 数据库关闭
	}catch(SQLException e){
		e.printStackTrace() ;
	}
   }
}

4.操作数据库
1)修改数据库
import java.sql.*;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "" ;
	public static void main(String args[]) throws Exception
        {
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                Statement stmt=null;            //数据库操作
                String sql="insert into user(name,password,age,birthday) values('张三','2334',23,'2013-1-29')";
                //动态写
                String name="wang5";
                String sql2="insert into user(name,password,age,birthday) values('"+name+"','2334',23,'2013-1-29')";
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接			
		System.out.println(conn) ;	// 如果此时可以打印表示连接正常	
 
                //添加,修改,删除表数据的操作
                stmt=conn.createStatement();
                stmt.executeUpdate(sql);  
                stmt.executeUpdate(sql2); 
                stmt.close();//关闭操作              	
		conn.close() ;		// 数据库关闭		
	}
};

2).查询数据库
import java.sql.*;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "" ;
	public static void main(String args[]) throws Exception
        {
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                Statement stmt=null;            //数据库操作
                ResultSet rs=null;              //保存查询结果
                //查询数据表语句
                String sql="select id,name,password,age,sex,birthday from user";                
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接	
                //查询表数据的操作
                stmt=conn.createStatement();
                rs=stmt.executeQuery(sql);
                while(rs.next())
               {	// 依次取出数据
			int id = rs.getInt("id") ;	// 取出id列的内容
			String name = rs.getString("name") ;	// 取出name列的内容
			String password = rs.getString("password") ; // 取出password列的内容
			int age = rs.getInt("age") ;	// 取出age列的内容
			String sex = rs.getString("sex") ;	// 取出sex列的内容
			java.util.Date d = rs.getDate("birthday") ; // 取出birthday列的内容
			System.out.print("编号：" + id + "；") ;
			System.out.print("姓名：" + name + "；") ;
			System.out.print("密码：" + password + "；") ;
			System.out.print("年龄：" + age + "；") ;
			System.out.print("性别：" + sex + "；") ;
			System.out.println("生日：" + d + "；") ;
			System.out.println("-----------------------") ;
		} 
                rs.close();
                stmt.close();//关闭操作              	
		conn.close() ;		// 数据库关闭		
	}
};

5.PreparedStatement:预占用，像占座，人其实还没到。一般都是使用这个而不用Statement，因为Statement不安全，会产生注入式漏洞
1）操作
import java.sql.*;
import java.text.SimpleDateFormat;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "" ;
	public static void main(String args[]) throws Exception
        {
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                PreparedStatement stmt=null;            //数据库操作
                //ResultSet rs=null;              //保存查询结果
                //查询数据表
                String name="zhao6";
                String password="223";
                int age=15;
                String sex="女";
                //得到时间
                String birthday="2013-02-03";
                java.util.Date temp=new SimpleDateFormat("yyyy-mm-dd").parse(birthday);
                java.sql.Date bir=new java.sql.Date(temp.getTime());  
                //sql语句
                String sql="insert into user(name,password,age,sex,birthday) values(?,?,?,?,?)";               
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接	
                //查询表数据的操作
                stmt=conn.prepareStatement(sql);
                stmt.setString(1,name);
                stmt.setString(2,password); 
                stmt.setInt(3,age);
                stmt.setString(4,sex);
                stmt.setDate(5,bir);                
                stmt.executeUpdate();//操作  
                stmt.close();            	
		conn.close() ;		// 数据库关闭		
	}
};

2)查询
import java.sql.*;
import java.text.SimpleDateFormat;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "" ;
	public static void main(String args[]) throws Exception
        {
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                PreparedStatement stmt=null;            //数据库操作
                ResultSet rs=null;              //保存查询结果
                //查询数据表
                String key="z";
                //sql语句
                String sql="select id,name,password,age,sex,birthday from user where name like ?";               
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接	
                //查询表数据的操作
                stmt=conn.prepareStatement(sql);
                stmt.setString(1,"%"+key+"%");//通配符
                rs=stmt.executeQuery();//查询操作  
                while(rs.next())
               {	// 依次取出数据
			int id = rs.getInt("id") ;	// 取出id列的内容
			String name = rs.getString("name") ;	// 取出name列的内容
			String password = rs.getString("password") ; // 取出password列的内容
			int age = rs.getInt("age") ;	// 取出age列的内容
			String sex = rs.getString("sex") ;	// 取出sex列的内容
			java.util.Date d = rs.getDate("birthday") ; // 取出birthday列的内容
			System.out.print("编号：" + id + "；") ;
			System.out.print("姓名：" + name + "；") ;
			System.out.print("密码：" + password + "；") ;
			System.out.print("年龄：" + age + "；") ;
			System.out.print("性别：" + sex + "；") ;
			System.out.println("生日：" + d + "；") ;
			System.out.println("-----------------------") ;
		} 
                rs.close();
                stmt.close();            	
		conn.close() ;		// 数据库关闭		
	}
};


6.处理大数据对象
CLOB存储海量文字，比如一本书。BLOB存储二进制数据，比如图片，视频等。要通过流进行处理.
但是一般情况下不建议这样做，往往采用映射路径方式进行操作

1)处理CLOB数据：LONGTEXT类型表示大文本数据,他最大数据量为4G
创建一个数据表
create table userclob
(
  id   int   auto_increment primary key,
  name varchar(30) not null,
  note  longtext    
)

（1）写入
import java.sql.*;
import java.io.*;
import java.text.SimpleDateFormat;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "admin" ;
	public static void main(String args[]) throws Exception
        {
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                PreparedStatement stmt=null;            //数据库操作
                //ResultSet rs=null;              //保存查询结果
                //查询数据表
                String name="kingkong";
                //sql语句
                String sql="insert into userclob(name,note) values(?,?)"; 
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接	
                //查询表数据的操作
                stmt=conn.prepareStatement(sql);
                stmt.setString(1,name);
                File f=new File("test.java");
                InputStream input=new FileInputStream(f);
                stmt.setAsciiStream(2,input,(int)f.length());                 
                stmt.executeUpdate();//操作  
                stmt.close();            	
		conn.close() ;		// 数据库关闭		
	}
};


(2)读取
import java.sql.*;
import java.io.*;
import java.util.Scanner;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "admin" ;
	public static void main(String args[]) throws Exception
        {
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                PreparedStatement stmt=null;            //数据库操作
                ResultSet rs=null;              //保存查询结果
                //查询数据表
                int id=2;
                //sql语句
                String sql="select name,note from userclob where id=?"; 
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接	
                //查询表数据的操作
                stmt=conn.prepareStatement(sql);
                stmt.setInt(1,id);
                rs= stmt.executeQuery();//操作  
                if(rs.next())
                {
                    String name=rs.getString(1);
                    System.out.println(name+"--->"); 
                    StringBuffer note=new StringBuffer();
                    InputStream input=rs.getAsciiStream(2);
                    Scanner scan=new Scanner(input);//读取内容
                    scan.useDelimiter("\r\n");//将文件换行作为分割符
                    while(scan.hasNext())
                    {
                       note.append(scan.next()).append("\n");
                    }
                    System.out.println(note);
                    input.close(); 
                }                  
                rs.close();
                stmt.close();            	
		conn.close() ;		// 数据库关闭		
	}
};


（3）上面的读取太复杂了，使用clob类进行简单读取
rs= stmt.executeQuery();//操作  
if(rs.next())
                {
                    String name=rs.getString(1);
                    System.out.println(name+"--->"); 
                    Clob c= rs.getClob(2);
                    //也可以截取部分数据
                    String note=c.getSubString(1,(int)c.length()); 
                    System.out.println(note+"<part---->");
                    //读取部分内容
                    c.truncate(100);//读100个内容
                    System.out.println(c.getSubString(1,(int)c.length()));  
                }  


2)处理BLOB数据：LONGBLOB类型表示大图像二进制数据,他最大数据量为4G
创建一个数据表
create table userblob
(
  id   int   auto_increment primary key,
  name varchar(30) not null,
  photo  longblob    
)

(1)读取
import java.sql.*;
import java.io.*;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "admin" ;
	public static void main(String args[]) throws Exception
        {                
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                PreparedStatement stmt=null;            //数据库操作
                //ResultSet rs=null;              //保存查询结果
                //查询数据表
                String name="king";
                //sql语句
                String sql="insert into userblob(name,photo) values(?,?)";
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接	
                //查询表数据的操作
                stmt=conn.prepareStatement(sql);
                stmt.setString(1,name);
                File f=new File("chris.jpg");//图片文件
                InputStream input=new FileInputStream(f);
                stmt.setBinaryStream(2,input,(int)f.length());                 
                stmt.executeUpdate();//操作  
                stmt.close();            	
		conn.close() ;		// 数据库关闭	                
	}
};

(2)写入
rs = pstmt.executeQuery() ;	// 执行查询
		if(rs.next()){
			String name = rs.getString(1) ;
			System.out.println("姓名：" + name) ;
			InputStream input = rs.getBinaryStream(2) ;
			File f = new File("d:" + File.separator + "loadmldn.gif") ;	// 图片文件
			OutputStream out = null ;
			out = new FileOutputStream(f) ;
			int temp = 0 ;
			while((temp=input.read())!=-1){	// 边读边写
				out.write(temp) ;
			}
			input.close() ;
			out.close() ;
		}
		pstmt.close() ;
		conn.close() ;			// 数据库关闭

（3）上面的读取太复杂了，使用blob类进行简单读取
if(rs.next()){
			String name = rs.getString(1) ;
			System.out.println("姓名：" + name) ;
			Blob b = rs.getBlob(2) ;
			File f = new File("d:" + File.separator + "loadmldn.gif") ;	// 图片文件
			OutputStream out = null ;
			out = new FileOutputStream(f) ;
			out.write(b.getBytes(1,(int)b.length())) ;
			out.close() ;
		}


7.存储过程的操作:CallableStatement
1)存储过程写法
DELIMITER //  先把分号符改为//
create procedure myproc(in p1 int,inout p2 int,out p3 int)
begin
    select p1,p2,p3;
    set p1=10;
    set p2=20;
    set p3=30;  
end//
说明p1是输入,p2是输入输出,p3是输出
DELIMITER ;把分割符改为;

使用：
set @x1=70;
set @x2=80;
call myproc(@x1,@x2,@x3);
select @x1,@x2,@x3;

2)通过程序使用
import java.sql.*;
public class data{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "org.gjt.mm.mysql.Driver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:mysql://localhost:3306/mldn" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "root" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "admin" ;
	public static void main(String args[]) throws Exception
        {                
		Class.forName(DBDRIVER) ;	// 加载驱动程序		
                CallableStatement cstmt=null;   //存储过程操作
                //sql语句
                String sql="{CALL myproc(?,?,?)}";
		Connection conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;// 数据库连接	
                //存储过程的操作
                cstmt=conn.prepareCall(sql);
                //输入参数
                cstmt.setInt(1,70);
                cstmt.setInt(2,80);   
                //输出参数
                cstmt.registerOutParameter(2,Types.INTEGER); 
                cstmt.registerOutParameter(3,Types.INTEGER);            
                cstmt.execute();//操作 
                System.out.println("p2="+cstmt.getInt(2)+" p3="+cstmt.getInt(3)); 
                cstmt.close();            	
		conn.close() ;		// 数据库关闭	                
	}
};


8.JDBC2的新特性：一般情况下不用
1)可滚动的查询结果：这将整张表都加载到内存中，然后选择显示，这消耗内存非常大，一般不用这种方法
//查询表数据的操作,创建可滚动结果集
                stmt=conn.prepareStatement(sql,
			ResultSet.TYPE_SCROLL_SENSITIVE,
			ResultSet.CONCUR_READ_ONLY) ;;
                rs=stmt.executeQuery();//查询操作  
                rs.absolute(1);//定位第二条语句
                print(rs);
                rs.beforeFirst();//定位第一条语句
                print(rs);

public static void print(ResultSet rs)throws Exception
        {
             //while(rs.next())
             rs.next();
               {	// 依次取出数据
			int id = rs.getInt("id") ;	// 取出id列的内容
			String name = rs.getString("name") ;	// 取出name列的内容
			String password = rs.getString("password") ; // 取出password列的内容
			int age = rs.getInt("age") ;	// 取出age列的内容
			String sex = rs.getString("sex") ;	// 取出sex列的内容
			java.util.Date d = rs.getDate("birthday") ; // 取出birthday列的内容
			System.out.print("编号：" + id + "；") ;
			System.out.print("姓名：" + name + "；") ;
			System.out.print("密码：" + password + "；") ;
			System.out.print("年龄：" + age + "；") ;
			System.out.print("性别：" + sex + "；") ;
			System.out.println("生日：" + d + "；") ;
			System.out.println("-----------------------") ;
		} 
        }

2)使用结果集插入操作:一般不用这种方法
String sql = "SELECT id,name,password,age,sex,birthday FROM user WHERE id=?" ;// 此处不需要设置任何的内容
		Class.forName(DBDRIVER) ;	// 加载驱动程序
		conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;
		pstmt = conn.prepareStatement(sql,
			ResultSet.TYPE_SCROLL_SENSITIVE,
			ResultSet.CONCUR_UPDATABLE) ;	// 表示结果集可以更新
		pstmt.setInt(1,4) ;
		rs = pstmt.executeQuery() ;	// 查询操作
		rs.last() ;	// 到最后一行

		rs.updateString("name","李藏") ;	// 设置姓名
		rs.updateString("password","lizang") ;	// 设置密码
		rs.updateInt("age",23) ;	// 设置要插入的年龄
		rs.updateString("sex","女") ;	// 设置要插入的性别
		rs.updateDate("birthday",new java.sql.Date(new java.util.Date().getTime()));
		rs.cancelRowUpdates() ;	// 取消更新
		rs.updateRow() ;	// 真正提交数据

3）插入操作:一般不用这种方法
pstmt = conn.prepareStatement(sql,
			ResultSet.TYPE_SCROLL_SENSITIVE,
			ResultSet.CONCUR_UPDATABLE) ;	// 表示结果集可以更新
		rs = pstmt.executeQuery() ;	// 查询操作
		rs.moveToInsertRow() ;	// 移动到插入的一行
		rs.updateString("name","李华") ;	// 设置姓名
		rs.updateString("password","lixinghua") ;	// 设置密码
		rs.updateInt("age",33) ;	// 设置要插入的年龄
		rs.updateString("sex","女") ;	// 设置要插入的性别
		rs.updateDate("birthday",new java.sql.Date(new java.util.Date().getTime()));
		rs.insertRow() ;	// 真正提交数据

4)删除操作:一般不用这种方法
pstmt = conn.prepareStatement(sql,
			ResultSet.TYPE_SCROLL_SENSITIVE,
			ResultSet.CONCUR_UPDATABLE) ;	// 表示结果集可以更新
		pstmt.setInt(1,2) ;
		rs = pstmt.executeQuery() ;	// 查询操作
		rs.last() ;	// 到最后一行

		rs.deleteRow() ;	// 真正提交数据


5）批处理：执行多条语句，一起提交
pstmt = conn.prepareStatement(sql) ;	// 表示结果集可以更新
		for(int i=0;i<10;i++){
			pstmt.setString(1,"李兴华 - " + i) ;
			pstmt.setString(2,"MLDN - " + i) ;
			pstmt.setInt(3,20 + i) ;
			pstmt.setString(4,"男")  ;
			pstmt.setDate(5,new java.sql.Date(new java.util.Date().getTime())) ;
			pstmt.addBatch() ;	// 加入批处理，等待执行
		}
		int temp[] = pstmt.executeBatch() ;
		System.out.println("更新了" + temp.length + "条数据。") ;


9.事务处理
1)数据库的事务处理
set autocommit=0;//取消自动提交，开启事务处理
begin;
insert into user(name,password,age) values('qian8','112','23');
rollback;//回退
commit;//提交

2)程序中使用事务
Connection conn = null ;		// 数据库连接
		Statement stmt = null ;		// 定义数据库操作
		Class.forName(DBDRIVER) ;	// 加载驱动程序
		conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;
conn.setAutoCommit(false) ;	// 取消掉自动提交

		stmt = conn.createStatement() ;
		stmt.addBatch("INSERT INTO user(name,password,age,sex,birthday)" +
			" VALUES ('LXH-1','hello-1',11,'男','1975-03-05') ") ;
		stmt.addBatch("INSERT INTO user(name,password,age,sex,birthday)" +
			" VALUES ('LXH-2','hello-2',12,'女','1976-03-05') ") ;
		// 加入“'”之后，此SQL语法就出现了错误，所以，肯定执行到此语句的时候出现代码错误
		stmt.addBatch("INSERT INTO user(name,password,age,sex,birthday)" +
			" VALUES ('LXH-'3','hello-3',13,'男','1977-06-01') ") ;
		stmt.addBatch("INSERT INTO user(name,password,age,sex,birthday)" +
			" VALUES ('LXH-4','hello-4',14,'女','1965-03-05') ") ;
		stmt.addBatch("INSERT INTO user(name,password,age,sex,birthday)" +
			" VALUES ('LXH-5','hello-5',15,'女','1965-08-05') ") ;
		try{
			int temp[] = stmt.executeBatch() ;
			System.out.println("更新了：" + temp.length+ "条数据。") ;
			conn.commit() ;	// 所有的操作成功了
		}catch(Exception e){
			try{
				conn.rollback() ;
			}catch(Exception e1){
				
			}
		}
		stmt.close() ;
		conn.close() ;			// 数据库关闭


10.元数据：得到本数据库，或者表的具体结构信息，一般没用
11.用JDBC连接Oracle数据库
1)安装Oracle，完了之后配置JDBC安装驱动
\oracle\product\10\db_1\jdbc\classes12.jar放到环境变量classpath中

2)注意，Oracle连接的时候，会自动配置所有的JRE环境变量，所以如果要使用自己的JRE,就要删除掉Oracle的
进入环境变量classpath
把oracle\product\10\db_1\jre\client;
  oracle\product\10\db_1\jre\bin删除掉

3)程序连接
public class JDBCOracle{
	// 定义MySQL的数据库驱动程序
	public static final String DBDRIVER = "oracle.jdbc.driver.OracleDriver" ;
	// 定义MySQL数据库的连接地址
	public static final String DBURL = "jdbc:oracle:thin:@localhost:1521:MLDN" ;
	// MySQL数据库的连接用户名
	public static final String DBUSER = "scott" ;
	// MySQL数据库的连接密码
	public static final String DBPASS = "tiger" ;
	public static void main(String args[]) throws Exception{	// 所有异常抛出
		Connection conn = null ;		// 数据库连接
		Class.forName(DBDRIVER) ;	// 加载驱动程序
		conn = DriverManager.getConnection(DBURL,DBUSER,DBPASS) ;
		PreparedStatement pstmt = null ;
		String sql = "INSERT INTO person(id,name,age,birthday) VALUES (myseq.nextVal,?,?,?)" ;
		pstmt = conn.prepareStatement(sql) ;
		pstmt.setString(1,"李兴华") ;
		pstmt.setInt(2,30) ;
		pstmt.setDate(3,new java.sql.Date(new java.util.Date().getTime())) ;
		pstmt.executeUpdate() ;	// 执行更新操作
		pstmt.close() ;
		conn.close() ;			// 数据库关闭
	}
};



//****************
//网络编程
//****************
*IP地址：本机地址127.0.0.1，或者localhost
import java.net.*;
public class nete
{
   public static void main(String args[]) throws Exception
   {
      InetAddress localadd=InetAddress.getLocalHost();//本地地址
      //InetAddress netadd=InetAddress.getByName("http://www.baidu.com/");//远程地址
      System.out.println("local="+localadd.getHostAddress());
      //System.out.println("net="+netadd.getHostAddress());
      System.out.println("本机是否访问：" + localadd.isReachable(5000)) ;//给5秒时间，看能否回复本机
   }
}

*URL
1)网页地址:得到该网页地址的源码
import java.net.*;
import java.io.*;
import java.util.*;
public class nete{
	public static void main(String args[]) throws Exception {// 所有异常抛出
		URL url=new URL("http","www.mldnjava.cn",80,"/curriculum.htm");
                InputStream input=url.openStream();//打开输入流
                Scanner scan=new Scanner(input);//实例化
                scan.useDelimiter("\n");//设置读取分隔符
                while(scan.hasNext())
                {   
		    System.out.println(scan.next()) ;
		}
	}
};

2)URLConnection:封装的URL
public static void main(String args[]) throws Exception {// 所有异常抛出
		URL url=new URL("http://www.mldnjava.cn");
                URLConnection urlcon=url.openConnection();//建立连接
                System.out.println("内容大小：" + urlcon.getContentLength()) ;
		System.out.println("内容类型：" + urlcon.getContentType()) ;
	}

3)URL编码和解码：URLEncoder,URLDecoder
网络开发时传递中文，会用到编码和解码
String key="你好";
                String encode=URLEncoder.encode(key,"UTF-8");//编码
                System.out.println("encode="+encode);
                String decode=URLDecoder.decode(encode,"UTF-8");//编码
                System.out.println("decode="+decode);

*TCP
1)简单的网络服务
import java.net.*;
import java.io.*;
public class tcpserver
{
   public static void main(String args[]) throws Exception
   {
       ServerSocket server=null;
       Socket client=null;
       PrintStream out=null;//打印输出流
       server=new ServerSocket(8888);//服务器监听窗口
       System.out.println("服务器运行，等待客户端连接...");
       client = server.accept();//阻塞等待连接

       //客户端连接后，向客户端输出信息 
       String str="hello world"; 
       out = new PrintStream(client.getOutputStream()); 
       out.println(str);//向客户端输出信息
       client.close();
       server.close(); 
   }
}

import java.net.*;
import java.io.*;
public class tcpclient
{
   public static void main(String args[]) throws Exception
   {
       Socket client=new Socket("localhost",8888);
       BufferedReader buf= new BufferedReader(new InputStreamReader(client.getInputStream()));
       String str=buf.readLine();
       System.out.println("服务器端数据="+str);
       client.close();
       buf.close(); 
   }
}

以上客户端服务端只能连接一次，就退出连接了

2)echo程序：客户端向服务端输出信息，服务端向客户端回复信息
import java.net.*;
import java.io.*;
public class tcpserver
{
   public static void main(String args[]) throws Exception
   {
       ServerSocket server=null;
       Socket client=null;
       BufferedReader buf=null;//读取客户端输过来的数据
       PrintStream out=null;//打印输出流
       server=new ServerSocket(8888);//服务器监听窗口
       boolean f=true;
       while(f)
       { 
           System.out.println("服务器运行，等待客户端连接...");       
           client = server.accept();//阻塞等待连接
           out = new PrintStream(client.getOutputStream()); 
           buf= new BufferedReader(new InputStreamReader(client.getInputStream()));//接受客户端输入信息
           String str=buf.readLine();
  
           out.println("ECHO="+str);//向客户端输出信息           
       }
       client.close();
       server.close(); 
   }
}


import java.net.*;
import java.io.*;
public class tcpclient
{
   public static void main(String args[]) throws Exception
   {
       Socket client=new Socket("localhost",8888);
       BufferedReader buf= new BufferedReader(new InputStreamReader(client.getInputStream()));
       BufferedReader input=new BufferedReader(new InputStreamReader(System.in));//接受键盘输入数据
       PrintStream out=new PrintStream(client.getOutputStream());
       boolean flag=true; 
       while(flag)
       { 
          System.out.println("输入信息");
          String str=input.readLine();
          out.println(str);//向服务端输出信息 
       }
       client.close();
       buf.close(); 
   }
}

3）服务端使用多线程处理
import java.net.* ;
import java.io.* ;
public class EchoThread implements Runnable{
	private Socket client = null ;
	public EchoThread(Socket client){
		this.client = client ;
	}
	public void run(){
		BufferedReader buf = null ;	// 接收输入流
		PrintStream out = null ;		// 打印流输出最方便
		try{
			out = new PrintStream(client.getOutputStream()) ;
			// 准备接收客户端的输入信息
			buf = new BufferedReader(new InputStreamReader(client.getInputStream())) ;
			boolean flag = true ;	// 标志位，表示可以一直接收并回应信息
			while(flag){
				String str = buf.readLine() ;		// 接收客户端发送的内容
				if(str==null||"".equals(str)){	// 表示没有内容
					flag = false ;	// 退出循环
				}else{
					if("bye".equals(str)){	// 如果输入的内容为bye表示结束
						flag = false ;
					}else{
						out.println("ECHO : " + str) ;	// 回应信息
					}
				}
			}
			client.close() ;
		}catch(Exception e){}
		
	}
};

import java.net.* ;
import java.io.* ;
public class EchoThreadServer{
	public static void main(String args[]) throws Exception {	// 所有异常抛出
		ServerSocket server = null ;		// 定义ServerSocket类
		Socket client = null ;	// 表示客 户端
		server = new ServerSocket(8888) ;	// 服务器在8888端口上监听
		boolean f = true ;	// 定义个标记位
		while(f){
			System.out.println("服务器运行，等待客户端连接。") ;
			client = server.accept() ;		// 得到连接，程序进入到阻塞状态
			new Thread(new EchoThread(client)).start() ;	// 每一个客户端表示一个线程
		}
		server.close() ;
	}
};


*UDP:不可靠连接
服务端发送信息，客户端接受信息
import java.net.DatagramPacket ;
import java.net.DatagramSocket ;

public class UDPClient{
	public static void main(String args[]) throws Exception{	// 所有异常抛出
		DatagramSocket ds = null ;		// 定义接收数据报的对象
		byte[] buf = new byte[1024] ;	// 开辟空间，以接收数据
		DatagramPacket dp = null ;		// 声明DatagramPacket对象
		ds = new DatagramSocket(9000) ;	// 客户端在9000端口上等待服务器发送信息
		dp = new DatagramPacket(buf,1024) ; // 所有的信息使用buf保存
		ds.receive(dp)  ;	// 接收数据
		String str = new String(dp.getData(),0,dp.getLength()) + "from " + 
			dp.getAddress().getHostAddress() + "：" + dp.getPort() ;
		System.out.println(str) ;	// 输出内容
	}
};


import java.net.DatagramPacket ;
import java.net.DatagramSocket ;
import java.net.InetAddress ;

public class UDPServer{
	public static void main(String args[]) throws Exception{	// 所有异常抛出
		DatagramSocket ds = null ;		// 定义发送数据报的对象
		DatagramPacket dp = null ;		// 声明DatagramPacket对象
		ds = new DatagramSocket(3000) ;	// 服务端在3000端口上等待服务器发送信息\
		String str = "hello World!!!" ;
		dp = new DatagramPacket(str.getBytes(),str.length(),InetAddress.getByName("localhost"),9000) ; // 所有的信息使用buf保存
		System.out.println("发送信息。") ;
		ds.send(dp);	// 发送信息出去
		ds.close() ;
	}
};


*web简介
静态web:简单的客户端发送请求，服务端返回请求。但是不能访问资源文件，如数据库等。客户端如果要多一些动态效果，
需要用applet增强。目前不用了
动态web:简单的客户端,具备了交互性，可以访问资源文件，如数据库等。服务端不是再通过web服务器进行接收，而是先通过
一个web服务插件，用于区分是动态请求还是静态请求。
如果是静态请求，通过web服务器,调用文件系统进行处理
如果是动态请求，将进入一个web容器，进行代码的拼凑工作，动态web本身是没有固定代码的，但是不管是固定代码还是拼凑代码，现在
基本都会通过web服务器返回给客户端进行内容显示

静态web靠普通的html实现
动态web靠jsp(java服务页)/servlet(服务端小程序)实现
开发架构
操作系统->数据库->中间件Tomcat->JAVA EE
JAVA EE框架：由容器，组件，服务组成，MVC是基本设计思路
客户端      中间层                                       服务端
java,web--  web容器(Servlet,jsp,html),服务(JDBC) ----    数据库

struts框架：中间层web容器(struts框架)(Servlet,jsp,html)，他主要是为了解决WEB层开发问题


*HTML、JavaScript
HTTP协议:浏览器中默认的端口是80，地址有可能是静态IP，有可能是DNS域名
HTTP协议要传输数据，如果要让数据正常的显示，则可以使用HTML完成，现在都是美工自动生成的代码
1.html文件
1).简单的html文件
新建table.html文件
<html>
     <head>//标题栏
          <title>guohello</title>
     </head>
     //文件体
     <body>
          <center>//居中显示
                 <h2><font color="BLUE">你好</h2>//文本
                 <h3><a href="http://www.baidu.com">按钮</a></h3>//超链接
          </center>
     </body>
</html>

2).操作表格
colspan，rowspan很重要
<html>
     <head>
          <title>guohello</title>
     </head>
     <body>
          <center>
                 <table border="1" width="80%">
                       <tr>
                          <td colspan="6">
                              <font size="15">跨六列</font>
                          </td>
                         <td rowspan="2">
                              <font size="15">跨两行</font>
                          </td>
                       </tr>
                 </table>
          </center>
     </body>
</html>

3).表单元素
<html>
     <head>
          <title>guohello</title>
     </head>
     <body>
          <form action="" method="post">
               编&nbsp;&nbsp;号:<input type="text" name="userid" value="no" size="2" mexlength="2"><br>
               用户名:<input type="text" name="username" value="请输入用户名"><br> 
               密码:<input type="password" name="userpass" value="请输入密码"><br>
               性&nbsp;&nbsp;别:<input type="radio" name="sex" value="男"checked>男
                                <input type="radio" name="sex" value="女">女<br>
               部&nbsp;&nbsp;门:<select name="dept">
                                       <option value="技术部" SELECTED>技术部</option>
                                       <option value="市场部">市场部</option>
                                </select><br> 
               兴&nbsp;&nbsp;趣:<input type="checkbox" name="inst" value="唱歌">唱歌
                               <input type="checkbox" name="inst" value="游泳" CHECKED>游泳<br> 
               说&nbsp;&nbsp;明:<textarea name="note" cols="30" rows="3">
                                     你好java
                               </textarea><br>
               <input type="submit" value="提交"><input type="reset" value="重置">  
          </form>
     </body>
</html>

2.JavaScript：为了补充HTML脚本
1）
(1)
<html>
     <head>
          <title>guohello</title>
          <script language="JavaScript">
                 alert("Hello world");   //弹出提示框
                 document.write("<h1>hello 1</h1>");输出页面显示
                 document.write("<h5>hello 5</h5>");
          </script>
     </head>
     
     <body>
          <center>
                 <h2><font color="BLUE">你好</h2>
                 <h3><a href="http://www.baidu.com">按钮</a></h3>
          </center>
     </body>
</html>

(2）使用变量
<script language="JavaScript">
      var num=30;
      var info="ppt";
      alert("Hello world"+num+info);   //弹出提示框
</script>

(3)循环分支
var str="b";
if(str=="a")
   alert("A");
else
   alert("B");

for(i=0;i<5;i++)

(4)函数
function fun()
{
  alert("hello world");
  return "www";
}

alert(fun());

(5)数组
var arr=new Array(3);
var i;
for(i=0;i<arr.length.i++)
   arr[i]=i;

2）如果里面的JavaScript代码过长，会使得页面不好看，一般都用*.js文件保存所有的JavaScript代码，用的时候导入进去
新建hello.js文件
alert("hello 6");

使用
<script language="JavaScript" src="hello.js">                
</script>


3)事件处理
（1）
<html>
     <head>
          <title>guohello</title>
          <script language="JavaScript">
                function hello()
                {alert("Welcome");}
                function bye()
                {alert("bye");}                 
          </script>
     </head>
     
     <body onLoad="hello()" onUnload="bye()">//加载页面时调用hello，退出页面时调用bye
          <center>
                 <h2><font color="BLUE">你好</h2>
                 <h3><a href="#" onclick="bye()">按钮</a></h3>//点击按钮打开
          </center>
     </body>
</html>

（2）提交表单
Onsubmit事件，是一个在表单上的事件操作，只要表单提交，都会进行验证
<html>
     <head>
          <title>guohello</title>
          <script language="JavaScript">
                function validate(f)
                {
                   var value=f.email.value;
                   alert(value);
                   if(!/^\w+)//正则表达式
                      return false; 
                   else
                      return true;
                }               
          </script>
     </head>
     
     <body>
          <form action="" method="post" name="myform" onsubmit="return validate(this)">
               EMAIL:<input type="text" name="email"><br>                 
               <input type="submit" value="提交"><input type="reset" value="重置">  
          </form>
     </body>
</html>

(3)显示表单信息
<html>
     <head>
          <title>guohello</title>
          <script language="JavaScript">                
                function show()
                {
                   var name=document.myform.username.value;
                   alert("username="+name);

                   var sex;
                   if(document.myform.sex[0].checked)
                      sex = document.myform.sex[0].value;
                   else
                      sex = document.myform.sex[1].value;
                   alert("sex="+sex);  

                   var inst="";
                   for(i=0;i<document.myform.inst.length;i++)
                   {
                      if(document.myform.inst[i].checked)
                        inst+=document.myform.inst[i].value;
                   }  
                   alert("inst="+inst); 
                } 
                function showdept(v)
                {
                   alert("dept="+v); 
                   document.myform.result.value=val;//修改text
                }               
          </script>
     </head>
     
     <body>
          <form action="test.htm" method="post" name="myform">       //提交后，转到"test.htm"文件
               编&nbsp;&nbsp;号:<input type="text" name="userid" value="no" size="2" mexlength="2"><br>
               用户名:<input type="text" name="username" value="请输入用户名"><br> 
               密码:<input type="password" name="userpass" value="请输入密码"><br>
               性&nbsp;&nbsp;别:<input type="radio" name="sex" value="男"checked>男
                                <input type="radio" name="sex" value="女">女<br>
               部&nbsp;&nbsp;门:<select name="dept" onchange="showdept(this.value)">    //更改选项，调用
                                       <option value="技术部" SELECTED>技术部</option>
                                       <option value="市场部">市场部</option>
                                </select><br> 
               兴&nbsp;&nbsp;趣:<input type="checkbox" name="inst" value="唱歌">唱歌
                               <input type="checkbox" name="inst" value="游泳" CHECKED>游泳<br> 
               说&nbsp;&nbsp;明:<textarea name="note" cols="30" rows="3">
                                     你好java
                               </textarea><br>
               <input type="button" value="显示" onclick="show()"><br>            //提交表单，调用
               <input type="submit" value="提交"><input type="reset" value="重置">  
          </form>
     </body>
</html>

4)window窗口处理
(1)弹出式页面处理
function showwindow(url)
{
       window.open(url,"页面标题","width=470,heigth=150,scrollbars=yes,resizeable=no"); 
}

<input type="button" value="显示" onclick="showwindow('hello.htm')"><br>

(2)确认框
if(window.confirm("确认删除?"))  

<a href="#" onclick="fun()">删除邮件</a> 超链接

(3)页面重定向
function fun(url)
{
  window.location=url;//重定向
}

//选择了这个selectbox值后，页面会重定向到新的网址中
<SELECT name="url" onChange="fun(this.value)">
     <OPTION VALUE="http://www.baidu.com">baidu</OPTION>
     <OPTION VALUE="http://www.google.com">google</OPTION>

(4)父子窗口的交互
子窗口函数
function closewin()
{
  var city=document.myform.city.value;//取出当前选择好的信息
  var doc=window.opener.document;//取得父窗口文档
  doc.parentform.result.value=city;//设置新内容
  window.close();//关闭子窗口
}
window.opener.location.reload();//刷新页面



*XML
他的标记不是固定的，主要用来保存数据
注释与HTML一样<!--注释-->
转义字符
&amp;   代替 &
&lt;         <
&gt;         >
&quot;       "
&apos;       '
<?xml version="1.0" encoding="GBK" standalone="no"?>
<authors>
     <author>//元素author
          <name id="1">你好</name>//属性
          <books>
               <book>a</book>
               <book>b</book>
          </books>
     </author> 
</authors>


1.XML解析DOM:以DOM格式的XML读取和修改XML文件，他的作用类似ini文件
DOM是一个树状结构的文件
1）读取xml文件
（1）简单的解析
新建demo.xml文件
<?xml version="1.0" encoding="GBK"?>
<addresslist>
    <name>你好</name>
</addresslist>

解析xml文件
import javax.xml.parsers.*;
import java.io.*;
import org.w3c.dom.*;
public class dom
{
   public static void main(String args[]) throws Exception
   {	  	
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	  DocumentBuilder builder = factory.newDocumentBuilder();
	  Document doc=builder.parse(new File("demo.xml"));//加载文本
	  
	  //解析XML文件
	  //找到name节点
	  NodeList nl = doc.getElementsByTagName("name");
	  System.out.println("name="+nl.item(0).getFirstChild().getNodeValue());
   }
}


(2)复杂的解析
<?xml version="1.0" encoding="GBK"?>
<addresslist>
    <linkman>
	    <name>你好</name>
        <email>hello@163.com</email>		
	</linkman>
    <linkman>
	    <name>好啊</name>
        <email>haode@163.com</email>		
	</linkman>
</addresslist>


//解析XML文件
  //找到name元素节点下的所有子节点
  NodeList nl = doc.getElementsByTagName("linkman");
  for(int i=0;i<nl.getLength();i++)
  {
	 Element e=(Element) nl.item(i);//取出每一个元素
	 //找到name元素节点下的所有子节点
	 System.out.println("name="+e.getElementsByTagName("name").item(0).getFirstChild().getNodeValue());
	 System.out.println("email="+e.getElementsByTagName("email").item(0).getFirstChild().getNodeValue());
  }

2）生成xml文件  
import javax.xml.parsers.*;
import java.io.*;
import org.w3c.dom.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;
public class dom
{
   public static void main(String args[]) throws Exception
   {	  	
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	  DocumentBuilder builder = factory.newDocumentBuilder();
	  Document doc=builder.newDocument();//创建一个新的xml文档
	  //创建所有节点
	  Element  addresslist=doc.createElement("addresslist");
	  Element  linkman=doc.createElement("linkman");
	  Element  name=doc.createElement("name");
	  Element  email=doc.createElement("email");
	  //设置节点内容
	  name.appendChild(doc.createTextNode("hhiik"));
	  email.appendChild(doc.createTextNode("wwk@163.com"));
	  //设置各个节点关系
	  linkman.appendChild(name);
	  linkman.appendChild(email);
	  addresslist.appendChild(linkman);
	  doc.appendChild(addresslist);
	  //保存到文件中
	  TransformerFactory tf= TransformerFactory.newInstance();
	  Transformer t=tf.newTransformer();
	  //设置属性
	  t.setOutputProperty(OutputKeys.ENCODING,"GBK");
	  DOMSource source=new DOMSource(doc);//准备输出文档
	  StreamResult result=new StreamResult(new File("demo2.xml"));
	  t.transform(source,result);
   }
}

3)使用JavaScript操作DOM
(1)简单的DOM例子
function showDOM()
{
   <!--要在span上写上代码-->
   document.getElementById("info").innerHTML="<h3>www.baidu.com</h3>";				   
}

<input type="button" value="显示DOM" onclick="showDOM()"><br>
               <!--显示DOM的位置-->
			   <span id="info"></span>

(2)复杂的DOM例子	
function setCity()
{
	var id=new Array(1,2,3);
	var value=new Array("北京","上海","广州");
	<!--取得下拉列表框的对象-->
	var select=document.getElementById("city");
	select.length=1;<!--每次可以选的内容是一个-->
	select.options[0].selected=true;<!--设置第一个为默认选中-->
	<!--添加城市节点-->
	for(var x=0;x<id.length;x++)
	{
		<!--创建一个option节点-->
		var option=document.createElement("option");
		<!--为option节点设置属性-->
		option.setAttribute("value",id[x]);
		<!--在option节点添加文本-->
		option.appendChild(document.createTextNode(value[x]));	
		<!--增加子节点-->
		select.appendChild(option);						
	}					
}
				
<body onLoad="setCity()">	
		<form action="test.htm" method="post" name="myform">
			城&nbsp;&nbsp;市:<select name="city" id="city">
				   <option value="0" SELECTED>没有城市</option>                                      
			</select><br> 
		</form>
</body>	

(3)操作表格函数
insertRow();增加表格的行
deleteCell();删除单元格，列
insertCell();插入一个列

<!--添加一行-->
function addrow(btn)
{
	var table=document.getElementById("mytab");
	var tr=table.insertRow();<!--添加一行-->
	<!--添加三列-->
	var td3=tr.insertCell();
	var td2=tr.insertCell();
	var td1=tr.insertCell();
	td1.innerHTML = "AA";
	td2.innerHTML = "BB";
	td3.innerHTML = "<input type='button' value='-' onclick='deleterow(this)'>";
}
<!--删除一行-->
function deleterow(btn)
{
	var tr=btn.parentNode.parentNode;<!--定位到tr-->
	var table=document.getElementById("mytab");
	table.deleteRow(tr.rowIndex);
}	

<!--添加有信息的一行-->
function addxinxi()
{
	var table=document.getElementById("mytab");
	var id=document.getElementById("userid").value;
	var name=document.getElementById("username").value;
	var tr=document.createElement("tr");<!--添加一行-->
	var tbody=document.createElement("tbody");
	<!--添加两列-->
	var td_id=document.createElement("td");
	var td_name=document.createElement("td");
	td_id.appendChild(document.createTextNode(id));
	td_name.appendChild(document.createTextNode(name));
	tr.appendChild(td_id);
	tr.appendChild(td_name);
	tbody.appendChild(tr);
	table.appendChild(tbody);					
}	   

<TABLE id="mytab" border="1">
	<TR>
		<TD>ML-1</TD>
		<TD>hello-1</TD>
		<TD><input type="button" value="+" onclick="addrow(this)"></TD>
	</TR>
	<TR>
		<TD>ML-2</TD>
		<TD>hello-2</TD>
		<TD><input type="button" value="-" onclick="deleterow(this)"></TD>
	</TR>
	<TR>
		<TD>ML-3</TD>
		<TD>hello-3</TD>
		<TD><input type="button" value="++" onclick="addxinxi()"></TD>
	</TR>
</TABLE>			   
			   
2.XML解析SAX:像流一样，顺序读取
import org.xml.sax.*;
import org.xml.sax.helpers.*;

import java.io.*;
import javax.xml.parsers.*;

//作sax解析器
class saxdel extends DefaultHandler
{
	public void startDocument() throws SAXException
	{
		System.out.println("<?xml version=\"1.0\" encoding=\"GBK\"?>");
	}
	//开始
	public void startElement(String uri,String localName,String qName,
	            Attributes attributes)throws SAXException
	{
		System.out.print("<");
		System.out.print(qName);
		System.out.print(">");
		//如果存在了属性
		if(attributes != null)
		{
			for(int x=0;x<attributes.getLength();x++)
			{
				System.out.println(" "+attributes.getQName(x)+"=\""+attributes.getValue(x)+"\"");
			}
		}
	}
	//结束
	public void endElement(String uri,String localName,String qName,
	            Attributes attributes)throws SAXException
	{
		System.out.print("<");
		System.out.print(qName);
		System.out.print(">");
	}	
	//实际解析的地方
	public void characters(char[] ch,int start,int length)throws SAXException
	{
		System.out.print(new String(ch,start,length));
	}
	public void endDocument() throws SAXException
	{
		System.out.print("end xml");
	}
}

public class sax 
{
	public static void main(String args[]) throws Exception
	{
		//建立SAX解析工厂
		SAXParserFactory factory = SAXParserFactory.newInstance();
		SAXParser parser = factory.newSAXParser();
		parser.parse("demo.xml",new saxdel());
	}
} 
3.XML解析JDOM,DOM4J: 需要另外下载组件包

  
//=========================
//Androaid程序设计
//=========================

//****************
//Androaid总体框架
//****************
*Androaid系统框架:一个整个的Androaid项目包括
src目录:java代码编写，他存放的是Activity程序，或者以后其他组件，在此文件夹中建立
        类的时候，包名称不能是一级
gen目录:此文件系统自动生成，不用管
    |---R.java文件用来注册java控件的ID     
Android 4.3:此项目依赖于的Android平台版本。注意，如果这个版本编译出来的程序版本
    高于当前虚拟机的版本，则程序运行不了
    (修改方法:右击项目->Properties->Android->选择平台版本)
assets目录:资源目录，放html的资源文件，不用管
res目录:保存图片，布局文件，配置文件等信息
     (每张图片分成三种分辨率存放，用于不同的设备)
   |---drawable-hdpi:放高清图片
   |---drawable-ldpi：放低分辨率图片
   |---drawable-mdpi：放中等分辨率
   |---layout:程序布局页面
   |---values:存放所有信息
    strings.xml:存放所有文字信息，以后直接引用这个变量就可以了(类似language.h文件)
    例如：
    <string name="app_name">hellohome</string>
    <string name="action_settings">Settings</string>
    <string name="hello_world">Hello world!</string>
     定义了三个变量，以后程序中或布局页面中直接引用hello_world即可
 
     以后可以自己添加各种文件，例如array.xml,color.xml,styles.xml等
bin目录：执行文件*.apk,下载到手机里直接可以安装运行
project.properites:工程属性配置目录
gen目录：系统生成的，不管
AndroaidManifest.xml:工程信息，包括版本号，工程包名等
      package:工程名称
      androaid:versionCode="1"程序apk版本号，更改这里，可以升级程序
      androaid:versionVersion="1.0"程序apk版本名称
      androaid:installLocation="auto"程序安装到手机位置，auto自动寻找安装地方,
ROM或者SDcard卡。internalonly装在ROM上,preferExternal装在sdcard

  例如：
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.hellohome"   //package:工程名称
    android:versionCode="1"   //"1"程序apk版本号，更改这里，可以升级程序
    android:versionName="1.0" >  //"1.0"程序apk版本名称

    //表明这个版本编译出来的程序版本最低支持的sdk版本号，和当前支持的版本号
注意，如果这个版本编译出来的程序版本高于当前虚拟机的版本，则程序运行不了
    <uses-sdk
        android:minSdkVersion="8"
        android:targetSdkVersion="18" />

    //配置所有应用程序
    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"//程序的图标，在R.java中显示
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >

        //配置的一个activity程序，如果有需要可以编写多个此节点 
        <activity
            android:name="com.example.hellohome.MainActivity"//工程程序的名称
            android:label="@string/app_name" >//程序的提示信息
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
    <uses-permission
       表示应用的授权
</manifest>
*开发环境搭建
1.JDK安装
http://java.sun.com/javase/downloads/index.jsp
2.配置环境变量
1)我的电脑->属性->高级->环境变量->系统变量中添加以下环境变量：
2)JAVA_HOME值为： C:\Program Files (x86)\Java\jdk1.7.0_40（你安装JDK的目录）
3）CLASSPATH值为：.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\bin;
4)Path:  %JAVA_HOME%\bin;
5)安装完成之后，可以在检查JDK是否安装成功。打开cmd窗口，输入java Cversion 查看JDK的版本信息。出现类似下面的画面表示安装成功了
Java<TM> SE Runtime ....<build 1.7.0_40-b43>


3.Eclipse安装
http://www.eclipse.org/downloads/
Eclipse IDE for Java EE Developers, 247 MB

4.android 的sdk安装
http://developer.android.com/sdk/index.html
1)
打开SDK Manager.exe，先Fetch
这个工具是一个下载平台，选择Android 4.4(API19)->Install安装4.4版本的平台的开发包
(里面的几项要全部打钩下载，如果下载失败，Install...重新试几次)
已经下载完成的版本在C:\android-sdk-windows-64\sdk\platforms中
2)配置环境变量
在用户变量中,PATH值添加一个为：Android SDK中的tools绝对路径（本机为C:\android-sdk-windows-64\sdk\tools）。
Path:  %JAVA_HOME%\bin;C:\android-sdk-windows-64\sdk\tools

3)安装完成之后，可以在检查SDK是否安装成功。打开cmd窗口，输入android Ch

5.配置Eclipse
/*已经废弃
1)使用ADT插件
Help->Install New software->Add->
Name:ADT
Location:https://dl-ssl.google.com/android/eclipse/
勾选Developer Tools->下一步->I accepter..->等待安装完成后，重启Eclipse
*/
1)直接打开eclipse-forandroid程序,ADT已经安装好
2)选择SDK插件的目录
window->preference->选中android->SDK Location->C:\android-sdk-windows-64\sdk
->Apply

3)配置打开sdk and avd manager
Windows==》Customize Perspective==》Command Groups Availability选项卡，左边的Available command groups 下的Android 开头的那几个都打上勾

4)配置虚拟机
工具栏目上选中Virtual Device Manager->New->
Name:Android 4.3
Target:Android 4.3
其他按情况设置，跟新建虚拟机一样

5)选择显示打开运行菜单
window->Show view->other->android->logcat(deprecated)

6.新建工程
1)
new->Android->Android Application Project

2).选择工程仿真器
run->run configurations->点击android application->hello1->右侧的面板上Target
->给仿真器打钩->Apply->Run
或者
右击工程名->run as->android application
或者
直接点击run按钮
(1)此时如果有连接手机，则会提示是使用手机进行打开，还是使用仿真器打开
(2)如果没有连接手机，则默认用仿真器打开
(3)
第一次启动虚拟机会比较慢，打开虚拟机后，就可以不断按run键进行运行程序了。
同理使用手机安装后，不断按run键打开手机了
(4)
ctrl+f11可以变为横屏幕显示

3）.断点调试
（1）双击代码的左边设置断点，debug as->开始进行调试模式
（2）有四种调试模式


*Activity类：是一个基本的主类
一个Android项目中包含多个Activity程序，通过这些程序可以完成一个个的界面显示
以及事件处理

主程序类public class MainActivity extends Activity 说明他继承于Activity类

protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);//生命周期的方法
        setContentView(R.layout.activity_main);//设置要使用的布局管理器,就是画界面
    }

1)界面设计activity_main.xml
快捷键：ALT+/  弹出自动提示，CTRL+/整块注释，CTRL+1弹出错误提示
例子1：
<LinearLayout //布局管理器，此为线性布局
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation = "vertical"是组件的排列方式垂直，horizontal水平排列
    android:layout_width="fill_parent"//布局管理器屏幕宽大小为父屏幕，即跟手机屏幕一样大
    android:layout_height="fill_parent"//布局管理器屏幕高大小跟手机屏幕一样大
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >
    
    //文本控件
    <TextView
        android:layout_width="wrap_content"组件宽度为自适应字符大小
        android:layout_height="wrap_content"组件高度为自适应字符大小
        android:text="@string/hello_world" />组件默认显示文字
   <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="www.android.com" />   
</LinearLayout>

例子2：
<RelativeLayout //布局管理器，此为相对布局，
    //LinearLayout是线性布局,android:orientation = "vertical"是组件的排列方式
    //位垂直
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />

</RelativeLayout>


2)通过代码来编写界面
(1)
<TextView
        android:id="@+id/mytext"//创建这个文本组件的ID,为mytext
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="www.android.com" />  
<Button
        android:id="@+id/mybtn"//创建这个按钮组件的ID,为mytext
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="default" />   
此时，在R.java中生成一个引用的ID

（2）Activity类的一个方法
public final View findViewById(int id)根据组件的ID取得组件的对象
所有组件都是我们View的子类。布局管理器也是View的子类
在主程序MainActivity.java中
import android.widget.TextView;//android.widget是所有组件的所在包
import android.widget.Button;//android.widget是所有组件的所在包
        
        //取得TextView组件，因为组件是View父类型，因此需要强制转换为TextView
        TextView mytxt = (TextView)super.findViewById(R.id.mytext);
        mytxt.setText("郭阵阵程序");//设置显示文字
        //取得Button组件，因为组件是View父类型，因此需要强制转换为Button
        Button mybtn = (Button)super.findViewById(R.id.mybtn);
        mybtn.setText("点击郭阵阵程序");//设置显示文字



3)通过Strings.xml定义字符串常量
(1)通过Strings.xml定义字符串常量
<string name="mytext_info">郭阵阵程序2</string>
<string name="mybtn_info">点击郭阵阵程序2</string>

此时，R.java也会自动进行信息文字的注册ID
(2)使用
在主程序MainActivity.java中
 mytxt.setText(R.string.mytext_info);//设置显示文字
 mybtn.setText(R.string.mybtn_info);//设置显示文字


或者
activity_main.xml中
android:text="@string/mytext_info" 
android:text="@string/mybtn_info"


4）通过程序动态生成
删除xml中有关于TextView,Button的组件代码

在主程序MainActivity.java中
TextView mytext= new TextView(this);//根据上下文(Context)创建组件


//****************
//Android屏幕适配
//****************
屏幕尺寸这么多，为了让我们开发的程序能够比较美观的显示在不同尺寸、分辨率、像素密度,
6个主流分辨率占比最高的是480*800，320*480,720*1280,320*480,480*854,540*960,1080*1920.我们只要尽量适配这几种分辨率，就可以在大部分的手机上正常运行了
屏幕尺寸

屏幕尺寸指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米

比如常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等

屏幕分辨率
屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1个像素点。一般以纵向像素*横向像素，如1960*1080。

屏幕像素密度dp、dip、dpi、sp

屏幕像素密度是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写。屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。
在Android开发中，写布局的时候要尽量使用dp而不是px


mdpi、hdpi、xdpi、xxdpi
mdpi	 48x48px
hdpi	 72x72px
xhdpi	 96x96px
xxhdpi	 144x144px
xxxhdpi	 192x192px


//****************
//View类的组件
//****************
*View类：android.view.View是所有图形界面的父类
*TextView:文本组件android.widget.TextView类
import android.widget.TextView;//android.widget是所有组件的所在包

xml配置                      Activity方法        功能
android:layout_margin="30px"                     配置偏移30个像素
android:text        public final void setText("..")               显示文字
android:maxLength   public void setFilters(InputFilter[] filters) 设组建最大允许长度
     android:maxLength = “3”最多只显示3个文字
android:textColor   public void setTextColor(Colors)              设文本颜色
     android:textColor="#FFFF00" 表示是黄色
        
android:textSize    public void setTextSize(float size)           文字大小
     android:textSize="20px"  表示20个像素
android:textStyle                                                 文字样式，粗体或斜体等
     android:textStyle="bold" 粗体显示
android:selectAllOnFocus  public void selectAllOnFocus(boolean)   选中并获得焦点
android:password     public final void setTransformationMethod(method)  以密码方式显示
android:background="@drawable/bill"    显示背景图片
android:autoLink="all"   所有的都换成超链接

2）定义样式表格式
(1)定义一个样式表values/style.xml
<!-- Application theme. -->
    <style name="strStyle" >
       <item name="android:textSize">50px</item>
       <item name="android:textStyle">italic</item>
    </style>

(2)使用
activity_main.xml中
<TextView
        android:id="@+id/mytext"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        style="@style/strstyle"
        android:text="请选择网址"  
         />

text.setMovementMethod(ScrollingMovementMethod.getInstance());//设置文本组件的
内容可以滚动添加
*Button:import android.widget.Button;//android.widget是所有组件的所在包

*EditText:import android.widget.EditText;
android:selectAllOnFocus="true" 默认选中的功能
android:numeric="integer"只能输入数字

*RadioGroup:
import android.widget.RadioGroup;
import android.widget.RadioButton;

<RadioGroup    //建RadioGroup
        android:id="@+id/mygrp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="110px"
        android:orientation="horizontal"//里面的RadioButton组件是水平布局
        android:checkedButton="@+id/rbtnGBK">//默认选中rbtnGBK的RadioButton
        //新建两个RadioButton
        <RadioButton
            android:id="@+id/rbtnUTF"
            android:text="UTF8"
        />  
        <RadioButton
            android:id="@+id/rbtnGBK"
            android:text="GBK"
        />                  
</RadioGroup>   

*CheckBox:复选框import android.widget.RadioGroup;
<CheckBox
        android:id="@+id/mychk"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="130px"
        android:text="检测:"
        android:checked="true"   //默认选中
     />     

Activity
private CheckBox chk=null;//定义组件

this.chk = (CheckBox) super.findViewById(R.id.chkbox);
this.chk.setChecked(true);  //默认选中

*spinner下拉列表框:android.widget.Spinner
1.重点方法
setAdapter()设置下拉列表框中的显示内容
setOnItemClickListener设置选项单击事件
2.配置列表项
1)直接通过资源文件配置
(1)
新建一个资源文件，例如values/city.xml代表城市的资源文件
<resources>
    <string-array name="city_label">  配置字符数据
        <item>china</item>            添加几个选项
        <item>english</item>
        <item>france</item>
    </string-array>
</resources>

(2)使用资源文件到Spinner中
<Spinner
        android:id="@+id/myspin"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:entries="@array/city_label"//使用资源文件到Spinner中
/>

(3)设置字体大小的配置文件layout/viewspinner.xml
<?xml version="1.0" encoding="utf-8"?>
<TextView  xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@android:id/text1"  
    android:gravity="left"  
    android:paddingLeft="8dip"  
    android:textStyle="bold"  
    android:textSize="40sp" 
    android:singleLine="true"  
    android:layout_width="match_parent"  
    android:layout_height="wrap_content"  
    android:ellipsize="marquee" />

(4)activity中
private Spinner spinordergridtongji=null;
private String [] mStringArray; 
private ArrayAdapter<String> mAdapter ;	

spinordergridtongji= (Spinner) findViewById(R.id.spinordergridtongji); 
mStringArray=getResources().getStringArray(R.array.city);
//使用自定义的ArrayAdapter
mAdapter = new ArrayAdapter<String>(this,R.layout.viewspinner,mStringArray);
spinordergridtongji.setAdapter(mAdapter);// 为ListView列表设置数据源


2)通过android.widget.ArrayAdapter类
读取xml中设置的列表项
(1)新建一个资源文件，例如values/city.xml代表城市的资源文件
(2)使用资源文件到Spinner中
<Spinner
        android:id="@+id/myspin"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="180px"      
     /> 
注意，不用再加载资源文件，只是一个空的资源列表
(3)Activity里面进行配置
import android.widget.Spinner;
import android.widget.ArrayAdapter;

private Spinner myspinner = null;
private ArrayAdapter<CharSequence> arrayadapter = null;//因为是泛型，所以指定所有的数据都是CharSequence


protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        super.setContentView(R.layout.activity_main);
        this.myspinner = (Spinner) super.findViewById(R.id.myspin);
        this.myspinner.setPrompt("@string/city_st");//提示信息
        this.arrayadapter = ArrayAdapter.createFromResource(this,
        		R.array.city_label, android.R.layout.simple_spinner_item);//实例化了ArrayAdapter
        this.myspinner.setAdapter(this.arrayadapter);//设置显示信息
        
    }

	
3)通过List集合设置列表项
(1)新建一个资源文件，例如values/city.xml代表城市的资源文件
(2)使用资源文件到Spinner中，注意，不用再加载资源文件，只是一个空的资源列表
(3)设置字体大小的配置文件layout/viewspinner.xml
<?xml version="1.0" encoding="utf-8"?>
<TextView  xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@android:id/text1"  
    android:gravity="left"  
    android:paddingLeft="8dip"  
    android:textStyle="bold"  
    android:textSize="40sp" 
    android:singleLine="true"  
    android:layout_width="match_parent"  
    android:layout_height="wrap_content"  
    android:ellipsize="marquee" />
(4)Activity里面进行配置
import android.widget.Spinner;
import android.widget.ArrayAdapter;
import android.widget.Spinner;

import java.util.ArrayList;
import java.util.List;

private Spinner myspinner = null;
	private ArrayAdapter<CharSequence> arrayadapter = null;//因为是泛型，所以指定所有的数据都是CharSequence
	private List<CharSequence> dataEdu = null;//定义一个集合数据
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        super.setContentView(R.layout.activity_main);
        //this.myspinner = (Spinner) super.findViewById(R.id.myspin);
        //this.myspinner.setPrompt("@string/city_st");//提示信息
        //this.arrayadapter = ArrayAdapter.createFromResource(this,
        //		R.array.city_label, android.R.layout.simple_spinner_item);//实例化了ArrayAdapter
        //this.myspinner.setAdapter(this.arrayadapter);//设置显示信息
        
        //配置List集合包装的下拉内容
        this.dataEdu = new ArrayList<CharSequence>();
        this.dataEdu.add("大学");
        this.dataEdu.add("本科");
        this.dataEdu.add("硕士");
        
        this.myspinner = (Spinner) super.findViewById(R.id.myspin);
        this.myspinner.setPrompt("@string/city_st");//提示信息
        //方法一.准备好下拉列表框的内容,使用系统默认字体大小
        this.arrayadapter = new ArrayAdapter<CharSequence>(this, android.R.layout.simple_spinner_item,this.dataEdu);
		//方法二.准备好下拉列表框的内容,使用自定义字体大小
		this.arrayadapter = new ArrayAdapter<CharSequence>(this, R.layout.viewspinner,this.dataEdu);
        this.myspinner.setAdapter(this.arrayadapter);//设置显示信息
    }


*ImageView图片视图:
1.添加图片到res/drawable-ldpi中：android.widget.ImageView
2.
<ImageView
        android:id="@+id/myimage"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/christmas" /> //定义图片资源

3.设置桌面
this.clearWallpaper();//先清除桌面
this.setWallpaper(
this.myimage.getResources().openRawResource(R.drawable.imgjbg)
);//通过资源路径存放的图片设置界面

4.设置系统权限，才能更改手机桌面
<uses-permission android:name="android.permission.SET_WALLPAPER/>


*ImageButton图片按钮:android.widget.ImageButton
<ImageButton
        android:id="@+id/myimgbtn"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/christmas" />     
*TimePicker:时间选择器:android.widget.TimePicker
<TimePicker
        android:id="@+id/mytime"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        />   
在Activity中配置为24小时制:
import android.widget.TimePicker;
TimePicker mytime= null;
this.mytime = (TimePicker) super.findViewById(R.id.mytime);
this.mytime.setIs24HourView(true);
设置时间
this.mytime.setCurrentHour(18);
this.mytime.setCurrentMinute(34);

得到时间
mytime.getCurrentHour().toString()+":"+mytime.getCurrentMinute().toString()
*DatePicker:日期选择器:android.widget.DatePicker
<DatePicker
        android:id="@+id/mydate"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        />  
在Activity中配置:
import android.widget.DatePicker;
DatePicker mydate= null;
this.mydate = (DatePicker) super.findViewById(R.id.mydate);
this.mydate.updateDate(2014, 1, 23);

*视频播放器VideoView
原来的他不支持全屏播放，如果要，需要自己定义一个控件

MyVideoView.java
package com.easivend.view;

import android.content.Context;  
import android.util.AttributeSet;
import android.widget.VideoView;

public class MyVideoView extends VideoView {
	public MyVideoView(Context context, AttributeSet attrs, int defStyle) {  
        super(context, attrs, defStyle);  
    }  
  
    public MyVideoView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
  
    public MyVideoView(Context context) {  
        super(context);  
    }  
    
    //重c在此，override@ function 才可以正常M版!
    @Override  
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {  
        // TODO Auto-generated method stub  
  
        int width = getDefaultSize(0, widthMeasureSpec);  
        int height = getDefaultSize(0, heightMeasureSpec);  
        setMeasuredDimension(width, height);  
    }
}

xml布局文件
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
    <com.easivend.view.MyVideoView
        android:id="@+id/video"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"  />
    <ImageView  
	        android:id="@+id/ivads"  
	        android:layout_width="match_parent"   
	        android:layout_height="match_parent"   
	        android:src="@drawable/quhuo"
	        android:gravity="center"  	
	     />

</RelativeLayout>

activity.java文件
MyVideoView videoView=(MyVideoView)view.findViewById(R.id.video);

*WebView内置浏览器
对于有显示 HTML 内容的 Android 应用来说用这个控件
Android 的 WebView 组件使用非常简单，可以使用 loadUrl()加载一个 URL 地址，也可以使用 loadData()或 loadDataWithBaseURL()加载一段 HTML 代码片段。loadData()不能加载图片内容，所以在本例中选择使用可以加载图片内容，并获得更强大 Web 支持的 loadDataWithBaseURL()来显示文字与图片内容，
loadDataWithBaseURL()方法定义
baseUrl，相对路径，在本例中 HTML 文本内用到的所有资源文件，不论是图片还是其它的 JavaScript 文件或者 CSS 文件，其路径都是相对于这个参数的。
data， 以 encoding 格式编码的 HTML 内容字符串。
mimeType，数据的 MIME 类型，null 时默认为"text/html"。
encoding， 数据编码格式。
historyUrl，作为历史条目的 URL，可为 null。
例如： webproductDesc.loadDataWithBaseURL(null,tb_inaccount.getProductDesc().toString(), "text/html; charset=UTF-8","utf-8", null);//这种写法可以正确中文解码
			

1)loadData加载字
WebView webproductDesc = (WebView) findViewById(R.id.webproductDesc);
WebSettings settings = webproductDesc.getSettings();
settings.setSupportZoom(true);
settings.setTextSize(WebSettings.TextSize.LARGEST);
webproductDesc.getSettings().setDefaultTextEncodingName("UTF -8");//设置默认为utf-8
webproductDesc.loadData(tb_vmc_product.getProductDesc().toString(), "text/html; charset=UTF-8", null);//这种写法可以正确中文解码

*提示框Toast
二、五种效果实现
1、默认的Toast特效样式

在android4.1.2下对 <wbr>Toast五种显示效果建立属于你自己的Toast

代码
listener1 = newOnClickListener() {
public voidonClick(View v) {
setTitle(R.string.mybutton1_text);
Toast.makeText(ToastMainActivity.this,getText(R.string.mybutton1_text)+myeditText1.getText().toString(),Toast.LENGTH_LONG).show();
myText.setText(myeditText1.getText().toString());
myeditText1.setText("");
 }
};
2、自定义显示位置效果

在android4.1.2下对 <wbr>Toast五种显示效果建立属于你自己的Toast

代码
listener2 = newOnClickListener() {
public voidonClick(View v) {
setTitle(R.string.mybutton2_text);         
myToast=Toast.makeText(getApplicationContext(),getText(R.string.mybutton2_text)+myeditText1.getText().toString(),Toast.LENGTH_LONG);
myToast.setGravity(Gravity.CENTER, 0, 0);
myToast.show();
myText.setText(myeditText1.getText().toString());
myeditText1.setText("");
}
}; 
3、带图片效果

在android4.1.2下对 <wbr>Toast五种显示效果建立属于你自己的Toast

 
代码
listener3 = newOnClickListener() {
public voidonClick(View v) {
setTitle(R.string.mybutton3_text);         
myToast= Toast.makeText(getApplicationContext(),getText(R.string.mybutton3_text)+myeditText1.getText().toString(), Toast.LENGTH_LONG);
myToast.setGravity(Gravity.CENTER, 0, 0);
LinearLayout toastView = (LinearLayout) myToast.getView();
ImageView imageCodeProject = newImageView(getApplicationContext());
imageCodeProject.setImageResource(R.drawable.ic_action_search);
toastView.addView(imageCodeProject, 0);
myToast.show();
myText.setText(myeditText1.getText().toString());
myeditText1.setText("");
 }
}; 
4、完全自定义效果

在android4.1.2下对 <wbr>Toast五种显示效果建立属于你自己的Toast

代码
listener4 = newOnClickListener() {
public voidonClick(View v) {
setTitle(R.string.mybutton4_text);         
LayoutInflater inflater = getLayoutInflater();
View layout = inflater.inflate(R.layout.custom,(ViewGroup) findViewById(R.id.llToast));
ImageView image = (ImageView) layout.findViewById(R.id.tvImageToast);
image.setImageResource(R.drawable.ic_launcher);
TextView title = (TextView) layout.findViewById(R.id.tvTitleToast);
title.setText("Attention");
TextView text = (TextView) layout.findViewById(R.id.tvTextToast);
text.setText(getText(R.string.mybutton4_text)+myeditText1.getText().toString());
myToast= newToast(getApplicationContext());
myToast.setGravity(Gravity.RIGHT | Gravity.TOP, 12, 40);
myToast.setDuration(Toast.LENGTH_LONG);
myToast.setView(layout);
myToast.show();
myText.setText(myeditText1.getText().toString());
myeditText1.setText("");
  }
}; 
5、其他线程

在android4.1.2下对 <wbr>Toast五种显示效果建立属于你自己的Toast

  代码
listener5 = new OnClickListener() {    
public voidonClick(View v) {
setTitle(R.string.mybutton5_text);         
newThread(newRunnable() {
public voidrun() {
showToast();
}
}).start();
myText.setText(myeditText1.getText().toString());
myeditText1.setText("");                               
}
public voidshowToast() {
handler.post(new Runnable() {
//   @Override
public voidrun() {
                    myToast=Toast.makeText(getApplicationContext(),getText(R.string.mybutton5_text),Toast.LENGTH_SHORT);
myToast.show();
    }
});
}
};   
//**********
//布局管理器
//**********
颜色：
<?xml version="1.0" encoding="utf-8" ?>  
<resources>  
<color name="white">#FFFFFF</color><!--白色 -->  
<color name="ivory">#FFFFF0</color><!--象牙色 -->  
<color name="lightyellow">#FFFFE0</color><!--亮黄色 -->  
<color name="yellow">#FFFF00</color><!--黄色 -->  
<color name="snow">#FFFAFA</color><!--雪白色 -->  
<color name="floralwhite">#FFFAF0</color><!--花白色 -->  
<color name="lemonchiffon">#FFFACD</color><!--柠檬绸色 -->  
<color name="cornsilk">#FFF8DC</color><!--米绸色 -->  
<color name="seashell">#FFF5EE</color><!--海贝色 -->  
<color name="lavenderblush">#FFF0F5</color><!--淡紫红 -->  
<color name="papayawhip">#FFEFD5</color><!--番木色 -->  
<color name="blanchedalmond">#FFEBCD</color><!--白杏色 -->  
<color name="mistyrose">#FFE4E1</color><!--浅玫瑰色 -->  
<color name="bisque">#FFE4C4</color><!--桔黄色 -->  
<color name="moccasin">#FFE4B5</color><!--鹿皮色 -->  
<color name="navajowhite">#FFDEAD</color><!--纳瓦白 -->  
<color name="peachpuff">#FFDAB9</color><!--桃色 -->  
<color name="gold">#FFD700</color><!--金色 -->  
<color name="pink">#FFC0CB</color><!--粉红色 -->  
<color name="lightpink">#FFB6C1</color><!--亮粉红色 -->  
<color name="orange">#FFA500</color><!--橙色 -->  
<color name="lightsalmon">#FFA07A</color><!--亮肉色 -->  
<color name="darkorange">#FF8C00</color><!--暗桔黄色 -->  
<color name="coral">#FF7F50</color><!--珊瑚色 -->  
<color name="hotpink">#FF69B4</color><!--热粉红色 -->  
<color name="tomato">#FF6347</color><!--西红柿色 -->  
<color name="orangered">#FF4500</color><!--红橙色 -->  
<color name="deeppink">#FF1493</color><!--深粉红色 -->  
<color name="fuchsia">#FF00FF</color><!--紫红色 -->  
<color name="magenta">#FF00FF</color><!--红紫色 -->  
<color name="red">#FF0000</color><!--红色 -->  
<color name="oldlace">#FDF5E6</color><!--老花色 -->  
<color name="lightgoldenrodyellow">#FAFAD2</color><!--亮金黄色 -->  
<color name="linen">#FAF0E6</color><!--亚麻色 -->  
<color name="antiquewhite">#FAEBD7</color><!--古董白 -->  
<color name="salmon">#FA8072</color><!--鲜肉色 -->  
<color name="ghostwhite">#F8F8FF</color><!--幽灵白 -->  
<color name="mintcream">#F5FFFA</color><!--薄荷色 -->  
<color name="whitesmoke">#F5F5F5</color><!--烟白色 -->  
<color name="beige">#F5F5DC</color><!--米色 -->  
<color name="wheat">#F5DEB3</color><!--浅黄色 -->  
<color name="sandybrown">#F4A460</color><!--沙褐色 -->  
<color name="azure">#F0FFFF</color><!--天蓝色 -->  
<color name="honeydew">#F0FFF0</color><!--蜜色 -->  
<color name="aliceblue">#F0F8FF</color><!--艾利斯兰 -->  
<color name="khaki">#F0E68C</color><!--黄褐色 -->  
<color name="lightcoral">#F08080</color><!--亮珊瑚色 -->  
<color name="palegoldenrod">#EEE8AA</color><!--苍麒麟色 -->  
<color name="violet">#EE82EE</color><!--紫罗兰色 -->  
<color name="darksalmon">#E9967A</color><!--暗肉色 -->  
<color name="lavender">#E6E6FA</color><!--淡紫色 -->  
<color name="lightcyan">#E0FFFF</color><!--亮青色 -->  
<color name="burlywood">#DEB887</color><!--实木色 -->  
<color name="plum">#DDA0DD</color><!--洋李色 -->  
<color name="gainsboro">#DCDCDC</color><!--淡灰色 -->  
<color name="crimson">#DC143C</color><!--暗深红色 -->  
<color name="palevioletred">#DB7093</color><!--苍紫罗兰色 -->  
<color name="goldenrod">#DAA520</color><!--金麒麟色 -->  
<color name="orchid">#DA70D6</color><!--淡紫色 -->  
<color name="thistle">#D8BFD8</color><!--蓟色 -->  
<color name="lightgray">#D3D3D3</color><!--亮灰色 -->  
<color name="lightgrey">#D3D3D3</color><!--亮灰色 -->  
<color name="tan">#D2B48C</color><!--茶色 -->  
<color name="chocolate">#D2691E</color><!--巧可力色 -->  
<color name="peru">#CD853F</color><!--秘鲁色 -->  
<color name="indianred">#CD5C5C</color><!--印第安红 -->  
<color name="mediumvioletred">#C71585</color><!--中紫罗兰色 -->  
<color name="silver">#C0C0C0</color><!--银色 -->  
<color name="darkkhaki">#BDB76B</color><!--暗黄褐色 -->  
<color name="rosybrown">#BC8F8F</color><!--褐玫瑰红 -->  
<color name="mediumorchid">#BA55D3</color><!--中粉紫色 -->  
<color name="darkgoldenrod">#B8860B</color><!--暗金黄色 -->  
<color name="firebrick">#B22222</color><!--火砖色 -->  
<color name="powderblue">#B0E0E6</color><!--粉蓝色 -->  
<color name="lightsteelblue">#B0C4DE</color><!--亮钢兰色 -->  
<color name="paleturquoise">#AFEEEE</color><!--苍宝石绿 -->  
<color name="greenyellow">#ADFF2F</color><!--黄绿色 -->  
<color name="lightblue">#ADD8E6</color><!--亮蓝色 -->  
<color name="darkgray">#A9A9A9</color><!--暗灰色 -->  
<color name="darkgrey">#A9A9A9</color><!--暗灰色 -->  
<color name="brown">#A52A2A</color><!--褐色 -->  
<color name="sienna">#A0522D</color><!--赭色 -->  
<color name="darkorchid">#9932CC</color><!--暗紫色 -->  
<color name="palegreen">#98FB98</color><!--苍绿色 -->  
<color name="darkviolet">#9400D3</color><!--暗紫罗兰色 -->  
<color name="mediumpurple">#9370DB</color><!--中紫色 -->  
<color name="lightgreen">#90EE90</color><!--亮绿色 -->  
<color name="darkseagreen">#8FBC8F</color><!--暗海兰色 -->  
<color name="saddlebrown">#8B4513</color><!--重褐色 -->  
<color name="darkmagenta">#8B008B</color><!--暗洋红 -->  
<color name="darkred">#8B0000</color><!--暗红色 -->  
<color name="blueviolet">#8A2BE2</color><!--紫罗兰蓝色 -->  
<color name="lightskyblue">#87CEFA</color><!--亮天蓝色 -->  
<color name="skyblue">#87CEEB</color><!--天蓝色 -->  
<color name="gray">#808080</color><!--灰色 -->  
<color name="grey">#808080</color><!--灰色 -->  
<color name="olive">#808000</color><!--橄榄色 -->  
<color name="purple">#800080</color><!--紫色 -->  
<color name="maroon">#800000</color><!--粟色 -->  
<color name="aquamarine">#7FFFD4</color><!--碧绿色 -->  
<color name="chartreuse">#7FFF00</color><!--黄绿色 -->  
<color name="lawngreen">#7CFC00</color><!--草绿色 -->  
<color name="mediumslateblue">#7B68EE</color><!--中暗蓝色 -->  
<color name="lightslategray">#778899</color><!--亮蓝灰 -->  
<color name="lightslategrey">#778899</color><!--亮蓝灰 -->  
<color name="slategray">#708090</color><!--灰石色 -->  
<color name="slategrey">#708090</color><!--灰石色 -->  
<color name="olivedrab">#6B8E23</color><!--深绿褐色 -->  
<color name="slateblue">#6A5ACD</color><!--石蓝色 -->  
<color name="dimgray">#696969</color><!--暗灰色 -->  
<color name="dimgrey">#696969</color><!--暗灰色 -->  
<color name="mediumaquamarine">#66CDAA</color><!--中绿色 -->  
<color name="cornflowerblue">#6495ED</color><!--菊兰色 -->  
<color name="cadetblue">#5F9EA0</color><!--军兰色 -->  
<color name="darkolivegreen">#556B2F</color><!--暗橄榄绿 -->  
<color name="indigo">#4B0082</color><!--靛青色 -->  
<color name="mediumturquoise">#48D1CC</color><!--中绿宝石 -->  
<color name="darkslateblue">#483D8B</color><!--暗灰蓝色 -->  
<color name="steelblue">#4682B4</color><!--钢兰色 -->  
<color name="royalblue">#4169E1</color><!--皇家蓝 -->  
<color name="turquoise">#40E0D0</color><!--青绿色 -->  
<color name="mediumseagreen">#3CB371</color><!--中海蓝 -->  
<color name="limegreen">#32CD32</color><!--橙绿色 -->  
<color name="darkslategray">#2F4F4F</color><!--暗瓦灰色 -->  
<color name="darkslategrey">#2F4F4F</color><!--暗瓦灰色 -->  
<color name="seagreen">#2E8B57</color><!--海绿色 -->  
<color name="forestgreen">#228B22</color><!--森林绿 -->  
<color name="lightseagreen">#20B2AA</color><!--亮海蓝色 -->  
<color name="dodgerblue">#1E90FF</color><!--闪兰色 -->  
<color name="midnightblue">#191970</color><!--中灰兰色 -->  
<color name="aqua">#00FFFF</color><!--浅绿色 -->  
<color name="cyan">#00FFFF</color><!--青色 -->  
<color name="springgreen">#00FF7F</color><!--春绿色 -->  
<color name="lime">#00FF00</color><!--酸橙色 -->  
<color name="mediumspringgreen">#00FA9A</color><!--中春绿色 -->  
<color name="darkturquoise">#00CED1</color><!--暗宝石绿 -->  
<color name="deepskyblue">#00BFFF</color><!--深天蓝色 -->  
<color name="darkcyan">#008B8B</color><!--暗青色 -->  
<color name="teal">#008080</color><!--水鸭色 -->  
<color name="green">#008000</color><!--绿色 -->  
<color name="darkgreen">#006400</color><!--暗绿色 -->  
<color name="blue">#0000FF</color><!--蓝色 -->  
<color name="mediumblue">#0000CD</color><!--中兰色 -->  
<color name="darkblue">#00008B</color><!--暗蓝色 -->  
<color name="navy">#000080</color><!--海军色 -->  
<color name="black">#000000</color><!--黑色 -->  
</resources> 
字体大小：
android:textColor="#FF0000"
android:textSize="55dp"
改变颜色的几种方法
1、利于系统自带的颜色类
如TextView1.setTextColor(android.graphics.Color.RED);
//2014.12.9
布局文件中：android:textColor="@android:color/white"
2、数字颜色表示法
TextView1.setTextColor(0xffff00ff);


wrap_content：组件的大小以能装入其内容即可； 
fill_parent：组件会显示得和其父组件一样大，并填充剩余的空间（在 API Level 8中命名为 match_parent）。
*Android按钮按下的时候改变颜色实现方法
1.简单改变颜色
首先，在res文件夹下新建一个文件夹drawable，这是无关分辨率的：

在下面建立一个xml文件：login_button_selector.xml


复制代码 代码如下:


<selector xmlns:android="http://schemas.android.com/apk/res/android">

        <item android:drawable="@drawable/clr_normal" android:state_pressed="false"/>
        <item android:drawable="@drawable/clr_pressed" android:state_pressed="true"/>

    </selector>



然后在value文件夹下的string.xml文件里添加：


复制代码 代码如下:


<drawable name="clr_normal">#ff6501</drawable>
 <drawable name="clr_pressed">#a44100</drawable>
 
 



最后为button添加：


复制代码 代码如下:


<Button
  android:layout_marginTop="15dp"
         android:layout_width="match_parent" 
         android:layout_height="wrap_content"
         android:text="@string/loginSubmit"
         android:id="@+id/login"
         android:textColor="@android:color/white"
         android:background="@drawable/login_button_selector"
         />
		 
2.改变背景图
在res/drawable文件下创建selector.xml，示例代码如下
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:state_pressed="false"
        android:drawable="@drawable/title_button_back">
    </item>
    <item
        android:state_pressed="true"
        android:drawable="@drawable/title_button_back_h">
    </item>
    <item
        android:state_window_focused="false"
        android:drawable="@drawable/title_button_back">
    </item>
</selector>

编写布局文件，为布局文件中的ImageButton设置selector，示例代码如下
<?xml version="1.0" encoding="utf-8"?>  
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:layout_height="wrap_content" 
    android:layout_width="fill_parent">  
    <ImageButton 
        android:id="@+id/title_IB" ; 
        android:layout_height="wrap_content" 
        android:layout_width="wrap_content" 
        android:background="#00000000" 
        android:layout_marginRight="4dp" 
        android:layout_centerVertical="true" 
        android:src="@drawable/selector"> ; 
    </ImageButton>  
</RelativeLayout>
		 

*android中添加背景图片
在main.xml中的LinearLayout下面，添加android:background="@drawable/d"
设置颜色
android:background="@drawable/white"
或者android:background="#FFFFFF"		 
*线性布局管理器（重要）：android.widget.LinearLayout
<LinearLayout //线性布局管理器
 android:orientation = "vertical"//所有组件垂直排列
                       horizontal//所有组件水平排列
    android:layout_width="fill_parent"//此布局管理器填充整个宽度
    android:layout_height="fill_parent"//此布局管理器填充整个高度

2）代码进行设置（基本没这么用）
android.widget.LinearLayout;
android.widget.LinearLayout.LayoutParams;


LinearLayout layout= new LinearLayout(this);//创建一个线性布局管理器
        LinearLayout.LayoutParams param = new LinearLayout.LayoutParams(
        		ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.FILL_PARENT);//定义线性布局管理器的宽度和高度充满屏幕
        layout.setOrientation(LinearLayout.VERTICAL);//组件垂直布局
       
        //定义了一个装门存放组件的布局管理器,宽度和高度和文本内容一样
        LinearLayout.LayoutParams txtParam=new .LinearLayout.LayoutParams(
        		ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);
        //定义一个TextView组件
        TextView txt = new TextView(this);
        txt.setLayoutParams(txtParam);//配置文本组件的参数
        txt.setText("你好"); 
        layout.addView(txt,txtParam);//增加组件
        setContentView(layout,param);//增加新的布局管理器

*框架布局管理器:将所有组件都叠加到屏幕的左上角
android.widget.FrameLayout;
android.widget.FrameLayout.LayoutParams;

*表格布局管理器TableLayout（重要）:用TableRow进行表格的行控制，之后所有的组件都要在TableRow中增加
1)添加组件
<TableLayout    //表格编码器
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation = "vertical" // 垂直布局
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"    
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >
    
    <TableRow >                         //添加一行
	    //表格布局的子对象不能指定 layout_width 属性.宽度永远是 MATCH_PARENT,所以要内嵌一个布局
        <LinearLayout 
                android:layout_width="wrap_content"
            	android:layout_height="wrap_content"> 
            	<TextView 		    
					android:layout_width="wrap_content"
					android:layout_height="wrap_content"
					android:text="类别ID:"/>
		        
		         <EditText
		            android:id="@+id/edtclassid"
			        android:layout_width="wrap_content" 
			        android:layout_height="wrap_content"
			        android:textSize="40sp"
		            android:textStyle="bold"		        
			        android:text="" />
            </LinearLayout> 
    </TableRow>
    <View                              //添加一个分割线，2个像素
        android:layout_height="2px"
        android:background="#FF909090"
    /> 
   <TableRow >                         //添加一行
       <Spinner 
	        android:id="@+id/myspin"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:entries="@array/city_label"/> 
	   <RadioGroup 
	        android:id="@+id/myrgp"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:orientation="vertical">
	   	    <RadioButton 
	   	        android:id = "@+id/utf8"
	   	        android:text="UTF编码"
	   	    />
	   	    <RadioButton 
	   	        android:id = "@+id/gbk"
	   	        android:text="GBK编码"
	   	    />
	   </RadioGroup>     
   </TableRow>
   
   <TimePicker
        android:id="@+id/mytime"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        />  
   <DatePicker
        android:id="@+id/mydate"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        />                           
</TableLayout>

2)添加表格数据
<TableLayout    //表格编码器
android:shrinkColumns="3"          //制定第3列为伸缩列，即是如果字符串太长了     ，他会移到下一列居中显示
android:collapseColumns="1，4"第1,4 列不显示
android:background="@drawable/christmas"作背景图片

 <TableRow >
       <TextView
	        android:layout_column="0"   //ID编号
	        android:text="ID"             
	        android:gravity="center_horizontal"  //水平居中 
	        android:padding="8px"/>            //宽8个像素
	   <TextView
	        android:layout_column="1"
	        android:text="姓名"
	        android:gravity="center_horizontal" 
	        android:padding="8px"/> 
	  <TextView
	        android:layout_column="2"
	        android:text="email"
	        android:gravity="center_horizontal" 
	        android:padding="8px"/> 
	 <TextView
	        android:layout_column="3"
	        android:text="地址"
	        android:gravity="center_horizontal" 
	        android:padding="8px"/>                 
   </TableRow>

</TableLayout>

3)在程序里动态添加表格的数据（基本没这么用）
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TableLayout.LayoutParams;

private String titleData[][]= new String[][]{{"1","2","3","4"},{"5","6","7","8"}};//定义要显示的数据


TableLayout layout=new TableLayout(this);//定义表格布局
        TableLayout.LayoutParams layoutpar= new TableLayout.LayoutParams(
        		ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.FILL_PARENT);//定义布局管理器参数
        for(int x=0;x<this.titleData.length;x++)
        {
        	TableRow row=new TableRow(this);
        	for(int y=0;y<this.titleData[x].length;y++)
        	{
        		TextView textv=new TextView(this);
        		textv.setText(this.titleData[x][y]);
        		row.addView(textv,y);//加入组件编号        		
        	}
        	layout.addView(row);//向表格中间增加表格行
        }
        
        setContentView(layout,layoutpar);//增加新的布局管理器

*相对布局: 
<RelativeLayout
    <ImageView
        android:id="@+id/img1"//组件1，是参考点
    />
    <ImageView
        android:id="@+id/img2"
        android:layout_toRightOf="@+id/img1"//组件放在1右边
    />
    <ImageView
        android:id="@+id/img3"              //组件3放在2右下角
        android:layout_toRightOf="@+id/img1"
        android:layout_below="@+id/img2"
    />
<RelativeLayout/> 
RelativeLayout用到的一些重要的属性：

第一类:属性值为true或false
android:layout_centerHorizontal 水平居中
android:layout_centerVertical 垂直居中
android:layout_centerInparent 相对于父元素完全居中
android:layout_alignParentBottom 贴紧父元素的下边缘
android:layout_alignParentLeft 贴紧父元素的左边缘
android:layout_alignParentRight 贴紧父元素的右边缘
android:layout_alignParentTop 贴紧父元素的上边缘
android:layout_alignWithParentIfMissing 如果对应的兄弟元素找不到的话就以父元素做参照物

第二类：属性值必须为id的引用名“@id/id-name”
android:layout_below 在某元素的下方
android:layout_above 在某元素的的上方
android:layout_toLeftOf 在某元素的左边
android:layout_toRightOf 在某元素的右边

android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐
android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐
android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐
android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐

第三类：属性值为具体的像素值，如30dip，40px
android:layout_marginBottom 离某元素底边缘的距离
android:layout_marginLeft 离某元素左边缘的距离
android:layout_marginRight 离某元素右边缘的距离
android:layout_marginTop 离某元素上边缘的距离  
例如：
<Button  
       android:id="@+id/button1"  
      android:layout_width="wrap_content"　　　　　　　　　　　　　　　　//宽度匹配内容  
       android:layout_height="wrap_content"　　　　　　　　　　　　　　　//高度匹配内容　　  
       android:layout_alignParentLeft="true"                         //贴紧父元素左边  
       android:layout_alignParentTop="true"　　　　　　　　　　　　　　　//贴紧父元素上边　  
       android:layout_marginLeft="20dp"                              //设置左间距20dp  
       android:layout_marginTop="20dp"                               //设置上间距20dp 
<Button  
		android:id="@+id/button2"  
		android:layout_width="wrap_content"　　　　　　　　　　　　　　//宽度匹配内容  
		android:layout_height="wrap_content"　　　　　　　　　　　　 　//高度匹配内容  
		android:layout_below="@+id/button1"　　　　　　　　　　　　　　//位置在第一个按钮的下面  
		android:layout_toRightOf="@+id/button1" 　　　　　　　　　　　//与第一个按钮的右边对齐  
		android:layout_marginTop="15dp"                            //设置上间距15dp  
　　　　 android:text="第二个按钮" />  	   
<Button  
	android:id="@+id/button3"  
	android:layout_width="wrap_content"　　　　　　　　　　　　　　//宽度匹配内容  
	android:layout_height="wrap_content"　　　　　　　　　　　　 　//高度匹配内容  
	android:layout_below="@+id/button2"　　　　　　　　　　　　　　//位置在第二个按钮的下面  
	android:layout_toLeftOf="@+id/button2"　　　　　　　　　　　　//与第二个按钮的左边对齐  
	android:layout_marginTop="15dp"　　　　　　　　　　　　　　　　//设置上间距15dp          
	android:text="第三个按钮" />  

*布局的嵌套
<TableLayout>
   ...
   <LinearLayout 
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    android:layout_below="@+id/mygrp" 
    >
   </LinearLayout>
</TableLayout>

*绝对布局，也就是用坐标来指定每一个控件的位置
<?xml version="1.0" encoding="utf-8"?> 
<AbsoluteLayout xmlns:android="http://schemas.android.com/apk/res/android" 
    android:orientation="vertical" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent" 
    > 
<!-- 定义一个文本框，使用绝对定位 --> 
<TextView  
    android:layout_x="20dip" 
    android:layout_y="20dip" 
    android:layout_width="wrap_content"  
    android:layout_height="wrap_content"  
    android:text="用户名：" 
    /> 
<!-- 定义一个文本编辑框，使用绝对定位 --> 
<EditText  
    android:layout_x="80dip" 
    android:layout_y="15dip" 
    android:layout_width="wrap_content"  
    android:width="200px"  
    android:layout_height="wrap_content"  
    /> 
<!-- 定义一个文本框，使用绝对定位 -->    
<TextView  
    android:layout_x="20dip" 
    android:layout_y="80dip" 
    android:layout_width="wrap_content"  
    android:layout_height="wrap_content"  
    android:text="密  码：" 
    /> 
<!-- 定义一个文本编辑框，使用绝对定位 -->  
<EditText  
    android:layout_x="80dip" 
    android:layout_y="75dip" 
    android:layout_width="wrap_content"  
    android:width="200px"  
    android:layout_height="wrap_content"  
    android:password="true" 
    /> 
<!-- 定义一个按钮，使用绝对定位 --> 
<Button  
    android:layout_x="130dip" 
    android:layout_y="135dip" 
    android:layout_width="wrap_content"  
    android:layout_height="wrap_content"  
    android:text="登   录" 
    />    
</AbsoluteLayout> 


//********
//事件处理
//********
一般是对控件进行监听，如果用户触发了事件，则产生一个事件源。针对这个事件源，进行
方法的处理。每一个事件处理的接口都需要一个特定的方法进行事件的绑定操作

*单击事件
单击接口的定义如下
public static interface View.OnClickListener
{
	public void onClick(View v);
}
static，把接口从内部接口，改为外部接口。注册的onClick函数，表示单击后执行的函数
。而传入的是一个操作此方法的组件的对象，因为所有类都是View类的子类

1.处理一个单击事件的程序
import android.view.View;
import android.view.View.OnClickListener;

Button btn1 = null;
TextView txt1 = null;
@Override
protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	setContentView(R.layout.activity_main);
		
	this.btn1 = (Button) super.findViewById(R.id.btn1);
	this.txt1 = (TextView) super.findViewById(R.id.txt1);
//用btn1.setOnClickListener的方法为按钮绑定一个接口的对象
	this.btn1.setOnClickListener(new showviewListener());//设置事件
}

//创建一个专门处理单击接口的子类
private class showviewListener implements OnClickListener
{
	//内部处理
	public void onClick(View v)
	{
		//因为不是本函数，因此只有写成MainActivity(类的名称).this(代表本类).txt1,或者直接txt1即可
		String info = txt1.getText().toString();//取得txt1的内容
		txt1.setText("Hello WOrld+"+info);
	}
}

2.上面程序专门定义了一个处理单击事件的子类showviewListener，但是如果这个子类只
使用一次的话，就没有必要单独定义一个子类，而可以使用一个匿名内部类的方式完成
protected void onCreate(Bundle savedInstanceState)
{
	super.onCreate(savedInstanceState);
	setContentView(R.layout.activity_main);
		
	this.btn1 = (Button) super.findViewById(R.id.btn1);
	this.txt1 = (TextView) super.findViewById(R.id.txt1);
	this.btn1.setOnClickListener(new OnClickListener()
	{
		public void onClick(View v)
		{
			String info = txt1.getText().toString();
			txt1.setText("Hello WOrld+"+info);
		}
	}
	);

}


3.进行横屏和竖屏的切换
1)、禁止横竖屏转换
(1)系统XML文件:AndroidMainfest.xml
转屏幕是一个系统服务，就需要一些系统权限支持
<activity
            android:name="com.example.buttonclick.MainActivity"
            android:label="@string/app_name"
            //设当前系统为竖屏显示
            android:screenOrientation="portrait" >

//改变系统权限允许改变配置信息的权限
<uses-permission 
	    android:name = "android.permission.CHANGE_CONFIGURATION"
	/>
	
android:screenOrientation="landscape"，为横屏显示。
android:screenOrientation="nosensor",彻底禁止翻转

(2)在原先AndroidMainfest.xml中已经配置好了情况下，要在程序中修改
	public void onClick(View v)
	{
	//String info = txt1.getText().toString();
	//txt1.setText("Hello WOrld+"+info);
	//无法进行画面选转
	if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)
	{
		txt1.setText("无法进行画面选转");
	}
	//如果是横屏
	else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
	{
		txt1.setText("现在是横屏");
		//变为竖屏										MainActivity.this.setRequestedOrientation		(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
	}
	//如果是竖屏
	else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
	{
		txt1.setText("现在是竖屏");
		//变为横屏								MainActivity.this.setRequestedOrientation		(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
	}	
}
另外，android中每次屏幕的切换动会重启Activity，所以应该在Activity销毁前保存当前活动的状态，在Activity再次Create的时候载入配置，那样，进行中的游戏就不会自动重启了！			
2)横竖屏切换
(1)
如果要让软件在横竖屏之间切换，由于横竖屏的高宽会发生转换，有可能会要求不同的布局。
在res目录下建立layout-land和layout-port目录,相应的layout文件名不变，比如main.xml。layout-land是横屏的layout,layout-port是竖屏的layout，其他的不用管，横竖屏切换时程序为调用Activity的onCreate方法，从而加载相应的布局。
例如：
res\layout-land
    activity_main.xml
res\layout-port
    activity_main.xml
res\layout

MainActivity.java文件
protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	setContentView(R.layout.activity_main);
	Log.i("EV_JNI","程序开始");
	Button btn=(Button)findViewById(R.id.btn);
	btn.setOnClickListener(new View.OnClickListener() {
			
		@Override
		public void onClick(View v) {
			// TODO Auto-generated method stub
			if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)
			{
				Log.i("EV_JNI","无法进行画面选转");
			}
			//如果是横屏
			else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
			{
				Log.i("EV_JNI","现在是横屏->转为竖屏");
				//变为竖屏										
				MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
			}
			//如果是竖屏
			else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
			{
				Log.i("EV_JNI","现在是竖屏->转为横屏");
				//变为横屏								
				MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
			}
		}
	});
}	

(2)在上面那个方法中，运行时
打印：08-31 14:13:36.039: I/EV_JNI(32343): 程序开始
当点击一下切换按钮，他由横屏转为竖屏，并打印
08-31 14:14:08.349: I/EV_JNI(32343): 现在是横屏->转为竖屏
08-31 14:14:08.489: I/EV_JNI(32343): 程序开始
当点击一下切换按钮，他由竖屏转为横屏，并打印
08-31 14:14:43.419: I/EV_JNI(32343): 现在是竖屏->转为横屏
08-31 14:14:43.599: I/EV_JNI(32343): 程序开始

说明：Activity每次横竖屏切换都会重新调用onPause-> onStop-> onDestory-> onCreate->onStart->onResume，为此涉及到内容和数据的保存和读取，否则转屏之前的内容就会消失了。很多时候这样的结果让程序繁琐

解决方法：
Android提供了在manifest中设置android:configChanges属性，从而让Activity不延续上述的重建流程。在Android工程的Mainfest.xml中配置Activity：android:configChanges="keyboardHidden|orientation"，横竖屏切换之后就不会去执行OnCreat函数了，而是会去调用onConfigurationChanged（）

AndroidMainfest.xml
<activity
            android:name="com.example.buttonclick.MainActivity"
            android:label="@string/app_name"
            //设当前系统为竖屏显示
            android:screenOrientation="landscape"
            //表示两种操作都可以触发事件
            android:configChanges="orientation|keyboardHidden"
 >
 
MainActivity.java文件
@Override
protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	setContentView(R.layout.activity_main);
	Log.i("EV_JNI","程序开始");
	Button btn=(Button)findViewById(R.id.btn);
	btn.setOnClickListener(new View.OnClickListener() {
		
		@Override
		public void onClick(View v) {
			// TODO Auto-generated method stub
			if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)
			{
				Log.i("EV_JNI","无法进行画面选转");
			}
			//如果是横屏
			else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
			{
				Log.i("EV_JNI","现在是横屏->转为竖屏");
				//变为竖屏										
				MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
			}
			//如果是竖屏
			else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
			{
				Log.i("EV_JNI","现在是竖屏->转为横屏");
				//变为横屏								
				MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
			}
		}
	});
}

运行时
08-31 14:27:08.459: I/EV_JNI(10597): 程序开始
当点击一下切换按钮，他由横屏转为竖屏，并打印
08-31 14:27:50.559: I/EV_JNI(10597): 现在是横屏->转为竖屏
08-31 14:27:50.709: I/EV_JNI(10597): 现在变成是竖屏
08-31 14:27:50.769: I/EV_JNI(10597): 程序开始
当点击一下切换按钮，他由竖屏转为横屏，并打印
08-31 14:28:11.009: I/EV_JNI(10597): 现在是竖屏->转为横屏
08-31 14:28:11.129: I/EV_JNI(10597): 现在变成是横屏
08-31 14:28:11.189: I/EV_JNI(10597): 程序开始

(3)假如布局资源不按照如上设置，则可以通过java代码来判断当前是横屏还是竖屏然后来加载相应的xml布局文件。因为当屏幕变为横屏的时候,系统会重新呼叫当前Activity的onCreate方法,你可以把以下方法放在你的onCreate中来检查当前的方向,然后可以让你的setContentView来载入不同的layout xml。
if(this.getResources().getConfiguration().orientation==Configuration.ORIENTATION_LANDSCAPE)
{  
     Log.i("info", "landscape"); // 横屏 
}  else if(this.getResources().getConfiguration().orientation==Configuration.ORIENTATION_PORTRAIT)
 {  
    Log.i("info", "portrait"); // 竖屏 
 }
 
(4)适配不同的屏幕
有4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge)
适配大屏幕的layout：res\layout-large\
适配横屏大屏幕res\layout-large-land

(5)创建不同的bitmap
xhdpi: 2.0
hdpi: 1.5
mdpi: 1.0 (基准)
ldpi: 0.75
这意味着，如果针对xhdpi的设备生成了一张200x200的图像，那么应该为hdpi生成150x150,为mdpi生成100x100, 和为ldpi生成75x75的图片资源

3)自适应转换
（1）
如果想让它启动的时候是横屏的话就横屏表示，纵屏的话就纵屏表示，然后手机切换横竖屏就不能用了
此处的screenOrientation有如下选项： 
==================================================================
= unspecified 默认值，由系统判断状态自动切换 
= landscape 横屏 
= portrait 竖屏 
= user 用户当前设置的orientation值 
= behind 下一个要显示的Activity的orientation值 
= sensor 使用传感器 传感器的方向 
= nosensor 不使用传感器 基本等同于unspecified

此处的configChanges有如下选项： 如果需要多个选项 用"|"隔开 
==================================================================
= orientation 屏幕在纵向和横向间旋转 
= keyboardHidden 键盘显示或隐藏 
= fontScale 用户变更了首选的字体大小 
= locale 用户选择了不同的语言设定 
= keyboard 键盘类型变更，例如手机从12键盘切换到全键盘 
= touchscreen或navigation 键盘或导航方式变化，一般不会发生这样的事件 
1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 
2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 
3、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法

AndroidMainfest.xml
<activity
            android:name="com.example.pingmu.MainActivity"
            android:label="@string/app_name"
			//当前系统按重力传感器自动切换横屏和竖屏
            android:screenOrientation="sensor" 
            android:configChanges="keyboardHidden|orientation">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

MainActivity.java文件
public class MainActivity extends Activity {
	int orientation=0;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		Log.i("EV_JNI","程序开始");
		//取得屏幕的长和宽，进行比较设置横竖屏的变量
		Display display = getWindowManager().getDefaultDisplay();  
		 int width = display.getWidth();  
		int height = display.getHeight();  
		if (width > height) {  
		      orientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;  //横屏
		} else {  
		      orientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;  //竖屏
		}
		//设置横屏还是竖屏的布局策略
		MainActivity.this.setRequestedOrientation(orientation);
		
		Button btn=(Button)findViewById(R.id.btn);
		btn.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)
				{
					Log.i("EV_JNI","无法进行画面选转");
				}
				//如果是横屏
				else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
				{
					Log.i("EV_JNI","现在是横屏->转为竖屏");
					//变为竖屏										
					MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
				}
				//如果是竖屏
				else if(MainActivity.this.getRequestedOrientation()==ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
				{
					Log.i("EV_JNI","现在是竖屏->转为横屏");
					//变为横屏								
					MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
				}
			}
		});
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		// TODO Auto-generated method stub
		super.onConfigurationChanged(newConfig);
		if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)
		{
            	// land do nothing is ok
			Log.i("EV_JNI","现在变成是横屏");
	    } 
		else if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT)
	    {
	            // port do nothing is ok
			Log.i("EV_JNI","现在变成是竖屏");  
	    }		
	}
	
}


（2）但是这样的话你切到别的画面的时候再回到原画面，它就仍然是横的或者是纵的。怎么让它从别的屏幕回来后，又重新横竖屏布局呢？
只要在OnResume()中在设定下就行了，但是这个只支持横竖屏只有一个layout的。横竖屏分别对应layout的还不知道该怎么解决。
protected void onResume() {  
2.      orientation = ActivityInfo.SCREEN_ORIENTATION_USER;  
3.      this.setRequestedOrientation(orientation);  
4.      Display display = getWindowManager().getDefaultDisplay();  
5.      int width = display.getWidth();  
6.      int height = display.getHeight();  
7.      if (width > height) {  
8.          orientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;  
9.      } else {  
10.         orientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;  
11.     }  
12.     super.onResume();  
13. }  

4.适配不同的语言
1)默认文件比如res/values/strings.xml，用于保存字符串值
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="title">My Application</string>
    <string name="hello_world">Hello World!</string>
</resources>

添加不同区域语言的字符串值到相应的文件:
英语(默认区域语言)，/values/strings.xml:

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="title">My Application</string>
    <string name="hello_world">Hello World!</string>
</resources>
西班牙语，/values-es/strings.xml:

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="title">Mi Aplicación</string>
    <string name="hello_world">Hola Mundo!</string>
</resources>
法语，/values-fr/strings.xml:

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="title">Mon Application</string>
    <string name="hello_world">Bonjour le monde !</string>
</resources>

2)使用字符资源
textView.setText(R.string.hello_world);
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" />
	
	

4.弹出小键盘后，不遮住页面
AndroidManifest.xml 中设置 android:windowSoftInputMode="stateUnspecified|adjustPan" 不挤压屏幕，反之为把界面挤压上去。
例如：
<activity
	android:name="com.easivend.app.business.BusHuo"
	android:label="@string/app_name"
	android:windowSoftInputMode="stateUnspecified|adjustPan"
	android:screenOrientation="sensor"
	android:configChanges="keyboardHidden|orientation">
</activity>

5.CheckBox触发事件：让EditText明文显示或者密码显示
private class onClickListenerChk implements OnClickListener
	{
		public void onClick(View v)
		{
			if(chk1.isChecked())
			{
				//设置为明文显示	
				edt1.setTransformationMethod(HideReturnsTransformationMethod.getInstance());
			}
			else
			{
				//设置为密码显示	
				edt1.setTransformationMethod(PasswordTransformationMethod.getInstance());
			}
		}
	}
变种Switch:
<Switch   
   android:layout_marginTop="20dip"  
   android:id="@+id/state_switch"  
   android:layout_width="wrap_content"  
   android:layout_height="wrap_content"  
   android:textOn="联网版"  
   android:textOff="单机版"  							           
   android:layout_gravity="center_horizontal"/> 
   
   
switchamount = (Switch)findViewById(R.id.switchamount);
switchamount.setOnCheckedChangeListener(new OnCheckedChangeListener() {

	@Override
	public void onCheckedChanged(CompoundButton buttonView,
			boolean isChecked) {
		// TODO Auto-generated method stub
		btnamount.setEnabled(isChecked);	
	}  
	
	
}); 

*单选钮接口:OnCheckedChangeListener
import android.widget.RadioGroup.OnCheckedChangeListener;
protected void onCreate(Bundle savedInstanceState) 
{
    this.grp = (RadioGroup) super.findViewById(R.id.mygrp);
    this.rbtnUTF = (RadioButton) super.findViewById(R.id.rbtnUTF);
    this.rbtnGBK = (RadioButton) super.findViewById(R.id.rbtnGBK);		
    this.grp.setOnCheckedChangeListener(new OnCheckedChangeListenergrp());
}

private class OnCheckedChangegrp implements OnCheckedChangeListener
{
	//方法可以通过source->override/Im.. Methods->选到
	@Override
	public void onCheckedChanged(RadioGroup group, int checkedId) 
	{
		String temp=null;
		if(MainActivity.this.rbtnUTF.getId()==checkedId)
		{
			temp = MainActivity.this.rbtnUTF.getText().toString();			
		}
		else if(MainActivity.this.rbtnGBK.getId()==checkedId)
		{
			temp = MainActivity.this.rbtnGBK.getText().toString();				
		}
		edt1.setText(temp);
	}
		
}

*下拉列表框接口:OnItemSelectedListener选项变更事件
1.
import android.widget.AdapterView.OnItemSelectedListener;

this.myspin = (Spinner) super.findViewById(R.id.myspin);
this.myspin.setOnItemSelectedListener(new OnItemSelectedListenercity());


private class OnItemSelectedListenercity implements OnItemSelectedListener
{

	@Override
	//当选项改变时触发
	public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2,
			long arg3) 
	{
		// TODO Auto-generated method stub
                //arg2即是position参数 
		String values = arg0.getItemAtPosition(arg2).toString();//取得选中的选项
		edt1.setText(values);
	}

	@Override
	public void onNothingSelected(AdapterView<?> arg0) {
		// TODO Auto-generated method stub		
		}
				
}

2.联动菜单，当选择city菜单时，相应的第二个下拉菜单的城市名称会改变
import android.widget.AdapterView.OnItemSelectedListener;
import java.util.ArrayList;

String areaData[][]=new String[][]
{
	{"北京","上海","广州"},{"巴比伦","圣弗朗西斯哥","雅加达"},{"富兰克林","利物浦","圣地亚哥"}
};
private ArrayAdapter<CharSequence> arrayadapter = null;//因为是泛型，所以指定所有的数据都是CharSequence


this.cityspin = (Spinner) super.findViewById(R.id.cityspin);
this.cityspin.setOnItemSelectedListener(new OnItemSelectedListenercity());
this.areaspin = (Spinner) super.findViewById(R.id.areaspin);


private class OnItemSelectedListenercity implements OnItemSelectedListener
{

	@Override
	//当选项改变时触发
	public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2,
			long arg3) 
	{
		// TODO Auto-generated method stub
		//String values = arg0.getItemAtPosition(arg2).toString();//取得选中的选项
		//edt1.setText(values);
                //配置显示信息，//arg2即是position参数 
		MainActivity.this.arrayadapter = new ArrayAdapter<CharSequence>(MainActivity.this, 		android.R.layout.simple_spinner_item,MainActivity.this.areaData[arg2]);
		//设置显示信息	
                MainActivity.this.areaspin.setAdapter(MainActivity.this.arrayadapter);
	}

	@Override
	public void onNothingSelected(AdapterView<?> arg0) {
		// TODO Auto-generated method stub
			
	}
				
}

3.直接得到选项的值
dialogspincabtype.getSelectedItem();//得到选项值
dialogspincabtype.getSelectedItemId()//得到选项id索引
spinbillmanagerbill.getSelectedItemPosition()//得到选项数字位置


*日期和时间选择器接口DatePicker,TimePicker:
android.widget.DatePicker.OnDateChangedListener;
android.widget.TimePicker.OnTimeChangedListener;

this.mytime.setOnTimeChangedListener(new onTimeChangedListenertime());
//注意，日期的绑定方法这样写
this.mydate.init(this.mydate.getYear(), this.mydate.getMonth(), this.mydate.getDayOfMonth(), new onDateChangedListenerdate());

*焦点改变事件:
android.View.OnFocusChangeListener

*常按事件:android.View.OnLongClickListener
1.操作手机桌面的方法
clearWallpaper();   清除已有的手机屏幕
setWallpaper(bitmap);通过bitmap设手机屏幕
setWallpaper(inputstream);通过输入流设置手机屏幕
getWallpaper();取得手机屏幕信息

*键盘事件：import android.view.View.OnKeyListener;
在接口的处理方法中，要区分KeyEvent中事件，是按下，还是弹起
private class OnKeyListeneremail implements OnKeyListener
{

	@Override
	public boolean onKey(View v, int keyCode, KeyEvent event) 
	{
		// TODO Auto-generated method stub
		//得到操作类型
		switch(event.getAction())
		{
			case KeyEvent.ACTION_UP:弹起
				String s=MainActivity.this.myedt.getText().toString();
				if(s.matches("\\w+@\\w+\\.\\w+"))//正则表达式验证
				{
					MainActivity.this.mytext.setText("邮箱地址正确");
				}
				else            按下
				{
					MainActivity.this.mytext.setText("邮箱地址错误");
				}	
				break;
			case KeyEvent.ACTION_DOWN:
				break;
		}
		
		return false;
	}
	
}
*触摸事件:当用户在屏幕上划过时，取得当前的坐标OnTouchListener
import android.view.View.OnTouchListener;
private class setOnTouchListeneredt implements OnTouchListener
{

	@Override
	public boolean onTouch(View v, MotionEvent event) {
		//MainActivity.this.myedt.setText("x="+event.getX() + " Y="+ event.getY());
		Point p = new Point((int)event.getX(),(int)event.getY());//将坐标保存到Point类
		if(event.getAction()==MotionEvent.ACTION_DOWN)
		{
				
		}
		else if(event.getAction()==MotionEvent.ACTION_UP)
		{
				
		}
		else if(event.getAction()==MotionEvent.ACTION_MOVE)//用户移动
		{
				
		}
		// TODO Auto-generated method stub
		return false;
	}
	
}


//********
//复杂控件
//********
*滚动视图ScrollView:android.widget.ScrollView
滚动视图可以看作一个布局管理器，但是里面只能存在一个组件
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >
	<RelativeLayout 
         android:layout_width="match_parent"
	    android:layout_height="match_parent"	    
	    tools:context=".MainActivity" >
         。。。
        </RelativeLayout>

</ScrollView>
可以在嵌套布局里面直接添加组件

2.通过程序来添加
//这些信息以后通过程序加入到内嵌的线性布局文件中
private String dataList[]=new String[]{"11","22","33","44","55","66","77","88","99"};
LinearLayout lineLayout = null;

this.lineLayout = (LinearLayout) super.findViewById(R.id.lineLayout);//取得线性布局控件
//定义布局参数
LinearLayout.LayoutParams param = new LinearLayout.LayoutParams(
  		ViewGroup.LayoutParams.FILL_PARENT,
    		ViewGroup.LayoutParams.WRAP_CONTENT
    		);
for(int x=0;x<this.dataList.length;x++)
{
    	Button btn=new Button(this);
    	btn.setText(this.dataList[x]);
    	lineLayout.addView(btn,param);//增加组件
}


*列表显示他是一个控件，作用和scrollView类似:ListView:android.widget.ListView
1.
ListView本身就是一个组件，如果要配置他的显示内容，可以使用setAdapter()方法完成，
而setAdapter()方法需要设置ListAdapter接口的对象
一个简单的例子
private String dataList[]=new String[]{"11","22","33","44","55","66","77","88","99"};
private ListView list = null;

//setContentView(R.layout.activity_main);说明现在程序不再通过activity_main的
xml文件布局，了而是通过程序自定义布局
 
this.list = new ListView(this);
//为list组件设置内容
this.list.setAdapter(new ArrayAdapter<String>(this,
 		android.R.layout.simple_list_item_1,this.dataList));
super.setContentView(this.list);//显示组件

（1）通过指定android.R.layout.simple_list_item_checked这个资源，实现带选择框的ListView。需要用setChoiceMode()方法设定选择为多选还是单选，否则将不能实现选择效果，运行效果如图4-30所示。

实现代码如下：

lv.setAdapter(new ArrayAdapter<String>(this,
                android.R.layout.simple_list_item_checked, strs));
lv.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
 （2）通过指定android.R.layout.simple_list_item_multiple_choice这个资源实现带CheckBox的ListView。同样的，需要用setChoiceMode()方法来设置单选或者多选，运行效果如图4-31所示。

实现代码如下：

lv.setAdapter(new ArrayAdapter<String>(this,
                android.R.layout.simple_list_item_multiple_choice, strs));
lv.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
（3）通过指定android.R.layout.simple_list_item_single_choice这个资源实现带RadioButton的ListView。这里要注意的是，这里并不是指定了单选。是多选还是单选要通过setChoiceMode()方法来指定，运行效果如图4-32所示。

实现代码如下：

 

lv.setAdapter(newArrayAdapter<String>(this,

android.R.layout.simple_list_item_single_choice,strs));

lv.setChoiceMode(ListView.CHOICE_MODE_SINGLE);



2.进行复杂的显示:android.widget.SimpleAdapter类
很多时候需要在列表中展示一些除了文字以外的东西，比如图片等
1）定义一个模板布局管理器
新建Layout/data_list
<?xml version="1.0" encoding="utf-8"?>
<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    <TableRow >
		<ImageView 
    	    android:id = "@+id/icon"
    	    android:layout_width="wrap_parent"
			android:layout_height="wrap_parent"
			android:src="@drawable/icon"
    	/> 
    	<TextView 
    	    android:id = "@+id/_id"
    	    android:textSize="15px"
    	    android:gravity="center"
    	    android:layout_width="wrap_content"
    	    android:layout_height="wrap_content"
    	/> 
    	<TextView 
    	    android:id = "@+id/_name"
    	    android:textSize="15px"
    	    android:gravity="center"
    	    android:layout_width="wrap_content"
    	    android:layout_height="wrap_content"
    	/>   
    </TableRow>
	<View                              
        android:layout_height="2px"
        android:background="#FF909090"
    />
</TableLayout>

此时每个TableRow都表示一个ListView中定义的表格行处理
2)主要的activity_main.xml文件中新建一个ListView
<ListView 
	android:id="@+id/datalist"
	android:layout_width="fill_parent"
	android:layout_height="wrap_content"
/>

3)Activity程序中，需要使用SimpleAdapter类的对象来处理要包装的数据
import java.util.List;
import java.util.Map;
import java.util.HashMap;

//这些信息以后通过程序加入到内嵌的线性布局文件中
private String dataList[][]=new String[][]{{"11","aa"},{"22","bb"},{"33","cc"},{"44","dd"},{"55","ee"},
		{"66","ff"},{"77","gg"},{"88","hh"},{"99","ii"}};
private ListView list = null;
//定义显示的内容包装，因为他有两列，因此就两个
private List<Map<String,String>> listMap = new ArrayList<Map<String,String>>();
private SimpleAdapter simpleada = null;//进行数据的转换操作
	

this.list =(ListView) super.findViewById(R.id.datalist);
for(int x=0;x<this.dataList.length;x++)
{
  	Map<String,String> map = new HashMap<String,String>();//定义Map集合，保存每一行数据
   	map.put("_id", this.dataList[x][0]);//与data_list中的_id这一列加载数据
    	map.put("_name", this.dataList[x][1]);//与data_list中的_name这一列加载数据
    	this.listMap.add(map);//保存数据行
}
//将这个构架加载到data_list中            数据填充        控件布局
this.simpleada = new SimpleAdapter(this,this.listMap,R.layout.data_list,
    		new String[]{"_id","_name"},//Map中的key名称
    		new int[]{R.id._id,R.id._name});//list中的控件名称
this.list.setAdapter(this.simpleada);

如果一行有多列：
for(int x=0;x<this.dataList.length;x++)
{
  	Map<String,String> map = new HashMap<String,String>();//定义Map集合，保存每一行数据
   	map.put("_id", this.dataList[x][0]);//与data_list中的_id这一列加载数据
    	map.put("_name", this.dataList[x][1]);//与data_list中的_name这一列加载数据
	map.put("a", this.dataList[x][0]);//与data_list中的a这一列加载数据
    map.put("b", this.dataList[x][0]);//与data_list中的b这一列加载数据	
    this.listMap.add(map);//保存数据行
}
//将这个构架加载到data_list中            数据填充        控件布局
this.simpleada = new SimpleAdapter(this,this.listMap,R.layout.data_list,
    		new String[]{"_id","_name","a","b"},//Map中的key名称
    		new int[]{R.id._id,R.id._name,R.id.a,R.id.b});//list中的控件名称

3.更复杂的显示:android.widget.SimpleAdapter类
1）定义一个模板布局管理器
新建Layout/data_list
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal" >
	<ImageView                           //放大图片
    	    android:id = "@+id/icon"
    	    android:layout_width="wrap_parent"
			android:layout_height="wrap_parent"
			android:padding="3px"
    	/>
    <LinearLayout 
	    android:layout_width="200px"
	    android:layout_height="wrap_content"
	    android:orientation="vertical"
	    android:gravity="left" >
	    <TextView
	        android:id="@+id/title"
	        android:textSize="16px"
	        android:padding="3px"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        />
	    <TextView
	        android:id="@+id/author"
	        android:textSize="16px"
	        android:padding="3px"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        />
    </LinearLayout>
    <LinearLayout 
	    android:layout_width="200px"
	    android:layout_height="wrap_content"
	    android:orientation="vertical"
	    android:gravity="left" >
	    <TextView
	        android:id="@+id/type"
	        android:textSize="16px"
	        android:padding="3px"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        />
	    <ImageView                      //放星星评分图片
	        android:id="@+id/score"
	        android:textSize="16px"
	        android:padding="3px"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        />
    </LinearLayout>
</LinearLayout>
2)主要的activity_main.xml文件中新建一个ListView
<ListView 
	android:id="@+id/datalist"
	android:layout_width="fill_parent"
	android:layout_height="wrap_content"
/>

3)Activity程序中，需要使用SimpleAdapter类的对象来处理要包装的数据
private int pic[]=new int[]{R.drawable.pic_1,R.drawable.pic_2,R.drawable.pic_3};
private String data[][]=new String[][]{{"aa","11"},{"bb","22"},{"cc","33"},{"dd","44"},
			{"ee","55"},{"ff","66"},{"gg","77"}};
private ListView datalist;
//定义显示的内容包装，因为他有两列，因此就两个
private List<Map<String,String>> listMap = new ArrayList<Map<String,String>>();
private SimpleAdapter simpleada = null;//进行数据的转换操作


@Override
protected void onCreate(Bundle savedInstanceState) {
   super.onCreate(savedInstanceState);
   setContentView(R.layout.activity_main);
   this.datalist = (ListView) super.findViewById(R.id.datalist);
   for(int x=0;x<this.data.length;x++)
   {
       	Map<String,String> map = new HashMap<String,String>();//定义Map集合，保存每一行数据
       	map.put("pic", String.valueOf(this.pic[x]));
		map.put("title", this.data[x][0]);//与data_list中的_id这一列加载数据
        map.put("author", this.data[x][1]);//与data_list中的_name这一列加载数据
        map.put("type", "免费");//与data_list中的_name这一列加载数据
        map.put("score", String.valueOf(R.drawable.start5));//5颗星
        this.listMap.add(map);//保存数据行
    }
    //将这个构架加载到data_list中
    this.simpleada = new SimpleAdapter(this,this.listMap,R.layout.datalist,
   		new String[]{"pic","title","author","type","score"},//Map中的key名称
      		new int[]{R.id.pic,R.id.title,R.id.author,R.id.type,R.id.score});
        this.datalist.setAdapter(this.simpleada);
        
}

4.事件处理:android.widget.AdapterView
例如:AdapterView.OnItemSelectedListener这个监听接口用来选中ListView中行的编号

this.datalist.setOnItemClickListener(new OnItemClickListenerList());

private class OnItemClickListenerList implements OnItemClickListener
{

	@Override
	public void onItemClick(AdapterView<?> arg0, View arg1, int arg2,
				long arg3)
	{
		// TODO Auto-generated method stub
		Map<String,String> map = (Map<String,String>) MainActivity.this.simpleada.getItem(arg2);//取得所选中的内容
		//打印到textview中
		MainActivity.this.listSeltxt.setText(map.get("title")+" "+map.get("author")+" "+map.get("type")+" "+map.get("score") );
	}
    	
}

5.模拟报表控件
1)创建listviewlayout.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal" >
    <View 
        android:layout_width="0.5px" 
        android:layout_height="fill_parent" 
        android:background="#B8B8B8" 
        android:visibility="visible" /> 
   
    <TextView 
        android:id="@+id/id" 
        android:layout_width="40dip" 
        android:layout_height="55dip" 
        android:textColor="#CD3700" 
        android:textSize="20sp" /> 
   
    <View 
        android:layout_width="0.5px" 
        android:layout_height="fill_parent" 
        android:background="#B8B8B8" 
        android:visibility="visible" /> 
   
    <TextView 
        android:id="@+id/job" 
        android:layout_width="200dip" 
        android:layout_height="wrap_content" 
        android:textColor="#000000" 
        android:textSize="17sp" /> 
   
    <View 
        android:layout_width="0.5px" 
        android:layout_height="fill_parent" 
        android:background="#B8B8B8" 
        android:visibility="visible" /> 
   
    <TextView 
        android:id="@+id/addr" 
        android:layout_width="150dip" 
        android:layout_height="wrap_content" 
        android:textColor="#000000" 
        android:textSize="17sp" /> 
   
    <View 
        android:layout_width="0.5px" 
        android:layout_height="fill_parent" 
        android:background="#B8B8B8" 
        android:visibility="visible" /> 
   
    <TextView 
        android:id="@+id/student" 
        android:layout_width="100dip" 
        android:layout_height="wrap_content" 
        android:textColor="#000000" 
        android:textSize="20sp" /> 
   
    <View 
        android:layout_width="0.5px" 
        android:layout_height="fill_parent" 
        android:background="#B8B8B8" 
        android:visibility="visible" /> 

</LinearLayout>

2)创建activity_main
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity" >

    <LinearLayout 
        android:layout_width="fill_parent" 
        android:layout_height="wrap_content" 
        android:orientation="horizontal" > 
   
        <TextView 
            android:layout_width="40dip" 
            android:layout_height="30dp" 
            android:text="序号" 
            android:textSize="20sp" /> 
   
        <TextView 
            android:id="@+id/job" 
            android:layout_width="200dip" 
            android:layout_height="30dp" 
            android:text="岗位名称" 
            android:textSize="20sp" /> 
   
        <TextView 
            android:id="@+id/addr" 
            android:layout_width="150dip" 
            android:layout_height="30dp" 
            android:text="详细地点" 
            android:textSize="20sp" /> 
   
        <TextView 
            android:id="@+id/student" 
            android:layout_width="100dip" 
            android:layout_height="30dp" 
            android:text="工作学生" 
            android:textSize="20sp" /> 
   
        <TextView 
            android:id="@+id/isworking" 
            android:layout_width="80dip" 
            android:layout_height="30dp" 
            android:text="备注" 
            android:textSize="20sp" /> 
    </LinearLayout> 
   
    <ListView 
        android:id="@+id/lv" 
        android:layout_width="fill_parent" 
        android:layout_height="wrap_content" > 
    </ListView> 

</LinearLayout>

3)DataHelper.java   创建数据库的文件
public class DataHelper extends SQLiteOpenHelper {

	@Override 
    public synchronized void close() { 
        // TODO Auto-generated method stub 
        super.close(); 
    } 
   
    public DataHelper(Context context, String name, CursorFactory factory, 
            int version) { 
        super(context, name, factory, version); 
        // TODO Auto-generated constructor stub 
   
    } 
   
    @Override 
    public void onCreate(SQLiteDatabase db) { 
        // TODO Auto-generated method stub 
   
        String sql = "CREATE  TABLE JobChecker (_id INTEGER PRIMARY KEY , department VARCHAR, job VARCHAR,teacher VARCHAR,address VARCHAR,student VARCHAR,isworking VARCHAR)"; 
        db.execSQL(sql); 
   
    } 
   
    @Override 
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { 
        // TODO Auto-generated method stub 
    	//String sql = "insert into JobChecker (_id, department, job,teacher,address,student,isworking) values ()"; 
    	db.execSQL("insert into JobChecker (_id, department, job,teacher,address,student,isworking) values (?,?,?,?,?,?,?)",
		        new Object[] { "0001", "a", "a","a","a","a","a" });
    	db.execSQL("insert into JobChecker (_id, department, job,teacher,address,student,isworking) values (?,?,?,?,?,?,?)",
		        new Object[] { "0002", "b", "b","b","b","b","b" });
    	db.execSQL("insert into JobChecker (_id, department, job,teacher,address,student,isworking) values (?,?,?,?,?,?,?)",
		        new Object[] { "0003", "c", "c","c","c","c","c" });
    	db.execSQL("insert into JobChecker (_id, department, job,teacher,address,student,isworking) values (?,?,?,?,?,?,?)",
		        new Object[] { "0004", "d", "d","d","d","d","d" });
    	db.execSQL("insert into JobChecker (_id, department, job,teacher,address,student,isworking) values (?,?,?,?,?,?,?)",
		        new Object[] { "0005", "e", "e","e","e","e","e" });
    	db.execSQL("insert into JobChecker (_id, department, job,teacher,address,student,isworking) values (?,?,?,?,?,?,?)",
		        new Object[] { "0006", "f", "f","f","f","f","f" });
    	db.execSQL("insert into JobChecker (_id, department, job,teacher,address,student,isworking) values (?,?,?,?,?,?,?)",
		        new Object[] { "0007", "g", "g","g","g","g","g" });
    }

}

4)MySimpleCursorAdapter.java文件
public class MySimpleCursorAdapter extends SimpleCursorAdapter {
	public MySimpleCursorAdapter(Context context, int layout, Cursor c, 
            String[] from, int[] to) { 
        super(context, layout, c, from, to); 
        // TODO Auto-generated constructor stub 
   
    } 
   
    @Override 
    public View getView(final int position, View convertView, ViewGroup parent) { 
        // TODO Auto-generated method stub 
        // listview每次得到一个item，都要view去绘制，通过getView方法得到view 
        // position为item的序号 
        View view = null; 
        if (convertView != null) { 
            view = convertView; 
            // 使用缓存的view,节约内存 
            // 当listview的item过多时，拖动会遮住一部分item，被遮住的item的view就是convertView保存着。 
            // 当滚动条回到之前被遮住的item时，直接使用convertView，而不必再去new view() 
   
        } else { 
            view = super.getView(position, convertView, parent); 
   
        } 
   
        int[] colors = { Color.WHITE, Color.rgb(219, 238, 244) };//RGB颜色 
   
        view.setBackgroundColor(colors[position % 2]);// 每隔item之间颜色不同 
   
        return super.getView(position, view, parent); 
    } 
}

5)MainActivity.java
public class MainActivity extends Activity {

	SQLiteDatabase sqldb; 
    public String DB_NAME = "DB.sqlite"; 
    public String DB_TABLE = "num"; 
    public int DB_VERSION = 2; 
    final DataHelper helper = new DataHelper(this, DB_NAME, null, DB_VERSION); 
    // DbHelper类在DbHelper.java文件里面创建的 
    ListView lv; 
   
    @Override 
    public void onCreate(Bundle savedInstanceState) { 
        // TODO Auto-generated method stub 
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.activity_main); 
        sqldb = helper.getWritableDatabase(); 
        lv = (ListView) findViewById(R.id.lv); 
        updatelistview(); 
    } 
   
    // 更新listview 
    public void updatelistview() { 
   
        // 
        Cursor cr = sqldb.query("JobChecker", null, null, null, null, null, 
                null); 
   
        String id = cr.getColumnName(0);// 获取第1列 
        String job = cr.getColumnName(2);// 获取第3列 
        String address = cr.getColumnName(4);// 获取第5列 
        String student = cr.getColumnName(5);// 获取第6列 
        String[] ColumnNames = { id, job, address, student }; 
   
        ListAdapter adapter = new MySimpleCursorAdapter(this, 
                R.layout.listviewlayout, cr, ColumnNames, new int[] { R.id.id, 
                        R.id.job, R.id.addr, R.id.student }); 
        // layout为listView的布局文件，包括三个TextView，用来显示三个列名所对应的值 
        // ColumnNames为数据库的表的列名 
        // 最后一个参数是int[]类型的，为view类型的id，用来显示ColumnNames列名所对应的值。view的类型为TextView 
        lv.setAdapter(adapter); 
   
    } 
   
    @Override 
    protected void onDestroy() {// 关闭数据库 
        // TODO Auto-generated method stub 
        super.onDestroy(); 
        if (helper != null) { 
            helper.close(); 
        } 
    } 

}

6. ListView使用BaseAdapter与ListView的优化
在ListView的使用中，有时候还需要在里面加入按钮等控件，实现单独的操作。也就是说，这个ListView不再只是展示数据，也不仅仅是这一行要来处理用户的操作，而是里面的控件要获得用户的焦点。读者可以试试用SimpleAdapter添加一个按钮到ListView的条目中，会发现可以添加，但是却无法获得焦点，点击操作被ListView的Item所覆盖。这时候最方便的方法就是使用灵活的适配器BaseAdapter了。
使用BaseAdapter必须写一个类继承它，同时BaseAdapter是一个抽象类，继承它必须实现它的方法。BaseAdapter的灵活性就在于它要重写很多方法，看一下有哪些方法，
publicclass MyListViewBase extends Activity {
    
    private ListView lv;
    /*定义一个动态数组*/
    ArrayList<HashMap<String, Object>>listItem;


/** Called when the activity is first created. */
@Override
publicvoid onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

lv = (ListView) findViewById(R.id.lv);
        MyAdapter mAdapter = new MyAdapter(this);//得到一个MyAdapter对象
lv.setAdapter(mAdapter);//为ListView绑定Adapter
/*为ListView添加点击事件*/
lv.setOnItemClickListener(new OnItemClickListener() {

            @Override
            publicvoid onItemClick(AdapterView<?> arg0, View arg1, int arg2,
                    long arg3) {
        Log.v("MyListViewBase", "你点击了ListView条目" + arg2);//在LogCat中输出信息
                
            }
        });

    }
/*添加一个得到数据的方法，方便使用*/
private ArrayList<HashMap<String, Object>> getDate(){
    
    ArrayList<HashMap<String, Object>> listItem = new ArrayList<HashMap<String,     Object>>();
    /*为动态数组添加数据*/
    for(int i=0;i<30;i++)  
         {  
             HashMap<String, Object> map = new HashMap<String, Object>();  
             map.put("ItemTitle", "第"+i+"行");  
             map.put("ItemText", "这是第"+i+"行");  
             listItem.add(map);  
         } 
        return listItem;
    
    }
/*
     * 新建一个类继承BaseAdapter，实现视图与数据的绑定
     */
privateclass MyAdapter extends BaseAdapter {
    
private LayoutInflater mInflater;//得到一个LayoutInfalter对象用来导入布局

/*构造函数*/
public MyAdapter(Context context) {
    this.mInflater = LayoutInflater.from(context);
        }

        @Override
        publicint getCount() {
            
            return getDate().size();//返回数组的长度
        }

        @Override
        public Object getItem(int position) {
            returnnull;
        }

        @Override
        publiclong getItemId(int position) {
            return 0;
        }
        /*书中详细解释该方法*/
        @Override
        public View getView(finalint position, View convertView, ViewGroup parent) {
             ViewHolder holder;
            //观察convertView随ListView滚动情况
             Log.v("MyListViewBase", "getView " + position + " " + convertView);
            if (convertView == null) {
                     convertView = mInflater.inflate(R.layout.item,
    null);
                     holder = new ViewHolder();
                    /*得到各个控件的对象*/
                    holder.title = (TextView) convertView.findViewById(R.id.ItemTitle);
                    holder.text = (TextView) convertView.findViewById(R.id.ItemText);
                    holder.bt = (Button) convertView.findViewById(R.id.ItemButton);
                    convertView.setTag(holder);//绑定ViewHolder对象
                   }
    else{
                    holder = (ViewHolder)convertView.getTag();//取出ViewHolder对象
                  }
            /*设置TextView显示的内容，即我们存放在动态数组中的数据*/
            holder.title.setText(getDate().get(position).get("ItemTitle").toString());
            holder.text.setText(getDate().get(position).get("ItemText").toString());
            
            /*为Button添加点击事件*/
             holder.bt.setOnClickListener(new OnClickListener() {
                
                @Override
                publicvoid onClick(View v) {
                Log.v("MyListViewBase", "你点击了按钮" + position);                                //打印Button的点击信息
                    
                }
            });
            
            return convertView;
        }
    
    }
/*存放控件*/
publicfinalclass ViewHolder{
    public TextView title;
    public TextView text;
    public Button   bt;
    }
}

7.ListView item缓存机制：为了使得性能更优，ListView会缓存行item(某行对应的View)。ListView通过adapter的getView函数获得每行的item。滑动过程中，
a. 如果某行item已经滑出屏幕，若该item不在缓存内，则put进缓存，否则更新缓存；
b. 获取滑入屏幕的行item之前会先判断缓存中是否有可用的item，如果有，做为convertView参数传递给adapter的getView。
更具体可见源代码ListView.obtainView。
 
这样，如下的getView写法就可以充分利用缓存大大提升ListView的性能。即便上万个行item，最多inflate的次数为n，n为一屏最多显示ListView 行item的个数。
ListView Adapter getView写法Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
@Override
public View getView(int position, View convertView, ViewGroup parent) {
	ViewHolder holder;
	if (convertView == null) {
		convertView = inflater.inflate(R.layout.list_item, null);
		holder = new ViewHolder();
		……
		convertView.setTag(holder);
	} else {
		holder = (ViewHolder)convertView.getTag();
	}
}
 
/**
 * ViewHolder
 * 
 * @author trinea@trinea.cn 2013-08-01
 */
private static class ViewHolder {
 
	ImageView appIcon;
	TextView  appName;
	TextView  appInfo;
}
这样提升了性能，但同时也会造成另外一些问题：
a. 行item图片显示重复
这个显示重复是指当前行item显示了之前某行item的图片。
比如ListView滑动到第2行会异步加载某个图片，但是加载很慢，加载过程中listView已经滑动到了第14行，且滑动过程中该图片加载结束，第2行已不在屏幕内，根据上面介绍的缓存原理，第2行的view可能被第14行复用，这样我们看到的就是第14行显示了本该属于第2行的图片，造成显示重复。
 
b. 行item图片显示错乱
这个显示错乱是指某行item显示了不属于该行item的图片。
比如ListView滑动到第2行会异步加载某个图片，但是加载很慢，加载过程中listView已经滑动到了第14行，第2行已不在屏幕内，根据上面介绍的缓存原理，第2行的view可能被第14行复用，第14行显示了第2行的View，这时之前的图片加载结束，就会显示在第14行，造成错乱。
 
c. 行item图片显示闪烁
上面b的情况，第14行图片又很快加载结束，所以我们看到第14行先显示了第2行的图片，立马又显示了自己的图片进行覆盖造成闪烁错乱。
 
2、解决方法
通过上面的分析我们知道了出现错乱的原因是异步加载及对象被复用造成的，如果每次getView能给对象一个标识，在异步加载完成时比较标识与当前行item的标识是否一致，一致则显示，否则不做处理即可。
下面以使用ImageCache为ListView提供图片获取缓存为例，ListView中强烈推荐使用ImageCache。
首先在listview adapter的getView中添加
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
@Override
public View getView(int position, View convertView, ViewGroup parent) {
	ViewHolder holder;
	if (convertView == null) {
		convertView = inflater.inflate(R.layout.list_item, null);
		holder = new ViewHolder();
		……
		convertView.setTag(holder);
	} else {
		holder = (ViewHolder)convertView.getTag();
	}
 
	……
	// add tag for image, to compare it when image loaded finish
	imageView.setTag(imageUrl);
	// if not in cache, restore default
	if (!Cache.ICON_CACHE.get(imageUrl, imageView)) {
		imageView.setImageDrawable(null);
	}
}
其中setTag表示设置标识，方便下面进行标志比对

1
if (!Cache.ICON_CACHE.get(imageUrl, imageView))
Cache.ICON_CACHE为ImageCache的实例，表示如果不在缓存内则设置drawable为null(当然你可以可以设置为你自己的默认资源)，防止显示了之前某个行item的图片，解决了a. 行item图片显示重复问题。
 
在ImageCache的OnImageCallbackListener的onGetSuccess函数中添加
Java

1
2
3
4
5
6
7
8
9
10
11
public void onGetSuccess(String imageUrl, Drawable imageDrawable, View view, boolean isInCache) {
	// can be another view child, like textView and so on
	if (view != null && imageDrawable != null) {
		ImageView imageView = (ImageView)view;
		// add tag judge, avoid listView cache and so on
		String imageUrlTag = (String)imageView.getTag();
		if (ObjectUtils.isEquals(imageUrlTag, imageUrl)) {
			imageView.setImageDrawable(imageDrawable);
		}
	}
};
在上面用String imageUrlTag = (String)imageView.getTag();取得之前设置的tag，然后和当前的url进行比较，如果相等则显示，解决了b. 行item图片显示错乱，c. 行item图片显示错乱的两个问题。其中ObjectUtils可见ObjectUtils@Github.
其他异步加载过程解决原理类似。


*树形组件android.widget.ExpandableListView:
1.基本显示
如果要配置他的显示内容，可以使用setAdapter()方法完成，
1).自定义一个类
//专门填充数据的适配器类
class MyExpanseListAdapter extends BaseExpandableListAdapter 
{
	//组名称
	private String group[]=new String[]{"我的好友","家人","同事","黑名单"};
	//子名称
	private String child[][]=new String[][]{{"aa","bb","cc","dd"},{"11","22","333","44"},
			{"11q","12w","22","3w"},{"4a","43","dw","aax"}};
	private Context context=null;

	//构造方法
	public MyExpanseListAdapter(Context context)
	{
		this.context = context;
	}
	@Override
	//取得指定的子选项
	public Object getChild(int arg0, int arg1) {
		// TODO Auto-generated method stub
		return this.child[arg0][arg1];
	}

	@Override
	//取得子ID
	public long getChildId(int arg0, int arg1) {
		// TODO Auto-generated method stub
		return arg1;
	}
	
	private TextView buildTextView()
	{
		AbsListView.LayoutParams params=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,35); 
		TextView textView=new TextView(this.context);
		textView.setLayoutParams(params);
		textView.setTextSize(15.0f);
		textView.setGravity(Gravity.LEFT);
		textView.setPadding(40, 8, 3, 3);
		return textView;
	}

	@Override
	//返回子视图
	public View getChildView(int groupPosition, int childPosition,
			boolean isLastChild, View convertView, ViewGroup parent) {
		// TODO Auto-generated method stub
		TextView textview=new TextView(this.context);
		textview.setText(this.getChild(groupPosition, childPosition).toString());
		return textview;
	}

	@Override
	public int getChildrenCount(int groupPosition) {
		// TODO Auto-generated method stub
		return this.child[groupPosition].length;
	}

	@Override
	public Object getGroup(int groupPosition) {
		// TODO Auto-generated method stub
		return this.group[groupPosition];
	}

	@Override
	public int getGroupCount() {
		// TODO Auto-generated method stub
		return this.group.length;
	}

	@Override
	public long getGroupId(int groupPosition) {
		// TODO Auto-generated method stub
		return groupPosition;
	}
	
	@Override
	public View getGroupView(int groupPosition, boolean isExpanded,
			View convertView, ViewGroup parent) {
		// TODO Auto-generated method stub
		TextView textview=this.buildTextView();
		textview.setText(this.getGroup(groupPosition).toString());
		return textview;
	}

	@Override
	public boolean hasStableIds() {
		// TODO Auto-generated method stub
		return true;
	}

	@Override
	public boolean isChildSelectable(int groupPosition, int childPosition) {
		// TODO Auto-generated method stub
		return true;
	}

}

一个适配器类就完成了
2).要在该组件上配置数据，需要通过xml文件完成
<ExpandableListView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/listview" />
3).
private ExpandableListView listview = null;
	private ExpandableListAdapter adapter = null;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.listview = (ExpandableListView) super.findViewById(R.id.listview);
        this.adapter = new MyExpanseListAdapter(this);
        this.listview.setAdapter(this.adapter);
    }

2.实现监听接口
ExpandableListView.onChildClickListener单机子选项
ExpandableListView.onGroupClickListener单机组选项
ExpandableListView.onGroupCollapseListener分组关闭
ExpandableListView.onGroupExpandListener分组打开
this.elistview.setOnChildClickListener(new OnChildClickListener() {
			
	@Override
	public boolean onChildClick(ExpandableListView parent, View v,
			int groupPosition, int childPosition, long id) {
		// TODO Auto-generated method stub
		Toast.makeText(MainActivity.this, "子选项,group="+groupPosition+",child="+childPosition, Toast.LENGTH_LONG).show();
		return false;
	}
	});
	this.elistview.setOnGroupClickListener(new OnGroupClickListener() {

	@Override
	public boolean onGroupClick(ExpandableListView parent, View v,
			int groupPosition, long id) {
		// TODO Auto-generated method stub
		return false;
	}
	});
	this.elistview.setOnGroupExpandListener(new OnGroupExpandListener() {

	@Override
	public void onGroupExpand(int groupPosition) {
		// TODO Auto-generated method stub
		
	}
	});
	this.elistview.setOnGroupCollapseListener(new OnGroupCollapseListener() {

	@Override
	public void onGroupCollapse(int groupPosition) {
		// TODO Auto-generated method stub
		
	}
	});
	
3.实现上下文菜单
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		this.elistview = (ExpandableListView) super.findViewById(R.id.elistview);
        this.adapter = new MyExpanseListAdapter(this);
        this.elistview.setAdapter(this.adapter);
        super.registerForContextMenu(this.elistview);//注册上下文菜单
        this.elistview.setOnChildClickListener(new OnChildClickListener() {
			
			@Override
			public boolean onChildClick(ExpandableListView parent, View v,
					int groupPosition, int childPosition, long id) {
				// TODO Auto-generated method stub
				Toast.makeText(MainActivity.this, "子选项,group="+groupPosition+",child="+childPosition, Toast.LENGTH_LONG).show();
				return false;
			}
		});
        this.elistview.setOnGroupClickListener(new OnGroupClickListener() {
			
			@Override
			public boolean onGroupClick(ExpandableListView parent, View v,
					int groupPosition, long id) {
				// TODO Auto-generated method stub
				return false;
			}
		});
        this.elistview.setOnGroupExpandListener(new OnGroupExpandListener() {
			
			@Override
			public void onGroupExpand(int groupPosition) {
				// TODO Auto-generated method stub
				
			}
		});
        this.elistview.setOnGroupCollapseListener(new OnGroupCollapseListener() {
			
			@Override
			public void onGroupCollapse(int groupPosition) {
				// TODO Auto-generated method stub
				
			}
		});
	}
	//创建上下文菜单，操作是长按住
	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
		// TODO Auto-generated method stub
		ExpandableListView.ExpandableListContextMenuInfo info=(ExpandableListView.ExpandableListContextMenuInfo)menuInfo;
		int type= ExpandableListView.getPackedPositionType(info.packedPosition);//取得菜单项
		int group= ExpandableListView.getPackedPositionGroup(info.packedPosition);//取得所在组的索引
		int child= ExpandableListView.getPackedPositionChild(info.packedPosition);//取得子菜单的索引
		Toast.makeText(MainActivity.this, "type="+type+",group="+group+",child="+child, Toast.LENGTH_LONG).show();
		
		
		super.onCreateContextMenu(menu, v, menuInfo);
	}	

*对话框:android.app.Dialog
1.
android.app.AlertDialog警告对话框
//创建警告对话框
Dialog alert=new AlertDialog.Builder(Main.this)
	.setTitle("对话框")//标题
	.setMessage("显示提示信息")//表示对话框中得内容
	.setIcon(R.drawable.ic_launcher)//设置logo
	.setPositiveButton("退出", new DialogInterface.OnClickListener()//退出按钮，点击后调用监听事件
		{				
			@Override
			public void onClick(DialogInterface dialog, int which) 
			{
				// TODO Auto-generated method stub	
				Main.this.finish();//退出程序
			}
	    	}
		)
	        .setNeutralButton("查看详情", new DialogInterface.OnClickListener()//查看详情按钮，点击后调用监听事件
	        	{			
					@Override
					public void onClick(DialogInterface dialog, int which) 
					{
						// TODO Auto-generated method stub				
					}
	        	}
	        )
	        .setNegativeButton("取消", new DialogInterface.OnClickListener()//取消按钮，点击后调用监听事件
	        	{			
					@Override
					public void onClick(DialogInterface dialog, int which) 
					{
						// TODO Auto-generated method stub				
					}
	        	}
	        )
	        .create();//创建一个对话框
	        alert.show();//显示对话框

2.复写一个方法，监听按键，如果按下esc键，不会直接退出，会予以提示
Source->Override/..Methods->onKeyDown

public boolean onKeyDown(int keyCode, KeyEvent event) {
		// TODO Auto-generated method stub
		if(keyCode==KeyEvent.KEYCODE_BACK)
		{}
	}

3.对话框列表
fruitData[]={...};
 .setItems(Main.this.fruitData, new listener...)
或者通过配置文件显示
 .setItems(R.array.fruitLable, new listener...)
4.单选项的对话框列表
fruitData[]={...};
.setSingleChoiceItems(Main.this.fruitData, 0, new DialogInterface.OnClickListener()//取消按钮，点击后调用监听事件
	        	{			
					@Override
					public void onClick(DialogInterface dialog, int which) 
					{
						// TODO Auto-generated method stub
                                                .....
                                                fruitData[which];//选中的列表信息,which是选项的索引				
					}
	        	}
	        )
5.复选框的对话框列表
int     fruitData[]={"1","2","3"};
boolean chdata[]=   {true,true,true};//代表三项默认都选中
 .setMultiChoiceItems(fruitData, chdata, new OnMultiChoiceClickListener() {
				
				@Override
				public void onClick(DialogInterface dialog, int which, boolean isChecked) {
					// TODO Auto-generated method stub
					for(int x=0;x<Main.this.fruitData.length;x++)
					{
						if(x==which&&isChecked)//如果当前选项被选中
					}
				}
			})

6.定制对话框：如果需要自定义复杂的对话框，例如登陆框，这时需要通过布局文件定义显示组件，之后再将布局显示到对话框中，
需要LayoutInflater类支持
1)定制对话框
<?xml version="1.0" encoding="utf-8"?>
<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
    <TableRow>
        <TextView 
            android:text = "用户名:"
            android:layout_marginLeft="20dip"
            android:textSize="8pt"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
        />
        <EditText 
            android:width="60pt"
            android:layout_height="wrap_content"
        />
    </TableRow>
	<TableRow>
        <TextView 
            android:text = "密码:"
            android:layout_marginLeft="20dip"
            android:textSize="8pt"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
        />
        <EditText 
            android:width="60pt"
            android:layout_height="wrap_content"
            android:password="true"
        />
    </TableRow>
</TableLayout>

2)
private class OnClickListenerlogin implements OnClickListener
{

	@Override
	public void onClick(View arg0) 
	{
		// TODO Auto-generated method stub
		LayoutInflater factory = LayoutInflater.from(Main.this);
		View myview=factory.inflate(R.layout.logindialog, null);
		Dialog dialog = new AlertDialog.Builder(Main.this)
		.setTitle("用户登陆")
		.setPositiveButton("登陆", new DialogInterface.OnClickListener() 		{
				
			@Override
			public void onClick(DialogInterface dialog, int which)
			{
				// TODO Auto-generated method stub
				Main.this.finish();
			}
		})
		.setNegativeButton("取消", ..)
		.setView(myview)//这里将对话框布局文件加入到对话框中
		.create();
		dialog.show();	
	}
		
}

7.日期对话框
Dialog dialog = new DatePickerDialog(Main.this, new DatePickerDialog.OnDateSetListener() 
	{
		@Override
		public void onDateSet(DatePicker view, int year, int 		monthOfYear,int dayOfMonth) 
		{
			// TODO Auto-generated method stub
			TextView txt= (TextView) Main.this.findViewById(R.id.txt);
			txt.setText(year+"-"+monthOfYear+"-"+dayOfMonth);
				}
		},2013,8,12);//后面几个参数是默认的年月日
		dialog.show();
	}

8.时间对话框：TimePickerDialog,与日期是一样的
9.进度对话框：ProgressDialog
进度的控制需要交给另外一个线程去运行的（比如主界面处理），只有当他处理完成后，
进度框才会退出
1)环形对话框
//进度对话框
final ProgressDialog dialog= ProgressDialog.show(Main.this,"搜索网络","请稍候...");
new Thread()//启动线程
{
	public void run()//线程的主体类
	{
		try 
		{
			Thread.sleep(3000);
		} catch (InterruptedException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}//等待3秒
		finally
		{
			dialog.dismiss();//结束进度框
		}
	}
				
}.start();
dialog.show();

2)水平条对话框
//进度对话框
final ProgressDialog dialog= new ProgressDialog(Main.this);
dialog.setTitle("搜索网络");
dialog.setMessage("请稍候...");
dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);//水平条
dialog.setMax(100);//设进度的最大值
dialog.setProgress(30);//从进度30开始
dialog.onStart();
new Thread()//启动线程
{
	public void run()//线程的主体类
	{
		for(int x=0;x<100;x++)
		{
			try 
			{
				Thread.sleep(500);//等待500毫秒
			} 
			catch (InterruptedException e) 
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			dialog.incrementProgressBy(1);//结束进度框,自增长一个	
		}
		
		dialog.dismiss();				
	}
	
}.start();
dialog.show();

*AutoCompleteTextView随笔提示功能组件：
<AutoCompleteTextView 
	    android:id="@+id/autotxt"
	    android:layout_width="wrap_content"
        android:layout_height="wrap_content"
	/>

private static final String data[]=new String[]{"a","aa","b","bcc","acc","ab"};
private AutoCompleteTextView autotxt = null;

ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,				android.R.layout.simple_dropdown_item_1line,data);//绑定数据集
this.autotxt = (AutoCompleteTextView) super.findViewById(R.id.autotxt);
this.autotxt.setAdapter(adapter);//设置内容

*拖动条SeekBar:android.widget.SeekBar
OnSeekBarChangeListener接口

<SeekBar 
	android:id="@+id/seekbar"
	android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:max="100"       总大小设为100
/>

public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) {
	// TODO Auto-generated method stub
	Main.this.autotxt.setText("拖动当前值:"+arg0.getProgress());//或者arg1
}

2.设置手机屏幕亮度的调节:android.view.Window的screenBrightness属性实现
//设置手机屏幕的亮度,num是0-1之间的浮点型数据
private void setScreen(float num)
{
	//取得屏幕的属性
	WindowManager.LayoutParams layoutParams = super.getWindow().getAttributes();
	layoutParams.screenBrightness = num;//设置屏幕亮度
	super.getWindow().setAttributes(layoutParams);//重新设置窗口属性
}

public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) 
{
	// TODO Auto-generated method stub
	Main.this.autotxt.setText("拖动当前值:"+arg1);
	Main.this.setScreen(arg0.getProgress()/100);
}

*评分组件RatingBar:android.widget.RatingBar
OnRatingBarChangeListener接口
android.isIndicator=""//true或者false 是否用户可任意改变
<RatingBar 
	android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:numStars="5"                //总共5格
        android:isIndicator="false"         //不允许用户修改
        android:rating="3"                  //当前3格
        android:stepSize="0.5"              //每次步长移动0.5格
	/>

*信息提示框Toast用于在页面上弹出提示信息，比如网络没通讯上等:android.widget.Toast
Buttonclick接口中
private class OnClickListenerlogin implements OnClickListener
{

@Override
public void onClick(View arg0) 
{
	Toast.makeText(Main.this, "Toast信息提示框", Toast.LENGTH_LONG).show();
}
}

或者使用自定义格式显示
Toast myToast = Toast.makeText(Main.this, "Toast信息提示框", Toast.LENGTH_LONG);
//居中对齐
myToast.setGravity(Gravity.CENTER, 60, 30);
myToast.show();


*PrograssBar进度条控件
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical" >
   
    <ProgressBar
        android:id="@+id/large_indeterminate"
        style="?android:attr/progressBarStyleLarge"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:visibility="gone"
        android:indeterminate="true" />

    <ProgressBar
        android:id="@+id/horizontal_indeterminate"
       
        style="@android:style/Widget.ProgressBar.Horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:visibility="gone"
        android:indeterminate="true" />

    <Button
        android:id="@+id/indeterminate"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/indeterminate" />

    <ProgressBar
        android:id="@+id/large_determinate"
        style="?android:attr/progressBarStyleLargeInverse"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:max="100"
        android:visibility="gone" />

    <ProgressBar
        android:id="@+id/horizontal_determinate"
        style="@android:style/Widget.ProgressBar.Horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="100"
        android:visibility="gone" />

    <TextView
        android:id="@+id/progress"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/progress" />

    <Button
        android:id="@+id/determinate"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/determinate" />

</LinearLayout>

package com.csc.progressbartest;

import com.example.progressbartest.R;

import Android.os.Bundle;
import android.os.Handler;
import android.app.Activity;
import android.view.View;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;

public class ProgressBarActivity extends Activity {
 //定义是否显示进度条
 boolean isVisable = true;
 //定义显示精度条的进度
 int status = 0;
 @Override
 protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_progress_bar);
  final Handler handler = new Handler();
  final TextView progress = (TextView)findViewById(R.id.progress);
  final ProgressBar largeIndeterminate = (ProgressBar)findViewById(R.id.large_indeterminate);
  final ProgressBar horizontalIndeterminate = (ProgressBar)findViewById(R.id.horizontal_indeterminate);
  final ProgressBar largeDeterminate = (ProgressBar)findViewById(R.id.large_determinate);
  final ProgressBar horizontalDeterminate = (ProgressBar)findViewById(R.id.horizontal_determinate);
  Button indeterminate = (Button)findViewById(R.id.indeterminate);
  Button determinate = (Button)findViewById(R.id.determinate);
  indeterminate.setOnClickListener(new View.OnClickListener() {
   
   @Override
   public void onClick(View v) {
    //当单击不确定按钮时显示或隐藏进度条
    if (isVisable) {
     largeIndeterminate.setVisibility(View.VISIBLE);
     horizontalIndeterminate.setVisibility(View.VISIBLE);
     isVisable = false;
    } else {
     largeIndeterminate.setVisibility(View.GONE);
     horizontalIndeterminate.setVisibility(View.GONE);
     isVisable = true;
    }
   }
  });
 
  determinate.setOnClickListener(new View.OnClickListener() {
   
   @Override
   public void onClick(View v) {
    new Thread(new Runnable() {
     
     @Override
     public void run() {
      status = 0;
      while (status<100) {
       handler.post(new Runnable() {
       
        @Override
        public void run() {
         //显示进度条
         progress.setVisibility(View.VISIBLE);
         largeDeterminate.setVisibility(ProgressBar.VISIBLE);
         horizontalDeterminate.setVisibility(ProgressBar.VISIBLE);
         largeDeterminate.setProgress(status);
         horizontalDeterminate.setProgress(status);
         //显示已进行的进度
         progress.setText("进度："+status+"%");
        }
       });
       try {
        Thread.sleep(50);
       } catch (InterruptedException e) {
        e.printStackTrace();
       }
       //改变进度条的进度
       status++;
      }
      handler.post(new Runnable() {
       
       @Override
       public void run() {
        //隐藏进度条
        largeDeterminate.setVisibility(View.GONE);
        horizontalDeterminate.setVisibility(View.GONE);
        progress.setVisibility(View.GONE);
       }
      });
     
     }
    }).start();
   }
  });
 }

}

*ImageView图片显示控件
例子1：android加载自己文件夹的图片，使用R类

 

main.xml文件
1.从xml加载资源文件
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    >
<ImageView
     android:id="@+id/iv1"
     android:layout_width="fill_parent"
     android:layout_height="wrap_content"
     android:src="@drawable/longshuai"      <!-- longshuai.png为图片的名称，记在资源文件里头，不用文件名后缀-->
   />
</LinearLayout>

注意：强调一下，资源文件的图片命名规则比较严格，由[a-z]和数字和“_”组成，而且不能数字开头，我就常犯傻，命名老是数字或者大写字母开头，这种错误――濉！
我们要把longshuai.png导入到res中，最简单的方式就是直接找到这个文件夹，复制进去
之后右键更新，我们就可以在res中看到自己的图片了
不用写代码。。直接用自动生成的代码。。

     public void onCreate(Bundle savedInstanceState)

    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

      }
	
2)从代码加载资源文件
ImageView.setImageResource(R.drawable.longshuai);	

2、加载本地图片（其实主要是SdCard中图片）
xml文件同上面的是一样的，并不需要修改

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
       
        ImageView image1 = (ImageView) findViewById(R.id.iv1);  //获得ImageView对象
         /*为什么图片一定要转化为 Bitmap格式的！！ */
        Bitmap bitmap = getLoacalBitmap("/sdcard/tubiao.jpg"); //从本地取图片(在cdcard中获取)  //
        image1 .setImageBitmap(bitmap); //设置Bitmap
      }

 

    /**
    * 加载本地图片
    * @param url
    * @return
    */
    public static Bitmap getLoacalBitmap(String url) {
         try {
              FileInputStream fis = new FileInputStream(url);
              return BitmapFactory.decodeStream(fis);  ///把流转化为Bitmap图片        

           } catch (FileNotFoundException e) {
              e.printStackTrace();
              return null;
         }
    }

3获取网络上的图片
mian.xml文件和1中一样，并不需要修改！
 
代码：
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
       
        ImageView image1 = (ImageView) findViewById(R.id.iv1);
        Bitmap bitmap =getHttpBitmap("http://images.missyuan.com/attachments/day_071123/20071123_b2bfefe1ec56e2df6582vCGIZG81gbyM.png");  
                       //从网上取图片
        image1 .setImageBitmap(bitmap); //设置Bitmap
}
 
    /**
    * 从服务器取图片
    * @param url
    * @return
    */
    public static Bitmap getHttpBitmap(String url) {
         URL myFileUrl = null;
         Bitmap bitmap = null;
         try {
              myFileUrl = new URL(url);
         } catch (MalformedURLException e) {
              e.printStackTrace();
         }
         try {
              HttpURLConnection conn = (HttpURLConnection) myFileUrl.openConnection();
              conn.setConnectTimeout(0);
              conn.setDoInput(true);
              conn.connect();
              InputStream is = conn.getInputStream();
              bitmap = BitmapFactory.decodeStream(is);
              is.close();
         } catch (IOException e) {
              e.printStackTrace();
         }
         return bitmap;
    }
 
 
注意：由于需要使用网络，所以 AndroidManfest.xml 文件需要添加使用网络权限！！！
    <uses-permission android:name="android.permission.INTERNET" />

	

*图片切换ImageSwitcher,用户点击按钮一张张切换图片，而且可以增加动画效果:
android.widget.ImageSwitcher
ViewFactory类
1.
<ImageSwitcher 
	android:id="@+id/myimage"
	android:layout_width="wrap_content"
        android:layout_height="wrap_content"
/>
<LinearLayout 
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    >    
    <Button 
	    android:id ="@+id/picbtn"
	    android:layout_width="wrap_content"
            android:layout_height="wrap_content"
	    android:text="picture" 
     />

</LinearLayout>

2.
private int[] imgres=new int[]{R.drawable.pic1,R.drawable.pic2};//加载2张资源图片
private ImageSwitcher myimage = null;

this.myimage = (ImageSwitcher) super.findViewById(R.id.myimage);

3.添加一个图片显示工厂
//设置图片转换工厂类
this.myimage.setFactory(new ViewFactoryImp());
this.myimage.setImageResource(this.imgres[0]);//先显示一张图片

//设置图片转换工厂类,该类是ImageSwitcher的类
private class ViewFactoryImp implements ViewFactory
{
	@Override
	public View makeView() 
	{
		// TODO Auto-generated method stub
		ImageView img = new ImageView(Main.this);
		img.setBackgroundColor(0xFFFFFFFF);//设背景色彩
		//定义组件
		img.setLayoutParams(new ImageSwitcher.LayoutParams(LayoutParams.FILL_PARENT,LayoutParams.FILL_PARENT));
		return img;
	}
	
}

4.按钮切换下一张图片
private class OnClickListenerpic implements OnClickListener
{
	@Override
	public void onClick(View arg0) {
		// TODO Auto-generated method stub
		//切换到下一张图片
		Main.this.myimage.setImageResource(Main.this.imgres[1]);
	}
}

5.加载动画效果
//加载进入动画效果
		this.myimage.setInAnimation(AnimationUtils.loadAnimation(this, android.R.anim.fade_in));
		//加载离开动画效果
		this.myimage.setOutAnimation(AnimationUtils.loadAnimation(this, android.R.anim.fade_out));


*文本切换组件TextSwitcher:
android.widget.TextSwitcher
ViewFactory类
1.
<TextSwitcher 
	android:id="@+id/mytxt"
	android:layout_width="wrap_content"
        android:layout_height="wrap_content"
/>
2.
private TextSwitcher mytxt = null;

this.mytxt = (TextSwitcher) super.findViewById(R.id.mytxt);
3.添加一个文本显示工厂
//设置文本转换工厂类
this.mytxt.setFactory(new ViewFactoryImp());


//设置图片转换工厂类,该类是ImageSwitcher的类
private class ViewFactoryImp implements ViewFactory
{
	@Override
	public View makeView() 
	{
		// TODO Auto-generated method stub
		TextView img = new TextView(Main.this);
		img.setBackgroundColor(0xFFFFFFFF);//设背景色彩
		img.setTextColor(0xFF000000);//设字体色彩
                //定义组件
		img.setLayoutParams(new TextSwitcher.LayoutParams(LayoutParams.FILL_PARENT,LayoutParams.FILL_PARENT));  
		return img;
	}
	
}
4.按钮切换下一行字体
private class OnClickListenerpic implements OnClickListener
{
	@Override
	public void onClick(View arg0) {
		// TODO Auto-generated method stub
		//切换到下一张图片
		Main.this.mytxt.setText("Helloworld");
	}
}

5.加载动画效果
//加载进入动画效果
		this.mytxt.setInAnimation(AnimationUtils.loadAnimation(this, android.R.anim.fade_in));
		//加载离开动画效果
		this.mytxt.setOutAnimation(AnimationUtils.loadAnimation(this, android.R.anim.fade_out));

*BaseAdapter的使用 
适配器的作用主要是用来给诸如(Spinner、ListView、GridView)来填充数据的。而(Spinner、ListView、GridView)都有自己的适配器(记起来麻烦)。但是BaseAdapter（一招鲜）对他们来说却是通用的
下面我来说一下BaseAdapter的主要用法，就是我们定义一个类(如：MyAdapter)而这个类继承BaseAdapter.因为它是implements了ListAdapter和SpinnerAdapter的接口，所以要实现里面的方法，代码如下(未作任何改动的）：

private class MyAdapter extends BaseAdapter {
    @Override
    public int getCount() {
        // TODO Auto-generated method stub
        return 0;
    }
 
    @Override
    public Object getItem(int arg0) {
        // TODO Auto-generated method stub
        return null;
    }
 
    @Override
    public long getItemId(int position) {
        // TODO Auto-generated method stub
        return 0;
    }
 
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        // TODO Auto-generated method stub
        return null;
    }
}

例如：
第一步：新建一个main.xml,加载几个控件

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <TextView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="Welcome to Mr Wei's Blog" />
    <Spinner
        android:id="@+id/spinner"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        />
    <ListView
        android:id="@+id/listview"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        />
    <GridView
        android:id="@+id/gridview"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        />
</LinearLayout>

第三步：修该BaseAdapterDemo.java代码如下


package com.tutor.baseadapter;
 
import android.app.Activity;
import android.graphics.Color;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ListView;
import android.widget.Spinner;
import android.widget.TextView;
 
public class BaseAdapterDemo extends Activity {
 
    private Spinner mSpinner;
    private ListView mListView;
    private GridView mGridView;
    private MyAdapter mMyAdapter;
 
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        setupViews();
    }
 
    public void setupViews() {
        mMyAdapter = new MyAdapter();
        mSpinner = (Spinner) findViewById(R.id.spinner);
        mSpinner.setAdapter(mMyAdapter);
        mListView = (ListView) findViewById(R.id.listview);
        mListView.setAdapter(mMyAdapter);
        mGridView = (GridView) findViewById(R.id.gridview);
        mGridView.setAdapter(mMyAdapter);
        mGridView.setNumColumns(2);
 
    }
 
    // 定义自己的适配器,注意getCount和getView方法
    private class MyAdapter extends BaseAdapter {
        @Override
        public int getCount() {
            // 这里我就返回10了，也就是一共有10项数据项
            return 10;
        }
 
        @Override
        public Object getItem(int arg0) {
            return arg0;
        }
 
        @Override
        public long getItemId(int position) {
            return position;
        }
 
        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            // position就是位置从0开始，convertView是Spinner,ListView中每一项要显示的view
            // 通常return 的view也就是convertView
            // parent就是父窗体了，也就是Spinner,ListView,GridView了.
            TextView mTextView = new TextView(getApplicationContext());
            mTextView.setText("BaseAdapterDemo");
            mTextView.setTextColor(Color.RED);
            return mTextView;
        }
 
    }

们平常看的应用列表什么的，不是单单的一个TextView就可以了事的，所以我们可以在Layout里事先定义好布局。这里我新建了一个名叫baseadapter_provider.xml文件，代码如下：

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">
    <ImageView
        android:id="@+id/imageView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/icon"
        />
    <TextView
        android:id="@+id/textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="BaseAdapter"
        />
</LinearLayout>

将getView()方法修改如下：
	
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    // position就是位置从0开始，convertView是Spinner,ListView中每一项要显示的view
    // 通常return 的view也就是convertView
    // parent就是父窗体了，也就是Spinner,ListView,GridView了.
    // TextView mTextView = new TextView(getApplicationContext());
    // mTextView.setText("BaseAdapterDemo");
    // mTextView.setTextColor(Color.RED);
    // return mTextView;
     
    //LayoutInflater不会的参照我的 Android 高手进阶教程(五)
    convertView = LayoutInflater.from(getApplicationContext()).inflate
    convertView = LayoutInflater.from(getApplicationContext()).inflate
    (R.layout.baseadapter_provider,null);
     
    TextView mTextView = (TextView)convertView.findViewById(R.id.textview);
    mTextView.setText("BaseAdapterDemo" + position);
    mTextView.setTextColor(Color.RED);
    return convertView;
}

*LayoutInflater 
加载布局的任务通常都是在Activity中调用setContentView()方法来完成的。其实setContentView()方法的内部也是使用LayoutInflater来加载布局的，只不过这部分源码是internal的，不太容易查看到。
在实际工作中，事先写好的布局文件往往不能满足我们的需求，有时会根据情况在代码中自定义控件，这就需要用到LayoutInflater。
LayoutInflater在Android中是“扩展”的意思，作用类似于findViewById()，不同的是LayoutInflater是用来获得布局文件对象的，而

findViewById()是用来获得具体控件的。LayoutInflater经常在BaseAdapter的getView方法中用到，用来获取整个View并返回。
LayoutInflater的用法有三种：

第一种方法：
    LayoutInflater inflater = LayoutInflater.from(this);  
    View layout = inflater.inflate(R.layout.main, null);  	inflate()方法一般接收两个参数，第一个参数就是要加载的布局id，第二个参数是指给该布局的外部再嵌套一层父布局，如果不需要就直接传null

第二种方法：
    LayoutInflater inflater = getLayoutInflater();  
    View layout = inflater.inflate(R.layout.main, null);  

第三种方法：
    LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);  
    View layout = inflater.inflate(R.layout.main, null); 	

*拖拉图片组件Gallery:android.widget.Gallery
1.SimpleAdapter和BaseAdapter的区别
SimpleAdapter
可以显示比较复杂的列表，包括每行显示图片、文字等，但不能对列表进行后期加工（在java代码中加工），
也是只是单纯的负责显示（当然可以设计复杂点的布局来显示复杂列表），例如，每行显示不同背景等。
List<Map<String,Object>> mData= new ArrayList<Map<String,Object>>();;  
for(int i =0; i < lengh; i++) {      
    Map<String,Object> item = new HashMap<String,Object>();      
    item.put("image", R.drawable.portrait);      
    item.put("title", mListTitle[i]);      
    item.put("text", mListStr[i]);      
    mData.add(item);       
}      
SimpleAdapter adapter = new SimpleAdapter(  
                this,  
                mData,  
                R.layout.item,      
                new String[]{"image","title","text"},  
                new int[]{R.id.image,R.id.title,R.id.text});  

BaseAdapter
可以实现复杂的列表布局，由于BaseAdapter是一个抽象类，使用该类需要自己写一个适配器继承该类，
正是由于继承了该类，需要我们重写一些方法，让我们可以在代码里控制列表的样式，更加灵活。
private class MyListAdapter extends BaseAdapter{    
        private Context mContext;    
        private int[] colors=new int[]{0xff626569,0xff4f5257 };    
         public MyListAdapter(Context context){    
             mContext=context;    
         }    
        @Override    
        public int getCount() {    
            // TODO Auto-generated method stub    
            return mListText.length;    
        }    
    
        @Override    
        public Object getItem(int position) {    
            // TODO Auto-generated method stub    
            return position;    
        }    
    
        @Override    
        public long getItemId(int position) {    
            // TODO Auto-generated method stub    
            return position;    
        }    
    
        @Override    
        public View getView(int position, View convertView, ViewGroup parent) {    
            ImageView image=null;  //这些控件可以单独封装成一个类（Holder），便与优化  
            TextView title=null;    
            TextView  content=null;    
            if(convertView==null){    
                convertView=LayoutInflater.from(mContext).inflate(R.layout.colorlist, null);    
                image=(ImageView) convertView.findViewById(R.id.color_image);    
                title=(TextView) convertView.findViewById(R.id.color_title);    
                content=(TextView) convertView.findViewById(R.id.color_text);    
            }   
            int colorPos=position%colors.length;    
            convertView.setBackgroundColor(colors[colorPos]);    
            title.setText(mListTitle[position]);    
            content.setText(mListText[position]);    
            image.setImageResource(R.drawable.portrait);    
                
            return convertView;    
        }    
            
    }    
  
--------------------------下面样例列表页的控件单独封装成了一个类（Holder），便与优化-----  
  
  
 public class MyBaseAdapter extends BaseAdapter{  
       
           private LayoutInflater mInflater;  
            public MyAdapter(Context context){  
               this.mInflater = LayoutInflater.from(context);  
          }  
            @Override  
           public int getCount() {  
                // TODO Auto-generated method stub  
                return mData.size();  
            }  
       
            @Override  
            public Object getItem(int arg0) {  
                // TODO Auto-generated method stub  
                return null;  
           }  
       
            @Override  
            public long getItemId(int arg0) {  
                // TODO Auto-generated method stub  
                return 0;  
            }  
       
            @Override  
            public View getView(int position, View convertView, ViewGroup parent) {  
                   
                ViewHolder holder = null;  
                if (convertView == null) {  
                    holder=new ViewHolder();   
                    convertView = mInflater.inflate(R.layout.vlist2, null);  
                    holder.img = (ImageView)convertView.findViewById(R.id.img);  
                    holder.title = (TextView)convertView.findViewById(R.id.title);  
                    holder.info = (TextView)convertView.findViewById(R.id.info);  
                    holder.viewBtn = (Button)convertView.findViewById(R.id.view_btn);  
                    convertView.setTag(holder);  
                       
                }else {                       
                    holder = (ViewHolder)convertView.getTag();  
                }  
                holder.img.setBackgroundResource((Integer)mData.get(position).get("img"));  
                holder.title.setText((String)mData.get(position).get("title"));  
                holder.info.setText((String)mData.get(position).get("info"));  
                //给每一个列表后面的按钮添加响应事件  
                holder.viewBtn.setOnClickListener(new View.OnClickListener() {  
                    @Override  
                    public void onClick(View v) {  
                        showInfo();                  
                    }  
                });  
  
                return convertView;  
            }  
        ------------  
        public final class ViewHolder{  
            public ImageView img;  
            public TextView title;  
            public TextView info;  
            public Button viewBtn;  
        }  

2.使用baseadapter适配器
ProGalleryAdapter.java
public class ProGalleryAdapter extends BaseAdapter {
	private Context context;
	private int[] imageId = new int[] { R.drawable.one, R.drawable.two,
			R.drawable.three, R.drawable.four, R.drawable.five};//定义并初始化保存图片id的数组
	//构造函数
	public ProGalleryAdapter(Context context)
	{
		this.context=context;
	}
	/*
	 * 功能：获得当前选项的ID
	 */
	@Override
	public long getItemId(int position) {
		// TODO Auto-generated method stub
		return this.imageId[position];
	}
	/*
	 * 功能：获得当前选项
	 */
	@Override
	public Object getItem(int position) {
		// TODO Auto-generated method stub
		return this.imageId[position];
	}
	/*
	 * 获得数量
	 */
	@Override
	public int getCount() {
		// TODO Auto-generated method stub
		return this.imageId.length;
	}
	/*
	 * 主要方法，填充图片
	 */
	@Override
	public View getView(int position, View convertView, ViewGroup parent) {
		// TODO Auto-generated method stub
		ImageView imageView;
		//设置布局
		if(convertView==null)
		{
			imageView=new ImageView(this.context);
			imageView.setScaleType(ImageView.ScaleType.CENTER);//设置缩放方式
			imageView.setLayoutParams(new Gallery.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
			imageView.setBackgroundColor(0xFFFFFFFF);
			imageView.setPadding(5, 0, 5, 0);//设置ImageView的内边距			
		}
		else
		{
			imageView = (ImageView) convertView;
		}
		imageView.setImageResource(imageId[position]);//设置要显示的图片
		return imageView;
	}

}

activity_main.xml
<Gallery
	    android:id="@+id/gallery"
	    android:gravity="center_vertical"
		android:spacing="5px"
		android:unselectedAlpha="0.5"		
	    android:layout_width="fill_parent"
	    android:layout_height="wrap_content" />

MainActivity.java
public class MainActivity extends Activity {
	Gallery gallery=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		gallery = (Gallery) findViewById(R.id.gallery);
		final ProGalleryAdapter adapter=new ProGalleryAdapter(MainActivity.this);
		gallery.setAdapter(adapter);//将适配器adapter与控件gallery关联
		gallery.setSelection(adapter.getCount()/2);//中间的图片选中
		//添加单机事件监听
		gallery.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> parent, View view, int position,
					long id) {
				// TODO Auto-generated method stub
				Toast.makeText(MainActivity.this, "您的第"+id+"张图片", Toast.LENGTH_SHORT).show();
			}
			
			
		});		
	}
	
}

3.复杂的要显示文字等等的，可以看GridView部分
	
    
*GridView
1.这个是简单只加载图片，具体可以参考BaseAdapter的使用，若要加载图片和其他信息，可以参考书本
public class HeadActivity extends Activity 
{

	public int[] imageId = new int[] { R.drawable.img01, R.drawable.img02,
			R.drawable.img03, R.drawable.img04, R.drawable.img05,
			R.drawable.img06, R.drawable.img07, R.drawable.img08,
			R.drawable.img09 }; 							// 定义并初始化保存头像id的数组
	@Override
	protected void onCreate(Bundle savedInstanceState) 
	{
		super.onCreate(savedInstanceState);
		setContentView(R.layout.head);		//设置该Activity使用的布局
		GridView gridview = (GridView) findViewById(R.id.gridView1); 			// 获取GridView组件
		
		
		BaseAdapter adapter=new BaseAdapter() 
		{
			@Override
			public View getView(int position, View convertView, ViewGroup parent) 
			{
				ImageView imageview;							//声明ImageView的对象
				if(convertView==null)
				{
					imageview=new ImageView(HeadActivity.this);		//实例化ImageView的对象
					/*************设置图像的宽度和高度******************/
					imageview.setAdjustViewBounds(true);
					imageview.setMaxWidth(158);
					imageview.setMaxHeight(150);
					/**************************************************/
					imageview.setPadding(5, 5, 5, 5);				//设置ImageView的内边距
				}
				else
				{
					imageview=(ImageView)convertView;
				}
				imageview.setImageResource(imageId[position]);		//为ImageView设置要显示的图片
				return imageview;	//返回ImageView
			}
			/* 
			 * 功能：获得当前选项的ID
			 */
			@Override
			public long getItemId(int position) {
				return position;
			}
			/* 
			 * 功能：获得当前选项
			 */
			@Override
			public Object getItem(int position) {
				return position;
			}
			/*
			 * 获得数量
			 */
			@Override
			public int getCount() {
				return imageId.length;
			}
		};
		
		gridview.setAdapter(adapter); 									// 将适配器与GridView关联
		
*时钟组件AnalogClock,DigitalClock:显示时钟
*计时器android.widget.Chronometer:
public void onClick(DialogInterface dialog, int which) 
{
	// TODO Auto-generated method stub
	MainActivity.this.mychr.start();   //开始计时
}
MainActivity.this.mychr.stop();   //停止计时
MainActivity.this.mychr.setBase(SystemClock.elapsedRealtime());得到当前系统时间
MainActivity.this.mychr.setFormat("%s.");//格式化的显示时间

2.时间到时，震动提示
private Vibrator vib = null;

//时间变化监听接口
this.mychr.setOnChronometerTickListener(new OnChronometerTickListenerImg());
//取得震动服务
this.vib = (Vibrator)super.getApplication().getSystemService(Service.VIBRATOR_SERVICE);        

private class OnChronometerTickListenerImg implements OnChronometerTickListener
{
	@Override
	public void onChronometerTick(Chronometer chronometer)
	{
		// TODO Auto-generated method stub
		String time=chronometer.getText().toString();//得到当前时间
		//如果时间是1分钟
		if("01:00".equals(time))
		{
			MainActivity.this.vib.vibrate(new long[]{1000,10,100,100},0);//震动
		}
	}

}

2）设置权限
<uses-permission 
	    android:name="android.permission.VIBRATE"
	/>

*标签:android.widget.TabHost;
1.继承类，为TabActivity
1).更改继承类，为TabActivity
public class MainActivity extends TabActivity {
}
2).添加一个布局文件tab.xml,他里面包含多个标签的显示组件
定义三个标签页
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical" >
    <LinearLayout 
        android:id="@+id/tab_edit"
	    android:layout_width="fill_parent"
	    android:layout_height="fill_parent"		
	    android:orientation="vertical" >
	    <EditText 
	        android:id="@+id/edit"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:text="请输入检索"
	    />
	     <Button 
	        android:id="@+id/btn"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:text="检索"
	    />
	</LinearLayout>
	<LinearLayout 
        android:id="@+id/tab_clk"
	    android:layout_width="fill_parent"
	    android:layout_height="fill_parent"		
	    android:orientation="vertical" >
	    <AnalogClock 
	        android:id="@+id/clkan"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	   />
	    <DigitalClock 
	        android:id="@+id/clkdig"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	   />
	</LinearLayout>
	<LinearLayout 
        android:id="@+id/tab_rgp"
	    android:layout_width="fill_parent"
	    android:layout_height="fill_parent"		
	    android:orientation="vertical" >
	    <RadioGroup 
	        android:id="@+id/myrgp"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:orientation="vertical">
	   	    <RadioButton 
	   	        android:id = "@+id/utf8"
	   	        android:text="UTF编码"
	   	    />
	   	    <RadioButton 
	   	        android:id = "@+id/gbk"
	   	        android:text="GBK编码"
	   	    />
	   </RadioGroup>    
	</LinearLayout>
</LinearLayout>

3).
public class MainActivity extends TabActivity {
	private TabHost mytabhost = null;
	private int[] layres=new int[]{R.id.tab_edit,R.id.tab_clk,R.id.tab_rgp};//内嵌布局文件的id
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //super.setContentView(R.layout.activity_main);
        this.mytabhost = super.getTabHost();//取得TabHost对象
        LayoutInflater.from(this).inflate(R.layout.tab, this.mytabhost.getTabContentView(),true);
        //增加Tab的组件
        for(int x=0;x<this.layres.length;x++)
        {
        	TabSpec myTab=this.mytabhost.newTabSpec("tab"+x);
        	myTab.setIndicator("标签"+x);
        	myTab.setContent(this.layres[x]);
        	this.mytabhost.addTab(myTab);        	
        }
    }
}

*Activity生命周期
有三种生命周期
运行态
暂停态：调用别的页面，但是这个页面只有一半大，例如弹出窗口。这时主页面显示着，但是不可用
停止态：完全切换到别的页面

在多个Activity,相当于进行栈操作。但是如果某个Activity进行finish()操作时，就会自动消除，不会作
出栈操作
ActivityGroup:分页菜单栏使用TabHost组件太难，实际上不使用。而是用ActivityGroup+GridView,每一个
Activity程序都是独占运行，使用android.app.ActivityGroup类将多个Activity包括进来
但是现在也过时了，现在用Fragment

添加myMainActivity.java页面,作myactivity_main页面
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >

    <ImageView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="hello_worldOne" />

</LinearLayout>

将页面添加到AndroidManifest.xml中
<activity
	android:name="com.example.activitygroup.myMainActivity"
	android:label="@string/app_name" >            
</activity>

添加MainActivity.java页面,作主页面acitvity_main
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:orientation="vertical"
    tools:context=".MainActivity" >

    <RelativeLayout 
	    android:layout_width="fill_parent"
	    android:layout_height="fill_parent">
	    <LinearLayout      <!--存放内容Activity--> 
	        android:id="@+id/context"
	        android:orientation="vertical"
	        android:layout_width="fill_parent"
    		android:layout_height="fill_parent">	        
	    </LinearLayout>
		<GridView          <!--底下选择条-->
		    android:id="@+id/gridbar"
		    android:layout_width="fill_parent"
	    	android:layout_height="wrap_parent"
	    	android:layout_alignBottom="true"
	    	android:fadingEdgeLength="5px"
	    	android:fadingEdge="vertical"/>			
	</RelativeLayout>	    

</LinearLayout>

在res/drawable-hdpi/中添加按钮图片
定义一个BaseAdapter类的子类，负责所有内容的填充操作。添加menuAdapter.java类
public class menuAdapter extends BaseAdapter 
{
	private ImageView menuImg[];//保存所要填充的组件
	private Context context=null;//上下文对象
	private int selectMenu;//选中的索引
	public menuAdapter(Context context,int menuIds[],int width,int height,int selectMenu)
	{
		this.context = context;
		this.selectMenu=selectMenu;
		this.menuImg= new ImageView[menuIds.length];
		for(int x=0;x<menuIds.length;x++)
		{
			this.menuImg[x]=new ImageView(this.context);//实例化ImageView
			this.menuImg[x].setLayoutParams(new GridView.LayoutParams(width,height));//设置图片大小
			this.menuImg[x].setAdjustViewBounds(false);//不调整边界显示
			this.menuImg[x].setPadding(3, 3, 3, 3);//设置间距
			this.menuImg[x].setImageResource(menuIds[x]);//加载图片
		}
	}
	@Override
	public int getCount() {
		// TODO Auto-generated method stub
		return this.menuImg.length;
	}

	@Override
	public Object getItem(int position) {
		// TODO Auto-generated method stub
		return this.menuImg[position];
	}

	@Override
	public long getItemId(int position) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	//显示
	public View getView(int position, View convertView, ViewGroup parent) {
		// TODO Auto-generated method stub
		ImageView imgview=null;
		if(convertView==null)
		{
			imgview=this.menuImg[position];
		}
		else 
		{
			imgview=(ImageView)convertView;
		}
		return imgview;
	}
	//设置选中的显示
	public void setFocus(int setId)
	{
		for(int x=0;x<this.menuImg.length;x++)
		{
			if(x!=setId)//没有选中的
			{
				this.menuImg[x].setBackgroundResource(0);//不设置背景图片
			}
		}
		this.menuImg[setId].setBackgroundResource(this.selectMenu);
	}

}

通过Activity对GridView进行填充，打开myMainActivity.java
package com.example.activitygroup;

import android.os.Bundle;
import android.R.color;
import android.app.ActionBar.LayoutParams;
import android.app.Activity;
import android.app.ActivityGroup;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.view.Gravity;
import android.view.Menu;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.GridView;
import android.widget.LinearLayout;

public class myMainActivity extends ActivityGroup 
{
	private GridView gridviewTool;//工具菜单栏
	private menuAdapter menu=null;//图片适配器
	private LinearLayout content=null;//填充内容
	//填充图片资源
	private int menu_img[]=new int[]{R.drawable.an1,R.drawable.an2,R.drawable.an3,R.drawable.an4};
	private int width=0;//求出平均宽度
	private int height=0;//求出平均高度
	private Intent intent=null;//打开intent操作
	
	@Override
	protected void onCreate(Bundle savedInstanceState) 
	{
		super.onCreate(savedInstanceState);
		super.setContentView(R.layout.myactivity_main);
		this.gridviewTool = (GridView) super.findViewById(R.id.gridbar);
		this.content=(LinearLayout) super.findViewById(R.id.context);
		//定义工具栏的一些显示
		this.gridviewTool.setNumColumns(this.menu_img.length);//求出可以保存的个数
		this.gridviewTool.setSelector(new ColorDrawable(Color.TRANSPARENT));//透明色
		this.gridviewTool.setGravity(Gravity.CENTER);//居中显示
		this.gridviewTool.setVerticalSpacing(0);//垂直间隔0
		
		
		this.width=super.getWindowManager().getDefaultDisplay().getWidth();
		this.height=super.getWindowManager().getDefaultDisplay().getHeight();
		
		//图片显示
		this.menu = new menuAdapter(this,this.menu_img,this.width,this.height,R.drawable.an1);
		this.gridviewTool.setAdapter(this.menu);
		this.switchActivity(0);//第一个被选中
		this.gridviewTool.setOnItemClickListener(new OnItemClickListenerImp());
	}

	private class OnItemClickListenerImp implements	OnItemClickListener
	{

		@Override
		public void onItemClick(AdapterView<?> parent, View view, int position,
				long id) {
			// TODO Auto-generated method stub
			myMainActivity.this.switchActivity(position);
		}
		
	}
	//切换选中操作
	public void	switchActivity(int id)
	{
		this.menu.setFocus(id);//设置选中图片的背景
		this.content.removeAllViews();//删除所有的内容
		switch(id)
		{
			case 0:
				this.intent = new Intent(myMainActivity.this,MainActivity.class);
				break;
			case 1:
				this.intent = new Intent(myMainActivity.this,MainActivity.class);
				break;
			case 2:
				this.intent = new Intent(myMainActivity.this,MainActivity.class);
				break;
			case 3:
				this.intent = new Intent(myMainActivity.this,MainActivity.class);
				break;	
		}
		this.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
		//显示填充主页面
		Window subActivity=super.getLocalActivityManager().startActivity("subActivity", this.intent);
		this.content.addView(subActivity.getDecorView(),LayoutParams.FILL_PARENT,LayoutParams.FILL_PARENT);
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.main, menu);
		return true;
	}

}


*菜单:选项菜单OptionsMenu,上下文菜单ContextMenu,子菜单SubMenu
1.选项菜单OptionsMenu
1）通过程序编写
复写方法
onPrepareOptionsMenu(),onCreateOptionsMenu
public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        super.setContentView(R.layout.activity_main);
    }


    @Override
    //菜单选中之后的操作
	public boolean onOptionsItemSelected(MenuItem item) {
		// TODO Auto-generated method stub
    	switch(item.getItemId())
    	{
    		case Menu.FIRST + 1:
    			Toast.makeText(this, "删除菜单", Toast.LENGTH_LONG).show();
    			break;
    		case Menu.FIRST + 2:
    			Toast.makeText(this, "保存菜单", Toast.LENGTH_LONG).show();
    			break;
    		case Menu.FIRST + 3:
    			Toast.makeText(this, "编辑菜单", Toast.LENGTH_LONG).show();
    			break;	
    	}
		return false;
	}


	@Override
	public void onOptionsMenuClosed(Menu menu) {
		// TODO Auto-generated method stub
		super.onOptionsMenuClosed(menu);
	}


	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		// TODO Auto-generated method stub
		//return super.onPrepareOptionsMenu(menu);
		Toast.makeText(this, "在菜单显示", Toast.LENGTH_LONG).show();
		return true;
	}


	@Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
		//创建选项菜单OptionsMenu
        //getMenuInflater().inflate(R.menu.main, menu);
        menu.add(Menu.NONE,Menu.FIRST+1,5,"删除").setIcon(android.R.drawable.ic_menu_delete);
    	menu.add(Menu.NONE,Menu.FIRST+2,2,"保存").setIcon(android.R.drawable.ic_menu_save);
    	menu.add(Menu.NONE,Menu.FIRST+3,3,"编辑").setIcon(android.R.drawable.ic_menu_call);
        return true;
    }
    
}
启动程序后，按下pageup，或者menu菜单按键，可以显示他

2).通过res/menu/main.xml资源文件
(1)
<menu xmlns:android="http://schemas.android.com/apk/res/android" >

    <item
        android:id="@+id/item1"
        android:icon="@android:drawable/ic_menu_add"
        android:title="添加"/>
	<item
        android:id="@+id/item2"
        android:icon="@android:drawable/ic_menu_save"
        android:title="保存"/>
	<item
        android:id="@+id/item3"
        android:icon="@android:drawable/ic_menu_edit"
        android:title="编辑"/>
	<item
        android:id="@+id/item4"
        android:icon="@android:drawable/ic_menu_delete"
        android:title="删除"/>
</menu>

(2)
public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
		//创建选项菜单OptionsMenu
        getMenuInflater().inflate(R.menu.main, menu);        
        return true;
    }

3.上下文菜单ContextMenu:类似右键菜单
1）通过程序编写
复写方法
onContextItemSelected,onCreateContextMenu

private String data[]=new String[]{"aa","bb","cc"};
private ListView listview=null;

@Override
protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      //super.setContentView(R.layout.activity_main);
      this.listview = new ListView(this);
      this.listview.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_expandable_list_item_1,this.data));
      super.setContentView(this.listview);
      super.registerForContextMenu(this.listview);//注册listview的显示，在这里点击之后，可以弹出上下文菜单
}

@Override
public boolean onContextItemSelected(MenuItem item) {
	// TODO Auto-generated method stub
	switch(item.getItemId())
    	{
    		case Menu.FIRST + 1:
    			Toast.makeText(this, "删除菜单", Toast.LENGTH_LONG).show();
    			break;
    		case Menu.FIRST + 2:
    			Toast.makeText(this, "保存菜单", Toast.LENGTH_LONG).show();
    			break;    		
    	}
	return false;
}

@Override
public void onContextMenuClosed(Menu menu) {
	// TODO Auto-generated method stub
	super.onContextMenuClosed(menu);
}


@Override
//创建上下文菜单
public void onCreateContextMenu(ContextMenu menu, View v,
		ContextMenuInfo menuInfo) 
{
	// TODO Auto-generated method stub
	//super.onCreateContextMenu(menu, v, menuInfo);
	menu.setHeaderTitle("信息操作");
	menu.add(Menu.NONE,Menu.FIRST+1,5,"删除");
    	menu.add(Menu.NONE,Menu.FIRST+2,2,"保存");
   	
}

启动程序后，通过长按屏幕，调用注册了的上下文菜单


2).通过res/menu/main.xml资源文件
public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
		// TODO Auto-generated method stub
		super.onCreateContextMenu(menu, v, menuInfo);
		menu.setHeaderTitle("信息操作");
		//menu.add(Menu.NONE,Menu.FIRST+1,5,"删除");
    	//menu.add(Menu.NONE,Menu.FIRST+2,2,"保存");
		getMenuInflater().inflate(R.menu.main, menu);
	}
其他与上面一样

4.子菜单SubMenu
 public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
		//子创建选项菜单OptionsMenu
        SubMenu filemenu=menu.addSubMenu("文件");
        SubMenu editMenu=menu.addSubMenu("编辑");
        filemenu.add(Menu.NONE,Menu.FIRST+1,1,"删除").setIcon(android.R.drawable.ic_menu_delete);
        filemenu.add(Menu.NONE,Menu.FIRST+2,2,"保存").setIcon(android.R.drawable.ic_menu_save);
        editMenu.add(Menu.NONE,Menu.FIRST+3,3,"编辑").setIcon(android.R.drawable.ic_menu_call);
        return true;
}


5.弹出菜单android.widget.PopupWindow
与对话框不一样的是没有确定，取消按钮，里面的内容可以自己定义
1)新建popwindow.xml页面布局
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    <RadioGroup 
	        android:id="@+id/myrgp"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:orientation="vertical">
	   	    <RadioButton 
	   	        android:id = "@+id/utf8"
	   	        android:text="UTF编码"
	   	    />
	   	    <RadioButton 
	   	        android:id = "@+id/gbk"
	   	        android:text="GBK编码"
	   	    />
	</RadioGroup>   
	<Button 
	        android:id="@+id/cancel"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:text="取消"
	    />
</LinearLayout>

2)
private Button popbtn=null;
private View popview=null;
private PopupWindow popWin=null;
private RadioGroup myrgp=null;
private Button cancel=null;

protected void onCreate(Bundle savedInstanceState) 
{
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.popbtn=(Button) super.findViewById(R.id.popbtn);
        this.popbtn.setOnClickListener(new  OnClickListenerpop());
    }

    private class OnClickListenerpop implements OnClickListener
    {

		@Override
		public void onClick(View arg0) 
		{
			// TODO Auto-generated method stub
			LayoutInflater inflater=LayoutInflater.from(MainActivity.this);
			//找到了了布局文件中的view
			MainActivity.this.popview = inflater.inflate(R.layout.popwindow, null);
			//新建弹出菜单实例，使用布局文件中的view,长300,宽220，有焦距
			MainActivity.this.popWin = new PopupWindow(MainActivity.this.popview,300,220,true);
			//开始处理popWin中的控件
			MainActivity.this.myrgp = (RadioGroup)MainActivity.this.popview.findViewById(R.id.myrgp);
			MainActivity.this.cancel = (Button)MainActivity.this.popview.findViewById(R.id.cancel);
			
			//按下popwindow的单选钮
			MainActivity.this.myrgp.setOnCheckedChangeListener(new OnCheckedChangeListenergrp());
			MainActivity.this.cancel.setOnClickListener(new OnClickListenerCancel());
			//弹出窗体
			MainActivity.this.popWin.showAtLocation(MainActivity.this.popbtn, Gravity.CENTER, 0, 0);
		}
    	
    }
    private class OnCheckedChangeListenergrp implements OnCheckedChangeListener
    {

		@Override
		public void onCheckedChanged(RadioGroup group, int checkedId) 
		{
			// TODO Auto-generated method stub
			//取得指定的单选钮
			RadioButton but = (RadioButton)MainActivity.this.popview.findViewById(group.getCheckedRadioButtonId());
			but.setText("被选中:"+but.getText().toString());
		}
    	
    }
    private class OnClickListenerCancel implements OnClickListener
    {
    	//关闭弹出窗口
		@Override
		public void onClick(View v) 
		{
			// TODO Auto-generated method stub
			MainActivity.this.popWin.dismiss();
		}
    	
    }


*android.widget.SlidingDrawer抽屉组件：隐藏在右侧，一点击处理按钮，右面的菜单
就会弹出，类似于视频播放器的左边视频列表
1.
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >
	<SlidingDrawer 
	    android:id="@+id/slidingdrawer"
	    android:layout_width="fill_parent"
   		android:layout_height="fill_parent"
   		android:orientation="horizontal"
   		android:handle="@+id/handle"  表示要处理的操作控件是handle
   		android:content="@+id/content"他的内容是content
   		>
	    <TextView
	        android:id="@+id/handle"
	        android:layout_width="wrap_content"
	        android:layout_height="wrap_content"
	        android:text="->" />
	    <LinearLayout
	        android:id="@+id/content"
	        android:orientation="vertical"
	        android:layout_width="fill_parent"
   			android:layout_height="fill_parent"
	    >
	        
	    </LinearLayout>
	</SlidingDrawer>
</LinearLayout>

2.
public class MainActivity extends Activity 
{
	private String data[]=new String[]{"aa","bb","cc"};
	private ListView listview=null;
	private SlidingDrawer slidingdrawer=null;
	private TextView handle=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) 
        {
		super.onCreate(savedInstanceState);
		super.setContentView(R.layout.activity_main);
		//向这个布局文件保存listview
		LinearLayout layout=(LinearLayout) super.findViewById(R.id.content);
		this.listview =new ListView(this);
		this.listview.setAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_expandable_list_item_1,this.data));
		layout.addView(this.listview);
		
                //添加抽屉控件
		this.slidingdrawer = (SlidingDrawer) super.findViewById(R.id.slidingdrawer);
		this.handle = (TextView) super.findViewById(R.id.handle);
		//打开处理
		this.slidingdrawer.setOnDrawerOpenListener(new onDrawerOpenListenerslide());
		//关闭处理
		this.slidingdrawer.setOnDrawerCloseListener(new onDrawerCloseListenerslide());
		//滚动处理
		this.slidingdrawer.setOnDrawerScrollListener(new onDrawerScrollListenerslide());
	}
	//打开处理
	private class onDrawerOpenListenerslide implements OnDrawerOpenListener
	{

		@Override
		public void onDrawerOpened() 
		{
			// TODO Auto-generated method stub
			MainActivity.this.handle.setText("OPEN");
		}
		
	}
	//关闭处理
	private class onDrawerCloseListenerslide implements OnDrawerCloseListener
	{

		@Override
		public void onDrawerClosed() 
		{
			// TODO Auto-generated method stub
			MainActivity.this.handle.setText("CLOSE");
		}	
		
	}
	private class onDrawerScrollListenerslide implements OnDrawerScrollListener
	{

		@Override
		public void onScrollEnded() 
		{
			// TODO Auto-generated method stub
			Toast.makeText(MainActivity.this, "窗口拖动结束", Toast.LENGTH_SHORT).show();
		}

		@Override
		public void onScrollStarted() 
		{
			// TODO Auto-generated method stub
			Toast.makeText(MainActivity.this, "窗口拖动开始", Toast.LENGTH_SHORT).show();
		}
		
	}
}


*缩放控制android.widget.ZoomControls组件：对手机屏幕内容的放大和缩小
<ZoomControls
	android:id = "@+id/zoom"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:layout_below="@+id/txt1" 
/>

this.zoom = (ZoomControls) super.findViewById(R.id.zoom);
	    
点击放大事件处理
public void onClick(View v)
{
   Main.this.size = size+2;
   Main.this.text.setTextSize(size);    
}
点击缩小事件处理
public void onClick(View v)
{
   Main.this.size = size-2;
   Main.this.text.setTextSize(size);    
}

*Uri
android图片文件的路径地址与Uri的相互转换
这是一张图片的Uri，那么我们如何根据这个Uri获得其在文件系统中的路径呢？
/**
 * Try to return the absolute file path from the given Uri
 *
 * @param context
 * @param uri
 * @return the file path or null
 */
public static String getRealFilePath( final Context context, final Uri uri ) {
    if ( null == uri ) return null;
    final String scheme = uri.getScheme();
    String data = null;
    if ( scheme == null )
        data = uri.getPath();
    else if ( ContentResolver.SCHEME_FILE.equals( scheme ) ) {
        data = uri.getPath();
    } else if ( ContentResolver.SCHEME_CONTENT.equals( scheme ) ) {
        Cursor cursor = context.getContentResolver().query( uri, new String[] { ImageColumns.DATA }, null, null, null );
        if ( null != cursor ) {
            if ( cursor.moveToFirst() ) {
                int index = cursor.getColumnIndex( ImageColumns.DATA );
                if ( index > -1 ) {
                    data = cursor.getString( index );
                }
            }
            cursor.close();
        }
    }
    return data;
}

那么假如我们有一个图片的路径地址又该如何获得其Uri呢？
String type = Utils.ensureNotNull(intent.getType());
Log.d(TAG, "uri is " + uri);
if (uri.getScheme().equals("file") && (type.contains("image/"))) 
{
    String path = uri.getEncodedPath();
    Log.d(TAG, "path1 is " + path);
    if (path != null) 
	{
        path = Uri.decode(path);
        Log.d(TAG, "path2 is " + path);
        ContentResolver cr = this.getContentResolver();
        StringBuffer buff = new StringBuffer();
        buff.append("(")
                .append(Images.ImageColumns.DATA)
                .append("=")
                .append("'" + path + "'")
                .append(")");
        Cursor cur = cr.query(
                Images.Media.EXTERNAL_CONTENT_URI,
                new String[] { Images.ImageColumns._ID },
                buff.toString(), null, null);
        int index = 0;
        for (cur.moveToFirst(); !cur.isAfterLast(); cur
                .moveToNext()) {
            index = cur.getColumnIndex(Images.ImageColumns._ID);
            // set _id value
            index = cur.getInt(index);
        }
        if (index == 0) {
            //do nothing
        } else {
            Uri uri_temp = Uri
                    .parse("content://media/external/images/media/"
                            + index);
            Log.d(TAG, "uri_temp is " + uri_temp);
            if (uri_temp != null) {
                uri = uri_temp;
            }
        }
    }
}

*Fragment
Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。针对屏幕尺寸的差距，很多情况下，都是先针对手机开发一套App，然后拷贝一份，修改布局以适应平板神马超级大屏的。难道无法做到一个App可以同时适应手机和平板么，当然了，必须有啊。Fragment的出现就是为了解决这样的问题。你可以把Fragment当成Activity的一个界面的一个组成部分，甚至Activity的界面可以完全有不同的Fragment组成，更帅气的是Fragment拥有自己的生命周期和接收、处理用户的事件，这样就不必在Activity写一堆控件的事件处理的代码了。更为重要的是，你可以动态的添加、替换和移除某个Fragment。

可以看到Fragment比Activity多了几个额外的生命周期回调方法：
onAttach(Activity)
当Fragment与Activity发生关联时调用。
onCreateView(LayoutInflater, ViewGroup,Bundle)
创建该Fragment的视图
onActivityCreated(Bundle)
当Activity的onCreate方法返回时调用
onDestoryView()
与onCreateView想对应，当该Fragment的视图被移除时调用
onDetach()
与onAttach相对应，当Fragment与Activity关联被取消时调用
注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现，

1.静态的使用Fragment
这是使用Fragment最简单的一种方式，把Fragment当成普通的控件，直接写在Activity的布局文件中。步骤：
1、继承Fragment，重写onCreateView决定Fragemnt的布局
2、在Activity中声明此Fragment，就当和普通的View一样

1).标题布局
titlefragment.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"  
    android:layout_height="45dp"   >
    <ImageButton  
        android:id="@+id/id_title_left_btn"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_centerVertical="true"  
        android:layout_marginLeft="3dp"   />  
  
    <TextView  
        android:layout_width="fill_parent"  
        android:layout_height="fill_parent"  
        android:gravity="center"  
        android:text="我不是微信"  
        android:textColor="#fff"  
        android:textSize="20sp"  
        android:textStyle="bold" />  

</RelativeLayout>

TitleFragment.java
由于要作事件触发操作，因此这样写
public class TitleFragment extends Fragment {
	private ImageButton mLeftMenu;  
	@Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        View view = inflater.inflate(R.layout.titlefragment, container, false);  
        mLeftMenu = (ImageButton) view.findViewById(R.id.id_title_left_btn);  
        mLeftMenu.setOnClickListener(new View.OnClickListener()  
        {  
            @Override  
            public void onClick(View v)  
            {  
                Toast.makeText(getActivity(),  
                        "i am an ImageButton in TitleFragment ! ",  
                        Toast.LENGTH_SHORT).show();  
            }  
        });  
        return view;  
    } 
}

2)内容布局
fragment_content.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    <TextView  
        android:layout_width="fill_parent"  
        android:layout_height="fill_parent"  
        android:gravity="center"  
        android:text="使用Fragment做主面板"  
        android:textSize="20sp"  
        android:textStyle="bold" />  

</LinearLayout>


ContentFragment.java
不做事件触发，直接返回
public class ContentFragment extends Fragment {
	@Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        return inflater.inflate(R.layout.fragment_content, container, false);  
    }
}

3)整合到activity中
activity_main.xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >

    <fragment  
        android:id="@+id/id_fragment_title"  
        android:name="com.example.frame.TitleFragment"  
        android:layout_width="fill_parent"  
        android:layout_height="45dp" />  
  
    <fragment  
        android:layout_below="@id/id_fragment_title"  
        android:id="@+id/id_fragment_content"  
        android:name="com.example.frame.ContentFragment"  
        android:layout_width="fill_parent"  
        android:layout_height="fill_parent" />

</RelativeLayout>

MainActivity.java
public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_NO_TITLE);  
		setContentView(R.layout.activity_main);
	}

	
}


2.动态的使用Fragment：可用于手机app分屏页面风格
上面已经演示了最简单的使用Fragment的方式，下面分享一下如何动态的添加、更新、以及删除Fragment。首先是，MainActivity的布局文件activity_main.xml，该文件布局文件上面的顶部是一个TitleFragment，是一个静态声明的Fragment。中间也是一个Fragment，但是这个Fragment是动态使用的。最下面是四个按钮。
1).标题布局
titlefragment.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"  
    android:layout_height="45dp"   >
    <ImageButton  
        android:id="@+id/id_title_left_btn"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:layout_centerVertical="true"  
        android:layout_marginLeft="3dp"   />  
  
    <TextView  
        android:layout_width="fill_parent"  
        android:layout_height="fill_parent"  
        android:gravity="center"  
        android:text="我不是微信"  
        android:textColor="#fff"  
        android:textSize="20sp"  
        android:textStyle="bold" />  

</RelativeLayout>

TitleFragment.java
由于要作事件触发操作，因此这样写
public class TitleFragment extends Fragment {
	private ImageButton mLeftMenu;  
	@Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        View view = inflater.inflate(R.layout.titlefragment, container, false);  
        mLeftMenu = (ImageButton) view.findViewById(R.id.id_title_left_btn);  
        mLeftMenu.setOnClickListener(new View.OnClickListener()  
        {  
            @Override  
            public void onClick(View v)  
            {  
                Toast.makeText(getActivity(),  
                        "i am an ImageButton in TitleFragment ! ",  
                        Toast.LENGTH_SHORT).show();  
            }  
        });  
        return view;  
    } 
}

2)内容布局
(1)微信内容布局
fragment_content.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    <TextView  
        android:layout_width="fill_parent"  
        android:layout_height="fill_parent"  
        android:gravity="center"  
        android:text="使用微信做主面板"  
        android:textSize="20sp"  
        android:textStyle="bold" />  

</LinearLayout>


ContentFragment.java
不做事件触发，直接返回
public class ContentFragment extends Fragment {
	@Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
		Context context=this.getActivity();//获取activity的context
        return inflater.inflate(R.layout.fragment_content, container, false);  
    }
}

(2)朋友圈内容布局
fragment_friend.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    <TextView  
        android:layout_width="fill_parent"  
        android:layout_height="fill_parent"  
        android:gravity="center"  
        android:text="使用朋友圈做主面板"  
        android:textSize="20sp"  
        android:textStyle="bold" />

</LinearLayout>

FriendFragment.java

import android.app.Fragment;
public class FriendFragment extends Fragment {
	@Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
		Context context=this.getActivity();//获取activity的context
        return inflater.inflate(R.layout.fragment_friend, container, false);  
    }
}

3)
(1)
activity_main.xml

<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >

    <fragment  
        android:id="@+id/id_fragment_title"  
        android:name="com.example.frame.TitleFragment"  
        android:layout_width="fill_parent"  
        android:layout_height="45dp" />  
  
     <FrameLayout
        android:id="@+id/id_content"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"
        android:layout_below="@id/id_fragment_title"
         />
     
     <Button
	    android:id="@+id/btnweixin"
	    android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:text="微信"/>
	 <Button
	    android:id="@+id/btnfriend"
	    android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_toRightOf="@+id/btnweixin" 
        android:text="朋友圈"/>

</RelativeLayout>

(2)首先是将上面的布局文件通过setContentView()加载进来.然后是通过setDefaultFragment()；将默认的ContentFragment动态的加载进来。接下来就是通过我们在最下面防止的四个按钮可以随意的动态切换Fragment。这也是为什么Fragment会有如此火的原因吧
我们可以使用FragmentManager对Fragment进行动态的加载，这里使用的replace方法
MainActivity.java

package com.example.frame;

import android.os.Bundle;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.FragmentManager;
import android.app.FragmentTransaction;
import android.view.Menu;
import android.view.View;
import android.view.Window;
import android.widget.Button;

public class MainActivity extends Activity {
	private Button btnweixin;
    private Button btnfriend;
    private ContentFragment mWeiXinFragment;
    private FriendFragment mFriendFragment;
    
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_NO_TITLE);  
		setContentView(R.layout.activity_main);
		initView();
	}
	
	public void initView() {
        // 初始化控件和声明事件
		btnweixin = (Button) findViewById(R.id.btnweixin);
		btnfriend = (Button) findViewById(R.id.btnfriend);
		btnweixin.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				setonClick(v);
			}
		});
		btnfriend.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				setonClick(v);
			}
		});

        // 设置默认的Fragment
        setDefaultFragment();
    }
	
	@SuppressLint("NewApi")
    private void setDefaultFragment() {
        FragmentManager manager = getFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();

        mWeiXinFragment = new ContentFragment();
        transaction.replace(R.id.id_content, mWeiXinFragment);
        transaction.commit();
    }

	@SuppressLint("NewApi")
    public void setonClick(View v) {
        FragmentManager fm = getFragmentManager();
        // 开启Fragment事务
        FragmentTransaction transaction = fm.beginTransaction();
        switch (v.getId()) {
        case R.id.btnweixin:
            if (mWeiXinFragment == null) {
                mWeiXinFragment = new ContentFragment();
            }
            // 使用当前Fragment的布局替代id_content的控件
            transaction.replace(R.id.id_content, mWeiXinFragment);
            break;
        case R.id.btnfriend:
            if (mFriendFragment == null) {
                mFriendFragment = new FriendFragment();
            }
            transaction.replace(R.id.id_content, mFriendFragment);
            break;
        }
        // transaction.addToBackStack();
        // 事务提交
        transaction.commit();
    }
	
}

3.Fragment的生命周期
Fragment必须是依存于Activity而存在的，因此Activity的生命周期会直接影响到Fragment的生命周期
Fragment常用的API：

Fragment常用的三个类：

android.app.Fragment 主要用于定义Fragment

android.app.FragmentManager 主要用于在Activity中操作Fragment

android.app.FragmentTransaction 保证一些列Fragment操作的原子性，熟悉事务这个词，一定能明白~

a、获取FragmentManage的方式：

getFragmentManager() // v4中，getSupportFragmentManager

b、主要的操作都是FragmentTransaction的方法

FragmentTransaction transaction = fm.benginTransatcion();//开启一个事务

transaction.add() 

往Activity中添加一个Fragment

transaction.remove()

从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈（回退栈后面会详细说），这个Fragment实例将会被销毁。

transaction.replace()

使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体~

transaction.hide()

隐藏当前的Fragment，仅仅是设为不可见，并不会销毁

transaction.show()

显示之前隐藏的Fragment

detach()

将此Fragment从Activity中分离，会销毁其布局，但不会销毁该实例

attach()

将从Activity中分离的Fragment，重新关联到该Activity，重新创建其视图层次

transatcion.commit()//提交一个事务

注意：常用Fragment的哥们，可能会经常遇到这样Activity状态不一致：State loss这样的错误。主要是因为：commit方法一定要在Activity.onSaveInstance()之前调用。

上述，基本是操作Fragment的所有的方式了，在一个事务开启到提交可以进行多个的添加、移除、替换等操作。

值得注意的是：如果你喜欢使用Fragment，一定要清楚这些方法，哪个会销毁视图，哪个会销毁实例，哪个仅仅只是隐藏，这样才能更好的使用它们。

a、比如：我在FragmentA中的EditText填了一些数据，当切换到FragmentB时，如果希望会到A还能看到数据，则适合你的就是hide和show；也就是说，希望保留用户操作的面板，你可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。

b、再比如：我不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。

c、remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。

上述已经介绍完成了Fragment常用的一些方法，相信看完，大家一定清楚了Fragment的产生理由，以及如何使用Fragment，再根据API的讲解，也能明白，曾经为何觉得Fragment会出现一些列乱七八槽的问题，终究是因为没有弄清楚其生命周期。

d.管理Fragment回退栈:类似与Android系统为Activity维护一个任务栈，我们也可以通过Activity维护一个回退栈来保存每次Fragment事务发生的变化。如果你将Fragment任务添加到回退栈，当用户点击后退按钮时，将看到上一次的保存的Fragment。一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则退出当前Activity。
例如：
1)将FragmentOne添加作为默认的activity的fragment，注意这里并没有调用FragmentTransaction.addToBackStack(String)，因为如果用了，则点击Back键出现白板。
而不用，则是直接退出我们的Activity.
public class MainActivity extends Activity  
{  
  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        setContentView(R.layout.activity_main);  
  
        FragmentManager fm = getFragmentManager();  
        FragmentTransaction tx = fm.beginTransaction();  
        tx.add(R.id.id_content, new FragmentOne(),"ONE");  
        tx.commit();  
    }  
  
}  

2）FragmentOne
我们在点击FragmentOne中的按钮时，使用了replace方法，如果你看了前一篇博客，一定记得replace是remove和add的合体，并且如果不添加事务到回退栈，前一个Fragment实例会被销毁。这里很明显，我们调用tx.addToBackStack(null);将当前的事务添加到了回退栈，所以FragmentOne实例不会被销毁，但是从前输入的数据将会被清空
public class FragmentOne extends Fragment implements OnClickListener  
{  
  
    private Button mBtn;  
  
    @Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        View view = inflater.inflate(R.layout.fragment_one, container, false);  
        mBtn = (Button) view.findViewById(R.id.id_fragment_one_btn);  
        mBtn.setOnClickListener(this);  
        return view;  
    }  
  
    @Override  
    public void onClick(View v)  
    {  
        FragmentTwo fTwo = new FragmentTwo();  
        FragmentManager fm = getFragmentManager();  
        FragmentTransaction tx = fm.beginTransaction();  
        tx.replace(R.id.id_content, fTwo, "TWO");  //用two替换one
        tx.addToBackStack(null);  //当前的one加入回退栈
        tx.commit();  
  
    }  
  
}  

3)FragmentTwo
这里点击时，我们没有使用replace，而是先隐藏了当前的Fragment，然后添加了FragmentThree的实例，最后将事务添加到回退栈,从前输入的数据不会被清空。
public class FragmentTwo extends Fragment implements OnClickListener  
{  
  
    private Button mBtn ;  
    @Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        View view = inflater.inflate(R.layout.fragment_two, container, false);  
        mBtn = (Button) view.findViewById(R.id.id_fragment_two_btn);  
        mBtn.setOnClickListener(this);  
        return view ;   
    }  
    @Override  
    public void onClick(View v)  
    {  
        FragmentThree fThree = new FragmentThree();  
        FragmentManager fm = getFragmentManager();  
        FragmentTransaction tx = fm.beginTransaction();  
        tx.hide(this);  //把当前two隐藏
        tx.add(R.id.id_content , fThree, "THREE");  //添加three
        tx.addToBackStack(null);  //把two添加到回退栈
        tx.commit();  
    }    
  
}  

4.Fragment与Activity通信
1)
因为所有的Fragment都是依附于Activity的，所以通信起来并不复杂，大概归纳为：
注：如果在Fragment中需要Context，可以通过调用getActivity(),如果该Context需要在Activity被销毁后还存在，则使用getActivity().getApplicationContext()。
因为要考虑Fragment的重复使用，所以必须降低Fragment与Activity的耦合，而且Fragment更不应该直接操作别的Fragment，毕竟Fragment操作应该由它的管理者Activity来决定。

(1).Fragment中通过getActivity()然后进行强制转化，调用Activity中的公有方法
((XXXXActivity)getActivity()).fun();

(2)fragment可以通过getActivity() 方法来获得Activity的实例，然后就可以调用一些例如findViewById()之类的方法。
　　如：
　　View listView = getActivity().findViewById(R.id.list);
　　但是注意调用getActivity()时，fragment必须和activity关联（attached to an activity），否则将会返回一个null。
(3)相似的，activity也可以获得一个fragment的引用，从而调用fragment中的方法。
　　获得fragment的引用要用FragmentManager，之后可以调用findFragmentById() 或者 findFragmentByTag().
　　比如：
　　ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);
(4)Activity在切换Fragment的时候，通过setArguments向Fragment传递参数，Fragment通过getArguments();获得从activity中传递过来的值
(5)最重要，通过回调接口来操作

例1，fragment1发送数据给fragment2
ContentFragment.java
public class ContentFragment extends Fragment {
	 /**
     * 用来与外部activity交互的
     */
    private FragmentInteraction listterner;
    /**
     * 步骤四、当ContentFragment被加载到activity的时候，主动注册回调信息
     * @param activity
     */
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        if(activity instanceof FragmentInteraction)
        {
            listterner = (FragmentInteraction)activity;
        }
        else{
            throw new IllegalArgumentException("activity must implements FragmentInteraction");
        }

    }
    /**
     * 步骤一、定义了所有activity必须实现的接口
     */
    public interface FragmentInteraction
    {
        /**
         * Fragment 向Activity传递指令，这个方法可以根据需求来定义
         * @param str
         */
        void process(String str);


    }
    
	@Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
		View view = inflater.inflate(R.layout.fragment_content, container, false); 
		final EditText edit=(EditText) view.findViewById(R.id.edit);  
		Button button=(Button) view.findViewById(R.id.button); 
		button.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				//步骤二、fragment向activity发送回调信息
				listterner.process(edit.getText().toString());
			}
		});
		return view;
    }
	
    
    @Override
    public void onDetach() {
        super.onDetach();

        listterner = null;
    }
    
}

MainActivity.java
//引用接口
public class MainActivity extends Activity implements FragmentInteraction{
	private Button btnweixin;
    private Button btnfriend;
    private ContentFragment mWeiXinFragment;
    private FriendFragment mFriendFragment;
    
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_NO_TITLE);  
		setContentView(R.layout.activity_main);
		initView();
	}
	
	public void initView() {
        // 初始化控件和声明事件
		btnweixin = (Button) findViewById(R.id.btnweixin);
		btnfriend = (Button) findViewById(R.id.btnfriend);
		btnweixin.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				setonClick(v);
			}
		});
		btnfriend.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				setonClick(v);
			}
		});

        // 设置默认的Fragment
        setDefaultFragment();
    }
	
	@SuppressLint("NewApi")
    private void setDefaultFragment() {
        FragmentManager manager = getFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();

        mWeiXinFragment = new ContentFragment();
        transaction.replace(R.id.id_content, mWeiXinFragment);
        transaction.commit();
    }

	@SuppressLint("NewApi")
    public void setonClick(View v) {
        FragmentManager fm = getFragmentManager();
        // 开启Fragment事务
        FragmentTransaction transaction = fm.beginTransaction();
        switch (v.getId()) {
        case R.id.btnweixin:
            if (mWeiXinFragment == null) {
                mWeiXinFragment = new ContentFragment();
            }
            // 使用当前Fragment的布局替代id_content的控件
            transaction.replace(R.id.id_content, mWeiXinFragment);
            break;
        case R.id.btnfriend:
            if (mFriendFragment == null) {
                mFriendFragment = new FriendFragment();
            }
            transaction.replace(R.id.id_content, mFriendFragment);
            break;
        }
        // transaction.addToBackStack();
        // 事务提交
        transaction.commit();
    }
	
	//步骤三、实现接口
	@Override
	public void process(String str) {
		// TODO Auto-generated method stub
		Log.i("EV_JNI",str+"传递给friendfragment");
		//步骤五、传递这个数据给friendfragment
		//切换到friendfragment
		FragmentManager fm = getFragmentManager();
        // 开启Fragment事务
        FragmentTransaction transaction = fm.beginTransaction();
        if (mFriendFragment == null) {
            mFriendFragment = new FriendFragment();
        }
        //传递数据
        Bundle data = new Bundle();
        data.putString("TEXT", str);
        mFriendFragment.setArguments(data);
        transaction.replace(R.id.id_content, mFriendFragment);
        // transaction.addToBackStack();
        // 事务提交
        transaction.commit();
	}
		
}

FriendFragment.java
public class FriendFragment extends Fragment {
	@Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
		View view =  inflater.inflate(R.layout.fragment_friend, container, false); 
		//步骤六，接收activity传入的数据
		Bundle data = getArguments();//获得从activity中传递过来的值
		String str=data.getString("TEXT");
		TextView txt=(TextView) view.findViewById(R.id.txt);  
		txt.setText(str);
		return view;
    }
}

例2,不传递数据,可以参考一下，主要用例1的方法做：
FragmentOne
可以看到现在的FragmentOne不和任何Activity耦合，任何Activity都可以使用；并且我们声明了一个接口，来回调其点击事件，想要管理其点击事件的Activity实现此接口就即可。可以看到我们在onClick中首先判断了当前绑定的Activity是否实现了该接口，如果实现了则调用。
public class FragmentOne extends Fragment implements OnClickListener  
{  
    private Button mBtn;  
  
    /** 
     * 设置按钮点击的回调 
     * @author zhy 
     * 
     */  
    public interface FOneBtnClickListener  
    {  
        void onFOneBtnClick();  
    }  
  
    @Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        View view = inflater.inflate(R.layout.fragment_one, container, false);  
        mBtn = (Button) view.findViewById(R.id.id_fragment_one_btn);  
        mBtn.setOnClickListener(this);  
        return view;  
    }  
  
    /** 
     * 交给宿主Activity处理，如果它希望处理 
     */  
    @Override  
    public void onClick(View v)  
    {  
        if (getActivity() instanceof FOneBtnClickListener)  
        {  
            ((FOneBtnClickListener) getActivity()).onFOneBtnClick();  
        }  
    }  
  
} 

FragmentTwo
与FragmentOne极其类似，但是我们提供了setListener这样的方法，意味着Activity不仅需要实现该接口，还必须显示调用mFTwo.setfTwoBtnClickListener(this)。
public class FragmentTwo extends Fragment implements OnClickListener  
{  
  
      
    private Button mBtn ;  
      
    private FTwoBtnClickListener fTwoBtnClickListener ;  
      
    public interface FTwoBtnClickListener  
    {  
        void onFTwoBtnClick();  
    }  
    //设置回调接口  
    public void setfTwoBtnClickListener(FTwoBtnClickListener fTwoBtnClickListener)  
    {  
        this.fTwoBtnClickListener = fTwoBtnClickListener;  
    }  
    @Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        View view = inflater.inflate(R.layout.fragment_two, container, false);  
        mBtn = (Button) view.findViewById(R.id.id_fragment_two_btn);  
        mBtn.setOnClickListener(this);  
        return view ;   
    }  
    @Override  
    public void onClick(View v)  
    {  
        if(fTwoBtnClickListener != null)  
        {  
            fTwoBtnClickListener.onFTwoBtnClick();  
        }  
    }  
  
}

最后看Activity :
import com.zhy.zhy_fragments.FragmentOne.FOneBtnClickListener;  
import com.zhy.zhy_fragments.FragmentTwo.FTwoBtnClickListener;  
  
public class MainActivity extends Activity implements FOneBtnClickListener,  
        FTwoBtnClickListener  
{  
  
    private FragmentOne mFOne;  
    private FragmentTwo mFTwo;  
    private FragmentThree mFThree;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        setContentView(R.layout.activity_main);  
  
        mFOne = new FragmentOne();  
        FragmentManager fm = getFragmentManager();  
        FragmentTransaction tx = fm.beginTransaction();  
        tx.add(R.id.id_content, mFOne, "ONE");  
        tx.commit();  
    }  
  
    /** 
     * FragmentOne 按钮点击时的回调 
     */  
    @Override  
    public void onFOneBtnClick()  
    {  
  
        if (mFTwo == null)  
        {  
            mFTwo = new FragmentTwo();  
            mFTwo.setfTwoBtnClickListener(this);  
        }  
        FragmentManager fm = getFragmentManager();  
        FragmentTransaction tx = fm.beginTransaction();  
        tx.replace(R.id.id_content, mFTwo, "TWO");  
        tx.addToBackStack(null);  
        tx.commit();  
    }  
  
    /** 
     * FragmentTwo 按钮点击时的回调 
     */  
    @Override  
    public void onFTwoBtnClick()  
    {  
        if (mFThree == null)  
        {  
            mFThree = new FragmentThree();  
  
        }  
        FragmentManager fm = getFragmentManager();  
        FragmentTransaction tx = fm.beginTransaction();  
        tx.hide(mFTwo);  
        tx.add(R.id.id_content, mFThree, "THREE");  
        // tx.replace(R.id.id_content, fThree, "THREE");  
        tx.addToBackStack(null);  
        tx.commit();  
    }  
  
} 

5.如何处理运行时配置发生变化
运行时配置发生变化，最常见的就是屏幕发生旋转，或者
当你的应用被至于后台（例如用户点击了home），长时间没有返回的时候，你的应用也会被重新启动。比如上例：如果你把上面的例子你至于FragmentThree界面，然后处于后台状态，长时间后你会发现当你再次通过home打开时，上面FragmentThree与FragmentOne叠加在一起，这就是因为你的Activity重新启动，在原来的FragmentThree上又绘制了一个FragmentOne。

只有在savedInstanceState==null时，才进行创建Fragment实例就可以了
protected void onCreate(Bundle savedInstanceState)  
{  
	super.onCreate(savedInstanceState);  
	requestWindowFeature(Window.FEATURE_NO_TITLE);  
	setContentView(R.layout.activity_main);  

	Log.e(TAG, savedInstanceState+"");  
	  
	if(savedInstanceState == null)  
	{  
		mFOne = new FragmentOne();  
		FragmentManager fm = getFragmentManager();  
		FragmentTransaction tx = fm.beginTransaction();  
		tx.add(R.id.id_content, mFOne, "ONE");  
		tx.commit();  
	}  
	  
	  

}

6.Fragmeny与ActionBar和MenuItem集成
Fragment可以添加自己的MenuItem到Activity的ActionBar或者可选菜单中。

a、在Fragment的onCreate中调用 setHasOptionsMenu(true);

b、然后在Fragment子类中实现onCreateOptionsMenu

c、如果希望在Fragment中处理MenuItem的点击，也可以实现onOptionsItemSelected；当然了Activity也可以直接处理该MenuItem的点击事件。

Fragment
public class FragmentOne extends Fragment  
{  
  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setHasOptionsMenu(true);  
    }  
  
    @Override  
    public View onCreateView(LayoutInflater inflater, ViewGroup container,  
            Bundle savedInstanceState)  
    {  
        View view = inflater.inflate(R.layout.fragment_one, container, false);  
        return view;  
    }  
  
    @Override  
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater)  
    {  
        inflater.inflate(R.menu.fragment_menu, menu);  
    }  
  
    @Override  
    public boolean onOptionsItemSelected(MenuItem item)  
    {  
        switch (item.getItemId())  
        {  
        case R.id.id_menu_fra_test:  
            Toast.makeText(getActivity(), "FragmentMenuItem1", Toast.LENGTH_SHORT).show();  
            break;  
        }  
        return true;  
    }  
  
}

Activity
public class MainActivity extends Activity  
  
{  
    private static final String TAG = "FragmentOne";  
    private FragmentOne mFOne;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        setContentView(R.layout.activity_main);  
  
        Log.e(TAG, savedInstanceState + "");  
  
        if (savedInstanceState == null)  
        {  
            mFOne = new FragmentOne();  
            FragmentManager fm = getFragmentManager();  
            FragmentTransaction tx = fm.beginTransaction();  
            tx.add(R.id.id_content, mFOne, "ONE");  
            tx.commit();  
        }  
  
    }  
  
    @Override  
    public boolean onCreateOptionsMenu(Menu menu)  
    {  
        super.onCreateOptionsMenu(menu);  
        getMenuInflater().inflate(R.menu.main, menu);  
        return true;  
    }  
  
    @Override  
    public boolean onOptionsItemSelected(MenuItem item)  
    {  
        switch (item.getItemId())  
        {  
        case R.id.action_settings:  
            Toast.makeText(this, "setting", Toast.LENGTH_SHORT).show();  
            return true;  
        default:  
            //如果希望Fragment自己处理MenuItem点击事件，一定不要忘了调用super.xxx  
            return super.onOptionsItemSelected(item);  
        }  
    }  
  
}
`
7、使用Fragment创建对话框：这是Google推荐的方式


*多线程
1.子线程更改UI的东西，是需要通过sendmessage发给主线程来处理的
2.Looper:在Activity中，如果在create的界面就创建的线程,
或者主Activity implements Runnable.程序会自动启动好Looper对象。
但是在用户自定义的类中，就需要自己手动来启动Looper,然后才能处理线程
线程在默认情况下在run()方法中的内容执行完之后就退出了。
调用Looper类的 prepare() 方法可以为当前线程准备一个消息里面要做的事，调用loop() 方法使之开始处理这个信息循环，直到循环结束。

例如：主线程发消息给子线程，然后子线程回消息给主线程
public class MainActivity extends Activity {
	Button but=null;
	TextView info=null;
	public static final int SETMAIN=1;//what标记,设置主线程
	public static final int SETCHILD=2;//what标记,设置子线程
	private Handler mainhand=null,childhand=null;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//启动用户自己定义的类
		Thread thread=new Thread(new childthread(),"child Thread");
		thread.start();
		mainhand=new Handler()
		{

			@Override
			public void handleMessage(Message msg) {
				// TODO Auto-generated method stub				
				switch (msg.what)
				{
					case SETMAIN://子线程接收主线程消息
						info.setText(msg.obj.toString());
						break;
				}				
			}
			
		};		
		info=(TextView)findViewById(R.id.info);
		but=(Button)findViewById(R.id.but);
		but.setOnClickListener(new OnClickListener() {			
			@Override
			public void onClick(View v) {
				if(childhand!=null)
				{
					// 将信息发送到子线程中
					Message childmsg=childhand.obtainMessage();
					childmsg.what=SETCHILD;
					childmsg.obj=mainhand.getLooper().getThread().getName()+"-->Hello World";
					childhand.sendMessage(childmsg);
				}
				
			}
		});
	}
	
	class childthread implements Runnable
	{
		
		@Override
		public void run() {
			Looper.prepare();//用户自己定义的类，创建线程需要自己准备loop
			childhand=new Handler()
			{

				@Override
				public void handleMessage(Message msg) {
					switch (msg.what)
					{
					case SETCHILD://子线程接收主线程消息
							Log.i("mychild",msg.obj.toString());
							Message tomain=mainhand.obtainMessage();
							tomain.what=SETMAIN;
							tomain.obj=childhand.getLooper().getThread().getName()+"-->Hello World2";
							mainhand.sendMessage(tomain);
						break;

					default:
						break;
					}
				}
				
			};
			Looper.loop();//用户自己定义的类，创建线程需要自己准备loop
		}
		
	}
	
}

例如：新建一个线程childthread，这个线程用来监听信息。然后在这个线程里新建
孙子线程gradson,把Handler邮箱发送给他，让gradson每4s钟就作一次post操作，
MainAcitivy操作，只是用来生成childthread线程
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		Thread thread=new Thread(new childthread(),"child Thread");
		thread.start();		
	}
	
childthread作pend操作
childthread线程
public class childthread implements Runnable {
	Handler childhand=null;//hand邮箱
	@Override
	public void run() {
		Looper.prepare();//准备Loop循环
		// TODO Auto-generated method stub
		Log.i("mychild","childThread Run");
		
		//实例化hand邮箱，并且进行pend
		childhand=new Handler()
		{

			@Override
			public void handleMessage(Message msg) {
				// TODO Auto-generated method stub
				switch (msg.what)
				{
					case 1://子线程接收主线程消息
						Log.i("mychild",msg.obj.toString());
						break;
				}	
			}
			
		};
		//创建gradson线程，把实例化之后的hand邮箱发给他，启动线程
		Thread thread=new Thread(new gradson(childhand),"gradson");
		thread.start();
		Looper.loop();//运行Loop循环
	}

}

gradson线程
public class gradson extends Thread {

	Handler hand;
	//构造函数，得到hand邮箱
	public gradson(Handler hand) {		
		// TODO Auto-generated constructor stub
		this.hand=hand;
	}

	@Override
	public void run() {
		int i=1;
		// TODO Auto-generated method stub
		Looper.prepare();//准备Loop循环
		//每隔4s，作一下post邮箱
		while(i>0)
		{
			//Log.i("mychild","gradson Run");
			//将信息封装，以下两条都可以用
			//Message childmsg=  Message.obtain(); 
			Message childmsg=  hand.obtainMessage(); 
			childmsg.what=1;
			childmsg.obj="-->Hello childthread";
			
			//作post操作
			hand.sendMessage(childmsg);
			try {
				Thread.sleep(4000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		Looper.loop();//运行Loop循环
	}
	
}


例如：新建一个类childclass，这个类用来监听信息。然后在这个类里新建
孙子线程gradson,把Handler邮箱发送给他，让gradson每4s钟就作一次post操作，
在Activity里就可以调用这个类，作线程的操作
MainAcitivy操作，只是用来生成实例化childclass类，并且通过操作类来操作
gradson线程
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		but=(Button)findViewById(R.id.but);
		but.setOnClickListener(new OnClickListener() {			
			@Override
			public void onClick(View v) {
				childclass cls=new childclass();
				cls.startcom();//操作类，来间接操作线程
			}
		});	
	}
	
childclass作pend操作
childclass类
public class childclass 
{
	Handler childhand=new Handler()
	{
		@Override
		public void handleMessage(Message msg) {
			// TODO Auto-generated method stub
			switch (msg.what)
			{
				case 1://子线程接收主线程消息
					Log.i("mychild",msg.obj.toString());
					break;
			}	
		}
		
	};
	public childclass() {
		Log.i("mychild","childclass create");
	}
	public void startcom()
	{
		//把Handle传给gradson线程，并且启动gradson线程
		Thread thread=new Thread(new gradson(childhand),"gradson");
		thread.start();
	}
	
}

gradson线程与上面的例子一样
public class gradson extends Thread {

	Handler hand;
	//构造函数，得到hand邮箱
	public gradson(Handler hand) {		
		// TODO Auto-generated constructor stub
		this.hand=hand;
	}

	@Override
	public void run() {
		int i=1;
		// TODO Auto-generated method stub
		Looper.prepare();//准备Loop循环
		//每隔4s，作一下post邮箱
		while(i>0)
		{
			//Log.i("mychild","gradson Run");
			//将信息封装，以下两条都可以用
			//Message childmsg=  Message.obtain(); 
			Message childmsg=  hand.obtainMessage(); 
			childmsg.what=1;
			childmsg.obj="-->Hello childthread";
			
			//作post操作
			hand.sendMessage(childmsg);
			try {
				Thread.sleep(4000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		Looper.loop();//运行Loop循环
	}
	
}

3.异步处理AsyncTask:Handler的线程之间的处理是阻塞的，但是异步处理是非阻塞的
而且他整合了handler,和message的东西，操作很简单
AsyncTask的基本用法
首先来看一下AsyncTask的基本用法，由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：
1. Params
在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。
2. Progress
后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。
3. Result
当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。
因此，一个最简单的自定义AsyncTask就可以写成如下方式：
[java] view plain copy
class DownloadTask extends AsyncTask<Void, Integer, Boolean> {  
    ……  
}  
这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。
当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个：
1. onPreExecute()
这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。
2. doInBackground(Params...)
这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress...)方法来完成。
3. onProgressUpdate(Progress...)
当在后台任务中调用了publishProgress(Progress...)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。
4. onPostExecute(Result)
当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。
因此，一个比较完整的自定义AsyncTask就可以写成如下方式：
[java] view plain copy
class DownloadTask extends AsyncTask<Void, Integer, Boolean> {  
  
    @Override  
    protected void onPreExecute() {  
        progressDialog.show();  
    }  
  
    @Override  
    protected Boolean doInBackground(Void... params) {  
        try {  
            while (true) {  
                int downloadPercent = doDownload();  
                publishProgress(downloadPercent);  
                if (downloadPercent >= 100) {  
                    break;  
                }  
            }  
        } catch (Exception e) {  
            return false;  
        }  
        return true;  
    }  
  
    @Override  
    protected void onProgressUpdate(Integer... values) {  
        progressDialog.setMessage("当前下载进度：" + values[0] + "%");  
    }  
  
    @Override  
    protected void onPostExecute(Boolean result) {  
        progressDialog.dismiss();  
        if (result) {  
            Toast.makeText(context, "下载成功", Toast.LENGTH_SHORT).show();  
        } else {  
            Toast.makeText(context, "下载失败", Toast.LENGTH_SHORT).show();  
        }  
    }  
}  
这里我们模拟了一个下载任务，在doInBackground()方法中去执行具体的下载逻辑，在onProgressUpdate()方法中显示当前的下载进度，在onPostExecute()方法中来提示任务的执行结果。如果想要启动这个任务，只需要简单地调用以下代码即可：
[java] view plain copy
new DownloadTask().execute();  
以上就是AsyncTask的基本用法，怎么样，是不是感觉在子线程和UI线程之间进行切换变得灵活了很多？我们并不需求去考虑什么异步消息处理机制，也不需要专门使用一个Handler来发送和接收消息，只需要调用一下publishProgress()方法就可以轻松地从子线程切换到UI线程了。


例如：文本和进度条显示执行进度
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		bar=(ProgressBar)findViewById(R.id.bar);
		info=(TextView)findViewById(R.id.info);
		childupdate child=new childupdate();
		child.execute(100);//休眠100ms
	}
//子类处理后台进度的类型是int,更新之后的数值是int,最后结果返回string 
private class childupdate extends AsyncTask<Integer, Integer, String>
{

	@Override
	//每次的进度处理，这里可以直接控制控件
	protected String doInBackground(Integer... params) {
		for(int i=0;i<100;i++)
		{
			MainActivity.this.bar.setProgress(i);//设置进度
			this.publishProgress(i);//更新，调用更新操作，onProgressUpdate进行处理
			try {
				Thread.sleep(params[0]);//延迟的时间由外部决定
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return "执行完毕";
	}

	@Override
	//执行完毕之后的操作
	protected void onPostExecute(String result) {
		MainActivity.this.info.setText(result);
	}

	@Override
	protected void onProgressUpdate(Integer... values) {
		MainActivity.this.info.setText("进度完成:"+String.valueOf(values[0]));
	}
	
}

例2：显示本机文件夹的列表，他是个耗时的过程，所以要用非阻塞
public class MainActivity extends Activity {
	private List<Map<String, Object>> allfile=new ArrayList<Map<String,Object>>();
	private SimpleAdapter simple=null;
	private ListView filelist=null;
	private listfilethread ft=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		filelist=(ListView) findViewById(R.id.list);
		filelist.setOnItemClickListener(new onItem());
		//从根目录下开始列出
		File filepathFile=new File(java.io.File.separator);	
		ft=new listfilethread();
		ft.execute(filepathFile);
	}

	private class onItem implements OnItemClickListener
	{

		@Override
		public void onItemClick(AdapterView<?> parent, View view, int position,
				long id) {
			// 单击点开目录
			File currFile=(File)MainActivity.this.allfile.get(position).get("name");
			if(currFile.isDirectory())//是目录
			{
				MainActivity.this.allfile=new ArrayList<Map<String,Object>>();
				MainActivity.this.ft=new listfilethread();
				MainActivity.this.ft.execute(currFile);
			}
			
		}
		
	}
	
	private class listfilethread extends AsyncTask<File, File, String>
	{

		@Override
		protected String doInBackground(File... params) {
			// 如果不是根目录
			if(!params[0].getPath().equals(java.io.File.separator))
			{
				//表示可以返回
				Map<String, Object> fileItemMap=new HashMap<String, Object>();
				fileItemMap.put("img", R.drawable.foldopen);//可以返回
				fileItemMap.put("name", params[0].getParentFile());
				MainActivity.this.allfile.add(fileItemMap);
			}
			//如果是文件夹
			if(params[0].isDirectory())
			{
				File tempFile[]=params[0].listFiles();
				if(tempFile!=null)
				{
					for(int x=0;x<tempFile.length;x++)
					{
						this.publishProgress(tempFile[x]);
					}
				}
			}
			return "finish";
		}

		@Override
		protected void onProgressUpdate(File... values) {
			Map<String, Object> fileItem=new HashMap<String, Object>();
			if(values[0].isDirectory())//是目录
			{
				fileItem.put("img", R.drawable.foldclose);
			}
			else //是文件
			{
				fileItem.put("img", R.drawable.file);
				
			}
			fileItem.put("name", values[0]);
			MainActivity.this.allfile.add(fileItem);
			MainActivity.this.simple=new SimpleAdapter
			(
					MainActivity.this, 
					MainActivity.this.allfile, 
					R.layout.list, new String[]{"img","name"}, 
					new int[]{R.id.img,R.id.name}
			);
			MainActivity.this.filelist.setAdapter(MainActivity.this.simple);
		}
		
	}
}



4.线程池
1)四种线程
(1)
根据需要创建新线程的线程池，有几个线程进来就创建几个缓存，直到系统溢出也不会报警。
当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
final ExecutorService pool = Executors.newCachedThreadPool();
(2)
创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。普遍用于服务器
线程并发操作
final ExecutorService pool = Executors.newFixedThreadPool(2);
(3)
newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。
延迟执行示例代码如下：
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
scheduledThreadPool.schedule(new Runnable() {
 
	@Override
	public void run() {
		System.out.println("delay 3 seconds");
	}
}, 3, TimeUnit.SECONDS);

定期执行示例代码如下：
scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
 
	@Override
	public void run() {
		System.out.println("delay 1 seconds, and excute every 3 seconds");
	}
}, 1, 3, TimeUnit.SECONDS);

(4)创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
final ExecutorService pool = Executors.newSingleThreadExecutor();

2)线程池的执行
thread1=new Thread(child,"child Thread");
		 thread2=new Thread(new childthread2(),"child Thread");
		 thread3=new Thread(new childthread3(),"child Thread");
		 thread4=new Thread(new childthread4(),"child Thread");
		pool.execute(thread1);
		pool.execute(thread2);
		pool.execute(thread3);
		pool.execute(thread4);

销毁
pool.shutdown();关闭，即当前线程执行完毕之后就不再接收新的线程了
pool.shutdownNow();	立即关闭，但是不一定能关闭的掉

例如：
普通线程
      for (int i = 0; i < 10; i++) 
      { 
	      	final int index = i;
	      	try 
	      	{
	      		Thread.sleep(index * 1000);
	      	} catch (InterruptedException e) {
	      		e.printStackTrace();
	      	} 
        
	      	new Thread(new Runnable() {
	       	 
	       	@Override
	       	public void run() {
	       		// TODO Auto-generated method stub
	       		Log.v("log",index+">>hellothread="+Thread.currentThread().getId());
	       	}
	       }).start();
      }

01-18 04:00:53.270: V/log(27107): 0>>hellothread=291
01-18 04:00:54.280: V/log(27107): 1>>hellothread=292
01-18 04:00:56.280: V/log(27107): 2>>hellothread=293
01-18 04:00:59.280: V/log(27107): 3>>hellothread=294
01-18 04:01:03.280: V/log(27107): 4>>hellothread=295
01-18 04:01:08.280: V/log(27107): 5>>hellothread=296
01-18 04:01:14.280: V/log(27107): 6>>hellothread=297
01-18 04:01:21.280: V/log(27107): 7>>hellothread=298
01-18 04:01:29.290: V/log(27107): 8>>hellothread=299
01-18 04:01:38.290: V/log(27107): 9>>hellothread=300

newCachedThreadPool：
线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        for (int i = 0; i < 10; i++) 
        { 
  	      	final int index = i;
  	      	try 
  	      	{
  	      		Thread.sleep(index * 1000);
  	      	} catch (InterruptedException e) {
  	      		e.printStackTrace();
  	      	} 
          
  	      cachedThreadPool.execute(new Runnable() {
  	         
  	        		@Override
  	        		public void run() {
  	        			Log.v("log",index+">>hellothread="+Thread.currentThread().getId());
  	        		}
  	        	});
        }

01-18 04:06:48.990: V/log(27250): 0>>hellothread=294
01-18 04:06:50.000: V/log(27250): 1>>hellothread=294
01-18 04:06:52.000: V/log(27250): 2>>hellothread=294
01-18 04:06:55.000: V/log(27250): 3>>hellothread=294
01-18 04:06:59.000: V/log(27250): 4>>hellothread=294
01-18 04:07:04.000: V/log(27250): 5>>hellothread=294
01-18 04:07:10.000: V/log(27250): 6>>hellothread=294
01-18 04:07:17.000: V/log(27250): 7>>hellothread=294
01-18 04:07:25.000: V/log(27250): 8>>hellothread=294
01-18 04:07:34.000: V/log(27250): 9>>hellothread=294


newFixedThreadPool：
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 10; i++) 
        { 
  	      	final int index = i;
  	      	try 
  	      	{
  	      		Thread.sleep(index * 1000);
  	      	} catch (InterruptedException e) {
  	      		e.printStackTrace();
  	      	} 
          
  	      fixedThreadPool.execute(new Runnable() {
  	         
  	        		@Override
  	        		public void run() {
  	        			Log.v("log",index+">>hellothread="+Thread.currentThread().getId());
  	        		}
  	        	});
        }

01-18 04:14:25.510: V/log(27414): 0>>hellothread=297
01-18 04:14:26.510: V/log(27414): 1>>hellothread=298
01-18 04:14:28.510: V/log(27414): 2>>hellothread=299
01-18 04:14:31.510: V/log(27414): 3>>hellothread=297
01-18 04:14:35.510: V/log(27414): 4>>hellothread=298
01-18 04:14:40.510: V/log(27414): 5>>hellothread=299
01-18 04:14:46.510: V/log(27414): 6>>hellothread=297
01-18 04:14:53.510: V/log(27414): 7>>hellothread=298
01-18 04:15:01.510: V/log(27414): 8>>hellothread=299
01-18 04:15:10.520: V/log(27414): 9>>hellothread=297


newScheduledThreadPool
创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：
Java

1
2
3
4
5
6
7
8
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
scheduledThreadPool.schedule(new Runnable() {
 
	@Override
	public void run() {
		System.out.println("delay 3 seconds");
	}
}, 3, TimeUnit.SECONDS);
表示延迟3秒执行。
 
定期执行示例代码如下：
Java

1
2
3
4
5
6
7
scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
 
	@Override
	public void run() {
		System.out.println("delay 1 seconds, and excute every 3 seconds");
	}
}, 1, 3, TimeUnit.SECONDS);
表示延迟1秒后每3秒执行一次。

 long initialDelay1 = 1;
        long period1 = 1;
        // 从现在开始1秒钟之后，每隔1秒钟执行一次job1
        service.scheduleAtFixedRate(
                new ScheduledExecutorTest("job1"), initialDelay1,
                period1, TimeUnit.SECONDS);

        long initialDelay2 = 1;
        long delay2 = 1;
        // 从现在开始2秒钟之后，每隔2秒钟执行一次job2
        service.scheduleWithFixedDelay(
                new ScheduledExecutorTest("job2"), initialDelay2,
                delay2, TimeUnit.SECONDS);
上面代码展示了 ScheduledExecutorService 中两种最常用的调度方法 scheduleAtFixedRate 和 scheduleWithFixedDelay。scheduleAtFixedRate 每次执行时间为上一次任务开始起向后推一个时间间隔，即每次执行时间为 :initialDelay, initialDelay+period, initialDelay+2*period, …；
scheduleWithFixedDelay 每次执行时间为上一次任务结束起向后推一个时间间隔，即每次执行时间为：initialDelay, initialDelay+executeTime+delay, initialDelay+2*executeTime+2*delay。由此可见，ScheduleAtFixedRate 是基于固定时间间隔进行任务调度，ScheduleWithFixedDelay 取决于每次任务执行的时间长短，是基于不固定时间间隔进行任务调度。
  				
ScheduledExecutorService比Timer更安全，功能更强大，后面会有一篇单独进行对比。


newSingleThreadExecutor：
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) 
        { 
  	      	final int index = i;
  	      	try 
  	      	{
  	      		Thread.sleep(index * 1000);
  	      	} catch (InterruptedException e) {
  	      		e.printStackTrace();
  	      	} 
          
  	      singleThreadExecutor.execute(new Runnable() {
  	         
  	        		@Override
  	        		public void run() {
  	        			Log.v("log",index+">>hellothread="+Thread.currentThread().getId());
  	        		}
  	        	});
        }
    }

01-18 04:22:23.060: V/log(27780): 0>>hellothread=309
01-18 04:22:24.060: V/log(27780): 1>>hellothread=309
01-18 04:22:26.060: V/log(27780): 2>>hellothread=309
01-18 04:22:29.060: V/log(27780): 3>>hellothread=309
01-18 04:22:33.060: V/log(27780): 4>>hellothread=309
01-18 04:22:38.060: V/log(27780): 5>>hellothread=309
01-18 04:22:44.060: V/log(27780): 6>>hellothread=309
01-18 04:22:51.060: V/log(27780): 7>>hellothread=309
01-18 04:22:59.060: V/log(27780): 8>>hellothread=309
01-18 04:23:08.060: V/log(27780): 9>>hellothread=309
	
	
 
*数据存储
1.SharedPreferences:类似属性文件Properties,作为资源文件保存配置信息
1)新建SharedPreferences工程，进行数据的保存操作
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		super.setContentView(R.layout.activity_main);
		//文件是私有的
		SharedPreferences share = super.getSharedPreferences(FILENAME, Activity.MODE_PRIVATE);
		//需要接口进行编辑
		SharedPreferences.Editor edit=share.edit();
		//设置字符串
		edit.putString("author", "guozz");
		edit.putInt("age", 30);
		edit.commit();//提交更新
	}
默认情况下，配置文件保存在编译器可以看见:window->show view->other->android/
file explorer:手机上的文件
找到data/data/com.example.sharedprj(本包名)/shared_prefs/mldn.xml(程序上保存的
文件名)
里面是一个xml文件，里面的内容是以map类集的格式保存的

2）读取保存的配置文件：
this.author = (TextView) super.findViewById(R.id.author);
		this.age = (TextView) super.findViewById(R.id.age);
		
//文件是私有的
SharedPreferences share = super.getSharedPreferences(FILENAME, Activity.MODE_PRIVATE);
//读取
this.author.setText("作者:"+share.getString("author", "默认值"));
this.age.setText("作者:"+share.getInt("age", 0));

2.复杂的数据存储：需要文件存储
1)简单读写
(1)写文件
private static final String FILENAME="hello.txt";
FileOutputStream output = null;
try 
{
	//打开文件
	output = super.openFileOutput(FILENAME,Activity.MODE_PRIVATE);
} 
catch (FileNotFoundException e)
{
	// TODO Auto-generated catch block
	e.printStackTrace();
}
//输出信息
PrintStream out = new PrintStream(output);
out.println("hello world");
out.println("hi welcome");
out.close();
找到data/data/com.example.sharedprj(本包名)/files/hello.txt(程序上保存的
文件名)

(2)读文件
String str=null;
FileInputStream input = null;
try 
{
	//打开文件
	input = super.openFileInput(FILENAME);
} 
catch (FileNotFoundException e)
{
	// TODO Auto-generated catch block
	e.printStackTrace();
}
//输出信息
Scanner scan=new Scanner(input);
while(scan.hasNext())
{
	str+=scan.next()+"\n";
}

2)sdcard读写
(1)写文件
private static final String FILENAME="hello.txt";
@Override
protected void onCreate(Bundle savedInstanceState) 
{
	super.onCreate(savedInstanceState);
	super.setContentView(R.layout.activity_main);
	
	//如果sd卡存在，他的路径就是/mnt/sdcard/
	if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
	{
		File file=new File(Environment.getExternalStorageDirectory()+File.separator+FILENAME);
		if(!file.getParentFile().exists())//不存在文件路径
		{
			file.getParentFile().mkdirs();//创建父文件夹路径
		}
		PrintStream out=null;
		try 
		{
			out = new PrintStream(new FileOutputStream(file));
		} 
		catch (FileNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		out.println("hello world");
		out.println("hi welcome");
		out.close();
	}		
}
	
添加权限：
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>

(2)读文件
String str=null;
if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
{
	File file=new File(Environment.getExternalStorageDirectory()+File.separator+FILENAME);
	if(!file.getParentFile().exists())//不存在文件路径
	{
		file.getParentFile().mkdirs();//创建父文件夹路径
	}
	Scanner scan = null;
	scan=new Scanner(FileInputStream(file));
	while(scan.hasNext())
	{
		str+=scan.next()+"\n";
	}
}	

3.资源文件的读写：通过R.java生成的
一个文件保存到工程的res/raw/book.txt中，book.txt文件要以utf-8编码保存
Resources resources=super.getResources();//资源操作类
InputStream input=resources.openRawResource(R.raw.book);
Scanner scan=new Scanner(input);
StringBuffer buffer=new StringBuffer();
while(scan.hasNext())
{
	buffer.append(scan.next()).append("\n");
}
scan.close();
input.close();

4.DOM解析XML文件：将页面布局内容xml文件保存起来，与web上DOM解析XML文件一样
实际没有用这种方法
添加权限：
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>

<TableLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity" >

    <TableRow >
	    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="姓名:" />
	    <EditText
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/name" />
	</TableRow> 	
    <TableRow >
	    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="email:" />
	    <EditText
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/email" />
	</TableRow> 
	<TableRow >
	    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="提交" 
        android:id="@+id/btn" />	    
	</TableRow> 

</TableLayout>

输出：
public void onClick(View v)
{
	Toast.makeText(MainActivity.this, "Toast信息提示框", Toast.LENGTH_LONG).show();
	// TODO Auto-generated method stub
	//如果sd卡存在，他的路径就是/mnt/sdcard/,不存在，则返回
	if(!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
	{
		return;
	}
	File file=new File(Environment.getExternalStorageDirectory()+File.separator+"guozz"
			+File.separator+"member.xml");
	if(!file.getParentFile().exists())//不存在文件路径
	{
		file.getParentFile().mkdirs();//创建父文件夹路径
	}
	
	//生成xml文件
	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	DocumentBuilder builder=null;
	try 
	{
		builder = factory.newDocumentBuilder();
	} catch (ParserConfigurationException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	Document doc=builder.newDocument();//创建一个新的xml文档
	  //创建所有节点
	  Element  addresslist=doc.createElement("addresslist");
	  Element  linkman=doc.createElement("linkman");
	  Element  name=doc.createElement("name");
	  Element  email=doc.createElement("email");
	  //设置节点内容
	  name.appendChild(doc.createTextNode(MainActivity.this.name.getText().toString()));
	  email.appendChild(doc.createTextNode(MainActivity.this.email.getText().toString()));
	  //设置各个节点关系
	  linkman.appendChild(name);
	  linkman.appendChild(email);
	  addresslist.appendChild(linkman);
	  doc.appendChild(addresslist);
	  //保存到文件中
	  TransformerFactory tf= TransformerFactory.newInstance();
	  Transformer t=null;
	  try
	  {
			t = tf.newTransformer();
	  }
	  catch (TransformerConfigurationException e1) 
	  {
			// TODO Auto-generated catch block
			e1.printStackTrace();
	  }
	  //设置属性
	  t.setOutputProperty(OutputKeys.ENCODING,"GBK");
	  DOMSource source=new DOMSource(doc);//准备输出文档
	  StreamResult result=new StreamResult(file);
	  try 
	  {
		t.transform(source,result);
	  }
	  catch (TransformerException e) 
	  {
		// TODO Auto-generated catch block
		e.printStackTrace();
	  }
}

结果是：
<?xml version="1.0" encoding="GBK"?>
<addresslist>
    <linkman>
	    <name>你好</name>
        <email>hello@163.com</email>		
	</linkman>
    <linkman>
	    <name>好啊</name>
        <email>haode@163.com</email>		
	</linkman>
</addresslist>

读取：
Document doc=builder.newDocument();//创建一个新的xml文档
		    
//找到name元素节点下的所有子节点
NodeList nl = doc.getElementsByTagName("linkman");
for(int i=0;i<nl.getLength();i++)
{
	 Element e=(Element) nl.item(i);//取出每一个元素
	 //找到name元素节点下的所有子节点
	 MainActivity.this.name.setText(e.getElementsByTagName("name").item(0).getFirstChild().getNodeValue());
	 MainActivity.this.email.setText("email="+e.getElementsByTagName("email").item(0).getFirstChild().getNodeValue());
}

5.SAX解析XML文件：将页面布局内容xml文件保存起来,目前也不常用
添加权限：
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>

package com.example.filestream;
//每一个linkman类的对象，都表示每一条linkman节点的内容
public class linkman {
	private String name;
	private String email;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	
}



package com.example.filestream;

import java.util.ArrayList;
import java.util.List;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import android.widget.ListView;

public class saxdel extends DefaultHandler {
	private List<linkman> all=null;//保存多条linkman数据
	private linkman man=null;
	private String element=null;//保存节点的名称
	
	@Override
	//实际解析的地方
	public void characters(char[] ch, int start, int length)
			throws SAXException {
		if(this.element!=null)
		{
			String data=new String(ch,start,length);//取得文本数据
			if("name".equals(this.element))
			{
				this.man.setName(data);
			}
			else if("email".equals(this.element))
			{
				this.man.setEmail(data);
			}
		}		
	}

	@Override	
	public void endDocument() throws SAXException {
		
	}

	@Override
	//linkman节点结束
	public void endElement(String uri, String localName, String qName)
			throws SAXException {
		if("linkman".equals(localName))
		{
			this.all.add(this.man);
			this.man=null;//保存下次数据
		}
		
	}

	@Override
	public void startDocument() throws SAXException {
		this.all = new ArrayList<linkman>();//设置集合，表示要开始解析文档
	}

	@Override
	//linkman节点开始
	public void startElement(String uri, String localName, String qName,
			Attributes attributes) throws SAXException {
		if("linkman".equals(localName))
		{
			this.man = new linkman();//取得对象
		}
		this.element = localName;//保存节点名称
	}

	public List<linkman> getAll() {
		return all;
	}

}


//sax解析xml文件
//建立SAX解析工厂
SAXParserFactory factory = SAXParserFactory.newInstance();
SAXParser parser=null;
saxdel   sax=new saxdel();
try 
{
	parser = factory.newSAXParser();
} 
catch (ParserConfigurationException e1)
{
	// TODO Auto-generated catch block
	e1.printStackTrace();
} 
catch (SAXException e1) 
{
	// TODO Auto-generated catch block
	e1.printStackTrace();
}

try 
{
	parser.parse(file,sax);
}
catch (SAXException e)
{
	// TODO Auto-generated catch block
	e.printStackTrace();
} 
catch (IOException e) 
{
	// TODO Auto-generated catch block
	e.printStackTrace();
}
List<linkman> all=sax.getAll();
MainActivity.this.name.setText(all.get(0).getName());
MainActivity.this.email.setText(all.get(0).getEmail());


6.xml_pull解析：类似JDOM,DOM4J,推荐使用
1)发送和接收明文数据
其中发送的xml数据为：
<?xml version = “1.0” ?> 
<SSOMessage version=”1.0”>
<SSOParas>
<SeqID>SeqID</SeqID> 
<CommandID>CommandID</CommandID> 
<MSISDN>ABSCDSDF</MSISDN>
<ChargeMSISDN>ChargeMSISDN</ChargeMSISDN>
<SPID>SPID</SPID>
<Code> Code </ Code >
< IDtype > IDtype 0</ IDtype >
<ID> ID 0</ID>
</SSOParas>
</SSOMessage>

返回的xml数据为：
<?xml version = “1.0” ?> 
<SSOMessage version=”1.0”> 
<SSOParas> 
<SeqID>SeqID</SeqID> 
<ResultCode>ResultCode0</ResultCode>
</SSOParas>
</SSOMessage>

class httpThread implements Runnable {

    /* (non-Javadoc)
     * @see java.lang.Runnable#run()
     */
    @Override
    public void run() {
        // TODO Auto-generated method stub
        //组建xml数据
        StringBuilder xml = new StringBuilder();
        xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        xml.append("<SSOMessage version=\"1.0\">");
        xml.append("<SSOParas>");
        xml.append("<SeqID>13333333333</SeqID>");
        xml.append("<CommandID>1</CommandID>");
        xml.append("<MSISDN>1333333333</MSISDN>");
        xml.append("<ChargeMSISDN>1333333333</ChargeMSISDN>");
        xml.append("<SPID>3510127</SPID>");
        xml.append("<Code></Code>");
        xml.append("<IDtype>0</IDtype>");
        xml.append("<ID>135000000000000216559</ID>");
        xml.append("</SSOParas>");
        xml.append("</SSOMessage>");

        try {
            byte[] xmlbyte = xml.toString().getBytes("UTF-8");
            
            System.out.println(xml);

            URL url = new URL("http://118.85.194.28:8080/sotpms_server/GetSSOMessage");
            
            
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setConnectTimeout(5000);
            conn.setDoOutput(true);// 允许输出
            conn.setDoInput(true);
            conn.setUseCaches(false);// 不使用缓存
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Connection", "Keep-Alive");// 维持长连接
            conn.setRequestProperty("Charset", "UTF-8");
            conn.setRequestProperty("Content-Length",
                    String.valueOf(xmlbyte.length));
            conn.setRequestProperty("Content-Type", "text/xml; charset=UTF-8");
            conn.setRequestProperty("X-ClientType", "2");//发送自定义的头信息

            conn.getOutputStream().write(xmlbyte);
            conn.getOutputStream().flush();
            conn.getOutputStream().close();


            if (conn.getResponseCode() != 200)
                throw new RuntimeException("请求url失败");

            InputStream is = conn.getInputStream();// 获取返回数据
              

            // 使用输出流来输出字符(可选)
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            byte[] buf = new byte[1024];
            int len;
            while ((len = is.read(buf)) != -1) {
                out.write(buf, 0, len);
            }
            String string = out.toString("UTF-8");
            System.out.println(string);
            out.close();
                 
                     
            // xml解析
            String version = null;
            String seqID = null;
            XmlPullParser parser = Xml.newPullParser();
            try {
                parser.setInput(new ByteArrayInputStream(string.substring(1)
                        .getBytes("UTF-8")), "UTF-8");
                 parser.setInput(is, "UTF-8");
                int eventType = parser.getEventType();
                while (eventType != XmlPullParser.END_DOCUMENT)
				{
                    if (eventType == XmlPullParser.START_TAG) 
					{
                        if ("SSOMessage".equals(parser.getName())) 
						{
                            version = parser.getAttributeValue(0);
                        } 
						else if ("SeqID".equals(parser.getName())) 
						{
                            seqID = parser.nextText();
                        } 
						else if ("ResultCode".equals(parser.getName())) 
						{
                            resultCode = parser.nextText();
                        }
                    }
                    eventType = parser.next();
                }
            } catch (XmlPullParserException e) {
                e.printStackTrace();
                System.out.println(e);
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println(e);
            }
            System.out.println("version = " + version);
            System.out.println("seqID = " + seqID);
            System.out.println("resultCode = " + resultCode);*/

        } catch (Exception e) {
            // TODO Auto-generated catch block
            System.out.println(e);
        }
    }

2)但是实际使用时，发现以上的方法接收的流不能解析xml,后来换成这样子
解析函数
public static Map<String, String> PendWeiBuy(InputStream is)
{
	Map<String, String>list=new HashMap<String, String>();
	
	XmlPullParser parser = Xml.newPullParser();
	try {
		//parser.setInput(new ByteArrayInputStream(string.substring(1)
		//        .getBytes("UTF-8")), "UTF-8");
		parser.setInput(is, "UTF-8");
		int eventType = parser.getEventType();
		while (eventType != XmlPullParser.END_DOCUMENT)
		{
			if (eventType == XmlPullParser.START_TAG) 
			{
				if ("return_code".equals(parser.getName())) 
				{
					list.put("return_code", parser.nextText());
				} 
				else if ("return_msg".equals(parser.getName())) 
				{
					list.put("return_msg", parser.nextText());
				} 
				else if ("result_code".equals(parser.getName())) 
				{
					list.put("result_code", parser.nextText());
				}
				else if ("err_code".equals(parser.getName())) 
				{
					list.put("err_code", parser.nextText());
				}
				else if ("err_code_des".equals(parser.getName())) 
				{
					list.put("err_code_des", parser.nextText());
				}
				else if ("prepay_id".equals(parser.getName())) 
				{
					list.put("prepay_id", parser.nextText());
				}
				else if ("code_url".equals(parser.getName())) 
				{
					list.put("code_url", parser.nextText());
				}					
			}
			eventType = parser.next();
		}
	} catch (XmlPullParserException e) {
		e.printStackTrace();
		System.out.println(e);
	} catch (IOException e) {
		e.printStackTrace();
		System.out.println(e);
	}
	return list;
}

实际使用：
//4.发送信息
try {
	byte[] xmlbyte = xml.toString().getBytes("UTF-8");
	
	//Log.i("EV_JNI","Send5="+xml);

	URL url = new URL("https://api.mch.weixin.qq.com/pay/unifiedorder");
	
	
	HttpURLConnection conn = (HttpURLConnection) url.openConnection();
	conn.setConnectTimeout(5000);
	conn.setDoOutput(true);// 允许输出
	conn.setDoInput(true);
	conn.setUseCaches(false);// 不使用缓存
	conn.setRequestMethod("POST");
	conn.setRequestProperty("Connection", "Keep-Alive");// 维持长连接
	conn.setRequestProperty("Charset", "UTF-8");
	conn.setRequestProperty("Content-Length",
			String.valueOf(xmlbyte.length));
	conn.setRequestProperty("Content-Type", "text/xml; charset=UTF-8");
	conn.setRequestProperty("X-ClientType", "2");//发送自定义的头信息

	conn.getOutputStream().write(xmlbyte);
	conn.getOutputStream().flush();
	conn.getOutputStream().close();


	if (conn.getResponseCode() != 200)
		throw new RuntimeException("请求url失败");

	InputStream in = conn.getInputStream();// 获取返回数据
	  
	BufferedReader bufferedReader = new BufferedReader(  
			new InputStreamReader(in));  
	StringBuffer temp = new StringBuffer();  
	String line = bufferedReader.readLine();  
	while (line != null) {  
		temp.append(line).append("\r\n");  
		line = bufferedReader.readLine();  
	}  
	bufferedReader.close(); 
	String content = new String(temp.toString().getBytes(), "UTF-8"); 				            

	Log.i("EV_JNI","rec1="+content);
	//5.解包返回的信息
	InputStream is = new ByteArrayInputStream(content.getBytes());// 获取返回数据
	//XML解析   
   Map<String, String> map2=WeiConfigAPI.PendWeiBuy(is);
   Log.i("EV_JNI","rec2="+map2.toString());

} catch (Exception e) {
	// TODO Auto-generated catch block
	System.out.println(e);
} 	

2)如果节点有几个重复的element,这样写
假设要要解析person.xml文档，有两个重复的person节点

<?xml version="1.0" encoding="UTF-8"?>
<persons>
  <person id="1">
    <name>zhangsan</name>
    <age>21</age>
  </person>
  <person id="2">
    <name>lisi</name>
    <age>22</age>
  </person>
  <person id="3">
    <name>wangwu</name>
    <age>222</age>
  </person>
</persons>

public class PulPersonService {

public List<Person> getPersons(InputStream instream) throws Exception
{
	List<Person> persons = null;
	Person person = null;
	XmlPullParser parser = Xml.newPullParser();//得到Pull解析器
	parser.setInput(instream, "UTF-8");//设置下输入流的编码
	int eventType = parser.getEventType();//得到第一个事件类型
	while (eventType != XmlPullParser.END_DOCUMENT) 
	{
	   //如果事件类型不是文档结束的话则不断处理事件
	   switch (eventType) 
	   {
		   case (XmlPullParser.START_DOCUMENT)://如果是文档开始事件
				persons = new ArrayList<Person>();创建一个person集合
				break;
		   case (XmlPullParser.START_TAG)://如果遇到标签开始

				String tagName = parser.getName();// 获得解析器当前元素的名称
				if ("person".equals(tagName)) 
				{
					//如果当前标签名称是<person>
					 person = new Person();//创建一个person
					 person.setId(new Integer(parser.getAttributeValue(0)));//将元素的属性值赋值给id
				}
				if (person != null) 
				{
					//如果person已经创建完成
					 if ("name".equals(tagName))//如果当前节点标记是name
						person.setName(new String(parser.nextText()));
					 else if ("age".equals(tagName))//如果当前元素节点标记是age
						person.setAge(new Short(parser.nextText()));
				}
		   break;
		   case (XmlPullParser.END_TAG)://如果遇到标签结束				
				if ("person".equals(parser.getName())) 
				{
					 //如果是person标签结束
					 persons.add(person);//将创建完成的person加入集合
					 person = null;//并且置空
				}				 
			break;
	   }
	   eventType=parser.next();//进入下一个事件处理
	}
	return persons;
 }

7.JSON解析
JSON是一个"key/value"的集合，
他简单格式是
{
	"key1":"value1",
	"key2":"value2"
}
value值如果是一个数组的情况下
{
	"students":
	[
		{"key1":"value1","key2":"value2"},
		{"key3":"value3","key4":"value4"}
	]
}

添加权限
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>


0.1)如果不需要解包整个json,只是提出里面的键值来用既可以了，只要简单的这样
做就行了
判断是否存在这个键值
先用jsonObject.has(key)判断，有再去取值

获取键值：
try {
	String text = msg.obj.toString();
	JSONObject jsonObject = new JSONObject(text); 
	//根据key取出内容
	JSONObject ev_head = (JSONObject) jsonObject.getJSONObject("EV_json");
	String str_evType =  ev_head.getString("EV_type");					
	//ToolClass.Log(ToolClass.INFO,"EV_JNI",str_evType);				    
	if(str_evType.equals("EV_INITING"))//正在初始化
	{
		ToolClass.Log(ToolClass.INFO,"EV_JNI","API<<正在初始化");
		EV_TYPE=EV_INITING;
	}
	else if(str_evType.equals("EV_ONLINE"))//str_evType.equals("EV_PAYOUT_RPT")
	{
		ToolClass.Log(ToolClass.INFO,"EV_JNI","API<<成功连接");
		EV_TYPE=EV_ONLINE;
		//往Activity线程发送信息
//							Message childmsg=mainHandler.obtainMessage();
//							childmsg.what=EV_ONLINE;
//							mainHandler.sendMessage(childmsg);
		//往接口回调信息
		allSet.clear();
		allSet.put("EV_TYPE", EV_ONLINE);
		callBack.jniCallback(allSet);
	}
	else if(str_evType.equals("EV_OFFLINE"))
	{
		ToolClass.Log(ToolClass.INFO,"EV_JNI","API<<断开连接");
		EV_TYPE=EV_OFFLINE;
	}
	

	
1)数据的封装
（1）简单有一个节点的数据
jsonTools.java文件

package com.example.json;

import org.json.JSONObject;

public class jsonTools {
	public jsonTools()
	{}
	//封装成json的方法，value是解析的集合的类型
	public static String jsonStr(String key,Object value)
	{
		JSONObject obj=new JSONObject();
		try {
			obj.put(key, value);			
		} catch (Exception e) {
			// TODO: handle exception
		}
		return obj.toString();//toString是保存json数据的作用
	}
}

Persong.java文件
package com.example.json;

import javax.security.auth.PrivateCredentialPermission;

public class Person {
	private int id;
	private String name;
	private String address;
	public Person() {
		// TODO Auto-generated constructor stub
	}
	public Person(int id, String name, String address) {
		super();
		this.id = id;
		this.name = name;
		this.address = address;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	@Override
	public String toString() {
		return id + ", " + name + ", " + address
				;
	}
	
}

jsonServer文件
package com.example.json;

public class jsonServer {
	public jsonServer(){}
	public Person getperson()
	{
		Person person=new Person(1001,"zhang3","beijing");
		return person;
	}
}

MainActivity文件
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		jsonServer json=new jsonServer();		
		Person person=json.getperson();//返回一个实际对象
		String msg=jsonTools.jsonStr("perkey1",person);
		//String msg=jsonTools.jsonStr("perkey1",getpersonlist());
		TextView txtjson=(TextView) findViewById(R.id.txtjson);
		txtjson.setText(msg);
		System.out.println(msg);
	}

结果是：
{"perkey1":"1001,zhang3,beijing"}


(2)传list数据
jsonServer文件
public class jsonServer {
	public jsonServer(){}
	public Person getperson()
	{
		Person person=new Person(1001,"zhang3","beijing");
		return person;
	}
	public List<Person> getpersonlist()
	{
		List<Person> list=new ArrayList<Person>();
		Person person1=new Person(1001,"zhang3","beijing");
		Person person2=new Person(1002,"li4","shanghai");
		list.add(person1);
		list.add(person2);
		return list;
	}
}
MainActivity文件
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		jsonServer json=new jsonServer();		
		//Person person=json.getperson();//返回一个实际对象
		//String msg=jsonTools.jsonStr("perkey1",person);
		String msg=jsonTools.jsonStr("perkey1",json.getpersonlist());
		TextView txtjson=(TextView) findViewById(R.id.txtjson);
		txtjson.setText(msg);
		System.out.println(msg);
	}
结果是：
{"perkey1":"[1001,zhang3,beijing,1002,li4,shanghai]"}

(3)传String类
//3.基础String类的集合
	public List<String> getstrlist()
	{
		List<String> list=new ArrayList<String>();
		list.add("beijing");
		list.add("shanghai");
		return list;
	}

//3.调用基础String类的集合
	String msg=jsonTools.jsonStr("perkey1",json.getstrlist());	

结果：{"perkey1":"[beijing,shanghai]"}

(4)传Map对象<String,String>的数据
//4.传Map对象<String,Object>的数据
	public List<Map<String, Object>> getMaplist()
	{
		List<Map<String, Object>> list=new ArrayList<Map<String,Object>>();
		Map<String, Object> map1=new HashMap<String, Object>();
			map1.put("id1", 10001);
			map1.put("name1", "zhang3");
			map1.put("address1", "beijing");
		Map<String, Object> map2=new HashMap<String, Object>();
			map1.put("id2", 10002);
			map1.put("name2", "li4");
			map1.put("address2", "shanghai");
		list.add(map1);
		list.add(map2);
		return list;
	}
	
//4.传Map对象<String,Object>的数据
		String msg=jsonTools.jsonStr("perkey1",json.getMaplist());	
	
2)数据的解析
加上读服务器数据的权限
<uses-permission android:name="android.permission.INTERNET"/>

(1)简单的Person流解析{"perkey1":{"address":"beijing","id":10001,"name":"jack"}}

HttpUtil文件用来从服务器得到流数据，并转为字符串

package com.example.json;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.net.URL;

import javax.net.ssl.HttpsURLConnection;

public class HttpUtil {

	public HttpUtil() {
		// TODO Auto-generated constructor stub
	}
	public static String getJsonContent(String url_path)
	{
		try {
			URL url=new URL(url_path);
			HttpsURLConnection con=(HttpsURLConnection)url.openConnection();
			con.setConnectTimeout(3000);
			con.setRequestMethod("GET");
			con.setDoInput(true);
			int code=con.getResponseCode();
			//表示服务器已经准备好了
			if(code==200)
			{
				//得到json流，并转成字符串
				return changeInputStraeam(con.getInputStream());
			}
		} catch (Exception e) {
			// TODO: handle exception
		}
		return "";
	}
	private static String changeInputStraeam(InputStream inputStream) {
		// TODO Auto-generated method stub
		String jsonString="";
		ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
		int len=0;
		byte data[]=new byte[1024];
		try {
			while((len=inputStream.read(data))!=-1)
			{
				outputStream.write(data,0,len);//转到输出流中
			}
			//转成字符串
			jsonString=new String(outputStream.toByteArray());
		} catch (Exception e) {
			// TODO: handle exception
		}
		
		return jsonString;
	}
}

jsonToolUnpack文件
//1.完成对person对象json字符串的解析
public static Person getPerson(String key,String jsonStr)
{
		
	Person person=new Person();
	try {
		JSONObject object=new JSONObject(jsonStr);//{"perkey1":"1001,zhang3,beijing"}
		JSONObject perobj=object.getJSONObject(key);//{"1001,zhang3,beijing"}
		//完善person对象
		person.setId(perobj.getInt("id"));
		person.setName(perobj.getString("name"));
		person.setAddress(perobj.getString("address"));
	} catch (JSONException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return person;
}

MainActivity文件
String path="http://117.27.89.53:10001/yv/api/vmcCheckin";
//1.完成对person对象json字符串的解析
String jsonStr=HttpUtil.getJsonContent(path);
Person person=jsonToolUnpack.getPerson("perkey1", jsonStr);

(2)Person集合的解析
{"perkey1":[{"id":10001,"name":"zhang3","address":"beijing"},{"id":10002,"name":"li4","address":"shanghai"}]}
//2.完成对person对象的集合json字符串的解析
	public static List<Person> getPersonList(String key,String jsonStr)
	{
		List<Person> list=new ArrayList<Person>();
		try {
			JSONObject object=new JSONObject(jsonStr);
			JSONArray arr=object.getJSONArray(key);//返回json数组
			for(int i=0;i<arr.length();i++)
			{
				JSONObject object2=arr.getJSONObject(i);
				Person person=new Person();
				//完善person对象
				person.setId(object2.getInt("id"));
				person.setName(object2.getString("name"));
				person.setAddress(object2.getString("address"));
				list.add(person);
			}
		} catch (Exception e) {
			// TODO: handle exception
		}
		return list;
	}
	
//2.完成对person对象的集合json字符串的解析
List<Person> list=jsonToolUnpack.getPersonList("perkey1", jsonStr);	

(3)String类集合的解析{"perkey1":["beijing","shanghai"]}
//3.完成对String类集合json字符串的解析
	public static List<String> getStrList(String key,String jsonStr)
	{
		List<String> list=new ArrayList<String>();
		try {
			JSONObject object=new JSONObject(jsonStr);
			JSONArray arr=object.getJSONArray(key);//返回json数组
			for(int i=0;i<arr.length();i++)
			{
				String str=arr.getString(i);
				list.add(str);
			}
		} catch (Exception e) {
			// TODO: handle exception
		}
		return list;
	}

//3.完成对String类集合json字符串的解析
	List<String> str=jsonToolUnpack.getStrList("perkey1", jsonStr);	

(4)Map对象<String,String>的数据{"perkey1":[{"address":"beijing","id":10001,"name":"jack"},
   {"address":"shanghai","id":10002,"name":"li4"}]}
//4.解析Map对象<String,Object>的数据集合
	public static List<Map<String, Object>> getMapList(String key,String jsonStr)
	{
		List<Map<String, Object>> list=new ArrayList<Map<String,Object>>();
		try {
			JSONObject object=new JSONObject(jsonStr);
			JSONArray arr=object.getJSONArray(key);//返回json数组
			for(int i=0;i<arr.length();i++)
			{
				JSONObject object2=arr.getJSONObject(i);	
				Map<String, Object> map=new HashMap<String, Object>();
				Iterator<String> it=object2.keys();
				while(it.hasNext())
				{
					String jkey=it.next();
					Object jvalue=object2.get(jkey);
					if(jvalue==null)
					{	
						jvalue="";
					}
					map.put(jkey, jvalue);
				}
				list.add(map);
			}
		} catch (Exception e) {
			// TODO: handle exception
		}
		return list;
	}

//4.完成对Map类集合json字符串的解析
		List<Map<String, Object>> str=jsonToolUnpack.getMapList("perkey1", jsonStr);	

3)简单有两个节点的数据
(1)写数据
String data[]=new String[]{"hello","world","msdn"};
JSONObject all=new JSONObject();//建立最外层的节点对象
JSONArray singArray=new JSONArray();//定义操作数组
//将数组内容配置到节点上
for(int i=0;i<data.length;i++)
{
	//每一个包装的数据都是JSONObject
	JSONObject temp=new JSONObject();
	try {
		temp.put("myurl", data[i]);
	} catch (JSONException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	singArray.put(temp);//保存多个JSONObject
}
try {
	all.put("urldata", singArray);
} catch (JSONException e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}

//如果sd卡存在，他的路径就是/mnt/sdcard/,不存在，则返回
if(!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
{
	return;
}
File file=new File(Environment.getExternalStorageDirectory()+File.separator+"guozz"
		+File.separator+"json.txt");
if(!file.getParentFile().exists())//不存在文件路径
{
	file.getParentFile().mkdirs();//创建父文件夹路径
}

try {
	PrintStream out=new PrintStream(new FileOutputStream(file));
	out.print(all.toString());//保存数据
	out.close();
} catch (FileNotFoundException e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}

数据结果
{"urldata":[{"myurl":"hello"},{"myurl":"world"},{"myurl":"msdn"}]}


(2)读数据
//读数据
//一个JSON格式的字符串
String str="[{\"id\":1,\"name\":\"hello\",\"age\":30},{\"id\":2,\"name\":\"world\",\"age\":26}]";
StringBuffer buffer=new StringBuffer();
List<Map<String, Object>> all=null;
try {
	all = this.delJSON(str);
	Iterator<Map<String, Object>> iter=all.iterator();
	while(iter.hasNext())
	{
		Map<String, Object> map=iter.next();
		buffer.append("id="+map.get("id")+",name="+map.get("name")+",age="+map.get("age")+"\n");
	}
} catch (Exception e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}		
this.msg.setText(buffer);


private List<Map<String, Object>> delJSON(String data)throws Exception
{
	List<Map<String, Object>> all = new ArrayList<Map<String, Object>>();
	JSONArray array=new JSONArray(data);
	for(int i=0;i<array.length();i++)
	{
		Map<String, Object> map=new HashMap<String, Object>();
		JSONObject object=array.getJSONObject(i);
		map.put("id", object.getInt("id"));
		map.put("name", object.getString("name"));
		map.put("age", object.getInt("age"));
		all.add(map);
	}
	return all;
}

4)复杂数据
(1)写数据
public class MainActivity extends Activity {
	private String nameData[]=new String[]{"zhang3","li4","wang5"};
	private int ageData[]=new int[]{21,23,27};
	private boolean marrData[]=new boolean[]{true,true,true};
	private double saleData[]=new double[]{21.3,23.4,27.5};
	private Date birthData[]=new Date[]{new Date(20140107),new Date(20140108),new Date(20140109)};
	private String cmpname="hellocompany";
	private String cmparr="helloarr";
	private String cmptel="1122334";
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		super.setContentView(R.layout.activity_main);
		JSONObject all=new JSONObject();//建立最外层的节点对象
		JSONArray singArray=new JSONArray();//定义操作数组
		//将数组内容配置到节点上
		for(int i=0;i<this.nameData.length;i++)
		{
			//每一个包装的数据都是JSONObject
			JSONObject temp=new JSONObject();
			try {
				temp.put("nameData", this.nameData[i]);
				temp.put("ageData", this.ageData[i]);
				temp.put("marrData", this.marrData[i]);
				temp.put("saleData", this.saleData[i]);
				temp.put("birthData", this.birthData[i]);
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			singArray.put(temp);//保存多个JSONObject
		}
		try {
			all.put("persondata", singArray);
			all.put("cmpname", cmpname);
			all.put("cmparr", cmparr);
			all.put("cmptel", cmptel);
		} catch (JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//如果sd卡存在，他的路径就是/mnt/sdcard/,不存在，则返回
		if(!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))
		{
			return;
		}
		File file=new File(Environment.getExternalStorageDirectory()+File.separator+"guozz"
				+File.separator+"json.txt");
		if(!file.getParentFile().exists())//不存在文件路径
		{
			file.getParentFile().mkdirs();//创建父文件夹路径
		}
		
		try {
			PrintStream out=new PrintStream(new FileOutputStream(file));
			out.print(all.toString());//保存数据
			out.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		finally
		{
			
		}
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.main, menu);
		return true;
	}

}

(2)读数据
//读数据
//一个JSON格式的字符串
String str="{\"memberdata\":[{\"id\":1,\"name\":\"hello\",\"age\":30},{\"id\":2,\"name\":\"world\",\"age\":26}],"
		+"\"company\":\"beijing\"}";
StringBuffer buffer=new StringBuffer();
Map<String, Object> result=null;
try {
	result = this.delJSON(str);
	buffer.append("company:"+result.get("company")+"\n");
	List<Map<String, Object>> all= (List<Map<String, Object>>)result.get("memberdata");
	Iterator<Map<String, Object>> iter=all.iterator();
	while(iter.hasNext())
	{
		Map<String, Object> map=iter.next();
		buffer.append("id="+map.get("id")+",name="+map.get("name")+",age="+map.get("age")+"\n");
	}
} catch (Exception e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}		
this.msg.setText(buffer);



private Map<String, Object> delJSON(String data)throws Exception
{
	Map<String, Object> allmap = new HashMap<String, Object>();
	JSONObject all=new JSONObject(data);//内容全部变为一个项
	allmap.put("company", all.getString("company"));//取出一个单想
	JSONArray array=all.getJSONArray("memberdata");//取出数组
	List<Map<String, Object>> alldata = new ArrayList<Map<String, Object>>();
	for(int i=0;i<array.length();i++)
	{
		Map<String, Object> map=new HashMap<String, Object>();
		JSONObject object=array.getJSONObject(i);
		map.put("id", object.getInt("id"));
		map.put("name", object.getString("name"));
		map.put("age", object.getInt("age"));
		alldata.add(map);
	}
	allmap.put("memberdata", alldata);
	return allmap;
}

8.GSON:google提供的，解析JSON协议的开发包
下载gson.jar包，把他考到工程的libs目录下
1)发送
jsonTools文件
public class jsonTools {
	public jsonTools()
	{}
	//封装成json的方法，value是解析的集合的类型
	public static String jsonStr(Object value)
	{
		Gson gson=new Gson();
		String string=gson.toJson(value);
		
		return string;
	}
}
Persong.java文件
package com.example.json;

import javax.security.auth.PrivateCredentialPermission;

public class Person {
	private int id;
	private String name;
	private String address;
	public Person() {
		// TODO Auto-generated constructor stub
	}
	public Person(int id, String name, String address) {
		super();
		this.id = id;
		this.name = name;
		this.address = address;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	@Override
	public String toString() {
		return id + ", " + name + ", " + address
				;
	}
	
}

jsonServer文件
public class jsonServer {
	public jsonServer(){}
	//1.person类
	public Person getperson()
	{
		Person person=new Person(1001,"zhang3","beijing");
		return person;
	}
	//2.Person类的集合
	public List<Person> getpersonlist()
	{
		List<Person> list=new ArrayList<Person>();
		Person person1=new Person(1001,"zhang3","beijing");
		Person person2=new Person(1002,"li4","shanghai");
		list.add(person1);
		list.add(person2);
		return list;
	}
	//3.基础String类的集合
	public List<String> getstrlist()
	{
		List<String> list=new ArrayList<String>();
		list.add("beijing");
		list.add("shanghai");
		return list;
	}
	//4.传Map对象<String,Object>的数据
	public List<Map<String, Object>> getMaplist()
	{
		List<Map<String, Object>> list=new ArrayList<Map<String,Object>>();
		Map<String, Object> map1=new HashMap<String, Object>();
			map1.put("id1", 10001);
			map1.put("name1", "zhang3");
			map1.put("address1", "beijing");
		Map<String, Object> map2=new HashMap<String, Object>();
			map1.put("id2", 10002);
			map1.put("name2", "li4");
			map1.put("address2", "shanghai");
		list.add(map1);
		list.add(map2);
		return list;
	}
}

MainActivity文件
//1.调用person类
//Person person=json.getperson();//返回一个实际对象
//String msg=jsonTools.jsonStr(person);
//2.调用Person类的集合
//String msg=jsonTools.jsonStr(json.getpersonlist());
//3.调用基础String类的集合
//String msg=jsonTools.jsonStr(json.getstrlist());
//4.传Map对象<String,Object>的数据
//String msg=jsonTools.jsonStr(json.getMaplist());
//txtjson=(TextView) findViewById(R.id.txtjson);
//txtjson.setText(msg);

2)解析
jsonToolUnpack文件
import com.google.gson.reflect.*;
//GSON方法
//1.完成对person对象json字符串的解析
public static <T>T getPersongson(String jsonStr,Class<T> cls)
{
		
	T t=null;
	try {
		Gson gson=new Gson();
		t=gson.fromJson(jsonStr, cls);
	} catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return t;
}
//2.完成对person对象的集合json字符串的解析
public static <T>List<T> getPersonListgson(String jsonStr,Class<T> cls)
{
		
	List<T> list=new ArrayList<T>();
	try {
		Gson gson=new Gson();
		//从jsonStr封装到list集合中，通过getType从key中取出所有类型
		list=gson.fromJson(jsonStr,new TypeToken<List<T>>(){}.getType());
	} catch (Exception e) {
		// TODO: handle exception
	}
	return list;
}
//3.完成对String类集合json字符串的解析
public static List<String> getStrListgson(String jsonStr)
{
	List<String> list=new ArrayList<String>();
	try {
		Gson gson=new Gson();
		list=gson.fromJson(jsonStr,new TypeToken<List<String>>(){}.getType());
	} catch (Exception e) {
		// TODO: handle exception
	}
	return list;
}
//4.解析Map对象<String,Object>的数据集合
public static List<Map<String, Object>> getMapListgson(String jsonStr)
{
	List<Map<String, Object>> list=new ArrayList<Map<String,Object>>();
	try {
		Gson gson=new Gson();
		list=gson.fromJson(jsonStr, new TypeToken<List<Map<String, Object>>>(){}.getType());
	} catch (Exception e) {
		// TODO: handle exception
	}
	return list;
}

MainActivity文件
//Gson
//1.完成对person对象json字符串的解析，Person.class是反射得到Person的类型		
Person person=jsonToolUnpack.getPersongson(jsonStr,Person.class);
//2.完成对person对象的集合json字符串的解析
List<Person> list=jsonToolUnpack.getPersonListgson(jsonStr, Person.class);
//3.完成对String类集合json字符串的解析
List<String> str=jsonToolUnpack.getStrListgson(jsonStr);
//4.完成对Map类集合json字符串的解析
List<Map<String, Object>> str2=jsonToolUnpack.getMapListgson(jsonStr);

*Http访问网络：Http在TCP之上，
客户端输入网址-Http->DNS->连接上服务端的固定IP地址，和端口
服务端--Html(网页),XML数据(效率比较低，不用了),JSON数据(一般用这个)-->客户端

1.通过JSON连接后台tomcat服务端
例如：骏鹏服务器端连接
设备签到：
客户端
URL:  /api/vmcCheckin
请求方式：POST
请求参数：
param对象    json类型
Param对象内容
vmc_no          String
vmc_auth_code   String
客户端发起接口请求，url地址必须携带token，token是设备签到时返回的唯一标识符，如有参数，参数放在param里并转换成json格式，如：param={“productNo”:”jyt_002”,.......}，用post方式请求服务端

注意1：他的参数param对象才是json格式{“productNo”:”jyt_002”,.......}
       而param=  并不是json封装
注意2：json的键值对vmc_no，vmc_auth_code无需按顺序
注意3：客户端发数据给服务端，他的参数也是一个键值对。
       key就是param，value就是json封装的{“productNo”:”jyt_002”,.......}
	   因此不能输入param=，要输入param，他的=号在上传的时候会自动添加

程序：
//需要创建线程来做
// 为按钮添加单击事件监听器
		button.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				

				// 创建一个新线程，用于从网络上获取文件
				new Thread(new Runnable() {
					public void run() {
						send();
						Message m = handler.obtainMessage(); // 获取一个Message
						handler.sendMessage(m); // 发送消息
					}
				}).start(); // 开启线程

			}
		});
		handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				if (result != null) {
					resultTV.setText(result); // 显示获得的结果
					content.setText(""); // 清空内容编辑框
					nickname.setText(""); // 清空昵称编辑框
				}
				super.handleMessage(msg);
			}
		};
		
		
public void send() 
{
	String target = "http://117.27.89.53:10001/yv/api/vmcCheckin";	//要提交的目标地址
	HttpClient httpclient = new DefaultHttpClient();	//创建HttpClient对象
	HttpPost httppost = new HttpPost(target);	//创建HttpPost对象
	//添加到类集中，其中key,value类型为String
	Map<String,String> parammap = new TreeMap<String,String>() ;
	parammap.put("vmc_no","ev0001");
	parammap.put("vmc_auth_code","0001");		
	Log.i("{JSON1}=",parammap.toString());
	//打印结果是{JSON1}=(7469): {vmc_auth_code=0001, vmc_no=ev0001}
	//将map类集转为json格式
	Gson gson=new Gson();
	String param=gson.toJson(parammap);		
	Log.i("{JSON2}=",param.toString());
	//打印结果是{JSON2}=(7469): {"vmc_auth_code":"0001","vmc_no":"ev0001"}
	//添加params
	List<NameValuePair> params = new ArrayList<NameValuePair>();
	params.add(new BasicNameValuePair("param", param));
	Log.i("{JSON3}=",params.toString());
	//打印结果是[param={"vmc_auth_code":"0001","vmc_no":"ev0001"}]
	
	try {
		httppost.setEntity(new UrlEncodedFormEntity(params, "utf-8")); //设置编码方式
		HttpResponse httpResponse = httpclient.execute(httppost);	//执行HttpClient请求
		if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK){	//如果请求成功
			result += EntityUtils.toString(httpResponse.getEntity());	//获取返回的字符串
			
		}else{
			result = "请求失败！";
		}
	} catch (UnsupportedEncodingException e1) {
		e1.printStackTrace();	//输出异常信息
	} catch (ClientProtocolException e) {
		e.printStackTrace();	//输出异常信息
	} catch (IOException e) {
		e.printStackTrace();	//输出异常信息
	}
	
}

2.通过post请求发送一个xml，解析返回xml数据
1)发送和接收明文数据
其中发送的xml数据为：
<?xml version = “1.0” ?> 
<SSOMessage version=”1.0”>
<SSOParas>
<SeqID>SeqID</SeqID> 
<CommandID>CommandID</CommandID> 
<MSISDN>ABSCDSDF</MSISDN>
<ChargeMSISDN>ChargeMSISDN</ChargeMSISDN>
<SPID>SPID</SPID>
<Code> Code </ Code >
< IDtype > IDtype 0</ IDtype >
<ID> ID 0</ID>
</SSOParas>
</SSOMessage>

返回的xml数据为：
<?xml version = “1.0” ?> 
<SSOMessage version=”1.0”> 
<SSOParas> 
<SeqID>SeqID</SeqID> 
<ResultCode>ResultCode0</ResultCode>
</SSOParas>
</SSOMessage>

class httpThread implements Runnable {

    /* (non-Javadoc)
     * @see java.lang.Runnable#run()
     */
    @Override
    public void run() {
        // TODO Auto-generated method stub
        //组建xml数据
        StringBuilder xml = new StringBuilder();
        xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        xml.append("<SSOMessage version=\"1.0\">");
        xml.append("<SSOParas>");
        xml.append("<SeqID>13333333333</SeqID>");
        xml.append("<CommandID>1</CommandID>");
        xml.append("<MSISDN>1333333333</MSISDN>");
        xml.append("<ChargeMSISDN>1333333333</ChargeMSISDN>");
        xml.append("<SPID>3510127</SPID>");
        xml.append("<Code></Code>");
        xml.append("<IDtype>0</IDtype>");
        xml.append("<ID>135000000000000216559</ID>");
        xml.append("</SSOParas>");
        xml.append("</SSOMessage>");

        try {
            byte[] xmlbyte = xml.toString().getBytes("UTF-8");
            
            System.out.println(xml);

            URL url = new URL("http://118.85.194.28:8080/sotpms_server/GetSSOMessage");
            
            
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setConnectTimeout(5000);
            conn.setDoOutput(true);// 允许输出
            conn.setDoInput(true);
            conn.setUseCaches(false);// 不使用缓存
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Connection", "Keep-Alive");// 维持长连接
            conn.setRequestProperty("Charset", "UTF-8");
            conn.setRequestProperty("Content-Length",
                    String.valueOf(xmlbyte.length));
            conn.setRequestProperty("Content-Type", "text/xml; charset=UTF-8");
            conn.setRequestProperty("X-ClientType", "2");//发送自定义的头信息

            conn.getOutputStream().write(xmlbyte);
            conn.getOutputStream().flush();
            conn.getOutputStream().close();


            if (conn.getResponseCode() != 200)
                throw new RuntimeException("请求url失败");

            InputStream is = conn.getInputStream();// 获取返回数据
              

            // 使用输出流来输出字符(可选)
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            byte[] buf = new byte[1024];
            int len;
            while ((len = is.read(buf)) != -1) {
                out.write(buf, 0, len);
            }
            String string = out.toString("UTF-8");
            System.out.println(string);
            out.close();
                 
                     
            // xml解析
            String version = null;
            String seqID = null;
            XmlPullParser parser = Xml.newPullParser();
            try {
                parser.setInput(new ByteArrayInputStream(string.substring(1)
                        .getBytes("UTF-8")), "UTF-8");
                 parser.setInput(is, "UTF-8");
                int eventType = parser.getEventType();
                while (eventType != XmlPullParser.END_DOCUMENT) {
                    if (eventType == XmlPullParser.START_TAG) {
                        if ("SSOMessage".equals(parser.getName())) {
                            version = parser.getAttributeValue(0);
                        } else if ("SeqID".equals(parser.getName())) {
                            seqID = parser.nextText();
                        } else if ("ResultCode".equals(parser.getName())) {
                            resultCode = parser.nextText();
                        }
                    }
                    eventType = parser.next();
                }
            } catch (XmlPullParserException e) {
                e.printStackTrace();
                System.out.println(e);
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println(e);
            }
            System.out.println("version = " + version);
            System.out.println("seqID = " + seqID);
            System.out.println("resultCode = " + resultCode);*/

        } catch (Exception e) {
            // TODO Auto-generated catch block
            System.out.println(e);
        }
    }

2)但是实际使用时，发现以上的方法接收的流不能解析xml,后来换成这样子
解析函数
public static Map<String, String> PendWeiBuy(InputStream is)
{
	Map<String, String>list=new HashMap<String, String>();
	
	XmlPullParser parser = Xml.newPullParser();
	try {
		//parser.setInput(new ByteArrayInputStream(string.substring(1)
		//        .getBytes("UTF-8")), "UTF-8");
		parser.setInput(is, "UTF-8");
		int eventType = parser.getEventType();
		while (eventType != XmlPullParser.END_DOCUMENT)
		{
			if (eventType == XmlPullParser.START_TAG) 
			{
				if ("return_code".equals(parser.getName())) 
				{
					list.put("return_code", parser.nextText());
				} 
				else if ("return_msg".equals(parser.getName())) 
				{
					list.put("return_msg", parser.nextText());
				} 
				else if ("result_code".equals(parser.getName())) 
				{
					list.put("result_code", parser.nextText());
				}
				else if ("err_code".equals(parser.getName())) 
				{
					list.put("err_code", parser.nextText());
				}
				else if ("err_code_des".equals(parser.getName())) 
				{
					list.put("err_code_des", parser.nextText());
				}
				else if ("prepay_id".equals(parser.getName())) 
				{
					list.put("prepay_id", parser.nextText());
				}
				else if ("code_url".equals(parser.getName())) 
				{
					list.put("code_url", parser.nextText());
				}					
			}
			eventType = parser.next();
		}
	} catch (XmlPullParserException e) {
		e.printStackTrace();
		System.out.println(e);
	} catch (IOException e) {
		e.printStackTrace();
		System.out.println(e);
	}
	return list;
}

实际使用：
//4.发送信息
try {
	byte[] xmlbyte = xml.toString().getBytes("UTF-8");
	
	//Log.i("EV_JNI","Send5="+xml);

	URL url = new URL("https://api.mch.weixin.qq.com/pay/unifiedorder");
	
	
	HttpURLConnection conn = (HttpURLConnection) url.openConnection();
	conn.setConnectTimeout(9000);//设置连接主机超时（单位：毫秒）
    conn.setReadTimeout(3000);//设置从主机读取数据超时（单位：毫秒）
	conn.setDoOutput(true);// 允许输出
	conn.setDoInput(true);
	conn.setUseCaches(false);// 不使用缓存
	conn.setRequestMethod("POST");
	conn.setRequestProperty("Connection", "Keep-Alive");// 维持长连接
	conn.setRequestProperty("Charset", "UTF-8");
	conn.setRequestProperty("Content-Length",
			String.valueOf(xmlbyte.length));
	conn.setRequestProperty("Content-Type", "text/xml; charset=UTF-8");
	conn.setRequestProperty("X-ClientType", "2");//发送自定义的头信息

	conn.getOutputStream().write(xmlbyte);
	conn.getOutputStream().flush();
	conn.getOutputStream().close();


	if (conn.getResponseCode() != 200)
		throw new RuntimeException("请求url失败");

	InputStream in = conn.getInputStream();// 获取返回数据
	  
	BufferedReader bufferedReader = new BufferedReader(  
			new InputStreamReader(in));  
	StringBuffer temp = new StringBuffer();  
	String line = bufferedReader.readLine();  
	while (line != null) {  
		temp.append(line).append("\r\n");  
		line = bufferedReader.readLine();  
	}  
	bufferedReader.close(); 
	String content = new String(temp.toString().getBytes(), "UTF-8"); 				            

	Log.i("EV_JNI","rec1="+content);
	//5.解包返回的信息
	InputStream is = new ByteArrayInputStream(content.getBytes());// 获取返回数据
	//XML解析   
   Map<String, String> map2=WeiConfigAPI.PendWeiBuy(is);
   Log.i("EV_JNI","rec2="+map2.toString());

} catch (Exception e) {
	// TODO Auto-generated catch block
	System.out.println(e);
} 	

3.支付宝发送表单，返回一个二维码图片
1)核心配置类AlipayConfig.java文件
package com.alipay.config;

/* *
 *类名：AlipayConfig
 *功能：基础配置类
 *详细：设置帐户有关信息及返回路径
 *版本：3.3
 *日期：2012-08-10
 *说明：
 *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。
 *该代码仅供学习和研究支付宝接口使用，只是提供一个参考。
	
 *提示：如何获取安全校验码和合作身份者ID
 *1.用您的签约支付宝账号登录支付宝网站(www.alipay.com)
 *2.点击“商家服务”(https://b.alipay.com/order/myOrder.htm)
 *3.点击“查询合作者身份(PID)”、“查询安全校验码(Key)”

 *安全校验码查看时，输入支付密码后，页面呈灰色的现象，怎么办？
 *解决方法：
 *1、检查浏览器配置，不让浏览器做弹框屏蔽设置
 *2、更换浏览器或电脑，重新登录查询。
 */

public class AlipayConfig {
	
	//↓↓↓↓↓↓↓↓↓↓请在这里配置您的基本信息↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
	// 合作身份者ID，以2088开头由16位纯数字组成的字符串
	public static String partner = "2088711021642556";
	// 商户的私钥
	public static String key = "q4qsttz5r4grwnr5y5h9shjzvjfxejco";

	//↑↑↑↑↑↑↑↑↑↑请在这里配置您的基本信息↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
	

	// 调试用，创建TXT日志文件夹路径
	public static String log_path = "D:\\";

	// 字符编码格式 目前支持 gbk 或 utf-8
	public static String input_charset = "utf-8";
	
	// 签名方式 不需修改
	public static String sign_type = "MD5";

}

package com.alipay.sign;

import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;


2）MD5的生成加密函数MD5.java文件
/** 
* 功能：支付宝MD5签名处理核心文件，不需要修改
* 版本：3.3
* 修改日期：2012-08-17
* 说明：
* 以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。
* 该代码仅供学习和研究支付宝接口使用，只是提供一个
* */

public class MD5 {
	 // ㄥ扮
    private final static String[] strDigits = { "0", "1", "2", "3", "4", "5",
            "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" };

	// 杩褰㈠涓烘板璺瀛绗涓?
    private static String byteToArrayString(byte bByte) {
        int iRet = bByte;
        // System.out.println("iRet="+iRet);
        if (iRet < 0) {
            iRet += 256;
        }
        int iD1 = iRet / 16;
        int iD2 = iRet % 16;
        return strDigits[iD1] + strDigits[iD2];
    }

    // 杩褰㈠涓烘板
    private static String byteToNum(byte bByte) {
        int iRet = bByte;
        System.out.println("iRet1=" + iRet);
        if (iRet < 0) {
            iRet += 256;
        }
        return String.valueOf(iRet);
    }

    // 杞㈠扮涓?6杩跺涓
    private static String byteToString(byte[] bByte) {
        StringBuffer sBuffer = new StringBuffer();
        for (int i = 0; i < bByte.length; i++) {
            sBuffer.append(byteToArrayString(bByte[i]));
        }
        return sBuffer.toString();
    }

    public static String GetMD5Code(String strObj) {
        String resultString = null;
        try {
            resultString = new String(strObj);
            MessageDigest md = MessageDigest.getInstance("MD5");
            // md.digest() 璇ュ芥拌?涓哄惧甯?缁byte扮
            resultString = byteToString(md.digest(strObj.getBytes()));
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        
        System.out.println(resultString);
        return resultString;
    }

	
	
	
    /**
     * 签名字符串
     * @param text 需要签名的字符串
     * @param key 密钥
     * @param input_charset 编码格式
     * @return 签名结果
     */
    public static String sign(String text, String key, String input_charset) {
    	text = text + key;
    	
        return GetMD5Code(text);
    }
    
    /**
     * 签名字符串
     * @param text 需要签名的字符串
     * @param sign 签名结果
     * @param key 密钥
     * @param input_charset 编码格式
     * @return 签名结果
     */
    public static boolean verify(String text, String sign, String key, String input_charset) {
    	text = text + key;
    	
    	String mysign = GetMD5Code(text);
    	if(mysign.equals(sign)) {
    		return true;
    	}
    	else {
    		return false;
    	}
    }

    /**
     * @param content
     * @param charset
     * @return
     * @throws SignatureException
     * @throws UnsupportedEncodingException 
     */
    private static byte[] getContentBytes(String content, String charset) {
        if (charset == null || "".equals(charset)) {
            return content.getBytes();
        }
        try {
            return content.getBytes(charset);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("MD5签名过程中出现错误,指定的编码集不对,您目前指定的编码集是:" + charset);
        }
    }

}


3)Alipay核心生成签到函数
AlipayCore.java文件
package com.alipay.util;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


import com.alipay.config.AlipayConfig;

/* *
 *类名：AlipayFunction
 *功能：支付宝接口公用函数类
 *详细：该类是请求、通知返回两个文件所调用的公用函数核心处理文件，不需要修改
 *版本：3.3
 *日期：2012-08-14
 *说明：
 *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。
 *该代码仅供学习和研究支付宝接口使用，只是提供一个参考。
 */
public class AlipayCore {

	/** 
     * 除去数组中的空值和签名参数
     * @param sArray 签名参数组
     * @return 去掉空值与签名参数后的新签名参数组
     */
    public static Map<String, String> paraFilter(Map<String, String> sArray) {

        Map<String, String> result = new HashMap<String, String>();

        if (sArray == null || sArray.size() <= 0) {
            return result;
        }

        for (String key : sArray.keySet()) {
            String value = sArray.get(key);
            if (value == null || value.equals("") || key.equalsIgnoreCase("sign")
                || key.equalsIgnoreCase("sign_type")) {
                continue;
            }
            result.put(key, value);
        }

        return result;
    }

    /** 
     * 把数组所有元素排序，并按照“参数=参数值”的模式用“&”字符拼接成字符串
     * @param params 需要排序并参与字符拼接的参数组
     * @return 拼接后字符串
     */
    public static String createLinkString(Map<String, String> params) {

        List<String> keys = new ArrayList<String>(params.keySet());
        Collections.sort(keys);

        String prestr = "";

        for (int i = 0; i < keys.size(); i++) {
            String key = keys.get(i);
            String value = params.get(key);

            if (i == keys.size() - 1) {//峰煎复璁圭娑宥瀵奉娓堕搴绔存锟界?妤
                prestr = prestr + key + "=" + value;
            } else {
                prestr = prestr + key + "=" + value + "&";
            }
        }

        return prestr;
    }

    /** 
     * 写日志，方便测试（看网站需求，也可以改成把记录存入数据库）
     * @param sWord 要写入日志里的文本内容
     */
    public static void logResult(String sWord) {
        FileWriter writer = null;
        try {
            writer = new FileWriter("alipay_log_" + System.currentTimeMillis()+".txt");
            writer.write(sWord);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /** 
     * 生成文件摘要
     * @param strFilePath 文件路径
     * @param file_digest_type 摘要算法
     * @return 文件摘要结果
     */
    public static String getAbstract(String strFilePath, String file_digest_type) throws IOException {
        //PartSource file = new FilePartSource(new File(strFilePath));
    	
    		//return md5(file.createInputStream());
    	return "";
    	
    	
    }
}


AlipayNotify.java文件

package com.alipay.util;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Map;

import com.alipay.config.AlipayConfig;
import com.alipay.sign.MD5;

/* *
 *类名：AlipayNotify
 *功能：支付宝通知处理类
 *详细：处理支付宝各接口通知返回
 *版本：3.3
 *日期：2012-08-17
 *说明：
 *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。
 *该代码仅供学习和研究支付宝接口使用，只是提供一个参考

 *************************注意*************************
 *调试通知返回时，可查看或改写log日志的写入TXT里的数据，来检查通知返回是否正常
 */
public class AlipayNotify {

	/**
     * 支付宝消息验证地址
     */
    private static final String HTTPS_VERIFY_URL = "https://mapi.alipay.com/gateway.do?service=notify_verify&";

    /**
     * 验证消息是否是支付宝发出的合法消息
     * @param params 通知返回来的参数数组
     * @return 验证结果
     */
    public static boolean verify(Map<String, String> params) {

    	//判断responsetTxt是否为true，isSign是否为true
        //responsetTxt的结果不是true，与服务器设置问题、合作身份者ID、notify_id一分钟失效有关
        //isSign不是true，与安全校验码、请求时的参数格式（如：带自定义参数等）、编码格式有关
    	String responseTxt = "true";
		if(params.get("notify_id") != null) {
			String notify_id = params.get("notify_id");
			responseTxt = verifyResponse(notify_id);
		}
	    String sign = "";
	    if(params.get("sign") != null) {sign = params.get("sign");}
	    boolean isSign = getSignVeryfy(params, sign);

	    //写日志记录（若要调试，请取消下面两行注释）
        //String sWord = "responseTxt=" + responseTxt + "\n isSign=" + isSign + "\n 返回回来的参数：" + AlipayCore.createLinkString(params);
	    //AlipayCore.logResult(sWord);

        if (isSign && responseTxt.equals("true")) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * 根据反馈回来的信息，生成签名结果
     * @param Params 通知返回来的参数数组
     * @param sign 比对的签名结果
     * @return 生成的签名结果
     */
	private static boolean getSignVeryfy(Map<String, String> Params, String sign) {
		//过滤空值、sign与sign_type参数
    	Map<String, String> sParaNew = AlipayCore.paraFilter(Params);
    	//获取待签名字符串
        String preSignStr = AlipayCore.createLinkString(sParaNew);
        //获得签名验证结果
        boolean isSign = false;
        if(AlipayConfig.sign_type.equals("MD5") ) {
        	isSign = MD5.verify(preSignStr, sign, AlipayConfig.key, AlipayConfig.input_charset);
        }
        return isSign;
    }

	/**
    * 获取远程服务器ATN结果,验证返回URL
    * @param notify_id 通知校验ID
    * @return 服务器ATN结果
    * 验证结果集：
    * invalid命令参数不对 出现这个错误，请检测返回处理中partner和key是否为空 
    * true 返回正确信息
    * false 请检查防火墙或者是服务器阻止端口问题以及验证时间是否超过一分钟
    */
    private static String verifyResponse(String notify_id) {
    	//获取远程服务器ATN结果，验证是否是支付宝服务器发来的请求

        String partner = AlipayConfig.partner;
        String veryfy_url = HTTPS_VERIFY_URL + "partner=" + partner + "&notify_id=" + notify_id;

        return checkUrl(veryfy_url);
    }

    /**
     * 获取远程服务器ATN结果
     * @param urlvalue 指定URL路径地址
     * @return 服务器ATN结果
     * 验证结果集：
     * invalid命令参数不对 出现这个错误，请检测返回处理中partner和key是否为空 
     * true 返回正确信息
     * false 请检查防火墙或者是服务器阻止端口问题以及验证时间是否超过一分钟
     */
    private static String checkUrl(String urlvalue) {
        String inputLine = "";

        try {
            URL url = new URL(urlvalue);
            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection
                .getInputStream()));
            inputLine = in.readLine().toString();
        } catch (Exception e) {
            e.printStackTrace();
            inputLine = "";
        }

        return inputLine;
    }
}

AlipaySubmit.java文件，用于签到用
package com.alipay.util;

import java.util.Map;

import com.alipay.config.AlipayConfig;

import com.alipay.sign.MD5;

/* *
 *类名：AlipaySubmit
 *功能：支付宝各接口请求提交类
 *详细：构造支付宝各接口表单HTML文本，获取远程HTTP数据
 *版本：3.3
 *日期：2012-08-13
 *说明：
 *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。
 *该代码仅供学习和研究支付宝接口使用，只是提供一个参考。
 */
public class AlipaySubmit {
    
	/**
     * 支付宝提供给商户的服务接入网关URL(新)
     */
    private static final String ALIPAY_GATEWAY_NEW = "https://mapi.alipay.com/gateway.do?";
	
    /**
     * 生成签名结果
     * @param sPara 要签名的数组
     * @return 签名结果字符串
     */
	public static String buildRequestMysign(Map<String, String> sPara) {
    	String prestr = AlipayCore.createLinkString(sPara); //跺缂澧澶缁辩绱稿ユ寮锟介灏锟介ㄥ瀵蹇らワ拷ユх锔藉鹃恒妤娑锟?        String mysign = "";
    	String mysign = "";
    	if(AlipayConfig.sign_type.equals("MD5") ) {
        	mysign = MD5.sign(prestr, AlipayConfig.key, AlipayConfig.input_charset);
        }
        return mysign;
    }
	
	/**
     * 生成要请求给支付宝的参数数组
     * @param sParaTemp 请求前的参数数组
     * @return 要请求的参数数组
     */
    public static Map<String, String> buildRequestPara(Map<String, String> sParaTemp) {
    	//除去数组中的空值和签名参数
        Map<String, String> sPara = AlipayCore.paraFilter(sParaTemp);
        //生成签名结果
        String mysign = buildRequestMysign(sPara);

        //签名结果与签名方式加入请求提交参数组中
        sPara.put("sign", mysign);
        sPara.put("sign_type", AlipayConfig.sign_type);

        return sPara;
    }

    
}

UtilDate.java文件

package com.alipay.util;

import java.util.Date;
import java.util.Random;
import java.text.SimpleDateFormat;
import java.text.DateFormat;

/* *
 *类名：UtilDate
 *功能：自定义订单类
 *详细：工具类，可以用作获取系统日期、订单编号等
 *版本：3.3
 *日期：2012-08-17
 *说明：
 *以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。
 *该代码仅供学习和研究支付宝接口使用，只是提供一个参考。
 */
public class UtilDate {
	
	/** 年月日时分秒(无下划线) yyyyMMddHHmmss */
    public static final String dtLong                  = "yyyyMMddHHmmss";
    
    /** 完整时间 yyyy-MM-dd HH:mm:ss */
    public static final String simple                  = "yyyy-MM-dd HH:mm:ss";
    
    /** 年月日(无下划线) yyyyMMdd */
    public static final String dtShort                 = "yyyyMMdd";
	
    
    /**
     * 返回系统当前时间(精确到毫秒),作为一个唯一的订单编号
     * @return
     *      以yyyyMMddHHmmss为格式的当前系统时间
     */
	public  static String getOrderNum(){
		Date date=new Date();
		DateFormat df=new SimpleDateFormat(dtLong);
		return df.format(date);
	}
	
	/**
	 * 获取系统当前日期(精确到毫秒)，格式：yyyy-MM-dd HH:mm:ss
	 * @return
	 */
	public  static String getDateFormatter(){
		Date date=new Date();
		DateFormat df=new SimpleDateFormat(simple);
		return df.format(date);
	}
	
	/**
	 * 获取系统当期年月日(精确到天)，格式：yyyyMMdd
	 * @return
	 */
	public static String getDate(){
		Date date=new Date();
		DateFormat df=new SimpleDateFormat(dtShort);
		return df.format(date);
	}
	
	/**
	 * 产生随机的三位数
	 * @return
	 */
	public static String getThree(){
		Random rad=new Random();
		return rad.nextInt(1000)+"";
	}
	
}


MainActivity.java文件，调用

public void send() {
	Map<String, String> sPara = new HashMap<String, String>();
		 sPara.put("service","alipay.acquire.precreate");
		 sPara.put("partner","2088711021642556");//支付宝 PID号
		 sPara.put("_input_charset","utf-8");//编码		
		 sPara.put("seller_email", "2544282805@qq.com");//卖家支付宝帐户		 
		 sPara.put("product_code","QR_CODE_OFFLINE");//二维码
		 sPara.put("total_fee","0.1");//订单总金额		   
		 sPara.put("out_trade_no","205211376305670");//商户网站唯一订单号		 
		 sPara.put("subject","订单下载");	 
		 Map<String, String> map1 = AlipaySubmit.buildRequestPara(sPara);
		 Log.i("EV_JNI","Send1="+map1);
       try {          	       	                    	       	
           HttpRequester request = new HttpRequester();              
           String url = "https://mapi.alipay.com/gateway.do?" + "_input_charset=" + AlipayConfig.input_charset;           
           HttpRespons hr = request.sendPost(url, map1);
           //result=hr.getContent();
           strpicString=hr.getContent();	//得到图片字符串
           result=strpicString.substring(strpicString.indexOf("<pic_url>")+9, strpicString.indexOf("</pic_url>"));
		   //txt.setText(strpicString); // 清空内容编辑框	
		   Log.i("EV_JNI","rec1="+result);
		   //result=strpicString;
		   HttpClient httpClient=new DefaultHttpClient();
			HttpGet httprequest=new HttpGet(result);
			HttpResponse httpResponse;
			try {
				httpResponse=httpClient.execute(httprequest);
				if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK){	//如果请求成功
					//result = EntityUtils.toString(httpResponse.getEntity());	//获取返回的字符串
					//取得相关信息 取得HttpEntiy  
	                HttpEntity httpEntity = httpResponse.getEntity();  
	                //获得一个输入流  
	                InputStream is = httpEntity.getContent();  
	                bitmap = BitmapFactory.decodeStream(is);  
	                is.close();  
	                Message m = handler.obtainMessage(); // 获取一个Message
	                m.what=1;
					handler.sendMessage(m); // 发送消息
	                 
				}else{
					result = "请求失败！";
				}
			} catch (ClientProtocolException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
       } catch (Exception e) {  
           e.printStackTrace();  
       }
}
	
HttpRequester.java,HttpRespons.java文件：通过post方法发送到服务器，从服务器
接收
package com.example.alipay;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.Map;
import java.util.Vector;

import android.util.Log;

public class HttpRequester {
	private String defaultContentEncoding; 
	public HttpRequester() {  
        this.defaultContentEncoding = Charset.defaultCharset().name();  
    } 
	/** 
     * 发送GET请求 
     *  
     * @param urlString 
     *            URL地址 
     * @return 响应对象 
     * @throws IOException 
     */  
    public HttpRespons sendGet(String urlString) throws IOException {  
        return this.send(urlString, "GET", null, null);  
    }  
   
    /** 
     * 发送GET请求 
     *  
     * @param urlString 
     *            URL地址 
     * @param params 
     *            参数集合 
     * @return 响应对象 
     * @throws IOException 
     */  
    public HttpRespons sendGet(String urlString, Map<String, String> params)  
            throws IOException {  
        return this.send(urlString, "GET", params, null);  
    }  
   
    /** 
     * 发送GET请求 
     *  
     * @param urlString 
     *            URL地址 
     * @param params 
     *            参数集合 
     * @param propertys 
     *            请求属性 
     * @return 响应对象 
     * @throws IOException 
     */  
    public HttpRespons sendGet(String urlString, Map<String, String> params,  
            Map<String, String> propertys) throws IOException {  
        return this.send(urlString, "GET", params, propertys);  
    }  
   
    /** 
     * 发送POST请求 
     *  
     * @param urlString 
     *            URL地址 
     * @return 响应对象 
     * @throws IOException 
     */  
    public HttpRespons sendPost(String urlString) throws IOException {  
        return this.send(urlString, "POST", null, null);  
    }  
   
    /** 
     * 发送POST请求 
     *  
     * @param urlString 
     *            URL地址 
     * @param params 
     *            参数集合 
     * @return 响应对象 
     * @throws IOException 
     */  
    public HttpRespons sendPost(String urlString, Map<String, String> params)  
            throws IOException {  
        return this.send(urlString, "POST", params, null);  
    }  
   
    /** 
     * 发送POST请求 
     *  
     * @param urlString 
     *            URL地址 
     * @param params 
     *            参数集合 
     * @param propertys 
     *            请求属性 
     * @return 响应对象 
     * @throws IOException 
     */  
    public HttpRespons sendPost(String urlString, Map<String, String> params,  
            Map<String, String> propertys) throws IOException {  
        return this.send(urlString, "POST", params, propertys);  
    }  
   
    /** 
     * 发送HTTP请求 
     *  
     * @param urlString 
     * @return 响映对象 
     * @throws IOException 
     */  
    private HttpRespons send(String urlString, String method,  
            Map<String, String> parameters, Map<String, String> propertys)  
            throws IOException {  
        HttpURLConnection urlConnection = null;  
   
        if (method.equalsIgnoreCase("GET") && parameters != null) {  
            StringBuffer param = new StringBuffer();  
            int i = 0;  
            for (String key : parameters.keySet()) {  
                if (i == 0)  
                    param.append("?");  
                else  
                    param.append("&");  
                param.append(key).append("=").append(parameters.get(key));  
                i++;  
            }  
            urlString += param;  
        }  
        URL url = new URL(urlString);  
        urlConnection = (HttpURLConnection) url.openConnection();  
   
        urlConnection.setRequestMethod(method);  
        urlConnection.setDoOutput(true);  
        urlConnection.setDoInput(true);  
        urlConnection.setUseCaches(false);  
   
        if (propertys != null)  
            for (String key : propertys.keySet()) {  
                urlConnection.addRequestProperty(key, propertys.get(key));  
            }  
   
        if (method.equalsIgnoreCase("POST") && parameters != null) {  
            StringBuffer param = new StringBuffer();  
            for (String key : parameters.keySet()) {  
                param.append("&");  
                param.append(key).append("=").append(parameters.get(key));  
            }  
            Log.i("EV_JNI","Send2="+param.toString());
            urlConnection.getOutputStream().write(param.toString().getBytes());  
            urlConnection.getOutputStream().flush();  
            urlConnection.getOutputStream().close();  
        }  
   
        return this.makeContent(urlString, urlConnection);  
    }  
   
    /** 
     * 得到响应对象 
     *  
     * @param urlConnection 
     * @return 响应对象 
     * @throws IOException 
     */  
    private HttpRespons makeContent(String urlString,  
            HttpURLConnection urlConnection) throws IOException {  
        HttpRespons httpResponser = new HttpRespons();  
        try {  
            InputStream in = urlConnection.getInputStream();  
            BufferedReader bufferedReader = new BufferedReader(  
                    new InputStreamReader(in));  
            httpResponser.contentCollection = new Vector<String>();  
            StringBuffer temp = new StringBuffer();  
            String line = bufferedReader.readLine();  
            while (line != null) {  
                httpResponser.contentCollection.add(line);  
                temp.append(line).append("\r\n");  
                line = bufferedReader.readLine();  
            }  
            bufferedReader.close();  
   
            String ecod = urlConnection.getContentEncoding();  
            if (ecod == null)  
                ecod = this.defaultContentEncoding;  
   
            httpResponser.urlString = urlString;  
   
            httpResponser.defaultPort = urlConnection.getURL().getDefaultPort();  
            httpResponser.file = urlConnection.getURL().getFile();  
            httpResponser.host = urlConnection.getURL().getHost();  
            httpResponser.path = urlConnection.getURL().getPath();  
            httpResponser.port = urlConnection.getURL().getPort();  
            httpResponser.protocol = urlConnection.getURL().getProtocol();  
            httpResponser.query = urlConnection.getURL().getQuery();  
            httpResponser.ref = urlConnection.getURL().getRef();  
            httpResponser.userInfo = urlConnection.getURL().getUserInfo();  
   
            httpResponser.content = new String(temp.toString().getBytes(), ecod);  
            httpResponser.contentEncoding = ecod;  
            httpResponser.code = urlConnection.getResponseCode();  
            httpResponser.message = urlConnection.getResponseMessage();  
            httpResponser.contentType = urlConnection.getContentType();  
            httpResponser.method = urlConnection.getRequestMethod();  
            httpResponser.connectTimeout = urlConnection.getConnectTimeout();  
            httpResponser.readTimeout = urlConnection.getReadTimeout();  
   
            return httpResponser;  
        } catch (IOException e) {  
            throw e;  
        } finally {  
            if (urlConnection != null)  
                urlConnection.disconnect();  
        }  
    }  
   
    /** 
     * 默认的响应字符集 
     */  
    public String getDefaultContentEncoding() {  
        return this.defaultContentEncoding;  
    }  
   
    /** 
     * 设置默认的响应字符集 
     */  
    public void setDefaultContentEncoding(String defaultContentEncoding) {  
        this.defaultContentEncoding = defaultContentEncoding;  
    }  
}


package com.example.alipay;

import java.util.Vector;

public class HttpRespons {
	 String urlString;  
	   
	    int defaultPort;  
	   
	    String file;  
	   
	    String host;  
	   
	    String path;  
	   
	    int port;  
	   
	    String protocol;  
	   
	    String query;  
	   
	    String ref;  
	   
	    String userInfo;  
	   
	    String contentEncoding;  
	   
	    String content;  
	   
	    String contentType;  
	   
	    int code;  
	   
	    String message;  
	   
	    String method;  
	   
	    int connectTimeout;  
	   
	    int readTimeout;  
	   
	    Vector<String> contentCollection;  
	   
	    public String getContent() {  
	        return content;  
	    }  
	   
	    public String getContentType() {  
	        return contentType;  
	    }  
	   
	    public int getCode() {  
	        return code;  
	    }  
	   
	    public String getMessage() {  
	        return message;  
	    }  
	   
	    public Vector<String> getContentCollection() {  
	        return contentCollection;  
	    }  
	   
	    public String getContentEncoding() {  
	        return contentEncoding;  
	    }  
	   
	    public String getMethod() {  
	        return method;  
	    }  
	   
	    public int getConnectTimeout() {  
	        return connectTimeout;  
	    }  
	   
	    public int getReadTimeout() {  
	        return readTimeout;  
	    }  
	   
	    public String getUrlString() {  
	        return urlString;  
	    }  
	   
	    public int getDefaultPort() {  
	        return defaultPort;  
	    }  
	   
	    public String getFile() {  
	        return file;  
	    }  
	   
	    public String getHost() {  
	        return host;  
	    }  
	   
	    public String getPath() {  
	        return path;  
	    }  
	   
	    public int getPort() {  
	        return port;  
	    }  
	   
	    public String getProtocol() {  
	        return protocol;  
	    }  
	   
	    public String getQuery() {  
	        return query;  
	    }  
	   
	    public String getRef() {  
	        return ref;  
	    }  
	   
	    public String getUserInfo() {  
	        return userInfo;  
	    }  
}


4.微信发送请求，生成一串二维码的路径，注意，这次是通过post方法发送xml格式
的请求，而且返回的二维码路径，还需要自己找办法生成二维码
/**
     * 生成要请求给支付宝的参数数组
     * @param sParaTemp 请求前的参数数组
     * @return 要请求的参数数组
     */
    private String buildRequestPara(Map<String, String> sParaTemp,String key) {
    	//除去数组中的空值和签名参数
    	Map<String, String> paraMap = paraFilter(sParaTemp);
    	Log.i("EV_JNI","Send2="+paraMap);
        //生成签名结果
        String mysign = buildRequestMysign(paraMap,key);   
        return mysign;
    }
 // <summary>
 // 除去数组中的空值和签名参数并以字母a到z的顺序排序
 // </summary>
 // <param name="dicArrayPre">过滤前的参数组</param>
 // <returns>过滤后的参数组</returns>
public static Map<String, String> paraFilter(Map<String, String> sArray)
{

		Map<String, String> result = new TreeMap<String, String>();
		
		List<String> alllist=new ArrayList<String>();
        if (sArray == null || sArray.size() <= 0) {
            return result;
        }

        for (String key : sArray.keySet()) {
            String value = sArray.get(key);
            if (value == null || value.equals("") || key.equalsIgnoreCase("key")
                ) {
                continue;
            }             
            alllist.add(key);
        }
        
        String asc[]= alllist.toArray(new String[]{});
        for(int i=0; i<asc.length; i++)
        {
            for(int j=i+1; j<asc.length; j++)
            {

               if(asc[i].compareTo(asc[j])>0)
               {
                   String t = asc[i];
                   asc[i]=asc[j];
                   asc[j]=t;
               }
            }
        }
        for (String key : asc) 
        {  
        	//Log.i("EV_JNI",key + " = " + result.get(key));  
        	result.put(key, sArray.get(key));   
        }  
        
        return result;
}
 
//添加MD5校验生成签名结果
String buildRequestMysign(Map<String, String> mapArr,String key)
{
   String preStr = createLinkString(mapArr);
   preStr += "&key="+key;
   //Log.i("EV_JNI","Send3="+preStr);
    //默认 MD5校验
   String mysign=null;
   mysign=MD5.GetMD5Code(preStr).toUpperCase();
   //String mysign=md5(preStr.getBytes());
   Log.i("EV_JNI","Send4="+mysign);
   return mysign;
}
//把参数组中所有元素，按照“参数=参数值”的模式用“&”字符拼接成字符串
String createLinkString(Map<String, String> mapArr)
{
	StringBuilder prestr = new StringBuilder();
	//遍历内容
	Set<Map.Entry<String,String>> allset=mapArr.entrySet();  //实例化
    Iterator<Map.Entry<String,String>> iter=allset.iterator();
    while(iter.hasNext())
    {
        Map.Entry<String,String> me=iter.next();
        prestr.append(me.getKey() + "=" + me.getValue() + "&");
    }   
    //去掉最後一&字符
    String str=prestr.toString();
    //Log.i("EV_JNI","Send3.1="+str);
    int len = str.length();
    if(len > 0)
    	str=str.substring(0,len-1);
    //Log.i("EV_JNI","Send3.2="+str);
    return str;
}

//调用
public void sendwei() {
						
		Map<String, String> sPara = new HashMap<String, String>();
		 
		//可以使用的例子，这个例子是微信提供的demo
//		 sPara.put("appid","wxd930ea5d5a258f4f");
//		 sPara.put("auth_code","123456");//订单总金额
//		 sPara.put("body","test");//编码		
//		 sPara.put("device_info","123");//商户网站唯一订单号	
//		 sPara.put("mch_id","1900000109");
//		 sPara.put("nonce_str","960f228109051b9969f76c82bde183ac");	 
//		 sPara.put("out_trade_no", "1400755861");//卖家支付宝帐户
//		 sPara.put("spbill_create_ip", "127.0.0.1");//卖家支付宝帐户
//		 sPara.put("sub_mch_id", "124");
//		 sPara.put("total_fee", "1");//卖家支付宝帐户
//		 String sign=buildRequestPara(sPara);
//		 StringBuilder xml = new StringBuilder();
//	     xml.append("<xml>");
//	     xml.append("<appid>wxd930ea5d5a258f4f</appid>");
//	     xml.append("<auth_code>123456</auth_code>");
//	     xml.append("<body><![CDATA[test]]></body>");
//	     xml.append("<device_info>123</device_info>");
//	     xml.append("<mch_id>1900000109</mch_id>");
//	     xml.append("<nonce_str>960f228109051b9969f76c82bde183ac</nonce_str>");
//	     xml.append("<out_trade_no>1400755861</out_trade_no>");
//	     xml.append("<spbill_create_ip>127.0.0.1</spbill_create_ip>");
//	     xml.append("<sub_mch_id>124</sub_mch_id>");
//	     xml.append("<total_fee>1</total_fee>");
//	     xml.append("<sign><![CDATA["+sign+"]]></sign>");
//	     xml.append("</xml>");
		
		
		 sPara.put("appid","wx37a5d49081f487c4");
		 sPara.put("mch_id","10052966");
		 sPara.put("nonce_str","960f228109051b9969f76c82bde183ac");	 		 
		 sPara.put("body","test");//编码		
		 sPara.put("out_trade_no", "1400755861");//卖家支付宝帐户
		 sPara.put("total_fee", "1");//卖家支付宝帐户
		 sPara.put("spbill_create_ip", "127.0.0.1");//卖家支付宝帐户
		 sPara.put("notify_url", "127.0.0.1");//卖家支付宝帐户
		 sPara.put("trade_type","NATIVE");//商户网站唯一订单号	
		 String key="1bd78d29964553116c7c405dd87b2072";
		 String sign=buildRequestPara(sPara,key);
		 
		 StringBuilder xml = new StringBuilder();
	     xml.append("<xml>");
	     xml.append("<appid>wx37a5d49081f487c4</appid>");
	     xml.append("<mch_id>10052966</mch_id>");
	     xml.append("<nonce_str>960f228109051b9969f76c82bde183ac</nonce_str>");
	     xml.append("<body><![CDATA[test]]></body>");
	     xml.append("<out_trade_no>1400755861</out_trade_no>");
	     xml.append("<total_fee>1</total_fee>");
	     xml.append("<spbill_create_ip>127.0.0.1</spbill_create_ip>");	     
	     xml.append("<notify_url>127.0.0.1</notify_url>");	     
	     xml.append("<trade_type>NATIVE</trade_type>");
	     xml.append("<sign><![CDATA["+sign+"]]></sign>");
	     xml.append("</xml>");	
		
	     try {
	            byte[] xmlbyte = xml.toString().getBytes("UTF-8");
	            
	            Log.i("EV_JNI","Send5="+xml);

	            URL url = new URL("https://api.mch.weixin.qq.com/pay/unifiedorder");
	            
	            
	            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
	            conn.setConnectTimeout(5000);
	            conn.setDoOutput(true);// 允许输出
	            conn.setDoInput(true);
	            conn.setUseCaches(false);// 不使用缓存
	            conn.setRequestMethod("POST");
	            conn.setRequestProperty("Connection", "Keep-Alive");// 维持长连接
	            conn.setRequestProperty("Charset", "UTF-8");
	            conn.setRequestProperty("Content-Length",
	                    String.valueOf(xmlbyte.length));
	            conn.setRequestProperty("Content-Type", "text/xml; charset=UTF-8");
	            conn.setRequestProperty("X-ClientType", "2");//发送自定义的头信息

	            conn.getOutputStream().write(xmlbyte);
	            conn.getOutputStream().flush();
	            conn.getOutputStream().close();


	            if (conn.getResponseCode() != 200)
	                throw new RuntimeException("请求url失败");

	            InputStream is = conn.getInputStream();// 获取返回数据
	              

	            // 使用输出流来输出字符(可选)
	            ByteArrayOutputStream out = new ByteArrayOutputStream();
	            byte[] buf = new byte[1024];
	            int len;
	            while ((len = is.read(buf)) != -1) {
	                out.write(buf, 0, len);
	            }
	            strpicString = out.toString("UTF-8");
	            out.close();
	            
	           result=strpicString.substring(strpicString.indexOf("<code_url><![CDATA[")+19, strpicString.indexOf("]]></code_url>"));
	 		   //txt.setText(strpicString); // 清空内容编辑框	
	 		   Log.i("EV_JNI","rec1="+result);
	 		   
	           
	     } catch (Exception e) {
	            // TODO Auto-generated catch block
	            System.out.println(e);
	        }      

	     
	     

	}

5.微信退款，需要附加p12证书到ssl中，连接的时候添加ssl
需要导入包httpclient-4.3.4.jar
注意，是使用HttpsURLConnection  conn = (HttpsURLConnection) url.openConnection();
	
public void sendpayoutwei() throws Exception{
	final String SDCARD_DIR=File.separator+"sdcard"+File.separator+"cert";
	final String NOSDCARD_DIR=File.separator+"cert";
	File fileName=null;
	String  sDir =null,str=null;
	
	
	//首先判断sdcard是否插入
  String status = Environment.getExternalStorageState();
  if (status.equals(Environment.MEDIA_MOUNTED)) 
  {
	 sDir = SDCARD_DIR;;
  } 
  else
  {
	  sDir = NOSDCARD_DIR;
  }
 
 
  fileName=new File(sDir+File.separator+"apiclient_cert.p12");
 //如果存在，才读文件
  if(fileName.exists())
  {
	
	//指定读取证书格式为PKCS12
	KeyStore keyStore = KeyStore.getInstance("PKCS12");
	//读取本机存放的PKCS12证书文件
	FileInputStream instream = new FileInputStream(sDir+File.separator+"apiclient_cert.p12");
	try {
		//指定PKCS12的密码(商户ID)10052966
		keyStore.load(instream, "10052966".toCharArray());
		} finally {
		instream.close();
		}
		SSLContext sslcontext = SSLContexts.custom()
		.loadKeyMaterial(keyStore, "10052966".toCharArray()).build();
//    		//指定TLS版本
//    		SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
//    		sslcontext,new String[] { "TLSv1" },null,
//    		SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
//    		//设置httpclient的SSLSocketFactory
//    		CloseableHttpClient httpclient = HttpClients.custom()
//    		.setSSLSocketFactory(sslsf)
//    		.build();
		SSLSocketFactory ssl=sslcontext.getSocketFactory(); 
		//ssl=null;
  
	
	
	Map<String, String> sPara = new HashMap<String, String>();
	
	sPara.put("appid","wx37a5d49081f487c4");
	sPara.put("mch_id","10052966");
	sPara.put("nonce_str","960f228109051b9969f76c82bde183ac");	 		 
	sPara.put("out_trade_no", "1400755868");//卖家支付宝帐户
	sPara.put("out_refund_no", "2400755868");//卖家支付宝帐户
	sPara.put("total_fee", "1");//卖家支付宝帐户
	sPara.put("refund_fee", "1");//卖家支付宝帐户
	sPara.put("op_user_id", "10052966");//卖家支付宝帐户
	String key="1bd78d29964553116c7c405dd87b2072";
	String sign=buildRequestPara(sPara,key);
	
	StringBuilder xml = new StringBuilder();
	xml.append("<xml>");
	xml.append("<appid>wx37a5d49081f487c4</appid>");
	xml.append("<mch_id>10052966</mch_id>");
	xml.append("<nonce_str>960f228109051b9969f76c82bde183ac</nonce_str>");
	xml.append("<out_trade_no>1400755868</out_trade_no>");
	xml.append("<out_refund_no>2400755868</out_refund_no>");
	xml.append("<total_fee>1</total_fee>");
	xml.append("<refund_fee>1</refund_fee>");
	xml.append("<op_user_id>10052966</op_user_id>");
	xml.append("<sign><![CDATA["+sign+"]]></sign>");
	xml.append("</xml>");	
	
	try {
	byte[] xmlbyte = xml.toString().getBytes("UTF-8");
	
	Log.i("EV_JNI","Send5="+xml);
	
	URL url = new URL("https://api.mch.weixin.qq.com/secapi/pay/refund");
	
	
	HttpsURLConnection  conn = (HttpsURLConnection) url.openConnection();
	if(ssl!=null)
	{
		conn.setSSLSocketFactory(ssl);
	}
	conn.setConnectTimeout(5000);
	conn.setDoOutput(true);// 允许输出
	conn.setDoInput(true);
	conn.setUseCaches(false);// 不使用缓存
	conn.setRequestMethod("POST");
	conn.setRequestProperty("Connection", "Keep-Alive");// 维持长连接
	conn.setRequestProperty("Charset", "UTF-8");
	conn.setRequestProperty("Content-Length",
			String.valueOf(xmlbyte.length));
	conn.setRequestProperty("Content-Type", "text/xml; charset=UTF-8");
	conn.setRequestProperty("X-ClientType", "2");//发送自定义的头信息
	
	conn.getOutputStream().write(xmlbyte);
	conn.getOutputStream().flush();
	conn.getOutputStream().close();
	
	
	if (conn.getResponseCode() != 200)
		throw new RuntimeException("请求url失败");
	
	InputStream is = conn.getInputStream();// 获取返回数据
	  
	
	// 使用输出流来输出字符(可选)
	ByteArrayOutputStream out = new ByteArrayOutputStream();
	byte[] buf = new byte[1024];
	int len;
	while ((len = is.read(buf)) != -1) {
		out.write(buf, 0, len);
	}
	strpicString = out.toString("UTF-8");
	out.close();
	
	result=strpicString;
	//txt.setText(strpicString); // 清空内容编辑框	
	Log.i("EV_JNI","rec1="+result);
	Message m = handler.obtainMessage(); // 获取一个Message
	m.what=2;
	handler.sendMessage(m); // 发送消息
	
	} catch (Exception e) {
	// TODO Auto-generated catch block
	//System.out.println(e);
		Log.i("EV_JNI","recerr="+e);
	}      
	
  }
	
	
}	

6.超时时间的设置
1)urlConnection
urlConnection = (HttpURLConnection) url.openConnection();  
   
urlConnection.setRequestMethod(method);  
urlConnection.setConnectTimeout(9000);//设置连接主机超时（单位：毫秒）
urlConnection.setReadTimeout(3000);//设置从主机读取数据超时（单位：毫秒）
urlConnection.setDoOutput(true);  // 允许输出
urlConnection.setDoInput(true);  // 允许输入
urlConnection.setUseCaches(false);// 不使用缓存 

2)DefaultHttpClient:（单位：毫秒）
请求超时
httpclient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 60000); 
读取超时
httpclient.getParams().setParameter(CoreConnectionPNames.SO_TIMEOUT, 60000);

3)HttpClient（单位：毫秒）
HttpClient httpClient=new HttpClient(); 
链接超时
httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(60000);  
读取超时
httpClient.getHttpConnectionManager().getParams().setSoTimeout(60000)


7.Volley简介
我们平时在开发Android应用的时候不可避免地都需要用到网络技术，而多数情况下应用程序都会使用HTTP协议来发送和接收网络数据。Android系统中主要提供了两种方式来进行HTTP通信，HttpURLConnection和HttpClient，几乎在任何项目的代码中我们都能看到这两个类的身影，使用率非常高。
不过HttpURLConnection和HttpClient的用法还是稍微有些复杂的，如果不进行适当封装的话，很容易就会写出不少重复代码。于是乎，一些Android网络通信框架也就应运而生，比如说AsyncHttpClient，它把HTTP所有的通信细节全部封装在了内部，我们只需要简单调用几行代码就可以完成通信操作了。再比如Universal-Image-Loader，它使得在界面上显示网络图片的操作变得极度简单，开发者不用关心如何从网络上获取图片，也不用关心开启线程、回收图片资源等细节，Universal-Image-Loader已经把一切都做好了。
Android开发团队也是意识到了有必要将HTTP的通信操作再进行简单化，于是在2013年Google I/O大会上推出了一个新的网络通信框架――Volley。Volley可是说是把AsyncHttpClient和Universal-Image-Loader的优点集于了一身，既可以像AsyncHttpClient一样非常简单地进行HTTP通信，也可以像Universal-Image-Loader一样轻松加载网络上的图片。除了简单易用之外，Volley在性能方面也进行了大幅度的调整，它的设计目标就是非常适合去进行数据量不大，但通信频繁的网络操作，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕。
下图所示的这些应用都是属于数据量不大，但网络通信频繁的，因此非常适合使用Volley。

2. 下载Volley
介绍了这么多理论的东西，下面我们就准备开始进行实战了，首先需要将Volley的jar包准备好，如果你的电脑上装有Git，可以使用如下命令下载Volley的源码：
[plain] view plain copy 在CODE上查看代码片派生到我的代码片
git clone https://android.googlesource.com/platform/frameworks/volley  
下载完成后将它导入到你的Eclipse工程里，然后再导出一个jar包就可以了。如果你的电脑上没有Git，那么也可以直接使用我导出好的jar包，下载地址是：http://download.csdn.net/detail/sinyu890807/7152015 。
新建一个Android项目，将volley.jar文件复制到libs目录下，这样准备工作就算是做好了。
3. StringRequest的用法
前面已经说过，Volley的用法非常简单，那么我们就从最基本的HTTP通信开始学习吧，即发起一条HTTP请求，然后接收HTTP响应。首先需要获取到一个RequestQueue对象，可以调用如下方法获取到：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
RequestQueue mQueue = Volley.newRequestQueue(context);  
注意这里拿到的RequestQueue是一个请求队列对象，它可以缓存所有的HTTP请求，然后按照一定的算法并发地发出这些请求。RequestQueue内部的设计就是非常合适高并发的，因此我们不必为每一次HTTP请求都创建一个RequestQueue对象，这是非常浪费资源的，基本上在每一个需要和网络交互的Activity中创建一个RequestQueue对象就足够了。
接下来为了要发出一条HTTP请求，我们还需要创建一个StringRequest对象，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
StringRequest stringRequest = new StringRequest("http://www.baidu.com",  
                        new Response.Listener<String>() {  
                            @Override  
                            public void onResponse(String response) {  
                                Log.d("TAG", response);  
                            }  
                        }, new Response.ErrorListener() {  
                            @Override  
                            public void onErrorResponse(VolleyError error) {  
                                Log.e("TAG", error.getMessage(), error);  
                            }  
                        });  
可以看到，这里new出了一个StringRequest对象，StringRequest的构造函数需要传入三个参数，第一个参数就是目标服务器的URL地址，第二个参数是服务器响应成功的回调，第三个参数是服务器响应失败的回调。其中，目标服务器地址我们填写的是百度的首页，然后在响应成功的回调里打印出服务器返回的内容，在响应失败的回调里打印出失败的详细信息。
最后，将这个StringRequest对象添加到RequestQueue里面就可以了，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
mQueue.add(stringRequest);  
另外，由于Volley是要访问网络的，因此不要忘记在你的AndroidManifest.xml中添加如下权限：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
<uses-permission android:name="android.permission.INTERNET" />  
好了，就是这么简单，如果你现在运行一下程序，并发出这样一条HTTP请求，就会看到LogCat中会打印出如下图所示的数据。

没错，百度返回给我们的就是这样一长串的HTML代码，虽然我们看起来会有些吃力，但是浏览器却可以轻松地对这段HTML代码进行解析，然后将百度的首页展现出来。
这样的话，一个最基本的HTTP发送与响应的功能就完成了。你会发现根本还没写几行代码就轻易实现了这个功能，主要就是进行了以下三步操作：
1. 创建一个RequestQueue对象。
2. 创建一个StringRequest对象。
3. 将StringRequest对象添加到RequestQueue里面。
不过大家都知道，HTTP的请求类型通常有两种，GET和POST，刚才我们使用的明显是一个GET请求，那么如果想要发出一条POST请求应该怎么做呢？StringRequest中还提供了另外一种四个参数的构造函数，其中第一个参数就是指定请求类型的，我们可以使用如下方式进行指定：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
StringRequest stringRequest = new StringRequest(Method.POST, url,  listener, errorListener);  
可是这只是指定了HTTP请求方式是POST，那么我们要提交给服务器的参数又该怎么设置呢？很遗憾，StringRequest中并没有提供设置POST参数的方法，但是当发出POST请求的时候，Volley会尝试调用StringRequest的父类――Request中的getParams()方法来获取POST参数，那么解决方法自然也就有了，我们只需要在StringRequest的匿名类中重写getParams()方法，在这里设置POST参数就可以了，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
StringRequest stringRequest = new StringRequest(Method.POST, url,  listener, errorListener) {  
    @Override  
    protected Map<String, String> getParams() throws AuthFailureError {  
        Map<String, String> map = new HashMap<String, String>();  
        map.put("params1", "value1");  
        map.put("params2", "value2");  
        return map;  
    }  
};  
你可能会说，每次都这样用起来岂不是很累？连个设置POST参数的方法都没有。但是不要忘记，Volley是开源的，只要你愿意，你可以自由地在里面添加和修改任何的方法，轻松就能定制出一个属于你自己的Volley版本。
4. JsonRequest的用法
学完了最基本的StringRequest的用法，我们再来进阶学习一下JsonRequest的用法。类似于StringRequest，JsonRequest也是继承自Request类的，不过由于JsonRequest是一个抽象类，因此我们无法直接创建它的实例，那么只能从它的子类入手了。JsonRequest有两个直接的子类，JsonObjectRequest和JsonArrayRequest，从名字上你应该能就看出它们的区别了吧？一个是用于请求一段JSON数据的，一个是用于请求一段JSON数组的。
至于它们的用法也基本上没有什么特殊之处，先new出一个JsonObjectRequest对象，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
JsonObjectRequest jsonObjectRequest = new JsonObjectRequest("http://m.weather.com.cn/data/101010100.html", null,  
        new Response.Listener<JSONObject>() {  
            @Override  
            public void onResponse(JSONObject response) {  
                Log.d("TAG", response.toString());  
            }  
        }, new Response.ErrorListener() {  
            @Override  
            public void onErrorResponse(VolleyError error) {  
                Log.e("TAG", error.getMessage(), error);  
            }  
        });  
可以看到，这里我们填写的URL地址是http://m.weather.com.cn/data/101010100.html，这是中国天气网提供的一个查询天气信息的接口，响应的数据就是以JSON格式返回的，然后我们在onResponse()方法中将返回的数据打印出来。
最后再将这个JsonObjectRequest对象添加到RequestQueue里就可以了，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
mQueue.add(jsonObjectRequest);  
这样当HTTP通信完成之后，服务器响应的天气信息就会回调到onResponse()方法中，并打印出来。现在运行一下程序，发出这样一条HTTP请求，就会看到LogCat中会打印出如下图所示的数据。

由此可以看出，服务器返回给我们的数据确实是JSON格式的，并且onResponse()方法中携带的参数也正是一个JSONObject对象，之后只需要从JSONObject对象取出我们想要得到的那部分数据就可以了。
你应该发现了吧，JsonObjectRequest的用法和StringRequest的用法基本上是完全一样的，Volley的易用之处也在这里体现出来了，会了一种就可以让你举一反三，因此关于JsonArrayRequest的用法相信已经不需要我再去讲解了吧。

在上篇文章中有提到过，Volley是将AsyncHttpClient和Universal-Image-Loader的优点集成于一身的一个框架。我们都知道，Universal-Image-Loader具备非常强大的加载网络图片的功能，而使用Volley，我们也可以实现基本类似的效果，并且在性能上也豪不逊色于Universal-Image-Loader，下面我们就来具体学习一下吧。
1. ImageRequest的用法
前面我们已经学习过了StringRequest和JsonRequest的用法，并且总结出了它们的用法都是非常类似的，基本就是进行以下三步操作即可：
1. 创建一个RequestQueue对象。
2. 创建一个Request对象。
3. 将Request对象添加到RequestQueue里面。
其中，StringRequest和JsonRequest都是继承自Request的，所以它们的用法才会如此类似。那么不用多说，今天我们要学习的ImageRequest，相信你从名字上就已经猜出来了，它也是继承自Request的，因此它的用法也是基本相同的，首先需要获取到一个RequestQueue对象，可以调用如下方法获取到：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
RequestQueue mQueue = Volley.newRequestQueue(context);  
接下来自然要去new出一个ImageRequest对象了，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
ImageRequest imageRequest = new ImageRequest(  
        "http://developer.android.com/images/home/aw_dac.png",  
        new Response.Listener<Bitmap>() {  
            @Override  
            public void onResponse(Bitmap response) {  
                imageView.setImageBitmap(response);  
            }  
        }, 0, 0, Config.RGB_565, new Response.ErrorListener() {  
            @Override  
            public void onErrorResponse(VolleyError error) {  
                imageView.setImageResource(R.drawable.default_image);  
            }  
        });  
可以看到，ImageRequest的构造函数接收六个参数，第一个参数就是图片的URL地址，这个没什么需要解释的。第二个参数是图片请求成功的回调，这里我们把返回的Bitmap参数设置到ImageView中。第三第四个参数分别用于指定允许图片最大的宽度和高度，如果指定的网络图片的宽度或高度大于这里的最大值，则会对图片进行压缩，指定成0的话就表示不管图片有多大，都不会进行压缩。第五个参数用于指定图片的颜色属性，Bitmap.Config下的几个常量都可以在这里使用，其中ARGB_8888可以展示最好的颜色属性，每个图片像素占据4个字节的大小，而RGB_565则表示每个图片像素占据2个字节大小。第六个参数是图片请求失败的回调，这里我们当请求失败时在ImageView中显示一张默认图片。
最后将这个ImageRequest对象添加到RequestQueue里就可以了，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
mQueue.add(imageRequest);  
现在如果运行一下程序，并尝试发出这样一条网络请求，很快就能看到网络上的图片在ImageView中显示出来了，如下图所示：

2.Android Volley框架的几种post提交请求方式
1.客户端以普通的post方式进行提交,服务端返回字符串 
Java代码  收藏代码
RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext());  
  
StringRequest stringRequest = new StringRequest(Request.Method.POST,httpurl,  
    new Response.Listener<String>() {  
        @Override  
        public void onResponse(String response) {  
            Log.d(TAG, "response -> " + response);  
        }  
    }, new Response.ErrorListener() {  
        @Override  
        public void onErrorResponse(VolleyError error) {  
            Log.e(TAG, error.getMessage(), error);  
        }  
    }) {  
    @Override  
    protected Map<String, String> getParams() {  
        //在这里设置需要post的参数  
            Map<String, String> map = new HashMap<String, String>();    
            map.put("name1", "value1");    
            map.put("name2", "value2");    
  
        return params;  
    }  
};        
  
requestQueue.add(stringRequest);  

2.客户端以json串的post请求方式进行提交,服务端返回json串 
Java代码  收藏代码
RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext());  
  
Map<String, String> map = new HashMap<String, String>();    
map.put("name1", "value1");    
map.put("name2", "value2");    
  
JSONObject jsonObject = new JSONObject(params);  
JsonRequest<JSONObject> jsonRequest = new JsonObjectRequest(Method.POST,httpurl, jsonObject,  
    new Response.Listener<JSONObject>() {  
        @Override  
        public void onResponse(JSONObject response) {  
            Log.d(TAG, "response -> " + response.toString());  
  
        }  
    }, new Response.ErrorListener() {  
        @Override  
        public void onErrorResponse(VolleyError error) {  
            Log.e(TAG, error.getMessage(), error);  
    }  
    })  
    {  
    //注意此处override的getParams()方法,在此处设置post需要提交的参数根本不起作用  
    //必须象上面那样,构成JSONObject当做实参传入JsonObjectRequest对象里  
    //所以这个方法在此处是不需要的  
//  @Override  
//  protected Map<String, String> getParams() {                 
//          Map<String, String> map = new HashMap<String, String>();    
//          map.put("name1", "value1");    
//          map.put("name2", "value2");    
                  
//      return params;  
//  }  
              
    @Override  
    public Map<String, String> getHeaders() {  
        HashMap<String, String> headers = new HashMap<String, String>();  
        headers.put("Accept", "application/json");  
        headers.put("Content-Type", "application/json; charset=UTF-8");  
                  
        return headers;  
    }  
};  
requestQueue.add(jsonRequest);  

看了上面这段代码,会觉得volley这个框架实在是还不够完善,使用JsonObjectRequest对象提交一个post请求,如果有参数需要提交,就必须以JSONObject的json串方式提交. 
如果服务端并不支持这种方式呢?比如常见的spring mvc服务端,就很难支持json的请求方式. 
那么我们想实现这个目标,就需要使用下面给出的办法. 

3.客户端以普通的post方式进行提交,服务端返回json串 
首先在Activity类里,继承Request实现一个NormalPostRequest类 
Java代码  收藏代码
private class NormalPostRequest extends Request<JSONObject> {  
    private Map<String, String> mMap;  
    private Listener<JSONObject> mListener;  
  
    public NormalPostRequest(String url, Listener<JSONObject> listener,ErrorListener errorListener, Map<String, String> map) {  
        super(Request.Method.POST, url, errorListener);  
              
        mListener = listener;  
        mMap = map;  
    }  
      
    //mMap是已经按照前面的方式,设置了参数的实例  
    @Override  
    protected Map<String, String> getParams() throws AuthFailureError {  
        return mMap;  
    }  
      
    //此处因为response返回值需要json数据,和JsonObjectRequest类一样即可  
    @Override  
    protected Response<JSONObject> parseNetworkResponse(NetworkResponse response) {  
        try {  
            String jsonString = new String(response.data,HttpHeaderParser.parseCharset(response.headers));  
                  
            return Response.success(new JSONObject(jsonString),HttpHeaderParser.parseCacheHeaders(response));  
        } catch (UnsupportedEncodingException e) {  
            return Response.error(new ParseError(e));  
        } catch (JSONException je) {  
            return Response.error(new ParseError(je));  
        }  
    }  
  
    @Override  
    protected void deliverResponse(JSONObject response) {  
        mListener.onResponse(response);  
    }  
}  

接下来的调用方式和前面差不多,生成一个Request实例,加入队列中即可. 
Java代码  收藏代码
RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext());  
  
Request<JSONObject> request = new NormalPostRequest(httpurl,  
    new Response.Listener<JSONObject>() {  
        @Override  
        public void onResponse(JSONObject response) {  
            Log.d(TAG, "response -> " + response.toString());  
        }  
    }, new Response.ErrorListener() {  
        @Override  
        public void onErrorResponse(VolleyError error) {  
            Log.e(TAG, error.getMessage(), error);  
        }  
    }, params);  
  
requestQueue.add(request);  

2. ImageLoader的用法
如果你觉得ImageRequest已经非常好用了，那我只能说你太容易满足了 ^_^。实际上，Volley在请求网络图片方面可以做到的还远远不止这些，而ImageLoader就是一个很好的例子。ImageLoader也可以用于加载网络上的图片，并且它的内部也是使用ImageRequest来实现的，不过ImageLoader明显要比ImageRequest更加高效，因为它不仅可以帮我们对图片进行缓存，还可以过滤掉重复的链接，避免重复发送请求。
由于ImageLoader已经不是继承自Request的了，所以它的用法也和我们之前学到的内容有所不同，总结起来大致可以分为以下四步：
1. 创建一个RequestQueue对象。
2. 创建一个ImageLoader对象。
3. 获取一个ImageListener对象。
4. 调用ImageLoader的get()方法加载网络上的图片。
下面我们就来按照这个步骤，学习一下ImageLoader的用法吧。首先第一步的创建RequestQueue对象我们已经写过很多遍了，相信已经不用再重复介绍了，那么就从第二步开始学习吧，新建一个ImageLoader对象，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
ImageLoader imageLoader = new ImageLoader(mQueue, new ImageCache() {  
    @Override  
    public void putBitmap(String url, Bitmap bitmap) {  
    }  
  
    @Override  
    public Bitmap getBitmap(String url) {  
        return null;  
    }  
});  
可以看到，ImageLoader的构造函数接收两个参数，第一个参数就是RequestQueue对象，第二个参数是一个ImageCache对象，这里我们先new出一个空的ImageCache的实现即可。
接下来需要获取一个ImageListener对象，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
ImageListener listener = ImageLoader.getImageListener(imageView,  
        R.drawable.default_image, R.drawable.failed_image);  
我们通过调用ImageLoader的getImageListener()方法能够获取到一个ImageListener对象，getImageListener()方法接收三个参数，第一个参数指定用于显示图片的ImageView控件，第二个参数指定加载图片的过程中显示的图片，第三个参数指定加载图片失败的情况下显示的图片。
最后，调用ImageLoader的get()方法来加载图片，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
imageLoader.get("http://img.my.csdn.net/uploads/201404/13/1397393290_5765.jpeg", listener);  
get()方法接收两个参数，第一个参数就是图片的URL地址，第二个参数则是刚刚获取到的ImageListener对象。当然，如果你想对图片的大小进行限制，也可以使用get()方法的重载，指定图片允许的最大宽度和高度，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
imageLoader.get("http://img.my.csdn.net/uploads/201404/13/1397393290_5765.jpeg",  
                listener, 200, 200);  
现在运行一下程序并开始加载图片，你将看到ImageView中会先显示一张默认的图片，等到网络上的图片加载完成后，ImageView则会自动显示该图，效果如下图所示。

虽然现在我们已经掌握了ImageLoader的用法，但是刚才介绍的ImageLoader的优点却还没有使用到。为什么呢？因为这里创建的ImageCache对象是一个空的实现，完全没能起到图片缓存的作用。其实写一个ImageCache也非常简单，但是如果想要写一个性能非常好的ImageCache，最好就要借助Android提供的LruCache功能了，如果你对LruCache还不了解，可以参考我之前的一篇博客Android高效加载大图、多图解决方案，有效避免程序OOM。
这里我们新建一个BitmapCache并实现了ImageCache接口，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
public class BitmapCache implements ImageCache {  
  
    private LruCache<String, Bitmap> mCache;  
  
    public BitmapCache() {  
        int maxSize = 10 * 1024 * 1024;  
        mCache = new LruCache<String, Bitmap>(maxSize) {  
            @Override  
            protected int sizeOf(String key, Bitmap bitmap) {  
                return bitmap.getRowBytes() * bitmap.getHeight();  
            }  
        };  
    }  
  
    @Override  
    public Bitmap getBitmap(String url) {  
        return mCache.get(url);  
    }  
  
    @Override  
    public void putBitmap(String url, Bitmap bitmap) {  
        mCache.put(url, bitmap);  
    }  
  
}  
可以看到，这里我们将缓存图片的大小设置为10M。接着修改创建ImageLoader实例的代码，第二个参数传入BitmapCache的实例，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
ImageLoader imageLoader = new ImageLoader(mQueue, new BitmapCache());  
这样我们就把ImageLoader的功能优势充分利用起来了。
3. NetworkImageView的用法
除了以上两种方式之外，Volley还提供了第三种方式来加载网络图片，即使用NetworkImageView。不同于以上两种方式，NetworkImageView是一个自定义控制，它是继承自ImageView的，具备ImageView控件的所有功能，并且在原生的基础之上加入了加载网络图片的功能。NetworkImageView控件的用法要比前两种方式更加简单，大致可以分为以下五步：
1. 创建一个RequestQueue对象。
2. 创建一个ImageLoader对象。
3. 在布局文件中添加一个NetworkImageView控件。
4. 在代码中获取该控件的实例。
5. 设置要加载的图片地址。
其中，第一第二步和ImageLoader的用法是完全一样的，因此这里我们就从第三步开始学习了。首先修改布局文件中的代码，在里面加入NetworkImageView控件，如下所示：
[html] view plain copy 在CODE上查看代码片派生到我的代码片
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:layout_width="fill_parent"  
    android:layout_height="fill_parent"  
    android:orientation="vertical" >  
  
    <Button  
        android:id="@+id/button"  
        android:layout_width="wrap_content"  
        android:layout_height="wrap_content"  
        android:text="Send Request" />  
      
    <com.android.volley.toolbox.NetworkImageView   
        android:id="@+id/network_image_view"  
        android:layout_width="200dp"  
        android:layout_height="200dp"  
        android:layout_gravity="center_horizontal"  
        />  
  
</LinearLayout>  
接着在Activity获取到这个控件的实例，这就非常简单了，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
networkImageView = (NetworkImageView) findViewById(R.id.network_image_view);  
得到了NetworkImageView控件的实例之后，我们可以调用它的setDefaultImageResId()方法、setErrorImageResId()方法和setImageUrl()方法来分别设置加载中显示的图片，加载失败时显示的图片，以及目标图片的URL地址，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
networkImageView.setDefaultImageResId(R.drawable.default_image);  
networkImageView.setErrorImageResId(R.drawable.failed_image);  
networkImageView.setImageUrl("http://img.my.csdn.net/uploads/201404/13/1397393290_5765.jpeg",  
                imageLoader);  
其中，setImageUrl()方法接收两个参数，第一个参数用于指定图片的URL地址，第二个参数则是前面创建好的ImageLoader对象。
好了，就是这么简单，现在重新运行一下程序，你将看到和使用ImageLoader来加载图片一模一样的效果，这里我就不再截图了。
这时有的朋友可能就会问了，使用ImageRequest和ImageLoader这两种方式来加载网络图片，都可以传入一个最大宽度和高度的参数来对图片进行压缩，而NetworkImageView中则完全没有提供设置最大宽度和高度的方法，那么是不是使用NetworkImageView来加载的图片都不会进行压缩呢？
其实并不是这样的，NetworkImageView并不需要提供任何设置最大宽高的方法也能够对加载的图片进行压缩。这是由于NetworkImageView是一个控件，在加载图片的时候它会自动获取自身的宽高，然后对比网络图片的宽度，再决定是否需要对图片进行压缩。也就是说，压缩过程是在内部完全自动化的，并不需要我们关心，NetworkImageView会始终呈现给我们一张大小刚刚好的网络图片，不会多占用任何一点内存，这也是NetworkImageView最简单好用的一点吧。
当然了，如果你不想对图片进行压缩的话，其实也很简单，只需要在布局文件中把NetworkImageView的layout_width和layout_height都设置成wrap_content就可以了，这样NetworkImageView就会将该图片的原始大小展示出来，不会进行任何压缩。
这样我们就把使用Volley来加载网络图片的用法都学习完了，

可是Volley提供给我们的Request类型就只有这么多，而我们都知道，在网络上传输的数据通常有两种格式，JSON和XML，那么如果想要请求一条XML格式的数据该怎么办呢？其实很简单，Volley提供了非常强的扩展机制，使得我们可以很轻松地定制出任意类型的Request，这也就是本篇文章的主题了。
在开始之前还是友情提醒一下，如果你还没有阅读过我前面两篇关于Volley的文章，建议先去阅读一下Android Volley完全解析(一)，初识Volley的基本用法和Android Volley完全解析(二)，使用Volley加载网络图片。
1. 自定义XMLRequest
下面我们准备自定义一个XMLRequest，用于请求一条XML格式的数据。那么该从哪里开始入手呢？额，好像是有些无从下手。遇到这种情况，我们应该去参考一下Volley的源码，看一看StringRequest是怎么实现的，然后就可以模仿着写出XMLRequest了。首先看下StringRequest的源码，如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
/** 
 * A canned request for retrieving the response body at a given URL as a String. 
 */  
public class StringRequest extends Request<String> {  
    private final Listener<String> mListener;  
  
    /** 
     * Creates a new request with the given method. 
     * 
     * @param method the request {@link Method} to use 
     * @param url URL to fetch the string at 
     * @param listener Listener to receive the String response 
     * @param errorListener Error listener, or null to ignore errors 
     */  
    public StringRequest(int method, String url, Listener<String> listener,  
            ErrorListener errorListener) {  
        super(method, url, errorListener);  
        mListener = listener;  
    }  
  
    /** 
     * Creates a new GET request. 
     * 
     * @param url URL to fetch the string at 
     * @param listener Listener to receive the String response 
     * @param errorListener Error listener, or null to ignore errors 
     */  
    public StringRequest(String url, Listener<String> listener, ErrorListener errorListener) {  
        this(Method.GET, url, listener, errorListener);  
    }  
  
    @Override  
    protected void deliverResponse(String response) {  
        mListener.onResponse(response);  
    }  
  
    @Override  
    protected Response<String> parseNetworkResponse(NetworkResponse response) {  
        String parsed;  
        try {  
            parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));  
        } catch (UnsupportedEncodingException e) {  
            parsed = new String(response.data);  
        }  
        return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));  
    }  
}  
可以看到，StringRequest的源码很简练，根本就没几行代码，我们一起来分析下。首先StringRequest是继承自Request类的，Request可以指定一个泛型类，这里指定的当然就是String了，接下来StringRequest中提供了两个有参的构造函数，参数包括请求类型，请求地址，以及响应回调等，由于我们已经很熟悉StringRequest的用法了，相信这几个参数的作用都不用再解释了吧。但需要注意的是，在构造函数中一定要调用super()方法将这几个参数传给父类，因为HTTP的请求和响应都是在父类中自动处理的。
另外，由于Request类中的deliverResponse()和parseNetworkResponse()是两个抽象方法，因此StringRequest中需要对这两个方法进行实现。deliverResponse()方法中的实现很简单，仅仅是调用了mListener中的onResponse()方法，并将response内容传入即可，这样就可以将服务器响应的数据进行回调了。parseNetworkResponse()方法中则应该对服务器响应的数据进行解析，其中数据是以字节的形式存放在NetworkResponse的data变量中的，这里将数据取出然后组装成一个String，并传入Response的success()方法中即可。
了解了StringRequest的实现原理，下面我们就可以动手来尝试实现一下XMLRequest了，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
public class XMLRequest extends Request<XmlPullParser> {  
  
    private final Listener<XmlPullParser> mListener;  
  
    public XMLRequest(int method, String url, Listener<XmlPullParser> listener,  
            ErrorListener errorListener) {  
        super(method, url, errorListener);  
        mListener = listener;  
    }  
  
    public XMLRequest(String url, Listener<XmlPullParser> listener, ErrorListener errorListener) {  
        this(Method.GET, url, listener, errorListener);  
    }  
  
    @Override  
    protected Response<XmlPullParser> parseNetworkResponse(NetworkResponse response) {  
        try {  
            String xmlString = new String(response.data,  
                    HttpHeaderParser.parseCharset(response.headers));  
            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();  
            XmlPullParser xmlPullParser = factory.newPullParser();  
            xmlPullParser.setInput(new StringReader(xmlString));  
            return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response));  
        } catch (UnsupportedEncodingException e) {  
            return Response.error(new ParseError(e));  
        } catch (XmlPullParserException e) {  
            return Response.error(new ParseError(e));  
        }  
    }  
  
    @Override  
    protected void deliverResponse(XmlPullParser response) {  
        mListener.onResponse(response);  
    }  
  
}  
可以看到，其实并没有什么太多的逻辑，基本都是仿照StringRequest写下来的，XMLRequest也是继承自Request类的，只不过这里指定的泛型类是XmlPullParser，说明我们准备使用Pull解析的方式来解析XML。在parseNetworkResponse()方法中，先是将服务器响应的数据解析成一个字符串，然后设置到XmlPullParser对象中，在deliverResponse()方法中则是将XmlPullParser对象进行回调。
好了，就是这么简单，下面我们尝试使用这个XMLRequest来请求一段XML格式的数据。http://flash.weather.com.cn/wmaps/xml/china.xml这个接口会将中国所有的省份数据以XML格式进行返回，如下所示：
[html] view plain copy 在CODE上查看代码片派生到我的代码片
<china dn="day" slick-uniqueid="3">  
<city quName="黑龙江" pyName="heilongjiang" cityname="哈尔滨" state1="0" state2="0" stateDetailed="晴" tem1="18" tem2="6" windState="西北风3-4级转西风小于3级"/>  
<city quName="吉林" pyName="jilin" cityname="长春" state1="0" state2="0" stateDetailed="晴" tem1="19" tem2="6" windState="西北风3-4级转小于3级"/>  
<city quName="辽宁" pyName="liaoning" cityname="沈阳" state1="0" state2="0" stateDetailed="晴" tem1="21" tem2="7" windState="东北风3-4级"/>  
<city quName="海南" pyName="hainan" cityname="海口" state1="1" state2="1" stateDetailed="多云" tem1="30" tem2="24" windState="微风"/>  
<city quName="内蒙古" pyName="neimenggu" cityname="呼和浩特" state1="0" state2="0" stateDetailed="晴" tem1="19" tem2="5" windState="东风3-4级"/>  
<city quName="新疆" pyName="xinjiang" cityname="乌鲁木齐" state1="0" state2="0" stateDetailed="晴" tem1="22" tem2="10" windState="微风转东南风小于3级"/>  
<city quName="西藏" pyName="xizang" cityname="拉萨" state1="1" state2="7" stateDetailed="多云转小雨" tem1="18" tem2="4" windState="微风"/>  
<city quName="青海" pyName="qinghai" cityname="西宁" state1="0" state2="1" stateDetailed="晴转多云" tem1="18" tem2="2" windState="微风"/>  
<city quName="宁夏" pyName="ningxia" cityname="银川" state1="0" state2="0" stateDetailed="晴" tem1="19" tem2="8" windState="微风"/>  
<city quName="甘肃" pyName="gansu" cityname="兰州" state1="0" state2="0" stateDetailed="晴" tem1="21" tem2="6" windState="微风"/>  
<city quName="河北" pyName="hebei" cityname="石家庄" state1="0" state2="0" stateDetailed="晴" tem1="25" tem2="12" windState="北风小于3级"/>  
<city quName="河南" pyName="henan" cityname="郑州" state1="0" state2="0" stateDetailed="晴" tem1="24" tem2="13" windState="微风"/>  
<city quName="湖北" pyName="hubei" cityname="武汉" state1="0" state2="0" stateDetailed="晴" tem1="24" tem2="12" windState="微风"/>  
<city quName="湖南" pyName="hunan" cityname="长沙" state1="2" state2="1" stateDetailed="阴转多云" tem1="20" tem2="15" windState="北风小于3级"/>  
<city quName="山东" pyName="shandong" cityname="济南" state1="1" state2="1" stateDetailed="多云" tem1="20" tem2="10" windState="北风3-4级转小于3级"/>  
<city quName="江苏" pyName="jiangsu" cityname="南京" state1="2" state2="2" stateDetailed="阴" tem1="19" tem2="13" windState="西北风4-5级转3-4级"/>  
<city quName="安徽" pyName="anhui" cityname="合肥" state1="2" state2="1" stateDetailed="阴转多云" tem1="20" tem2="12" windState="西北风转北风3-4级"/>  
<city quName="山西" pyName="shanxi" cityname="太原" state1="0" state2="0" stateDetailed="晴" tem1="22" tem2="8" windState="微风"/>  
<city quName="陕西" pyName="sanxi" cityname="西安" state1="1" state2="0" stateDetailed="多云转晴" tem1="21" tem2="9" windState="东北风小于3级"/>  
<city quName="四川" pyName="sichuan" cityname="成都" state1="1" state2="1" stateDetailed="多云" tem1="26" tem2="15" windState="南风小于3级"/>  
<city quName="云南" pyName="yunnan" cityname="昆明" state1="7" state2="7" stateDetailed="小雨" tem1="21" tem2="13" windState="微风"/>  
<city quName="贵州" pyName="guizhou" cityname="贵阳" state1="1" state2="3" stateDetailed="多云转阵雨" tem1="21" tem2="11" windState="东风小于3级"/>  
<city quName="浙江" pyName="zhejiang" cityname="杭州" state1="3" state2="1" stateDetailed="阵雨转多云" tem1="22" tem2="14" windState="微风"/>  
<city quName="福建" pyName="fujian" cityname="福州" state1="1" state2="2" stateDetailed="多云转阴" tem1="28" tem2="18" windState="微风"/>  
<city quName="江西" pyName="jiangxi" cityname="南昌" state1="2" state2="1" stateDetailed="阴转多云" tem1="23" tem2="15" windState="北风3-4级转微风"/>  
<city quName="广东" pyName="guangdong" cityname="广州" state1="3" state2="2" stateDetailed="阵雨转阴" tem1="26" tem2="20" windState="微风"/>  
<city quName="广西" pyName="guangxi" cityname="南宁" state1="3" state2="3" stateDetailed="阵雨" tem1="23" tem2="19" windState="东北风小于3级"/>  
<city quName="北京" pyName="beijing" cityname="北京" state1="0" state2="0" stateDetailed="晴" tem1="26" tem2="10" windState="微风"/>  
<city quName="天津" pyName="tianjin" cityname="天津" state1="1" state2="0" stateDetailed="多云转晴" tem1="22" tem2="13" windState="东北风3-4级转小于3级"/>  
<city quName="上海" pyName="shanghai" cityname="上海" state1="7" state2="1" stateDetailed="小雨转多云" tem1="20" tem2="16" windState="西北风3-4级"/>  
<city quName="重庆" pyName="chongqing" cityname="重庆" state1="1" state2="3" stateDetailed="多云转阵雨" tem1="21" tem2="14" windState="微风"/>  
<city quName="香港" pyName="xianggang" cityname="香港" state1="3" state2="1" stateDetailed="阵雨转多云" tem1="26" tem2="22" windState="微风"/>  
<city quName="澳门" pyName="aomen" cityname="澳门" state1="3" state2="1" stateDetailed="阵雨转多云" tem1="27" tem2="22" windState="东北风3-4级转微风"/>  
<city quName="台湾" pyName="taiwan" cityname="台北" state1="9" state2="7" stateDetailed="大雨转小雨" tem1="28" tem2="21" windState="微风"/>  
<city quName="西沙" pyName="xisha" cityname="西沙" state1="3" state2="3" stateDetailed="阵雨" tem1="30" tem2="26" windState="东北风4-5级"/>  
<city quName="南沙" pyName="nanshadao" cityname="南沙" state1="1" state2="1" stateDetailed="多云" tem1="32" tem2="27" windState="东风4-5级"/>  
<city quName="钓鱼岛" pyName="diaoyudao" cityname="钓鱼岛" state1="7" state2="1" stateDetailed="小雨转多云" tem1="23" tem2="19" windState="西南风3-4级转北风5-6级"/>  
</china>  
确定了访问接口后，我们只需要在代码中按照以下的方式来使用XMLRequest即可：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
XMLRequest xmlRequest = new XMLRequest(  
        "http://flash.weather.com.cn/wmaps/xml/china.xml",  
        new Response.Listener<XmlPullParser>() {  
            @Override  
            public void onResponse(XmlPullParser response) {  
                try {  
                    int eventType = response.getEventType();  
                    while (eventType != XmlPullParser.END_DOCUMENT) {  
                        switch (eventType) {  
                        case XmlPullParser.START_TAG:  
                            String nodeName = response.getName();  
                            if ("city".equals(nodeName)) {  
                                String pName = response.getAttributeValue(0);  
                                Log.d("TAG", "pName is " + pName);  
                            }  
                            break;  
                        }  
                        eventType = response.next();  
                    }  
                } catch (XmlPullParserException e) {  
                    e.printStackTrace();  
                } catch (IOException e) {  
                    e.printStackTrace();  
                }  
            }  
        }, new Response.ErrorListener() {  
            @Override  
            public void onErrorResponse(VolleyError error) {  
                Log.e("TAG", error.getMessage(), error);  
            }  
        });  
mQueue.add(xmlRequest);  
可以看到，这里XMLRequest的用法和StringRequest几乎是一模一样的，我们先创建出一个XMLRequest的实例，并把服务器接口地址传入，然后在onResponse()方法中解析响应的XML数据，并把每个省的名字打印出来，最后将这个XMLRequest添加到RequestQueue当中。
现在运行一下代码，观察控制台日志，就可以看到每个省的名字都从XML中解析出来了，如下图所示。

2. 自定义GsonRequest
JsonRequest的数据解析是利用Android本身自带的JSONObject和JSONArray来实现的，配合使用JSONObject和JSONArray就可以解析出任意格式的JSON数据。不过也许你会觉得使用JSONObject还是太麻烦了，还有很多方法可以让JSON数据解析变得更加简单，比如说GSON。遗憾的是，Volley中默认并不支持使用自家的GSON来解析数据，不过没有关系，通过上面的学习，相信你已经知道了自定义一个Request是多么的简单，那么下面我们就来举一反三一下，自定义一个GsonRequest。
首先我们需要把gson的jar包添加到项目当中，jar包的下载地址是：https://code.google.com/p/google-gson/downloads/list 。
接着定义一个GsonRequest继承自Request，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
public class GsonRequest<T> extends Request<T> {  
  
    private final Listener<T> mListener;  
  
    private Gson mGson;  
  
    private Class<T> mClass;  
  
    public GsonRequest(int method, String url, Class<T> clazz, Listener<T> listener,  
            ErrorListener errorListener) {  
        super(method, url, errorListener);  
        mGson = new Gson();  
        mClass = clazz;  
        mListener = listener;  
    }  
  
    public GsonRequest(String url, Class<T> clazz, Listener<T> listener,  
            ErrorListener errorListener) {  
        this(Method.GET, url, clazz, listener, errorListener);  
    }  
  
    @Override  
    protected Response<T> parseNetworkResponse(NetworkResponse response) {  
        try {  
            String jsonString = new String(response.data,  
                    HttpHeaderParser.parseCharset(response.headers));  
            return Response.success(mGson.fromJson(jsonString, mClass),  
                    HttpHeaderParser.parseCacheHeaders(response));  
        } catch (UnsupportedEncodingException e) {  
            return Response.error(new ParseError(e));  
        }  
    }  
  
    @Override  
    protected void deliverResponse(T response) {  
        mListener.onResponse(response);  
    }  
  
}  
可以看到，GsonRequest是继承自Request类的，并且同样提供了两个构造函数。在parseNetworkResponse()方法中，先是将服务器响应的数据解析出来，然后通过调用Gson的fromJson方法将数据组装成对象。在deliverResponse方法中仍然是将最终的数据进行回调。
那么下面我们就来测试一下这个GsonRequest能不能够正常工作吧，调用http://www.weather.com.cn/data/sk/101010100.html这个接口可以得到一段JSON格式的天气数据，如下所示：
[plain] view plain copy 在CODE上查看代码片派生到我的代码片
{"weatherinfo":{"city":"北京","cityid":"101010100","temp":"19","WD":"南风","WS":"2级","SD":"43%","WSE":"2","time":"19:45","isRadar":"1","Radar":"JC_RADAR_AZ9010_JB"}}  
接下来我们使用对象的方式将这段JSON字符串表示出来。新建一个Weather类，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
public class Weather {  
  
    private WeatherInfo weatherinfo;  
  
    public WeatherInfo getWeatherinfo() {  
        return weatherinfo;  
    }  
  
    public void setWeatherinfo(WeatherInfo weatherinfo) {  
        this.weatherinfo = weatherinfo;  
    }  
  
}  
Weather类中只是引用了WeatherInfo这个类。接着新建WeatherInfo类，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
public class WeatherInfo {  
  
    private String city;  
  
    private String temp;  
  
    private String time;  
  
    public String getCity() {  
        return city;  
    }  
  
    public void setCity(String city) {  
        this.city = city;  
    }  
  
    public String getTemp() {  
        return temp;  
    }  
  
    public void setTemp(String temp) {  
        this.temp = temp;  
    }  
  
    public String getTime() {  
        return time;  
    }  
  
    public void setTime(String time) {  
        this.time = time;  
    }  
  
}  
WeatherInfo类中含有city、temp、time这几个字段。下面就是如何调用GsonRequest了，其实也很简单，代码如下所示：
[java] view plain copy 在CODE上查看代码片派生到我的代码片
GsonRequest<Weather> gsonRequest = new GsonRequest<Weather>(  
        "http://www.weather.com.cn/data/sk/101010100.html", Weather.class,  
        new Response.Listener<Weather>() {  
            @Override  
            public void onResponse(Weather weather) {  
                WeatherInfo weatherInfo = weather.getWeatherinfo();  
                Log.d("TAG", "city is " + weatherInfo.getCity());  
                Log.d("TAG", "temp is " + weatherInfo.getTemp());  
                Log.d("TAG", "time is " + weatherInfo.getTime());  
            }  
        }, new Response.ErrorListener() {  
            @Override  
            public void onErrorResponse(VolleyError error) {  
                Log.e("TAG", error.getMessage(), error);  
            }  
        });  
mQueue.add(gsonRequest);  
可以看到，这里onResponse()方法的回调中直接返回了一个Weather对象，我们通过它就可以得到WeatherInfo对象，接着就能从中取出JSON中的相关数据了。现在运行一下代码，观察控制台日志，打印数据如下图所示：

这样的话，XMLRequest和GsonRequest的功能就基本都实现了，我们也是借助这两个例子深刻地理解了自定义Request的方法，对Volley的认识也是更加深入了。好了，


3.他是类似放到缓存里面，然后统一回调中来处理，onResponse处理上传完成后的结果，类似
线程AsyncTask的onPostExecute方法，因此如果要连续发送，不能直接用for循环，要这样写
JSONArray productarr=null;
JSONArray zhuheproductArray=null;
JSONObject zhuheproductjson = null; 
int productint=0;
//分解商品信息
private void productArray(String classrst) throws JSONException
{
	JSONObject jsonObject = new JSONObject(classrst); 
	productarr=jsonObject.getJSONArray("ProductList");
	productint=0;
	zhuheproductArray=new JSONArray();
	zhuheproductjson = new JSONObject(); 
	if(productarr.length()==0)
	{
		//向主线程返回信息
		Message tomain=mainhand.obtainMessage();
		tomain.what=SETRODUCTMAIN;
		tomain.obj=zhuheproductjson.toString();
		mainhand.sendMessage(tomain); // 发送消息	
	}
}
//更新商品图片信息
private String updateproduct(int i) throws JSONException
{
	final JSONObject object2=productarr.getJSONObject(i);
	ToolClass.Log(ToolClass.INFO,"EV_SERVER","更新商品图片="+object2.toString(),"server.txt");										
	final JSONObject zhuheobj=object2;
	//第一步.获取商品图片名字
	String target6 = httpStr+"/api/productImage";	//要提交的目标地址
	JSONObject json=new JSONObject();
	try {
		json.put("VmcNo", vmc_no);
		json.put("attId", object2.getString("att_batch_id"));				
	} catch (JSONException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}					
	final String param6=json.toString();		
	ToolClass.Log(ToolClass.INFO,"EV_SERVER","Send2="+param6.toString(),"server.txt");
	//4.准备加载信息设置
	StringRequest stringRequest6 = new StringRequest(Method.POST, target6,  new Response.Listener<String>() {  
		@Override  
		public void onResponse(String response) {  				   
			//如果请求成功
			result = response;	//获取返回的字符串
			ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec1[ok10]="+result,"server.txt");
			try
			{
				//第二步，获取图片名字ATTID
				JSONObject jsonObject3 = new JSONObject(result); 
				JSONArray arr3=jsonObject3.getJSONArray("ProductImageList");
				JSONObject object3=arr3.getJSONObject(0);
				final String ATT_ID=object3.getString("ATT_ID");
				ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec2[ok10]ATT_ID="+ATT_ID,"server.txt");
				//ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec2[ok10]zhuheobj="+zhuheobj+"zhuheproductArray="+zhuheproductArray,"server.txt");
				//第三步，把图片名字保存到json中
				zhuheobj.put("AttImg", ToolClass.getImgFile(ATT_ID));
				zhuheproductArray.put(zhuheobj);
				if(ATT_ID.isEmpty())
				{
					ToolClass.Log(ToolClass.INFO,"EV_SERVER","商品["+object2.getString("product_Name")+"]无图片","server.txt");
				}
				else
				{
					if(ToolClass.isImgFile(ATT_ID))
					{
						ToolClass.Log(ToolClass.INFO,"EV_SERVER","商品["+object2.getString("product_Name")+"]图片已存在","server.txt");
					}
					else 
					{
						ToolClass.Log(ToolClass.INFO,"EV_SERVER","商品["+object2.getString("product_Name")+"]图片,下载图片...","server.txt");
						//第四步.准备下载	
						String url= httpStr+"/topic/getFile/"+ATT_ID + ".jpg";	//要提交的目标地址
						ImageRequest imageRequest = new ImageRequest(  
								url,  
								new Response.Listener<Bitmap>() {  
									@Override  
									public void onResponse(Bitmap response) {  
										ToolClass.saveBitmaptofile(response,ATT_ID);
										try {
											ToolClass.Log(ToolClass.INFO,"EV_SERVER","商品["+object2.getString("product_Name")+"]图片,下载图片完成","server.txt");
										} catch (JSONException e) {
											// TODO Auto-generated catch block
											e.printStackTrace();
										}
									}  
								}, 0, 0, Config.RGB_565, new Response.ErrorListener() {  
									@Override  
									public void onErrorResponse(VolleyError error) {  
										result = "请求失败！";
										try {
											ToolClass.Log(ToolClass.INFO,"EV_SERVER","商品["+object2.getString("product_Name")+"]图片,下载图片失败","server.txt");
										} catch (JSONException e) {
											// TODO Auto-generated catch block
											e.printStackTrace();
										}
									}  
								});
						mQueue.add(imageRequest); 
					}
					
				}
			}
			catch (JSONException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			
			
			//第五步：进行下一个商品信息
			productint++;
			if(productint<productarr.length())
			{
				try {
					updateproduct(productint);
				} catch (JSONException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			else
			{
				try {
					zhuheproductjson.put("ProductList", zhuheproductArray);
				} catch (JSONException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				ToolClass.Log(ToolClass.INFO,"EV_SERVER","reczhuhe="+zhuheproductjson.toString(),"server.txt");

				//上传给server
				//向主线程返回信息
				Message tomain4=mainhand.obtainMessage();
				tomain4.what=SETRODUCTMAIN;
				tomain4.obj=zhuheproductjson.toString();
				mainhand.sendMessage(tomain4); // 发送消息
			}
		}  
	}, new Response.ErrorListener() {  
		@Override  
		public void onErrorResponse(VolleyError error) {  
			result = "请求失败！";
			//第三步，把图片名字保存到json中
			try {
				zhuheobj.put("AttImg", "");
				zhuheproductArray.put(zhuheobj);
				zhuheproductjson.put("ProductList", zhuheproductArray);
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}				
			ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec2=[fail10]"+result,"server.txt");
			
			//上传给server
			//向主线程返回信息
			Message tomain4=mainhand.obtainMessage();
			tomain4.what=SETRODUCTMAIN;
			tomain4.obj=zhuheproductjson.toString();
			mainhand.sendMessage(tomain4); // 发送消息
		}  
	}) 
	{  
		@Override  
		protected Map<String, String> getParams() throws AuthFailureError {  
			//3.添加params
			Map<String, String> map = new HashMap<String, String>();  
			map.put("Token", Tok);  
			map.put("param", param6);
			ToolClass.Log(ToolClass.INFO,"EV_SERVER","Send3="+map.toString(),"server.txt");
			return map;  
	   }  
	}; 	
	//5.加载信息并发送到网络上
	mQueue.add(stringRequest6);	
	
	//zhuheproductjson.put("ProductList", zhuheproductArray);
	//ToolClass.Log(ToolClass.INFO,"EV_SERVER","reczhuhe="+zhuheproductjson.toString(),"server.txt");
	//return zhuheproductjson.toString();
	return "";
}



*Android 二维码 生成和识别ZXing
今天讲一下目前移动领域很常用的技术――二维码。现在大街小巷、各大网站都有二维码的踪迹，不管是IOS、Android、WP都有相关支持的软件。之前我就想了解二维码是如何工作，最近因为工作需要使用相关技术，所以做了初步了解。今天主要是讲解如何使用ZXing库，生成和识别二维码。这篇文章实用性为主，理论性不会讲解太多，有兴趣可以自己查看源码。

1、ZXing库介绍

　　这里简单介绍一下ZXing库。ZXing是一个开放源码的，用Java实现的多种格式的1D/2D条码图像处理库，它包含了联系到其他语言的端口。Zxing可以实现使用手机的内置的摄像头完成条形码的扫描及解码。该项目可实现的条形码编码和解码。目前支持以下格式：UPC-A，UPC-E、EAN-8，EAN-13、39码、93码。ZXing是个很经典的条码/二维码识别的开源类库，以前在功能机上，就有开发者使用J2ME运用ZXing了，不过要支持JSR-234规范(自动对焦)的手机才能发挥其威力。
2、ZXing库主要类

　　下面给大家介绍一下，ZXing库里面主要的类以及这些类的作用：

    CaptureActivity。这个是启动Activity 也就是扫描器。
    CaptureActivityHandler 解码处理类，负责调用另外的线程进行解码。
    DecodeThread 解码的线程。
    com.google.zxing.client.android.camera 包，摄像头控制包。
    ViewfinderView 自定义的View，就是我们看见的拍摄时中间的框框了。
3、使用ZXing生成二维码

　　下面针对二维码生成和解析做个简单介绍，至于详细的使用方法，建议大家还是自己看看源码，使用起来很简单，不过这个开源项目的代码，值得好好看看。首先给出二维码生成的方法：
//Edited by mythou
//http://www.cnblogs.com/mythou/
　　//要转换的地址或字符串,可以是中文
    public void createQRImage(String url)
    {
        try
        {
            //判断URL合法性
            if (url == null || "".equals(url) || url.length() < 1)
            {
                return;
            }
            Hashtable<EncodeHintType, String> hints = new Hashtable<EncodeHintType, String>();
            hints.put(EncodeHintType.CHARACTER_SET, "utf-8");
            //图像数据转换，使用了矩阵转换
            BitMatrix bitMatrix = new QRCodeWriter().encode(url, BarcodeFormat.QR_CODE, QR_WIDTH, QR_HEIGHT, hints);
            int[] pixels = new int[QR_WIDTH * QR_HEIGHT];
            //下面这里按照二维码的算法，逐个生成二维码的图片，
            //两个for循环是图片横列扫描的结果
            for (int y = 0; y < QR_HEIGHT; y++)
            {
                for (int x = 0; x < QR_WIDTH; x++)
                {
                    if (bitMatrix.get(x, y))
                    {
                        pixels[y * QR_WIDTH + x] = 0xff000000;
                    }
                    else
                    {
                        pixels[y * QR_WIDTH + x] = 0xffffffff;
                    }
                }
            }
            //生成二维码图片的格式，使用ARGB_8888
            Bitmap bitmap = Bitmap.createBitmap(QR_WIDTH, QR_HEIGHT, Bitmap.Config.ARGB_8888);
            bitmap.setPixels(pixels, 0, QR_WIDTH, 0, 0, QR_WIDTH, QR_HEIGHT);
            //显示到一个ImageView上面
            sweepIV.setImageBitmap(bitmap);
        }
        catch (WriterException e)
        {
            e.printStackTrace();
        }
    }
上面就是二维码生成的方法接口，如果你只是使用者方法，很简单，只要传入一个URL即可，就像我截图里面一样，传入一个合法的网址即可。或者像现在一些移动APP的推广，把APP下载地址转为二维码，只要扫一下就可以下载相应的APP。这个也是目前比较流行的APP的推广方式。

　　上面代码做的事情不多，主要是调用ZXing库里面QRCodeWriter().encode的方法对我们传进去的URL进行编码，具体如何编码，这个我这里就不详细说，有兴趣可以看ZXing的源码。文章最后会给出ZXing的源码和例子代码。

 

4、扫描二维码获取信息

　　扫描获取二维码信息的工作稍微复杂一些，主要是需要编写Camera的使用，这个跟我们一般使用Camera一样，需要使用Surfaceview作为预览，这一部我这里就不说了，这个应该不是太复杂。对于使用过Camera做预览的朋友，应该是挺简单的事情。获取二维码数据的关键处理是在Camera的自动对焦回调函数哪里，调用ZXing的解码接口。
//Edited by mythou//http://www.cnblogs.com/mythou/ 　　private void restartPreviewAndDecode() {
    if (state == State.SUCCESS) {
      state = State.PREVIEW;
      CameraManager.get().requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
      CameraManager.get().requestAutoFocus(this, R.id.auto_focus);
      activity.drawViewfinder();
    }
  }

这里稍微多说一句，由于解码需要一定时间，所以ZXing的解码调用，都是使用了Handler作为线程通信机制，解码的工作都是放在独立线程里面使用的，如果你直接在主线程解码，恐怕ANR问题是避免不了。
//Edited by mythou
//http://www.cnblogs.com/mythou/
public void handleMessage(Message message) {
    switch (message.what) {
      case R.id.auto_focus:
        //Log.d(TAG, "Got auto-focus message");
        // When one auto focus pass finishes, start another. This is the closest thing to
        // continuous AF. It does seem to hunt a bit, but I'm not sure what else to do.
        if (state == State.PREVIEW) {
          CameraManager.get().requestAutoFocus(this, R.id.auto_focus);
        }
        break;
      case R.id.restart_preview:
        Log.d(TAG, "Got restart preview message");
        restartPreviewAndDecode();
        break;
      case R.id.decode_succeeded:
　　　　//解码成功，获取到界面的结果和原来的二维码数据
        Log.d(TAG, "Got decode succeeded message");
        state = State.SUCCESS;
        Bundle bundle = message.getData();
        Bitmap barcode = bundle == null ? null :
            (Bitmap) bundle.getParcelable(DecodeThread.BARCODE_BITMAP);
        activity.handleDecode((Result) message.obj, barcode);
        break;
      case R.id.decode_failed:
        // We're decoding as fast as possible, so when one decode fails, start another.
        state = State.PREVIEW;
        CameraManager.get().requestPreviewFrame(decodeThread.getHandler(), R.id.decode);
        break;
      case R.id.return_scan_result:
        Log.d(TAG, "Got return scan result message");
        activity.setResult(Activity.RESULT_OK, (Intent) message.obj);
        activity.finish();
        break;
      case R.id.launch_product_query:
        Log.d(TAG, "Got product query message");
        String url = (String) message.obj;
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        activity.startActivity(intent);
        break;
    }
  }

上面是解码的线程处理不同状态的时候需要注意的地方，我们这里只看获取图像成功的地方，成功获取图片解码的实在DecodeThread里面实现，DecodeThread里面解码成功后，会把数据序列化，然后保存到Bundle里面，我们可以直接通过Bundle的序列化，获取到图片数据。同时会把解码后的结果保存到MSG里面，然后就可以根据实际情况进行处理，例如上面代码，解码成功后，会调用一个处理函数：
//Edited by mythou
//http://www.cnblogs.com/mythou/
　　public void handleDecode(final Result obj, Bitmap barcode)
    {
        inactivityTimer.onActivity();
        playBeepSoundAndVibrate();
        AlertDialog.Builder dialog = new AlertDialog.Builder(this);
        if (barcode == null)
        {
            dialog.setIcon(null);
        }
        else
        {

            Drawable drawable = new BitmapDrawable(barcode);
            dialog.setIcon(drawable);
        }
        dialog.setTitle("扫描结果");
        dialog.setMessage(obj.getText());
        dialog.setNegativeButton("确定", new DialogInterface.OnClickListener()
        {
            @Override
            public void onClick(DialogInterface dialog, int which)
            {
                //用默认浏览器打开扫描得到的地址
                Intent intent = new Intent();
                intent.setAction("android.intent.action.VIEW");
                Uri content_url = Uri.parse(obj.getText());
                intent.setData(content_url);
                startActivity(intent);
                finish();
            }
        });
        dialog.setPositiveButton("取消", new DialogInterface.OnClickListener()
        {
            @Override
            public void onClick(DialogInterface dialog, int which)
            {
                finish();
            }
        });
        dialog.create().show();
    }

上面就是整个二维码的解码流程，里面因为涉及很多Camera的使用，所以你如果需要使用二维码识别，需要注意一下你的程序需要申请下面的权限，一般的Camera使用以及Camera的自动对焦等。
//Edited by mythou//http://www.cnblogs.com/mythou/ <uses-permission android:name="android.permission.CAMERA"></uses-permission>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
<uses-feature android:name="android.hardware.camera" />
<uses-feature android:name="android.hardware.camera.autofocus" />

5、结语

　　上面就是生成和识别二维码的关键流程和代码，有兴趣的朋友可以自己查看ZXing的源码，里面有很多图像分析的知识可以学习。具体使用也可以参考我下面给出的Demo。二维码对于现在移动开发来说很是很常用的技术，所以有空可以了解一下，说不定什么时候就用上了。另外，ZXing库除了二维码外，其实对于条形码也是支持的，只是我这里没有介绍。有需要的自己去看看源码即可。	
	
	

*ContentProvider组件:不同程序之间需要数据交换，就需要将文本数据或者数据库数据保存到这个
组件中。例如打电话的应用调用电话本的应用
将不同的应用程序的数据的操作标准统一起来，并且提供给其他程序
1原理
1)、ContentProvider使用表的形式来组织数据
　　 无论数据的来源是什么，ContentProvider都会认为是一种表，然后把数据组织成表格
2)、ContentProvider提供的方法
　　 query：查询
　　 insert：插入
　　 update：更新
　　 delete：删除
　　 getType：得到数据类型
　　 onCreate：创建数据时调用的回调函数
3)、每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。Android所提供的ContentProvider都存放在android.provider包当中

2.获取系统提供的ContentProvider，例如联系人，通话记录等
ContentResolver resolver = getContentResolver();
//获取联系人
Cursor cursor=resolver.query(ContactsContract.RawContacts.CONTENT_URI, null, null, null, null);
String str=null;
while(cursor.moveToNext())
{
	String s1=cursor.getString(0);
	String s2=cursor.getString(16);
	String s3=cursor.getString(17);
	str+="("+s1+s2+s3+")";
} 
//txt.setText(str);
Log.i("txt", str);

3.手工构建Uri
1)原理
content://com.example.transportation/trains/122
  标识        包名               这张数据表名 数据id

2)例：
String uristr="content://com.android.contacts/raw_contacts";
Uri uri=Uri.parse(uristr);
ContentResolver resolver = getContentResolver();
//获取联系人
Cursor cursor=resolver.query(uri, null, null, null, null);
 
3)UriMatcher 是Uri路径匹配判断是否正确
boolean match=false;
UriMatcher um=new UriMatcher(-1);
um.addURI("content://com.android.contacts","raw_contacts",1);//匹配到这个程度，返回1
um.addURI("content://com.android.contacts","raw_contacts/#",2);//匹配到这个程度，返回2,其中#是通配符，代表数字 
int code=um.match(uri);
if(code==1||code==2)
	reutn true;
else
	return false;

4)提取uri中id部分
long per=ContentUris.parseId(uri);

4.ContentResolver操作
//1.添加一个联系人，并得到id的值
ContentValues value1=new ContentValues();
 value1.put("display_name","zhang3");
 Uri newuri=resolver.insert(uri, value1); 
 long newid=ContentUris.parseId(newuri); 
 //2.删除
 resolver.delete(uri, "display_name is null", null);
 //3.修改
 ContentValues value2=new ContentValues();
 value2.put("display_name","zhang3");
 resolver.update(uri, value2, "display_name=? and type=?", new String[]{"zhaoliu","dd"});	

5.使用Content Provider对外共享数据的步骤
1>继承ContentProvider类并根据需求重写以下方法:
public boolean onCreate();//处理初始化操作

       /**
        * 插入数据到内容提供者(允许其他应用向你的应用中插入数据时重写)
        * @param uri
        * @param initialValues 插入的数据
        * @return
        */
       public Uri insert(Uri uri, ContentValues initialValues);

       /**
        * 从内容提供者中删除数据(允许其他应用删除你应用的数据时重写)
        * @param uri
        * @param selection 条件语句
        * @param selectionArgs 参数
        * @return
        */
       public int delete(Uri uri, String selection, String[] selectionArgs);

       /**
        * 更新内容提供者已存在的数据(允许其他应用更新你应用的数据时重写)
        * @param uri
        * @param values 更新的数据
        * @param selection 条件语句
        * @param selectionArgs 参数
        * @return
        */
       public int update(Uri uri, ContentValues values, String selection,
                     String[] selectionArgs);

       /**
        * 返回数据给调用者(允许其他应用从你的应用中获取数据时重写)
        * @param uri
        * @param projection 列名
        * @param selection 条件语句
        * @param selectionArgs 参数
        * @param sortOrder 排序
        * @return
        */
       public Cursor query(Uri uri, String[] projection, String selection,
                     String[] selectionArgs, String sortOrder) ;         

       /**
        * 用于返回当前Uri所代表数据的MIME类型
        * 如果操作的数据为集合类型(多条数据),那么返回的类型字符串应该为vnd.android.cursor.dir/开头
        * 例如要得到所有person记录的Uri为content://com.bravestarr.provider.personprovider/person,
　　　　 *　　　那么返回的MIME类型字符串应该为"vnd.android.cursor.dir/person"
        * 如果操作的数据为单一数据,那么返回的类型字符串应该为vnd.android.cursor.item/开头
        * 例如要得到id为10的person记录的Uri为content://com.bravestarr.provider.personprovider/person/10,
　　　　 *　　　那么返回的MIME类型字符串应该为"vnd.android.cursor.item/person"
        * @param uri
        */
       public String getType(Uri uri)

2>在AndroidManifest.xml中使用<provider>对ContentProvider进行配置注册(内容提供者注册它自己就像网站注册域名),ContentProvider采用authoritie(原意授权,可理解为域名)作为唯一标识,方便其他应用能找到
<application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <!-- authorities属性命名建议:公司名.provider.SomeProvider-->
        <provider android:name=".PersonProvider" android:authorities="com.bravestarr.provider.personprovider"/>
         ...
</application>	   

*Intent组件:一个程序由多个Activity组成，由Intent进行多个Activity的通讯
1.基本操作
1)send发送数据，然后跳转到rece页面，同时显示数据
send页面:启动startActivity--Intent-->rece页面:

send文件
private class OnClickListenersend implements OnClickListener
{

	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		Intent it=new Intent(Send.this,rece.class);//实例化一个intent
		it.putExtra("myinfo", "你好魔法学院");//要传的值
		Send.this.startActivity(it);//跳转
	}
	
}
rece文件
this.recetxt = (TextView) super.findViewById(R.id.recetxt);
Intent it=super.getIntent();//取得当前的intent
String info=it.getStringExtra("myinfo");//得到数据
this.recetxt.setText(info);

在AndroidManifest.xml文件中添加页面
//先加载send页面
<activity
	android:name="com.example.intentprj.Send"
	android:label="@string/app_name" >
	<intent-filter>
		<action android:name="android.intent.action.MAIN" />

		<category android:name="android.intent.category.LAUNCHER" />
	</intent-filter>
</activity> 
//rece页面作为从页面
<activity
	android:name="com.example.intentprj.rece"
	android:label="@string/app_name" >            
</activity>

2)send发送数据，然后跳转到rece页面，同时显示数据。然后rece页面通过操作，再返回send页面
send页面:启动startActivityForResult()--Intent-->rece页面:通过setResult()设置返回的状态
                 |                                              |
                 |<-------------Intent--finish()关闭当前Activity,调用onActivityResult()

send文件
private class OnClickListenersend implements OnClickListener
{

	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		Intent it=new Intent(Send.this,rece.class);//实例化一个intent
		it.putExtra("myinfo", "你好魔法学院");//要传的值
		Send.this.startActivityForResult(it, 1);//跳转，参数1是写死的
	}
	
}

@Override
protected void onActivityResult(int requestCode,int resultCode,Intent data)
{
	switch(resultCode)
	{
		case  RESULT_OK:
			Send.this.recmsg.setText("返回:"+data.getStringExtra("retmsg"));
			break;
		case  RESULT_CANCELED:
			Send.this.recmsg.setText("操作取消");
			break;	
	} 
}
rece文件
@Override
protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	super.setContentView(R.layout.rece_main);
	this.recetxt = (TextView) super.findViewById(R.id.recetxt);
	Intent it=super.getIntent();//取得当前的intent
	String info=it.getStringExtra("myinfo");//得到数据
	this.recetxt.setText(info);
	this.returnmsg = (Button) super.findViewById(R.id.returnmsg);
	this.returnmsg.setOnClickListener(new OnClickListenerreturnmsg());
}

private class OnClickListenerreturnmsg implements OnClickListener
{

	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		rece.this.getIntent().putExtra("retmsg", "邓布利多教授");
		rece.this.setResult(RESULT_OK,rece.this.getIntent());
		rece.this.finish();
	}

}

3).其他Intent操作
(1)例如打开网页
Uri  uri=Uri.parse("http://www.baidu.com");
Intent it=new Intent();//实例化一个intent
it.setAction(Intent.ACTION_VIEW);//设置要操作的Action
it.setData(uri);//要设置的数据
Send.this.startActivity(it);//跳转
(2)调用拨打电话
String tel=Send.this.recmsg.getText().toString();
Uri  uri=Uri.parse("tel:"+tel);
Intent it=new Intent();//实例化一个intent
it.setAction(Intent.ACTION_DIAL);//设置要操作的Action，表示调用拨打电话的页面
it.setData(uri);//要设置的数据
Send.this.startActivity(it);//跳转

要想直接拨出电话
it.setAction(Intent.ACTION_CALL);//设置要操作的Action，表示直接拨打电话出去
<uses-permission android:name="android.permission.CALL_PHONE"/>

(3)发送短信
String tel=Send.this.recmsg.getText().toString();
String note=Send.this.notemsg.getText().toString();
Uri  uri=Uri.parse("smsto:"+tel);
Intent it=new Intent();//实例化一个intent
it.setAction(Intent.ACTION_SENDTO);//设置要操作的Action，表示调用拨打电话的页面
it.putExtra("sms_body",note);//附加信息设置短信内容
it.setType("vnd:android-dir/mms-sms");//设置短信的MIME类型
it.setData(uri);//要设置的数据
Send.this.startActivity(it);//跳转

(4)发送彩信
// TODO Auto-generated method stub			
String tel=MainActivity.this.sendmsg.getText().toString();
String note="hello world你好魔法学院";
Uri  uri=Uri.parse("file:////sdcard/mypic.jpg");
Intent it=new Intent();//实例化一个intent
it.setAction(Intent.ACTION_SEND);//设置要操作的Action，表示调用拨打电话的页面
it.putExtra("address",tel);//附加信息设置发送地址
it.putExtra("sms_body",note);//附加信息设置发送文字信息
it.putExtra(Intent.EXTRA_STREAM,uri);//附加信息设置发送图片信息
it.setType("image/png");//设置短信的MIME类型			
MainActivity.this.startActivity(it);//跳转

(5)调用电话本,通过选择的联系人来得到他的电话号码
设置权限
<uses-permission android:name="android.permission.READ_CONTACTS"/>

protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
	setContentView(R.layout.activity_main);
	Uri  uri=Uri.parse("content://contacts/people");
	Intent intent=new Intent(Intent.ACTION_PICK,uri);//实例化一个intent
	super.startActivityForResult(intent, PICK);//跳转,显示通讯录
}

@Override
protected void onActivityResult(int requestCode,int resultCode,Intent data)
{
	switch(resultCode)
	{
		case  PICK:
			Uri ret=data.getData();//接收返回的数据
			String phone=ContactsContract.CommonDataKinds.Phone.CONTACT_ID + "=?";//设置查询条件
			String phoneargs[]={String.valueOf(ContentUris.parseId(ret))};//返回的ID
			Cursor c=super.managedQuery(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
					null, phone, phoneargs, null);//设置游标
			StringBuffer buffer=new StringBuffer();
			buffer.append("phone=");
			//通过游标来一条条读取,找到电话号码
			for(c.moveToFirst();!c.isAfterLast();c.moveToNext())
			{
				buffer.append(c.getString(c.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))).append(",");
			}
			Toast.makeText(this, buffer, Toast.LENGTH_LONG).show();
			break;
		case  RESULT_CANCELED:
			break;	
	} 
}

(6)询问需要通过什么软件来打开此操作
Intent intent=new Intent();
intent.setAction(Intent.ACTION_GET_CONTENT);
intent.setType("image/*");
MainActivity.this.startActivity(Intent.createChooser(intent, "选择图片浏览工具"));


*Service服务
Service服务是一个没有界面的Activity程序，当需要做一些很消耗时间的操作时，Activity就转给Service，让他在后台完成。执行某些需要跨进程访问的操作也可以使用
1.创建简单服务
timeservice文件
public class timeservice extends Service {

	public timeservice() {
		// TODO Auto-generated constructor stub
	}

	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void onCreate() {
		// TODO Auto-generated method stub
		Log.i("currenttime","service start");
	}

	@Override
	public void onDestroy() {
		// TODO Auto-generated method stub
		Log.i("currenttime","service stop");
	}

	@Override
	//接收intent,实现服务
	public int onStartCommand(Intent intent, int flags, int startId) {
		// TODO Auto-generated method stub
		Time time=new Time();
		time.setToNow();
		String currenttime=time.format("%Y-%m-%d %H:%M:%S");
		Log.i("currenttime",currenttime);
		return Service.START_CONTINUATION_MASK;//继续执行
	}
	
	

}

MainActivity文件
btn=(Button)findViewById(R.id.btn);
		btn.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				startService(new Intent(MainActivity.this,timeservice.class));
				//startService(new Intent(MainActivity.this, CurrentTimeService.class));// 启动服务
			}
		});
		btnstop=(Button)findViewById(R.id.btnstop);
		btnstop.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				stopService(new Intent(MainActivity.this,timeservice.class));
				//startService(new Intent(MainActivity.this, CurrentTimeService.class));// 启动服务
			}
		});
		
2.需要服务绑定Activity，用来服务与Activity之间的调用和返回(服务常绑定会出错，没有关系)
public class timeservice extends Service {
	private IBinder myBinder=new Binder()  //1.创建IBinder对象并复写里面方法
	{
		@Override
		public String getInterfaceDescriptor() {
			// TODO Auto-generated method stub
			return "MytimeService";
		}
		
	};
	public timeservice() {
		// TODO Auto-generated constructor stub
	}
	
	@Override
	public IBinder onBind(Intent intent) {//2.返回IBinder对象给activity调用
		// TODO Auto-generated method stub
		Log.i("currenttime","service onBind");
		return this.myBinder;
	}
	
	
	@Override
	public void onRebind(Intent intent) {
		Log.i("currenttime","service onReBind");
		super.onRebind(intent);
	}

	@Override
	public boolean onUnbind(Intent intent) {
		Log.i("currenttime","service onUnBind");
		return super.onUnbind(intent);
	}

	@Override
	public void onCreate() {
		// TODO Auto-generated method stub
		Log.i("currenttime","service start");
	}

	@Override
	public void onDestroy() {
		// TODO Auto-generated method stub
		Log.i("currenttime","service stop");
	}

	@Override
	//接收intent,实现服务
	public int onStartCommand(Intent intent, int flags, int startId) {
		// TODO Auto-generated method stub
		Time time=new Time();
		time.setToNow();
		String currenttime=time.format("%Y-%m-%d %H:%M:%S");
		Log.i("currenttime",currenttime);
		return Service.START_CONTINUATION_MASK;//继续执行
	}
	
	

}

MainActivity调用服务
public class MainActivity extends Activity {
	Button btn=null,btnstop=null,btnbind=null,btnunbund=null;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		btn=(Button)findViewById(R.id.btn);
		btn.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				startService(new Intent(MainActivity.this,timeservice.class));
				//startService(new Intent(MainActivity.this, CurrentTimeService.class));// 启动服务
			}
		});
		btnstop=(Button)findViewById(R.id.btnstop);
		btnstop.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				stopService(new Intent(MainActivity.this,timeservice.class));
				//startService(new Intent(MainActivity.this, CurrentTimeService.class));// 停止服务
			}
		});
		//绑定服务
		btnbind=(Button)findViewById(R.id.btnbind);
		btnbind.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				Intent intent=new Intent(MainActivity.this,timeservice.class);
				bindService(intent, conn, Context.BIND_AUTO_CREATE);
			}
		});
		//解绑服务
		btnunbund=(Button)findViewById(R.id.btnunbund);
		btnunbund.setOnClickListener(new View.OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				unbindService(conn);
			}
		});
	}
	//绑定的接口
	private ServiceConnection conn=new ServiceConnection()
	{

		@Override
		public void onServiceConnected(ComponentName name, IBinder service) {
			// TODO Auto-generated method stub
			try {
				Log.i("currenttime","service onBindSUC="+service.getInterfaceDescriptor());
			} catch (RemoteException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		@Override
		public void onServiceDisconnected(ComponentName name) {
			// TODO Auto-generated method stub
			Log.i("currenttime","service onBindFail");
		}
		
	};
}

1)点击start服务，打印
01-12 17:00:24.714: INFO/currenttime(18109): service start
01-12 17:00:24.720: INFO/currenttime(18109): 2015-01-12 17:00:24

2)然后点击bind，绑定Activity与service,打印
01-12 17:01:26.395: INFO/currenttime(18109): service onBind
01-12 17:01:26.399: INFO/currenttime(18109): service onBindSUC=MytimeService
打印的MytimeService，说明服务返回回调信息给Activity

3)不打开服务而直接绑定，会打印
01-12 17:00:24.714: INFO/currenttime(18109): service start
01-12 17:01:26.395: INFO/currenttime(18109): service onBind
01-12 17:01:26.399: INFO/currenttime(18109): service 
说明会自动打开服务和绑定

4）不停止，直接退出，会自动解绑定和自动关闭服务
01-12 17:00:24.714: INFO/currenttime(18109): service unbind
01-12 17:01:26.395: INFO/currenttime(18109): service destroy

5）返回到Activity,他会重新绑定


3.Service的基本用法
关于Service最基本的用法自然就是如何启动一个Service了，启动Service的方法和启动Activity很类似，都需要借助Intent来实现，下面我们就通过一个具体的例子来看一下。
新建一个Android项目，项目名就叫ServiceTest，这里我选择使用4.0的API。
然后新建一个MyService继承自Service，并重写父类的onCreate()、onStartCommand()和onDestroy()方法，如下所示：
[java] view plain copy
public class MyService extends Service {  
  
    public static final String TAG = "MyService";  
  
    @Override  
    public void onCreate() {  
        super.onCreate();  
        Log.d(TAG, "onCreate() executed");  
    }  
  
    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        Log.d(TAG, "onStartCommand() executed");  
        return super.onStartCommand(intent, flags, startId);  
    }  
      
    @Override  
    public void onDestroy() {  
        super.onDestroy();  
        Log.d(TAG, "onDestroy() executed");  
    }  
  
    @Override  
    public IBinder onBind(Intent intent) {  
        return null;  
    }  
  
}  
可以看到，我们只是在onCreate()、onStartCommand()和onDestroy()方法中分别打印了一句话，并没有进行其它任何的操作。
然后打开或新建activity_main.xml作为程序的主布局文件，代码如下所示：
[html] view plain copy
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:orientation="vertical" >  
  
    <Button  
        android:id="@+id/start_service"  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:text="Start Service" />  
  
    <Button  
        android:id="@+id/stop_service"  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:text="Stop Service" />  
  
</LinearLayout>  
我们在布局文件中加入了两个按钮，一个用于启动Service，一个用于停止Service。
然后打开或新建MainActivity作为程序的主Activity，在里面加入启动Service和停止Service的逻辑，代码如下所示：
[java] view plain copy
public class MainActivity extends Activity implements OnClickListener {  
  
    private Button startService;  
  
    private Button stopService;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        startService = (Button) findViewById(R.id.start_service);  
        stopService = (Button) findViewById(R.id.stop_service);  
        startService.setOnClickListener(this);  
        stopService.setOnClickListener(this);  
    }  
  
    @Override  
    public void onClick(View v) {  
        switch (v.getId()) {  
        case R.id.start_service:  
            Intent startIntent = new Intent(this, MyService.class);  
            startService(startIntent);  
            break;  
        case R.id.stop_service:  
            Intent stopIntent = new Intent(this, MyService.class);  
            stopService(stopIntent);  
            break;  
        default:  
            break;  
        }  
    }  
  
}  
可以看到，在Start Service按钮的点击事件里，我们构建出了一个Intent对象，并调用startService()方法来启动MyService。然后在Stop Serivce按钮的点击事件里，我们同样构建出了一个Intent对象，并调用stopService()方法来停止MyService。代码的逻辑非常简单，相信不需要我再多做解释了吧。
另外需要注意，项目中的每一个Service都必须在AndroidManifest.xml中注册才行，所以还需要编辑AndroidManifest.xml文件，代码如下所示：
[html] view plain copy
<?xml version="1.0" encoding="utf-8"?>  
<manifest xmlns:android="http://schemas.android.com/apk/res/android"  
    package="com.example.servicetest"  
    android:versionCode="1"  
    android:versionName="1.0" >  
  
    <uses-sdk  
        android:minSdkVersion="14"  
        android:targetSdkVersion="17" />  
  
    <application  
        android:allowBackup="true"  
        android:icon="@drawable/ic_launcher"  
        android:label="@string/app_name"  
        android:theme="@style/AppTheme" >  
          
    ……  
  
        <service android:name="com.example.servicetest.MyService" >  
        </service>  
    </application>  
  
</manifest>  
这样的话，一个简单的带有Service功能的程序就写好了，现在我们将程序运行起来，并点击一下Start Service按钮，可以看到LogCat的打印日志如下：
                                              
也就是说，当启动一个Service的时候，会调用该Service中的onCreate()和onStartCommand()方法。
那么如果我再点击一次Start Service按钮呢？这个时候的打印日志如下：
                                          
可以看到，这次只有onStartCommand()方法执行了，onCreate()方法并没有执行，为什么会这样呢？这是由于onCreate()方法只会在Service第一次被创建的时候调用，如果当前Service已经被创建过了，不管怎样调用startService()方法，onCreate()方法都不会再执行。因此你可以再多点击几次Start Service按钮试一次，每次都只会有onStartCommand()方法中的打印日志。
我们还可以到手机的应用程序管理界面来检查一下MyService是不是正在运行，如下图所示：
                                         
恩，MyService确实是正在运行的，即使它的内部并没有执行任何的逻辑。
回到ServiceTest程序，然后点击一下Stop Service按钮就可以将MyService停止掉了。
Service和Activity通信
上面我们学习了Service的基本用法，启动Service之后，就可以在onCreate()或onStartCommand()方法里去执行一些具体的逻辑了。不过这样的话Service和Activity的关系并不大，只是Activity通知了Service一下：“你可以启动了。”然后Service就去忙自己的事情了。那么有没有什么办法能让它们俩的关联更多一些呢？比如说在Activity中可以指定让Service去执行什么任务。当然可以，只需要让Activity和Service建立关联就好了。
观察MyService中的代码，你会发现一直有一个onBind()方法我们都没有使用到，这个方法其实就是用于和Activity建立关联的，修改MyService中的代码，如下所示：
[java] view plain copy
public class MyService extends Service {  
  
    public static final String TAG = "MyService";  
  
    private MyBinder mBinder = new MyBinder();  
  
    @Override  
    public void onCreate() {  
        super.onCreate();  
        Log.d(TAG, "onCreate() executed");  
    }  
  
    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        Log.d(TAG, "onStartCommand() executed");  
        return super.onStartCommand(intent, flags, startId);  
    }  
  
    @Override  
    public void onDestroy() {  
        super.onDestroy();  
        Log.d(TAG, "onDestroy() executed");  
    }  
  
    @Override  
    public IBinder onBind(Intent intent) {  
        return mBinder;  
    }  
  
    class MyBinder extends Binder {  
  
        public void startDownload() {  
            Log.d("TAG", "startDownload() executed");  
            // 执行具体的下载任务  
        }  
  
    }  
  
}  
这里我们新增了一个MyBinder类继承自Binder类，然后在MyBinder中添加了一个startDownload()方法用于在后台执行下载任务，当然这里并不是真正地去下载某个东西，只是做个测试，所以startDownload()方法只是打印了一行日志。
然后修改activity_main.xml中的代码，在布局文件中添加用于绑定Service和取消绑定Service的按钮：
[html] view plain copy
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:orientation="vertical" >  
  
    <Button  
        android:id="@+id/start_service"  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:text="Start Service" />  
  
    <Button  
        android:id="@+id/stop_service"  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:text="Stop Service" />  
  
    <Button  
        android:id="@+id/bind_service"  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:text="Bind Service" />  
      
    <Button   
        android:id="@+id/unbind_service"  
        android:layout_width="match_parent"  
        android:layout_height="wrap_content"  
        android:text="Unbind Service"  
        />  
      
</LinearLayout>  
接下来再修改MainActivity中的代码，让MainActivity和MyService之间建立关联，代码如下所示：
[java] view plain copy
public class MainActivity extends Activity implements OnClickListener {  
  
    private Button startService;  
  
    private Button stopService;  
  
    private Button bindService;  
  
    private Button unbindService;  
  
    private MyService.MyBinder myBinder;  
  
    private ServiceConnection connection = new ServiceConnection() {  
  
        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  
  
        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myBinder = (MyService.MyBinder) service;  
            myBinder.startDownload();  
        }  
    };  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        startService = (Button) findViewById(R.id.start_service);  
        stopService = (Button) findViewById(R.id.stop_service);  
        bindService = (Button) findViewById(R.id.bind_service);  
        unbindService = (Button) findViewById(R.id.unbind_service);  
        startService.setOnClickListener(this);  
        stopService.setOnClickListener(this);  
        bindService.setOnClickListener(this);  
        unbindService.setOnClickListener(this);  
    }  
  
    @Override  
    public void onClick(View v) {  
        switch (v.getId()) {  
        case R.id.start_service:  
            Intent startIntent = new Intent(this, MyService.class);  
            startService(startIntent);  
            break;  
        case R.id.stop_service:  
            Intent stopIntent = new Intent(this, MyService.class);  
            stopService(stopIntent);  
            break;  
        case R.id.bind_service:  
            Intent bindIntent = new Intent(this, MyService.class);  
            bindService(bindIntent, connection, BIND_AUTO_CREATE);  
            break;  
        case R.id.unbind_service:  
            unbindService(connection);  
            break;  
        default:  
            break;  
        }  
    }  
  
}  
可以看到，这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，这两个方法分别会在Activity与Service建立关联和解除关联的时候调用。在onServiceConnected()方法中，我们又通过向下转型得到了MyBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。现在我们可以在Activity中根据具体的场景来调用MyBinder中的任何public方法，即实现了Activity指挥Service干什么Service就去干什么的功能。
当然，现在Activity和Service其实还没关联起来了呢，这个功能是在Bind Service按钮的点击事件里完成的。可以看到，这里我们仍然是构建出了一个Intent对象，然后调用bindService()方法将Activity和Service进行绑定。bindService()方法接收三个参数，第一个参数就是刚刚构建出的Intent对象，第二个参数是前面创建出的ServiceConnection的实例，第三个参数是一个标志位，这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后自动创建Service，这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。
然后如何我们想解除Activity和Service之间的关联怎么办呢？调用一下unbindService()方法就可以了，这也是Unbind Service按钮的点击事件里实现的逻辑。
现在让我们重新运行一下程序吧，在MainActivity中点击一下Bind Service按钮，LogCat里的打印日志如下图所示：
                                         
另外需要注意，任何一个Service在整个应用程序范围内都是通用的，即MyService不仅可以和MainActivity建立关联，还可以和任何一个Activity建立关联，而且在建立关联时它们都可以获取到相同的MyBinder实例。
如何销毁Service
在Service的基本用法这一部分，我们介绍了销毁Service最简单的一种情况，点击Start Service按钮启动Service，再点击Stop Service按钮停止Service，这样MyService就被销毁了，可以看到打印日志如下所示：
                           
那么如果我们是点击的Bind Service按钮呢？由于在绑定Service的时候指定的标志位是BIND_AUTO_CREATE，说明点击Bind Service按钮的时候Service也会被创建，这时应该怎么销毁Service呢？其实也很简单，点击一下Unbind Service按钮，将Activity和Service的关联解除就可以了。
先点击一下Bind Service按钮，再点击一下Unbind Service按钮，打印日志如下所示：
                                     
以上这两种销毁的方式都很好理解。那么如果我们既点击了Start Service按钮，又点击了Bind Service按钮会怎么样呢？这个时候你会发现，不管你是单独点击Stop Service按钮还是Unbind Service按钮，Service都不会被销毁，必要将两个按钮都点击一下，Service才会被销毁。也就是说，点击Stop Service按钮只会让Service停止，点击Unbind Service按钮只会让Service和Activity解除关联，一个Service必须要在既没有和任何Activity关联又处理停止状态的时候才会被销毁。
为了证实一下，我们在Stop Service和Unbind Service按钮的点击事件里面加入一行打印日志：
[java] view plain copy
public void onClick(View v) {  
    switch (v.getId()) {  
    case R.id.start_service:  
        Intent startIntent = new Intent(this, MyService.class);  
        startService(startIntent);  
        break;  
    case R.id.stop_service:  
        Log.d("MyService", "click Stop Service button");  
        Intent stopIntent = new Intent(this, MyService.class);  
        stopService(stopIntent);  
        break;  
    case R.id.bind_service:  
        Intent bindIntent = new Intent(this, MyService.class);  
        bindService(bindIntent, connection, BIND_AUTO_CREATE);  
        break;  
    case R.id.unbind_service:  
        Log.d("MyService", "click Unbind Service button");  
        unbindService(connection);  
        break;  
    default:  
        break;  
    }  
}  
然后重新运行程序，先点击一下Start Service按钮，再点击一下Bind Service按钮，这样就将Service启动起来，并和Activity建立了关联。然后点击Stop Service按钮后Service并不会销毁，再点击一下Unbind Service按钮，Service就会销毁了，打印日志如下所示：
                                
我们应该始终记得在Service的onDestroy()方法里去清理掉那些不再使用的资源，防止在Service被销毁后还会有一些不再使用的对象仍占用着内存。


4.Service和Thread的关系
不少Android初学者都可能会有这样的疑惑，Service和Thread到底有什么关系呢？什么时候应该用Service，什么时候又应该用Thread？答案可能会有点让你吃惊，因为Service和Thread之间没有任何关系！
之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但是，如果我告诉你Service其实是运行在主线程里的，你还会觉得它和Thread有什么关系吗？让我们看一下这个残酷的事实吧。
在MainActivity的onCreate()方法里加入一行打印当前线程id的语句：
[java] view plain copy
Log.d("MyService", "MainActivity thread id is " + Thread.currentThread().getId());  
然后在MyService的onCreate()方法里也加入一行打印当前线程id的语句：
[java] view plain copy
Log.d("MyService", "MyService thread id is " + Thread.currentThread().getId());  
现在重新运行一下程序，并点击Start Service按钮，会看到如下打印日志：
                                 
可以看到，它们的线程id完全是一样的，由此证实了Service确实是运行在主线程里的，也就是说如果你在Service里编写了非常耗时的代码，程序必定会出现ANR的。
你可能会惊呼，这不是坑爹么！？那我要Service又有何用呢？其实大家不要把后台和子线程联系在一起就行了，这是两个完全不同的概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。
额，既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。
一个比较标准的Service就可以写成：
[java] view plain copy
@Override  
public int onStartCommand(Intent intent, int flags, int startId) {  
    new Thread(new Runnable() {  
        @Override  
        public void run() {  
            // 开始执行后台任务  
        }  
    }).start();  
    return super.onStartCommand(intent, flags, startId);  
}  
  
class MyBinder extends Binder {  
  
    public void startDownload() {  
        new Thread(new Runnable() {  
            @Override  
            public void run() {  
                // 执行具体的下载任务  
            }  
        }).start();  
    }  
  
}  
创建前台Service
Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service，比如说墨迹天气，它的Service在后台更新天气数据的同时，还会在系统状态栏一直显示当前天气的信息，如下图所示：
                                                   
那么我们就来看一下如何才能创建一个前台Service吧，其实并不复杂，修改MyService中的代码，如下所示：
[java] view plain copy
public class MyService extends Service {  
  
    public static final String TAG = "MyService";  
  
    private MyBinder mBinder = new MyBinder();  
  
    @Override  
    public void onCreate() {  
        super.onCreate();  
        Notification notification = new Notification(R.drawable.ic_launcher,  
                "有通知到来", System.currentTimeMillis());  
        Intent notificationIntent = new Intent(this, MainActivity.class);  
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,  
                notificationIntent, 0);  
        notification.setLatestEventInfo(this, "这是通知的标题", "这是通知的内容",  
                pendingIntent);  
        startForeground(1, notification);  
        Log.d(TAG, "onCreate() executed");  
    }  
  
    .........  
  
}  
这里只是修改了MyService中onCreate()方法的代码。可以看到，我们首先创建了一个Notification对象，然后调用了它的setLatestEventInfo()方法来为通知初始化布局和数据，并在这里设置了点击通知后就打开MainActivity。然后调用startForeground()方法就可以让MyService变成一个前台Service，并会将通知的图片显示出来。
现在重新运行一下程序，并点击Start Service或Bind Service按钮，MyService就会以前台Service的模式启动了，并且在系统状态栏会弹出一个通栏图标，下拉状态栏后可以看到通知的详细内容，如下图所示。

5.远程service(用AIDL,一般情况下不用，就是用，也是使用广播实现的)
在上一篇文章中，我们学习了Android Service相关的许多重要内容，包括Service的基本用法、Service和Activity进行通信、Service的销毁方式、Service与Thread的关系、以及如何创建前台Service。以上所提到的这些知识点，基本上涵盖了大部分日常开发工作当中可能使用到的Service技术。不过关于Service其实还有一个更加高端的使用技巧没有介绍，即远程Service的用法。使用远程Service甚至可以实现Android跨进程通信的功能，下面就让我们具体地学习一下。
如果你还没有看过前面一篇文章，建议先去阅读一下 Android Service完全解析，关于服务你所需知道的一切（上） ，因为本篇文章中涉及到的代码是在上篇文章的基础上进行修改的。
在上篇文章中我们知道了，Service其实是运行在主线程里的，如果直接在Service中处理一些耗时的逻辑，就会导致程序ANR。
让我们来做个实验验证一下吧，修改上一篇文章中创建的ServiceTest项目，在MyService的onCreate()方法中让线程睡眠60秒，如下所示：
[java] view plain copy
public class MyService extends Service {  
  
    ......  
  
    @Override  
    public void onCreate() {  
        super.onCreate();  
        Log.d(TAG, "onCreate() executed");  
        try {  
            Thread.sleep(60000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
      
    ......  
  
}  
重新运行后，点击一下Start Service按钮或Bind Service按钮，程序就会阻塞住并无法进行任何其它操作，过一段时间后就会弹出ANR的提示框，如下图所示。
                                                        
之前我们提到过，应该在Service中开启线程去执行耗时任务，这样就可以有效地避免ANR的出现。
那么本篇文章的主题是介绍远程Service的用法，如果将MyService转换成一个远程Service，还会不会有ANR的情况呢？让我们来动手尝试一下吧。
将一个普通的Service转换成远程Service其实非常简单，只需要在注册Service的时候将它的android:process属性指定成:remote就可以了，代码如下所示：
[html] view plain copy
<?xml version="1.0" encoding="utf-8"?>  
<manifest xmlns:android="http://schemas.android.com/apk/res/android"  
    package="com.example.servicetest"  
    android:versionCode="1"  
    android:versionName="1.0" >  
  
    ......  
      
    <service  
        android:name="com.example.servicetest.MyService"  
        android:process=":remote" >  
    </service>  
  
</manifest>  
现在重新运行程序，并点击一下Start Service按钮，你会看到控制台立刻打印了onCreate() executed的信息，而且主界面并没有阻塞住，也不会出现ANR。大概过了一分钟后，又会看到onStartCommand() executed打印了出来。
为什么将MyService转换成远程Service后就不会导致程序ANR了呢？这是由于，使用了远程Service后，MyService已经在另外一个进程当中运行了，所以只会阻塞该进程中的主线程，并不会影响到当前的应用程序。
为了证实一下MyService现在确实已经运行在另外一个进程当中了，我们分别在MainActivity的onCreate()方法和MyService的onCreate()方法里加入一行日志，打印出各自所在的进程id，如下所示：
[java] view plain copy
Log.d("TAG", "process id is " + Process.myPid());  
再次重新运行程序，然后点击一下Start Service按钮，打印结果如下图所示：
                       
可以看到，不仅仅是进程id不同了，就连应用程序包名也不一样了，MyService中打印的那条日志，包名后面还跟上了:remote标识。
那既然远程Service这么好用，干脆以后我们把所有的Service都转换成远程Service吧，还省得再开启线程了。其实不然，远程Service非但不好用，甚至可以称得上是较为难用。一般情况下如果可以不使用远程Service，就尽量不要使用它。
下面就来看一下它的弊端吧，首先将MyService的onCreate()方法中让线程睡眠的代码去除掉，然后重新运行程序，并点击一下Bind Service按钮，你会发现程序崩溃了！为什么点击Start Service按钮程序就不会崩溃，而点击Bind Service按钮就会崩溃呢？这是由于在Bind Service按钮的点击事件里面我们会让MainActivity和MyService建立关联，但是目前MyService已经是一个远程Service了，Activity和Service运行在两个不同的进程当中，这时就不能再使用传统的建立关联的方式，程序也就崩溃了。
那么如何才能让Activity与一个远程Service建立关联呢？这就要使用AIDL来进行跨进程通信了（IPC）。
AIDL（Android Interface Definition Language）是Android接口定义语言的意思，它可以用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。
下面我们就来一步步地看一下AIDL的用法到底是怎样的。首先需要新建一个AIDL文件，在这个文件中定义好Activity需要与Service进行通信的方法。新建MyAIDLService.aidl文件，代码如下所示：
[java] view plain copy
package com.example.servicetest;  
interface MyAIDLService {  
    int plus(int a, int b);  
    String toUpperCase(String str);  
}  
点击保存之后，gen目录下就会生成一个对应的Java文件，如下图所示：
                                             
然后修改MyService中的代码，在里面实现我们刚刚定义好的MyAIDLService接口，如下所示：
[java] view plain copy
public class MyService extends Service {  
  
    ......  
  
    @Override  
    public IBinder onBind(Intent intent) {  
        return mBinder;  
    }  
  
    MyAIDLService.Stub mBinder = new Stub() {  
  
        @Override  
        public String toUpperCase(String str) throws RemoteException {  
            if (str != null) {  
                return str.toUpperCase();  
            }  
            return null;  
        }  
  
        @Override  
        public int plus(int a, int b) throws RemoteException {  
            return a + b;  
        }  
    };  
  
}  
这里先是对MyAIDLService.Stub进行了实现，重写里了toUpperCase()和plus()这两个方法。这两个方法的作用分别是将一个字符串全部转换成大写格式，以及将两个传入的整数进行相加。然后在onBind()方法中将MyAIDLService.Stub的实现返回。这里为什么可以这样写呢？因为Stub其实就是Binder的子类，所以在onBind()方法中可以直接返回Stub的实现。
接下来修改MainActivity中的代码，如下所示：
[java] view plain copy
public class MainActivity extends Activity implements OnClickListener {  
  
    private Button startService;  
  
    private Button stopService;  
  
    private Button bindService;  
  
    private Button unbindService;  
      
    private MyAIDLService myAIDLService;  
  
    private ServiceConnection connection = new ServiceConnection() {  
  
        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  
  
        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myAIDLService = MyAIDLService.Stub.asInterface(service);  
            try {  
                int result = myAIDLService.plus(3, 5);  
                String upperStr = myAIDLService.toUpperCase("hello world");  
                Log.d("TAG", "result is " + result);  
                Log.d("TAG", "upperStr is " + upperStr);  
            } catch (RemoteException e) {  
                e.printStackTrace();  
            }  
        }  
    };  
  
    ......  
  
}  
我们只是修改了ServiceConnection中的代码。可以看到，这里首先使用了MyAIDLService.Stub.asInterface()方法将传入的IBinder对象传换成了MyAIDLService对象，接下来就可以调用在MyAIDLService.aidl文件中定义的所有接口了。这里我们先是调用了plus()方法，并传入了3和5作为参数，然后又调用了toUpperCase()方法，并传入hello world字符串作为参数，最后将调用方法的返回结果打印出来。
现在重新运行程序，并点击一下Bind Service按钮，可以看到打印日志如下所示：
                               
由此可见，我们确实已经成功实现跨进程通信了，在一个进程中访问到了另外一个进程中的方法。
不过你也可以看出，目前的跨进程通信其实并没有什么实质上的作用，因为这只是在一个Activity里调用了同一个应用程序的Service里的方法。而跨进程通信的真正意义是为了让一个应用程序去访问另一个应用程序中的Service，以实现共享Service的功能。那么下面我们自然要学习一下，如何才能在其它的应用程序中调用到MyService里的方法。
在上一篇文章中我们已经知道，如果想要让Activity与Service之间建立关联，需要调用bindService()方法，并将Intent作为参数传递进去，在Intent里指定好要绑定的Service，示例代码如下：
[java] view plain copy
Intent bindIntent = new Intent(this, MyService.class);  
bindService(bindIntent, connection, BIND_AUTO_CREATE);  
这里在构建Intent的时候是使用MyService.class来指定要绑定哪一个Service的，但是在另一个应用程序中去绑定Service的时候并没有MyService这个类，这时就必须使用到隐式Intent了。现在修改AndroidManifest.xml中的代码，给MyService加上一个action，如下所示：
[html] view plain copy
<?xml version="1.0" encoding="utf-8"?>  
<manifest xmlns:android="http://schemas.android.com/apk/res/android"  
    package="com.example.servicetest"  
    android:versionCode="1"  
    android:versionName="1.0" >  
  
    ......  
  
    <service  
        android:name="com.example.servicetest.MyService"  
        android:process=":remote" >  
        <intent-filter>  
            <action android:name="com.example.servicetest.MyAIDLService"/>  
        </intent-filter>  
    </service>  
  
</manifest>  
这就说明，MyService可以响应带有com.example.servicetest.MyAIDLService这个action的Intent。
现在重新运行一下程序，这样就把远程Service端的工作全部完成了。
然后创建一个新的Android项目，起名为ClientTest，我们就尝试在这个程序中远程调用MyService中的方法。
ClientTest中的Activity如果想要和MyService建立关联其实也不难，首先需要将MyAIDLService.aidl文件从ServiceTest项目中拷贝过来，注意要将原有的包路径一起拷贝过来，完成后项目的结构如下图所示：
                                     
然后打开或新建activity_main.xml，在布局文件中也加入一个Bind Service按钮：
[html] view plain copy
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:orientation="vertical"  
     >  
  
   <Button   
       android:id="@+id/bind_service"  
       android:layout_width="match_parent"  
       android:layout_height="wrap_content"  
       android:text="Bind Service"  
       />  
  
</LinearLayout>  
接下来打开或新建MainActivity，在其中加入和MyService建立关联的代码，如下所示：
[java] view plain copy
public class MainActivity extends Activity {  
  
    private MyAIDLService myAIDLService;  
  
    private ServiceConnection connection = new ServiceConnection() {  
  
        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  
  
        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myAIDLService = MyAIDLService.Stub.asInterface(service);  
            try {  
                int result = myAIDLService.plus(50, 50);  
                String upperStr = myAIDLService.toUpperCase("comes from ClientTest");  
                Log.d("TAG", "result is " + result);  
                Log.d("TAG", "upperStr is " + upperStr);  
            } catch (RemoteException e) {  
                e.printStackTrace();  
            }  
        }  
    };  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        Button bindService = (Button) findViewById(R.id.bind_service);  
        bindService.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                Intent intent = new Intent("com.example.servicetest.MyAIDLService");  
                bindService(intent, connection, BIND_AUTO_CREATE);  
            }  
        });  
    }  
  
}  
这部分代码大家一定会非常眼熟吧？没错，这和在ServiceTest的MainActivity中的代码几乎是完全相同的，只是在让Activity和Service建立关联的时候我们使用了隐式Intent，将Intent的action指定成了com.example.servicetest.MyAIDLService。
在当前Activity和MyService建立关联之后，我们仍然是调用了plus()和toUpperCase()这两个方法，远程的MyService会对传入的参数进行处理并返回结果，然后将结果打印出来。
这样的话，ClientTest中的代码也就全部完成了，现在运行一下这个项目，然后点击Bind Service按钮，此时就会去和远程的MyService建立关联，观察LogCat中的打印信息如下所示：
                            
不用我说，大家都已经看出，我们的跨进程通信功能已经完美实现了。
不过还有一点需要说明的是，由于这是在不同的进程之间传递数据，Android对这类数据的格式支持是非常有限的，基本上只能传递Java的基本数据类型、字符串、List或Map等。那么如果我想传递一个自定义的类该怎么办呢？这就必须要让这个类去实现Parcelable接口，并且要给这个类也定义一个同名的AIDL文件。这部分内容并不复杂，而且和Service关系不大，所以就不再详细进行讲解了，感兴趣的朋友可以自己去查阅一下相关的资料。
好了，结合上下两篇，这就是关于Service你所需知道的一切。

5.操作系统服务：可以调用操作系统提供的服务作一些事情
1)剪切板服务
MainActivity
protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//取得剪切板服务
		ClipboardManager clipboardManager=(ClipboardManager)super.getSystemService(Context.CLIPBOARD_SERVICE);
		clipboardManager.setText("你好");
	}
	
使用方法：长按，会出现粘贴的提示框，点击确定，就把你好粘贴进去了

2)通过服务，取得正在运行的所有程序信息
public class MainActivity extends Activity {
	ListView cut=null;
	ListAdapter adapter=null;
	List<String> all=new ArrayList<String>();
	ActivityManager activityManager=null;
	List<ActivityManager.RunningTaskInfo> alltaskinfo;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		cut=(ListView)super.findViewById(R.id.cut);
		//取得服务
		activityManager=(ActivityManager)super.getSystemService(Context.ACTIVITY_SERVICE);
		listactivity();
	}
	private void listactivity()
	{
		this.alltaskinfo=this.activityManager.getRunningTasks(30);//返回30条
		Iterator<ActivityManager.RunningTaskInfo> iterinfo=this.alltaskinfo.iterator();
		while(iterinfo.hasNext())
		{
			ActivityManager.RunningTaskInfo task=iterinfo.next();
			this.all.add("id="+task.id+"[]"+task.baseActivity.getClassName());
		}
		this.adapter=new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1,this.all);
		this.cut.setAdapter(adapter);
	}
	

}

添加权限
<uses-permission android:name="android.permission.GET_TASKS"/>

	
6.PendingIntent与Intent的区别是，Intent定义后，就一定会调用他来跳转到一些
Activity,或者service上。而PendingIntent是定义后，如果有产生某一个事件之后，才会调用这个PendingIntent来跳转。
1)例子：发送通知Notifcation,这个组件是把一些提示用户操作的信息发送到手机
上面的消息下拉框中
Notifcation是一个通知，NotifcationManager是一个发送通知的操作类
@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//取得服务
		NotificationManager notificationManager=(NotificationManager)super.getSystemService(Activity.NOTIFICATION_SERVICE);
		Notification notification=new Notification(R.drawable.ic_launcher,"来自Noti的消息",
				System.currentTimeMillis());//立即发送一个消息
		//创建一个PendingIntent对象
		PendingIntent conIntent=PendingIntent.getActivity(this, 0, super.getIntent(), PendingIntent.FLAG_UPDATE_CURRENT);
		notification.setLatestEventInfo(this, "通知", "这是一个通知", conIntent);
		notificationManager.notify("通知",R.drawable.ic_launcher,notification);
	}
 
实际运行情况：推送一个通知，只有当用户点击通知时，才触发一个事件，通过pendIntent跳转到他指定的页面，就是打开本activity程序	

7.广播BroadcastReceiver：像电视信号，打开电视所有台的电视信号都在放，但只能选择一台可以看见
service是一直在后台运行的，而广播是需要一些特定条件，才开始执行的。通过广播
可以实现service程序的启动

1)一个简单的广播例子,在activity中，通过按钮启动广播
(1)创建一个广播组件
public class MyBroadcastReceiveUtil extends BroadcastReceiver {
	
	public MyBroadcastReceiveUtil() {
		super();
		// TODO Auto-generated constructor stub
		System.out.println("每次广播都会实例化一个广播组件进行操作");
	}

	@Override
	public void onReceive(Context context, Intent intent) {
		// TODO Auto-generated method stub
		Toast.makeText(context, "广播已经启动", Toast.LENGTH_SHORT).show();
	}

}

(2）添加组件配置
<application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name="com.example.boardcast.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <receiver
            android:name="com.example.boardcast.MyBroadcastReceiveUtil"
            android:enabled="true" >
			//表示对一个指定的action操作时才启动广播，即可以通过activity来
			手动启动广播
            <intent-filter>
                <action android:name="android.intent.action.EDIT" />
            </intent-filter>
        </receiver>
    </application>

(3）main.xml文件
<Button
        android:id="@+id/mybut"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="开始广播" />

(4）MainActivity.java
mybut = (Button) findViewById(R.id.mybut);
mybut.setOnClickListener(new OnClickListener() {// 为退币按钮设置监听事件
	@Override
	public void onClick(View arg0) {
		//操作过滤，只有EDIT的action他才执行，而EDIT在刚才配置组件时定义了过滤器intent-filter
		Intent it=new Intent(Intent.ACTION_EDIT);
		MainActivity.this.sendBroadcast(it);//开启广播
	}
});	

这样点击按钮之后，就发送Intent给广播服务，由于有过滤器，所以广播服务收到
这个之后，就启动服务了

或者manifest.xml文件
<intent-filter>
	<action android:name="hello" />
</intent-filter>
activity.java文件
Intent it=new Intent("hello");


2)不通过intent-filter过滤，而通过代码手动注册广播
（1）不配置receiver了
<application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name="com.example.boardcast.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>        
    </application>	
	
(2)MainActivity.java
public class MainActivity extends Activity {
	Button mybut=null;
	MyBroadcastReceiveUtil broadUtil=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		mybut = (Button) findViewById(R.id.mybut);
		mybut.setOnClickListener(new OnClickListener() {// 为退币按钮设置监听事件
		    @Override
		    public void onClick(View arg0) {
		    	//操作过滤，action.MLDN
		    	Intent it=new Intent("action.MLDN");
		    	it.putExtra("msg", "value");
		    	IntentFilter filter=new IntentFilter("action.MLDN");
		    	MainActivity.this.broadUtil=new MyBroadcastReceiveUtil();
		    	MainActivity.this.registerReceiver(broadUtil, filter);
		    	MainActivity.this.sendBroadcast(it);//开启广播
		    }
		});
	}
	
}

3）修改广播处理类，因为不是针对于所有的Action进行广播，必须通过过滤的Action进行
public class MyBroadcastReceiveUtil extends BroadcastReceiver {
	
	public MyBroadcastReceiveUtil() {
		super();
		// TODO Auto-generated constructor stub
		System.out.println("每次广播都会实例化一个广播组件进行操作");
	}

	@Override
	public void onReceive(Context context, Intent intent) {		
		// TODO Auto-generated method stub
		if("action.MLDN".equals(intent.getAction()))
		{
			String msg=intent.getStringExtra("msg");
			Toast.makeText(context, "广播已经启动"+msg, Toast.LENGTH_SHORT).show();
		}
	}

}

4）通过BroadCast启动Service:服务可以通过Activity启动，也可以通过广播启动
区别是Activity是从界面来启动服务，而BroadCast是在某些特定条件下启动服务，
例如刚开机，或者某一应用程序执行
例子是通过Activity启动广播，再通过广播启动服务
（1）创建service服务文件
public class MyService extends Service {

	@Override
	public IBinder onBind(Intent arg0) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void onCreate() {
		// TODO Auto-generated method stub
		System.out.print("Service create");
		super.onCreate();
	}

	@Override
	public void onDestroy() {
		// TODO Auto-generated method stub
		System.out.print("Service destroy");
		super.onDestroy();
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		// TODO Auto-generated method stub
		System.out.print("Service startcommand");
		return Service.START_CONTINUATION_MASK;
	}
	
}

（2）添加配置文件到manifest.xml
<service
            android:name="com.example.boardcast.MyService"/>

（3）MyBroadcastReceiveUtil文件
public class MyBroadcastReceiveUtil extends BroadcastReceiver {
	
	@Override
	public void onReceive(Context context, Intent intent) {		
		// TODO Auto-generated method stub
		if("action.MLDN".equals(intent.getAction()))
		{
			String msg=intent.getStringExtra("msg");
			Toast.makeText(context, "广播已经启动"+msg, Toast.LENGTH_SHORT).show();
			//启动服务
			context.startService(new Intent(context,MyService.class));
		}
	}

}

(4)MainAcitivy文件
public class MainActivity extends Activity {
	Button mybut=null;
	MyBroadcastReceiveUtil broadUtil=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		mybut = (Button) findViewById(R.id.mybut);
		mybut.setOnClickListener(new OnClickListener() {// 为退币按钮设置监听事件
		    @Override
		    public void onClick(View arg0) {
		    	//操作过滤，只有EDIT的action他才执行，而EDIT在刚才配置组件时定义了过滤器intent-filter
		    	Intent it=new Intent("action.MLDN");
		    	it.putExtra("msg", "value");
		    	IntentFilter filter=new IntentFilter("action.MLDN");
		    	MainActivity.this.broadUtil=new MyBroadcastReceiveUtil();
		    	MainActivity.this.registerReceiver(broadUtil, filter);
		    	MainActivity.this.sendBroadcast(it);//开启广播
		    }
		});
	}
	@Override
	protected void onStop() {
		//停止本activity时，自动注销广播
		super.unregisterReceiver(MainActivity.this.broadUtil);
		// TODO Auto-generated method stub
		super.onStop();
	}
	
}

例子：闹钟
（1）调用闹钟页面AlarmMessage.java,他的触动通过广播来完成
public class AlarmMessage extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		new AlertDialog.Builder(this).setIcon(R.drawable.ic_launcher).setTitle("闹钟时间已到")
		.setMessage("闹钟响起").setPositiveButton("关闭", new DialogInterface.OnClickListener() {
			
			@Override
			public void onClick(DialogInterface dialog, int which) {
				// TODO Auto-generated method stub
				AlarmMessage.this.finish();
			}
		}).show();
	}
	
}

（2）添加广播MyAlarmReceiver
public class MyAlarmReceiver extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent) {
		// TODO Auto-generated method stub
		Intent it=new Intent(context,AlarmMessage.class);
		it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		context.startActivity(it);
	}

}

(3)设置一个操作界面，设置闹钟信息
<TimePicker 
	android:id="@+id/time"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	/>
<TextView
	android:id="@+id/msg"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:text="还没设置闹钟" />
<Button 
	android:id="@+id/set"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:text="设置闹钟"
	/>
<Button 
	android:id="@+id/del"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:text="取消闹钟"
	/>
	
MainActivity.java文件
	public class MainActivity extends Activity {
	AlarmManager alarm=null;//闹钟服务
	Button set=null,del=null;
	TimePicker time=null;
	TextView msg=null;
	int minute=0,hourOfDay=0;
	Calendar calendar=Calendar.getInstance();
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		alarm=(AlarmManager)super.getSystemService(Context.ALARM_SERVICE);//取得闹钟服务
		time = (TimePicker) findViewById(R.id.time);
		time.setOnTimeChangedListener(new OnTimeChangedListener() {
			
			@Override
			public void onTimeChanged(TimePicker view, int hourOfDay, int minute) {
				// TODO Auto-generated method stub				
				calendar.setTimeInMillis(System.currentTimeMillis());//设置当前时间
				calendar.set(calendar.HOUR_OF_DAY, hourOfDay);
				calendar.set(calendar.MINUTE, minute);
				MainActivity.this.hourOfDay=hourOfDay;
				MainActivity.this.minute=minute;
			}
		});
		msg = (TextView) findViewById(R.id.msg);
		set = (Button) findViewById(R.id.set);
		set.setOnClickListener(new View.OnClickListener() {// 设置闹钟服务
		    @Override
		    public void onClick(View arg0) {
		    	Intent intent=new Intent(MainActivity.this,MyAlarmReceiver.class);
		    	intent.setAction("setalarm");
		    	//一旦到时间之后，就跳转到由PendingIntent包装的Intent中，而这个Intent作用是
		    	//跳转到一个广播之中
		    	PendingIntent sender=PendingIntent.getBroadcast(MainActivity.this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
		    	//设置闹钟服务
		    	MainActivity.this.alarm.set(AlarmManager.RTC_WAKEUP, MainActivity.this.calendar.getTimeInMillis(), sender);
		    	
		    	MainActivity.this.msg.setText("闹钟响起时间"+MainActivity.this.hourOfDay+":"+MainActivity.this.minute);
		    	Toast.makeText(MainActivity.this, "闹钟设置成功", Toast.LENGTH_LONG).show();
		    	
		    }
		});
		del = (Button) findViewById(R.id.del);
		del.setOnClickListener(new View.OnClickListener() {// 为退币按钮设置监听事件
		    @Override
		    public void onClick(View arg0) {
		    	if(MainActivity.this.alarm!=null)
		    	{
		    		Intent intent=new Intent(MainActivity.this,MyAlarmReceiver.class);
			    	intent.setAction("setalarm");
			    	//一旦到时间之后，就跳转到由PendingIntent包装的Intent中，而这个Intent作用是
			    	//跳转到一个广播之中
			    	PendingIntent sender=PendingIntent.getBroadcast(MainActivity.this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
			    	//删除闹钟服务
			    	MainActivity.this.alarm.cancel(sender);
			    	MainActivity.this.msg.setText("当前没有设置闹钟");
			    	Toast.makeText(MainActivity.this, "闹钟删除成功", Toast.LENGTH_LONG).show();
		    	}
		    }
		});
	}
	
}

(4)添加配置文件到manifest
<activity
	android:name="com.example.alarm.MainActivity"
	android:label="@string/app_name" >
	<intent-filter>
		<action android:name="android.intent.action.MAIN" />

		<category android:name="android.intent.category.LAUNCHER" />
	</intent-filter>
</activity>
<activity android:name="com.example.alarm.AlarmMessage"></activity>
<receiver
	android:name="com.example.alarm.MyAlarmReceiver"
	android:enabled="true" 
	android:process=":remote">
	<intent-filter>
		<action android:name="setalarm" />
	</intent-filter>
</receiver>

例子：开机自启动
（1）界面Activity,BootStartDemo.java文件
public class BootStartDemo extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 无title
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        // 全屏
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                WindowManager.LayoutParams.FLAG_FULLSCREEN);
        setContentView(R.layout.main);
        new Thread() {
            public void run() {
                try {
                    /*  10秒后关闭页面*/
                    sleep(10000);
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    finish(); // 关闭页面
                }
            }
        }.start();
 
    }
}
这段代码很简单，当Activity 启动时，会显示TextView，用它显示你想显示的字样，并且这个页面只显示10秒后消失。

(2)接收广播消息：BootBroadcastReceiver.java
public class BootBroadcastReceiver extends BroadcastReceiver {
    static final String action_boot="android.intent.action.BOOT_COMPLETED";
 
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(action_boot)){
            Intent ootStartIntent=new Intent(context,BootStartDemo.class);
            ootStartIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(ootStartIntent);
        }
 
    }
 
}
该类继续自 BroadcastReceiver，覆载方法 onReceive 中，检测接收到的 Intent 是否符合
BOOT_COMPLETED，如果符合，则启动BootStartDemo这个Activity。


(3)AndroidManifest.xml ：
<?xml version="1.0" encoding="utf-8"?>
<!-- 这是一个开机自启动程序 -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="com.ajie.bootstartdemo"
      android:versionCode="1"
      android:versionName="1.0">
    <application android:icon="@drawable/icon" android:label="@string/app_name">
        <activity android:name=".BootStartDemo"
                  android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    <span style="color: #ff00ff;">
	<receiver android:name=".BootBroadcastReceiver">
        <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
        <category android:name="android.intent.category.HOME" />
        </intent-filter>
    </receiver>
    </span>    
    </application>
<span style="color: #ff00ff;"><strong>
<!--开机自启动的权限 -->
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"></uses-permission></strong>
</span></manifest>

6.当需要将service中的结果一次发送给多个activity时，我们又该如何实现呢？经过多个项目的积累，总结了三种实现的方式。分别是 回调接口、广播接收者，观察者模式 。其中，广播接收者应用最普遍
1)回调接口的方式 ，与单个service与单个activity通信类似，只是将service中的接口变为接口的集合，每个需要通信的activity都实现接口，然后在获取结果后，循环调用集合中的实现类，来与多个activity进行通信，代码如下：
Service类：


package com.example.servicecallback;

import java.util.ArrayList;
import java.util.List;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.util.Log;

public class ContentService extends Service {

  //回调接口的集合
  private List<Callback> list;

  @Override
  public IBinder onBind(Intent arg0) {
    // TODO Auto-generated method stub
    return new LocalBinder();
  }

  @Override
  public void onCreate() {
    // TODO Auto-generated method stub
    super.onCreate();
    list = new ArrayList<Callback>();
  }

  public final class LocalBinder extends Binder {
    public ContentService getService() {
      return ContentService.this;
    }
  }

  /**
   * 回调接口
   * @author Ivan Xu
   *
   */
  public interface Callback {
    public void getPerson(Person person);
  }

  /**
   * 往回调接口集合中添加一个实现类
   * @param callback
   */
  public void addCallback(Callback callback) {
    list.add(callback);
  }

  public void asyncSendPerson(final String name) {
    // 休息5秒，模拟异步任务
    new Thread(new Runnable() {
      @Override
      public void run() {
        // TODO Auto-generated method stub
        try {
          Thread.sleep(5000);
        } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        handler.sendMessage(handler.obtainMessage(0, name));
      }
    }).start();
  }

  private Handler handler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
      // TODO Auto-generated method stub
      String name = (String) msg.obj;
      Log.i("ContentService", "---name-->" + name);
      Person person = new Person();
      person.setName(name);
      Log.i("ContentService", "---list.size()-->" + list.size());
      Log.i("ContentService", "---person-->" + person.toString());
      //遍历集合，通知所有的实现类，即activity
      for (int i = 0; i < list.size(); i++) {
        list.get(i).getPerson(person);
      }
    }
  };
}
View Code

第一个activity：


package com.example.servicecallback;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.TextView;
import com.example.servicecallback.ContentService.Callback;
import com.example.servicecallback.ContentService.LocalBinder;

public class MainActivity extends Activity implements Callback {

  private MyServiceConn conn;
  private ContentService service;
  private TextView mContent;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    conn=new MyServiceConn();
    bindService(new Intent(this, ContentService.class), conn,
        BIND_AUTO_CREATE);

    mContent = (TextView) findViewById(R.id.content);

    this.findViewById(R.id.button1).setOnClickListener(
        new OnClickListener() {
          @Override
          public void onClick(View v) {
            // TODO Auto-generated method stub
            startActivity(new Intent(MainActivity.this,
                OtherActivity.class));
          }
        });
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }

  public class MyServiceConn implements ServiceConnection {

    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
      service = ((LocalBinder) binder).getService();
      //将当前activity添加到接口集合中
      service.addCallback(MainActivity.this);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
      // TODO Auto-generated method stub
      service = null;
    }
  }

  @Override
  protected void onDestroy() {
    // TODO Auto-generated method stub
    super.onDestroy();
    unbindService(conn);
  }

  /**
   * 获取回调的内容，更新UI
   */
  @Override
  public void getPerson(Person person) {
    // TODO Auto-generated method stub
    mContent.setText(person.toString());
  }
}
View Code

第二个activity：


package com.example.servicecallback;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import com.example.servicecallback.ContentService.Callback;
import com.example.servicecallback.ContentService.LocalBinder;
import com.example.servicecallback.MainActivity.MyServiceConn;

public class OtherActivity extends Activity implements Callback {

  private ContentService service;
  private TextView mContent;
  private Button mSubmit;
  private EditText mEditText;
  private ServiceConnection conn;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    // TODO Auto-generated method stub
    super.onCreate(savedInstanceState);

    setContentView(R.layout.other);

    mEditText = (EditText) findViewById(R.id.edittext);
    mSubmit = (Button) findViewById(R.id.button1);
    mContent = (TextView) findViewById(R.id.content);

    mSubmit.setOnClickListener(new OnClickListener() {
      @Override
      public void onClick(View v) {
        // TODO Auto-generated method stub
        String name = mEditText.getText().toString();
        service.asyncSendPerson(name);
      }
    });

    
    conn=new MyServiceConn();
    bindService(new Intent(OtherActivity.this, ContentService.class), conn,
        BIND_AUTO_CREATE);

  }

  public final class MyServiceConn implements ServiceConnection {
    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
      // TODO Auto-generated method stub
      service = ((LocalBinder) binder).getService();
      //将当前activity添加到接口集合中
      service.addCallback(OtherActivity.this);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
      // TODO Auto-generated method stub
      service = null;
    }
  }

  @Override
  protected void onDestroy() {
    // TODO Auto-generated method stub
    super.onDestroy();
    unbindService(conn);
  }

  /**
   * 获取回调的内容，更新UI
   */
  @Override
  public void getPerson(Person person) {
    // TODO Auto-generated method stub
    mContent.setText(person.toString());
  }
}

2).通过广播接收者 ，在service中执行完耗时操作后，将结果以广播的形式发送，在所有的activity中注册广播，接收到结果后更新UI，这种方式比较简单，也是笔者比较推荐的方式。因为耗时的操作结果不需要以handler的方式发送到主线程，可以直接在子线程中发送广播，接收者始终运行在主线程中。
 静态注册,注册的广播，在manifest中
 <receiver android:name=".SMSBroadcastReceiver" >
　　<intent-filter android:priority = "2147483647" >
　　　　<action android:name="android.provider.Telephony.SMS_RECEIVED" />
　　</intent-filter>
</receiver >

动态注册，一般在Activity可交互时onResume()内注册BroadcastReceiver
IntentFilter intentFilter=new IntentFilter("android.provider.Telephony.SMS_RECEIVED");
registerReceiver(mBatteryInfoReceiver ,intentFilter);

//反注册
unregisterReceiver(receiver);

动态注册广播接收器还有一个特点，就是当用来注册的Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭,只要设备是开启状态,广播接收器也是打开着的。也就是说哪怕app本身未启动,该app订阅的广播在触发时也会对它起作用

系统常见广播Intent,如开机启动、电池电量变化、时间改变等广播

(1)简单的service发送广播给activity接收，其中的ServiceConnection也可以不用做
Service类：
package com.example.servicecallback;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;

public class ContentService extends Service {


  @Override
  public IBinder onBind(Intent arg0) {
    // TODO Auto-generated method stub
    return new LocalBinder();
  }

  @Override
  public void onCreate() {
    // TODO Auto-generated method stub
    super.onCreate();
  }

  public final class LocalBinder extends Binder {
    public ContentService getService() {
      return ContentService.this;
    }
  }

  public void asyncSendPerson(final String name) {
    // 休息5秒，模拟异步任务
    new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          Thread.sleep(5000);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        //可以在子线程中直接发送广播
        sendContentBroadcast(name);
      }
    }).start();
  }

  /**
   * 发送广播
   * @param name
   */
  protected void sendContentBroadcast(String name) {
    // TODO Auto-generated method stub
    Intent intent=new Intent();
    intent.setAction("com.example.servicecallback.content");
    intent.putExtra("name", name);
    sendBroadcast(intent);
  }
}
View Code

第一个activity：


package com.example.servicecallback;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.TextView;

public class MainActivity extends Activity {

  private MyServiceConn conn;
  private TextView mContent;
  private ContentReceiver mReceiver;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    conn = new MyServiceConn();
    bindService(new Intent(this, ContentService.class), conn,
        BIND_AUTO_CREATE);

    mContent = (TextView) findViewById(R.id.content);

    this.findViewById(R.id.button1).setOnClickListener(
        new OnClickListener() {
          @Override
          public void onClick(View v) {
            // TODO Auto-generated method stub
            startActivity(new Intent(MainActivity.this,
                OtherActivity.class));
          }
        });

    
    doRegisterReceiver();
  }

  /**
   * 注册广播接收者
   */
  private void doRegisterReceiver() {
    mReceiver=new ContentReceiver();
    IntentFilter filter = new IntentFilter(
        "com.example.servicecallback.content");
    registerReceiver(mReceiver, filter);
  }

  public class MyServiceConn implements ServiceConnection {

    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
      // service = ((LocalBinder) binder).getService();
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
      // TODO Auto-generated method stub
      // service = null;
    }
  }

  @Override
  protected void onDestroy() {
    // TODO Auto-generated method stub
    super.onDestroy();
    unbindService(conn);
    if (mReceiver!=null) {
      unregisterReceiver(mReceiver);
    }
  }

  public class ContentReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
      String name = intent.getStringExtra("name");
      Person person = new Person();
      person.setName(name);
      mContent.setText(person.toString());
    }
  }
}
View Code

另一个activity：


package com.example.servicecallback;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.example.servicecallback.ContentService.LocalBinder;

public class OtherActivity extends Activity {

  private ContentService service;
  private TextView mContent;
  private Button mSubmit;
  private EditText mEditText;
  private ServiceConnection conn;
  private ContentReceiver mReceiver;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.other);

    mEditText = (EditText) findViewById(R.id.edittext);
    mSubmit = (Button) findViewById(R.id.button1);
    mContent = (TextView) findViewById(R.id.content);

    mSubmit.setOnClickListener(new OnClickListener() {
      @Override
      public void onClick(View v) {
        String name = mEditText.getText().toString();
        service.asyncSendPerson(name);
      }
    });

    
    conn=new MyServiceConn();
    bindService(new Intent(OtherActivity.this, ContentService.class), conn,
        BIND_AUTO_CREATE);

    doRegisterReceiver();
  }

  private void doRegisterReceiver() {
    mReceiver=new ContentReceiver();
    IntentFilter filter = new IntentFilter(
        "com.example.servicecallback.content");
    registerReceiver(mReceiver, filter);
  }
  
  public final class MyServiceConn implements ServiceConnection {
    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
      service = ((LocalBinder) binder).getService();
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
      service = null;
    }
  }

  @Override
  protected void onDestroy() {
    super.onDestroy();
    unbindService(conn);
    if (mReceiver!=null) {
      unregisterReceiver(mReceiver);
    }
  }

  public class ContentReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
      String name = intent.getStringExtra("name");
      Person person = new Person();
      person.setName(name);
      mContent.setText(person.toString());
    }
  }
}


(2)扩展：
service可以发送信息给activity,activity也可以发送信息给service,本例子没有使用ServiceConnection绑定，并且
注意观察注释的顺序点

service类：
public class EVServerService extends Service {
	boolean isStop=false;
    SendReceiver receiver;
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		Log.i("EV_JNI","Service bind");
		return null;
	}
	
	@Override
	public void onCreate() {
		// TODO Auto-generated method stub
		Log.i("EV_JNI","Service create");
		//timer = new Timer(true);
		//9.注册接收器
		receiver=new SendReceiver();
		IntentFilter filter=new IntentFilter();
		filter.addAction("android.intent.action.send");
		this.registerReceiver(receiver,filter);
		super.onCreate();
	}

	@Override
	public void onDestroy() {
		// TODO Auto-generated method stub		
		Log.i("EV_JNI","Service destroy");
		isStop=true;//即使service销毁线程也不会停止，所以这里通过设置isStop来停止线程
		//10.解除注册接收器
		this.unregisterReceiver(receiver);
		super.onDestroy();
	}
	
	@Override
	@Deprecated
	public void onStart(Intent intent, int startId) {
		// TODO Auto-generated method stub
		super.onStart(intent, startId);
		Log.i("EV_JNI","Service start");
		
		new Thread(){//1.新建线程，每隔1秒发送一次广播，同时把i放进intent传出
			public void run(){
				int i=0;
				while(!isStop){
					Intent intent=new Intent();
					intent.putExtra("i", i);
					i++;
					intent.setAction("android.intent.action.test");//action与接收器相同
					sendBroadcast(intent);
					Log.i("EV_JNI","ser="+String.valueOf(i));
					try {
						sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		}.start();
	}
	//8.创建activity的接收器广播，用来接收内容
	public class SendReceiver extends BroadcastReceiver {

		@Override
		public void onReceive(Context context, Intent intent) {
			// TODO Auto-generated method stub
						Bundle bundle=intent.getExtras();
						int a=bundle.getInt("i");
						Log.i("EV_JNI","actreceiver="+a);					
						//处理接收到的内容
				
					}

	}

}

MainActivity页面
public class MainActivity extends Activity {
	MyReceiver receiver;
	Button btn=null,btnint=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		//3.启动服务
		startService(new Intent(MainActivity.this,EVServerService.class));		
		//4.注册接收器
		receiver=new MyReceiver();
		IntentFilter filter=new IntentFilter();
		filter.addAction("android.intent.action.test");
		this.registerReceiver(receiver,filter);
		
		//7.发送指令广播给service
		btn = (Button) findViewById(R.id.btn); 
		btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent=new Intent();
				intent.putExtra("i", 100);
				intent.setAction("android.intent.action.send");//action与接收器相同
				sendBroadcast(intent);
				Log.i("EV_JNI","actsend="+String.valueOf(100));
			}
		});
		btnint = (Button) findViewById(R.id.btnint); 
		btnint.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent = new Intent(MainActivity.this, mainact2.class);// 使用Accountflag窗口初始化Intent
                startActivity(intent);// 打开Accountflag
                
			}
		});
	}
	//2.创建service的接收器广播，用来接收内容
	public class MyReceiver extends BroadcastReceiver {

		@Override
		public void onReceive(Context context, Intent intent) {
			// TODO Auto-generated method stub
						Bundle bundle=intent.getExtras();
						int a=bundle.getInt("i");
						Log.i("EV_JNI","onreceiver="+a);					
						//处理接收到的内容
				
					}

	}
	@Override
	protected void onDestroy() {
		// TODO Auto-generated method stub
		super.onDestroy();
		//5.解除注册接收器
		MainActivity.this.unregisterReceiver(receiver);
		//6.结束服务
		stopService(new Intent(MainActivity.this, EVServerService.class));
	}
	
	

}

调试信息：
接收到service的信息
07-01 17:49:46.717: I/EV_JNI(12741): ser=1
07-01 17:49:46.757: I/EV_JNI(12741): onreceiver=0
07-01 17:49:47.717: I/EV_JNI(12741): ser=2
07-01 17:49:47.717: I/EV_JNI(12741): onreceiver=1
发送给service信息
07-01 17:49:50.507: I/EV_JNI(12741): actsend=100
07-01 17:49:50.507: I/EV_JNI(12741): actreceiver=100


跳转到下一个activity
public class mainact2 extends Activity {
	Button btn=null;
	MyReceiver receiver;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main2);
		//12.注册接收器
		receiver=new MyReceiver();
		IntentFilter filter=new IntentFilter();
		filter.addAction("android.intent.action.test");
		this.registerReceiver(receiver,filter);
		//14.发送指令广播给service
		btn = (Button) findViewById(R.id.btn); 
		btn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Intent intent=new Intent();
				intent.putExtra("i", 200);
				intent.setAction("android.intent.action.send");//action与接收器相同
				sendBroadcast(intent);
				Log.i("EV_JNI","actsend="+String.valueOf(200));
			}
		});
	}
	//11.创建service的接收器广播，用来接收内容
	public class MyReceiver extends BroadcastReceiver {

		@Override
		public void onReceive(Context context, Intent intent) {
			// TODO Auto-generated method stub
						Bundle bundle=intent.getExtras();
						int a=bundle.getInt("i");
						Log.i("EV_JNI","onreceiver2="+a);					
						//处理接收到的内容
				
					}

	}
	@Override
	protected void onDestroy() {
		// TODO Auto-generated method stub
		super.onDestroy();
		//13.解除注册接收器
		mainact2.this.unregisterReceiver(receiver);		
	}
}
调试信息：
接收到service的信息
07-01 17:53:25.527: I/EV_JNI(12741): ser=219
07-01 17:53:25.527: I/EV_JNI(12741): onreceiver=218
07-01 17:53:25.537: I/EV_JNI(12741): onreceiver2=218
07-01 17:53:26.537: I/EV_JNI(12741): ser=220
07-01 17:53:26.537: I/EV_JNI(12741): onreceiver=219
07-01 17:53:26.537: I/EV_JNI(12741): onreceiver2=219
发送给service信息
07-01 17:53:28.537: I/EV_JNI(12741): actsend=200
07-01 17:53:28.547: I/EV_JNI(12741): actreceiver=200


返回到第一个activity
07-01 17:54:42.827: I/EV_JNI(12741): ser=296
07-01 17:54:42.827: I/EV_JNI(12741): onreceiver=295
07-01 17:54:43.837: I/EV_JNI(12741): ser=297
07-01 17:54:43.837: I/EV_JNI(12741): onreceiver=296


(3)使用LocalBroadcastManager：
在自己的进程内进行局部广播发送与注册，使用它比直接通过sendBroadcast(Intent)发送系统全局广播有以下几点好处。
1    因广播数据在本应用范围内传播，你不用担心隐私数据泄露的问题。
2    不用担心别的应用伪造广播，造成安全隐患。
3    相比在系统内发送全局广播，它更高效。

与上面全局广播类似
MainActivity.java
LocalBroadcastManager localBroadreceiver;
EVServerReceiver receiver;
	
//2.创建EVServerReceiver的接收器广播，用来接收服务器同步的内容
public class EVServerReceiver extends BroadcastReceiver 
{

	@Override
	public void onReceive(Context context, Intent intent) 
	{
		// TODO Auto-generated method stub
		Bundle bundle=intent.getExtras();
		int EVWhat=bundle.getInt("EVWhat");
		switch(EVWhat)
		{
		case EVServerhttp.SETMAIN:
			Log.i("EV_JNI","activity=签到成功");
			issuc=2;	
			dialog.dismiss();				
			break;
		case EVServerhttp.SETFAILMAIN:
			Log.i("EV_JNI","activity=失败，网络故障");
			if(dialog.isShowing())
				dialog.dismiss();
			break;	
		}
		if(issale==false)
		{
			issale=true;
			//签到完成，自动开启售货程序
			barmaintain= ProgressDialog.show(MaintainActivity.this,"打开交易页面","请稍候...");
			Intent intbus;
			//横屏
			if(ToolClass.getOrientation()==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
			{
				intbus = new Intent(MaintainActivity.this, BusLand.class);// 使用Accountflag窗口初始化Intent
			}
			//竖屏
			else
			{
				intbus = new Intent(MaintainActivity.this, BusPort.class);// 使用Accountflag窗口初始化Intent
			}
			startActivityForResult(intbus,REQUEST_CODE);// 打开Accountflag
		}
	}

}


//3.开启服务
startService(new Intent(MaintainActivity.this,EVServerService.class));
//4.注册接收器
localBroadreceiver = LocalBroadcastManager.getInstance(this);
receiver=new EVServerReceiver();
IntentFilter filter=new IntentFilter();
filter.addAction("android.intent.action.vmserverrec");
localBroadreceiver.registerReceiver(receiver,filter);

//5.解除注册接收器
localBroadreceiver.unregisterReceiver(receiver);
//6.结束服务
stopService(new Intent(MaintainActivity.this, EVServerService.class));

//7.发送
//上报给服务器
Intent intent=new Intent();
intent.putExtra("EVWhat", EVServerhttp.SETDEVSTATUCHILD);
intent.putExtra("bill_err", bill_err);
intent.putExtra("coin_err", coin_err);
intent.setAction("android.intent.action.vmserversend");//action与接收器相同
localBroadreceiver.sendBroadcast(intent); 



EVServerService.java
LocalBroadcastManager localBroadreceiver;
ActivityReceiver receiver;

//8.创建activity的接收器广播，用来接收内容
public class ActivityReceiver extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent)
	{
		// TODO Auto-generated method stub
		Bundle bundle=intent.getExtras();
		int EVWhat=bundle.getInt("EVWhat");
		switch(EVWhat)
		{
		//签到
		case EVServerhttp.SETCHILD:
			vmc_no=bundle.getString("vmc_no");
			vmc_auth_code=bundle.getString("vmc_auth_code");
			SerializableMap serializableMap = (SerializableMap) bundle.get("huoSet");
			huoSet=serializableMap.getMap();
			ToolClass.Log(ToolClass.INFO,"EV_SERVER","receiver:vmc_no="+vmc_no+"vmc_auth_code="+vmc_auth_code
					+"huoSet="+huoSet.toString(),"server.txt");
			ToolClass.setContext(context);
			//处理接收到的内容,发送签到命令到子线程中
			//初始化一:发送签到指令
			childhand=serverhttp.obtainHandler();
			Message childmsg=childhand.obtainMessage();
			childmsg.what=EVServerhttp.SETCHILD;
			JSONObject ev=null;
			try {
				ev=new JSONObject();
				ev.put("vmc_no", vmc_no);
				ev.put("vmc_auth_code", vmc_auth_code);
				ToolClass.Log(ToolClass.INFO,"EV_SERVER","Send0.1="+ev.toString(),"server.txt");
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			childmsg.obj=ev;
			childhand.sendMessage(childmsg);
			ischeck=false;
			break;
		//设备状态上报	
		case EVServerhttp.SETDEVSTATUCHILD:
			int bill_err=bundle.getInt("bill_err");
			int coin_err=bundle.getInt("coin_err");
			ToolClass.Log(ToolClass.INFO,"EV_SERVER","Service 上报设备bill_err="+bill_err
					+" coin_err="+coin_err,"server.txt");				
			//
			childhand=serverhttp.obtainHandler();
			Message childmsg3=childhand.obtainMessage();
			childmsg3.what=EVServerhttp.SETDEVSTATUCHILD;
			JSONObject ev3=null;
			try {
				ev3=new JSONObject();
				ev3.put("bill_err", bill_err);
				ev3.put("coin_err", coin_err);	    			  			
				ToolClass.Log(ToolClass.INFO,"EV_SERVER","Send0.1="+ev3.toString(),"server.txt");
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			childmsg3.obj=ev3;
			childhand.sendMessage(childmsg3);
			break;	
		//发送交易记录命令到子线程中
		case EVServerhttp.SETRECORDCHILD://子线程接收主线程消息获取心跳信息
			childhand=serverhttp.obtainHandler();
			Message childheartmsg2=childhand.obtainMessage();
			childheartmsg2.what=EVServerhttp.SETRECORDCHILD;
			childheartmsg2.obj=grid();
			childhand.sendMessage(childheartmsg2);						
			break;	
		//发送货道上传命令到子线程中	
		case EVServerhttp.SETHUODAOSTATUCHILD:				
			childhand=serverhttp.obtainHandler();
			Message childheartmsg3=childhand.obtainMessage();
			childheartmsg3.what=EVServerhttp.SETHUODAOSTATUCHILD;
			childheartmsg3.obj=columngrid();
			childhand.sendMessage(childheartmsg3);
			break;	
		}			
	}

}

@Override
public void onCreate() {
	// TODO Auto-generated method stub
	ToolClass.Log(ToolClass.INFO,"EV_SERVER","Service create","server.txt");
	super.onCreate();
	//9.注册接收器
	localBroadreceiver = LocalBroadcastManager.getInstance(this);
	receiver=new ActivityReceiver();
	IntentFilter filter=new IntentFilter();
	filter.addAction("android.intent.action.vmserversend");
	localBroadreceiver.registerReceiver(receiver,filter);						
}

@Override
public void onDestroy() {
	// TODO Auto-generated method stub		
	ToolClass.Log(ToolClass.INFO,"EV_SERVER","Service destroy","server.txt");
	//10.解除注册接收器
	localBroadreceiver.unregisterReceiver(receiver);
	super.onDestroy();
}

//11.发送广播
//返回给activity广播
intent=new Intent();
intent.putExtra("EVWhat", EVServerhttp.SETFAILMAIN);
intent.setAction("android.intent.action.vmse
rverrec");//action与接收器相同
localBroadreceiver.sendBroadcast(intent);	


3)使用观察者模式 ，service为被观察者，所以的activity为观察者，当service中的内容发生改变时，通知所有的activity来更新，代码如下
Service类：
package com.example.servicecallback;

import java.util.Observable;
import java.util.Observer;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;

public class ContentService extends Service {

  //被观察者
  private MyObservable mObservable;

  @Override
  public IBinder onBind(Intent arg0) {
    return new LocalBinder();
  }

  @Override
  public void onCreate() {
    super.onCreate();
    mObservable = new MyObservable();
  }

  public final class LocalBinder extends Binder {
    public ContentService getService() {
      return ContentService.this;
    }
  }

  public void asyncSendPerson(final String name) {
    // 休息5秒，模拟异步任务
    new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          Thread.sleep(5000);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        handler.sendMessage(handler.obtainMessage(0, name));
      }
    }).start();
  }

  /**
   * 添加观察者
   * @param observer
   */
  public void addObserver(Observer observer) {
    mObservable.addObserver(observer);
  }

  private Handler handler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
      String name = (String) msg.obj;
      Person person = new Person();
      person.setName(name);
      //通知更新
      mObservable.notifyChanged(person);
    }
  };

  public class MyObservable extends Observable {
    
    public void notifyChanged(Object object) {
      this.setChanged();
      this.notifyObservers(object);
    }
  }
}
View Code

第一个activity：


package com.example.servicecallback;

import java.util.Observable;
import java.util.Observer;
import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.TextView;

import com.example.servicecallback.ContentService.LocalBinder;

public class MainActivity extends Activity implements Observer {

  private MyServiceConn conn;
  private TextView mContent;
  private ContentService mService;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    conn = new MyServiceConn();
    bindService(new Intent(this, ContentService.class), conn,
        BIND_AUTO_CREATE);

    mContent = (TextView) findViewById(R.id.content);

    this.findViewById(R.id.button1).setOnClickListener(
        new OnClickListener() {
          @Override
          public void onClick(View v) {
            startActivity(new Intent(MainActivity.this,
                OtherActivity.class));
          }
        });
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }

  public class MyServiceConn implements ServiceConnection {

    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
      mService = ((LocalBinder) binder).getService();
      //将当前activity添加为观察者
      mService.addObserver(MainActivity.this);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
      mService = null;
    }
  }

  @Override
  protected void onDestroy() {
    super.onDestroy();
    unbindService(conn);
  }

  //更新UI
  @Override
  public void update(Observable observable, Object data) {
    Person person = (Person) data;
    mContent.setText(person.toString());
  }

}
View Code

第二个activity：


package com.example.servicecallback;

import java.util.Observable;
import java.util.Observer;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.example.servicecallback.ContentService.LocalBinder;

public class OtherActivity extends Activity implements Observer {

  private ContentService service;
  private TextView mContent;
  private Button mSubmit;
  private EditText mEditText;
  private ServiceConnection conn;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.other);

    mEditText = (EditText) findViewById(R.id.edittext);
    mSubmit = (Button) findViewById(R.id.button1);
    mContent = (TextView) findViewById(R.id.content);

    mSubmit.setOnClickListener(new OnClickListener() {
      @Override
      public void onClick(View v) {
        String name = mEditText.getText().toString();
        service.asyncSendPerson(name);
      }
    });

    conn = new MyServiceConn();
    bindService(new Intent(OtherActivity.this, ContentService.class), conn,
        BIND_AUTO_CREATE);

  }

  public final class MyServiceConn implements ServiceConnection {
    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
      service = ((LocalBinder) binder).getService();
      //将当前activity添加为观察者
      service.addObserver(OtherActivity.this);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
      service = null;
    }
  }

  @Override
  protected void onDestroy() {
    super.onDestroy();
    unbindService(conn);
  }

  //更新UI
  @Override
  public void update(Observable observable, Object data) {
    // TODO Auto-generated method stub
    Person person=(Person) data;
    
    mContent.setText(person.toString());
  }
}

*串口操作使用三方包android_serialport_api
1)在主页面
public class MainActivity extends Activity {
	FileOutputStream mOutputStream;  
    FileInputStream mInputStream;  
    SerialPort sp; 
    EditText edtrecv;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        final EditText edtsend= (EditText)findViewById(R.id.edtsend); 
        edtrecv= (EditText)findViewById(R.id.edtrecv);
        Button btnopen=(Button)findViewById(R.id.btnopen);  
        btnopen.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				try {  
	            sp=new SerialPort(new File("/dev/ttyS1"),9600,0);  
	            } catch (SecurityException e) {  
	                // TODO Auto-generated catch block  
	                e.printStackTrace();  
	            } catch (IOException e) {  
	                // TODO Auto-generated catch block  
	                e.printStackTrace();  
	            }     
	                
	              
	              mOutputStream=(FileOutputStream) sp.getOutputStream();  
	              mInputStream=(FileInputStream) sp.getInputStream();  
	              
	               Toast.makeText(getApplicationContext(), "open",  
	                        Toast.LENGTH_SHORT).show();   
			}
		});
        Button btnsend=(Button)findViewById(R.id.btnsend);  
        btnsend.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				//发送十六进制
				byte content[] = new byte[16];
				content[0]= ((char)0x0c);
				content[1]= ((char)0x1a);
				content[2]= ((char)0x0a);
				content[3]= ((char)0x06);
				content[4]= ((char)0x07);
				content[5]= ((char)0x50);
				content[6]= ((char)0x58);

				content[7]= ((char)0x05);
				content[8]= ((char)0x04);
				content[9]= ((char)0x0b);

				content[10]= ((char)0x02);
				content[11]= ((char)0x06);
				content[12]= ((char)0x01);
				content[13]= ((char)0x2b);

				content[14]= ((char)0x16);
				content[15]= ((char)0x09);
				
				
				try {  
	                mOutputStream.write(content);
	            } catch (IOException e) {  
	                e.printStackTrace();  
	            }
				
				//发送字符串
//				String str=edtsend.getText().toString();
//				 try {  
//		                mOutputStream.write(str.getBytes());  
//		                mOutputStream.write('\n');  
//		            } catch (IOException e) {  
//		                e.printStackTrace();  
//		            }  
				         
		             
		              Toast.makeText(getApplicationContext(), "send",  
		                         Toast.LENGTH_SHORT).show(); 
			}
		});
        Button btnrecv=(Button)findViewById(R.id.btnrecv);  
        btnrecv.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				int size;  
	              
	            try {  
	            byte[] buffer = new byte[64];  
	            if (mInputStream == null) return;  
	            size = mInputStream.read(buffer);
//	            //接收十六进制
//	            String res="";
//			    for(int i=0;i<size;i++)
//			    {
//			    	String hex = Integer.toHexString(buffer[i] & 0xFF);
//		            if (hex.length() == 1)
//		            {
//		                hex = '0' + hex;
//		            }	
//			    	res+="["+hex.toUpperCase()+"]";
//			    }
//			    edtrecv.setText(res);
	            //接收字符串
	            if (size > 0) 
	            {  
	                String str=new String(buffer, 0, size);
	                edtrecv.setText(str);   
	            }  
	        } catch (IOException e) {  
	            e.printStackTrace();  
	            return;  
	        }  
			}
		});
        
        
    } 

	//收到数据后，自动返回触发回调数值
	@Override
	protected void onDataReceived(final byte[] buffer, final int size) {
		runOnUiThread(new Runnable() {
			public void run() {
				if (mReception != null) {
					mReception.append(new String(buffer, 0, size));
				}
			}
		});
	}	
}	

2）在线程里面
@Override
public void run() {
	// TODO Auto-generated method stub
	Looper.prepare();//用户自己定义的类，创建线程需要自己准备loop
	ToolClass.Log(ToolClass.INFO,"EV_COM","Thread start["+Thread.currentThread().getId()+"]","com.txt");
	//打开串口1
	try {  
		sp=new SerialPort(new File("/dev/ttyS1"),9600,0);  
	} catch (SecurityException e) {  
		// TODO Auto-generated catch block  
		e.printStackTrace();  
	} catch (IOException e) {  
		// TODO Auto-generated catch block  
		e.printStackTrace();  
	}
			
	childhand=new Handler()
	{
		@Override
		public void handleMessage(Message msg) {
			switch (msg.what)
			{
			case EV_BENTO_CHECKCHILD://子线程接收主线程格子查询消息		
				//1.得到本机编号信息
				JSONObject ev=null;
				try {
					ev = new JSONObject(msg.obj.toString());
					cabinet=ev.getInt("cabinet");
					ToolClass.Log(ToolClass.INFO,"EV_COM","ThreadSend0.2=cabinet="+cabinet,"com.txt");
				} catch (JSONException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				//发送串口数据
				mOutputStream=(FileOutputStream) sp.getOutputStream(); 
				try {
					mOutputStream.write(BentPort.sendstatus(cabinet));
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				//向主线程返回信息
				final Message tomain11=mainhand.obtainMessage();
				tomain11.what=EV_BENTO_CHECKMAIN;
				mainhand.sendMessage(tomain11); // 发送消息
				break;						
			default:
				break;
			}
		}
		
	};
	//接收串口数据
	ScheduledExecutorService timer = Executors.newScheduledThreadPool(1);
	timer.scheduleWithFixedDelay(new Runnable() 
	{ 
		@Override 
		public void run() 
		{ 
			ToolClass.Log(ToolClass.INFO,"EV_COM","Thread hello["+Thread.currentThread().getId()+"]","com.txt");
		} 	           
	}, 3, 2, TimeUnit.SECONDS);       // timeTask 10*60
	Looper.loop();//用户自己定义的类，创建线程需要自己准备loop
}


3)String与十六进制数互转
/**   
 * 字符串转换成十六进制字符串  
 * @param String str 待转换的ASCII字符串  
 * @return String 每个Byte之间空格分隔，如: [61 6C 6B]  
 */      
public static String str2HexStr(String str)    
{      
  
    char[] chars = "0123456789ABCDEF".toCharArray();      
    StringBuilder sb = new StringBuilder("");    
    byte[] bs = str.getBytes();      
    int bit;      
        
    for (int i = 0; i < bs.length; i++)    
    {      
        bit = (bs[i] & 0x0f0) >> 4;      
        sb.append(chars[bit]);      
        bit = bs[i] & 0x0f;      
        sb.append(chars[bit]);    
        sb.append(' ');    
    }      
    return sb.toString().trim();      
}    
    
/**   
 * 十六进制转换字符串  
 * @param String str Byte字符串(Byte之间无分隔符 如:[616C6B])  
 * @return String 对应的字符串  
 */      
public static String hexStr2Str(String hexStr)    
{      
    String str = "0123456789ABCDEF";      
    char[] hexs = hexStr.toCharArray();      
    byte[] bytes = new byte[hexStr.length() / 2];      
    int n;      
  
    for (int i = 0; i < bytes.length; i++)    
    {      
        n = str.indexOf(hexs[2 * i]) * 16;      
        n += str.indexOf(hexs[2 * i + 1]);      
        bytes[i] = (byte) (n & 0xff);      
    }      
    return new String(bytes);      
}    
    
/**  
 * bytes转换成十六进制字符串  
 * @param byte[] b byte数组  
 * @return String 每个Byte值之间空格分隔  
 */    
public static String byte2HexStr(byte[] b)    
{    
    String stmp="";    
    StringBuilder sb = new StringBuilder("");    
    for (int n=0;n<b.length;n++)    
    {    
        stmp = Integer.toHexString(b[n] & 0xFF);    
        sb.append((stmp.length()==1)? "0"+stmp : stmp);    
        sb.append(" ");    
    }    
    return sb.toString().toUpperCase().trim();    
}    
    
/**  
 * bytes字符串转换为Byte值  
 * @param String src Byte字符串，每个Byte之间没有分隔符  
 * @return byte[]  
 */    
public static byte[] hexStr2Bytes(String src)    
{    
    int m=0,n=0;    
    int l=src.length()/2;    
    System.out.println(l);    
    byte[] ret = new byte[l];    
    for (int i = 0; i < l; i++)    
    {    
        m=i*2+1;    
        n=m+1;    
        ret[i] = Byte.decode("0x" + src.substring(i*2, m) + src.substring(m,n));    
    }    
    return ret;    
}    
  
/**  
 * String的字符串转换成unicode的String  
 * @param String strText 全角字符串  
 * @return String 每个unicode之间无分隔符  
 * @throws Exception  
 */    
public static String strToUnicode(String strText)    
    throws Exception    
{    
    char c;    
    StringBuilder str = new StringBuilder();    
    int intAsc;    
    String strHex;    
    for (int i = 0; i < strText.length(); i++)    
    {    
        c = strText.charAt(i);    
        intAsc = (int) c;    
        strHex = Integer.toHexString(intAsc);    
        if (intAsc > 128)    
            str.append("\\u" + strHex);    
        else // 低位在前面补00    
            str.append("\\u00" + strHex);    
    }    
    return str.toString();    
}    
    
/**  
 * unicode的String转换成String的字符串  
 * @param String hex 16进制值字符串 （一个unicode为2byte）  
 * @return String 全角字符串  
 */    
public static String unicodeToString(String hex)    
{    
    int t = hex.length() / 6;    
    StringBuilder str = new StringBuilder();    
    for (int i = 0; i < t; i++)    
    {    
        String s = hex.substring(i * 6, (i + 1) * 6);    
        // 高位需要补上00再转    
        String s1 = s.substring(2, 4) + "00";    
        // 低位直接转    
        String s2 = s.substring(4);    
        // 将16进制的string转为int    
        int n = Integer.valueOf(s1, 16) + Integer.valueOf(s2, 16);    
        // 将int转换为字符    
        char[] chars = Character.toChars(n);    
        str.append(new String(chars));    
    }    
    return str.toString();    
}   

*图表控件achartengine
将插件achartengine-1.0.0.jar放到工程的libs目录下
调用
Button pie=(Button) findViewById(R.id.pie); 
pie.setOnClickListener(new OnClickListener() {// 为退币按钮设置监听事件
	@Override
	public void onClick(View arg0) {
		Intent intent = new Intent(MainActivity.this, Pie.class);// 使用Accountflag窗口初始化Intent
		startActivity(intent);// 打开Accountflag
	}
});	
Button stacked=(Button) findViewById(R.id.stacked); 
stacked.setOnClickListener(new OnClickListener() {// 为退币按钮设置监听事件
	@Override
	public void onClick(View arg0) {
		Intent intent = new Intent(MainActivity.this, stacked.class);// 使用Accountflag窗口初始化Intent
		startActivity(intent);// 打开Accountflag
	}
});
Button line=(Button) findViewById(R.id.line); 
line.setOnClickListener(new OnClickListener() {// 为退币按钮设置监听事件
	@Override
	public void onClick(View arg0) {
		Intent intent = new Intent(MainActivity.this, Line.class);// 使用Accountflag窗口初始化Intent
		startActivity(intent);// 打开Accountflag
	}
});


1)饼状图
import org.achartengine.ChartFactory;
import org.achartengine.model.CategorySeries;
import org.achartengine.renderer.DefaultRenderer;
import org.achartengine.renderer.SimpleSeriesRenderer;

import android.app.Activity;
import android.graphics.Color;
import android.os.Bundle;
import android.view.View;

public class Pie extends Activity{

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		double[] values = new double[] { 12, 14, 11, 10, 19 };
        int[] colors = new int[] { Color.BLUE, Color.GREEN, Color.MAGENTA, Color.YELLOW, Color.CYAN };
        DefaultRenderer renderer = buildCategoryRenderer(colors);
        renderer.setZoomButtonsVisible(true);
        renderer.setZoomEnabled(true);
        renderer.setChartTitleTextSize(20);
        //        Intent intent = ChartFactory.getPieChartIntent(this, buildCategoryDataset("Project budget", values), renderer, "Budget");
        //        startActivity(intent);
        View view = ChartFactory.getPieChartView(this, buildCategoryDataset("Project budget", values), renderer);
        view.setBackgroundColor(Color.BLACK);
        setContentView(view);
	}
	protected DefaultRenderer buildCategoryRenderer(int[] colors) {
        DefaultRenderer renderer = new DefaultRenderer();
        renderer.setLabelsTextSize(15);
        renderer.setLegendTextSize(15);
        renderer.setMargins(new int[] { 20, 30, 15, 0 });
        for (int color : colors) {
            SimpleSeriesRenderer r = new SimpleSeriesRenderer();
            r.setColor(color);
            renderer.addSeriesRenderer(r);
        }
        return renderer;
    }

    protected CategorySeries buildCategoryDataset(String title, double[] values) {
        CategorySeries series = new CategorySeries(title);
        int k = 0;
        for (double value : values) {
            series.add("Project " + ++k + " (" + value + ")", value);
        }
        return series;
    }
	
}
分析demo。

代码中比较关键的地方其实是 ChartFactory.getPieChartView，它返回一个view，也就是我们需要显示的chart。那么我们看看这个方法（在doc上有开发说明）：

public static final GraphicalView getPieChartView(android.content.Context context,
                                                  CategorySeries dataset,
                                                  DefaultRenderer renderer)

Creates a pie chart intent that can be used to start the graphical view activity. 
Parameters:
context - the context
dataset - the category series dataset (cannot be null)
renderer - the series renderer (cannot be null)
Returns:
a pie chart view
Throws:
java.lang.IllegalArgumentException - if dataset is null or renderer is null or if the dataset number of items is different than the number of series renderer。
所以需要两个非常重要的参数，也就是开始我们提到的dataset、renderer。具体是如何构造的见代码。

这里需要值一提的是dataset中的item数应该和renderer中的SeriesRenderer数相等。每组数据应该对已一个renderer，也就是说每一组数据都应有自己独立的显示样式。


2)柱状图：
import java.util.ArrayList;
import java.util.List;

import org.achartengine.ChartFactory;
import org.achartengine.chart.BarChart.Type;
import org.achartengine.model.CategorySeries;
import org.achartengine.model.XYMultipleSeriesDataset;
import org.achartengine.renderer.SimpleSeriesRenderer;
import org.achartengine.renderer.XYMultipleSeriesRenderer;

import android.app.Activity;
import android.graphics.Color;
import android.graphics.Paint.Align;
import android.os.Bundle;
import android.view.View;

public class stacked extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		String[] titles = new String[] { "2008", "2007" };
        List<double[]> values = new ArrayList<double[]>();
        values.add(new double[] { 14230, 12300, 14240, 15244, 15900, 19200, 22030, 21200, 19500, 15500, 12600, 14000 });
        values.add(new double[] { 5230, 7300, 9240, 10540, 7900, 9200, 12030, 11200, 9500, 10500, 11600, 13500 });
        int[] colors = new int[] { Color.BLUE, Color.CYAN };
        XYMultipleSeriesRenderer renderer = buildBarRenderer(colors);
        setChartSettings(renderer, "Monthly sales in the last 2 years", "Month", "Units sold", 0.5, 12.5, 0, 24000, Color.GRAY, Color.LTGRAY);
        renderer.getSeriesRendererAt(0).setDisplayChartValues(true);
        renderer.getSeriesRendererAt(1).setDisplayChartValues(true);
        renderer.setXLabels(12);
        renderer.setYLabels(10);
        renderer.setXLabelsAlign(Align.LEFT);
        renderer.setYLabelsAlign(Align.LEFT);
        renderer.setPanEnabled(true, false);
        renderer.setZoomEnabled(false);
        renderer.setZoomRate(1.1f);
        renderer.setBarSpacing(0.5f);
        View view = ChartFactory.getBarChartView(this, buildBarDataset(titles, values), renderer, Type.DEFAULT); //Type.STACKED
        view.setBackgroundColor(Color.BLACK);
        setContentView(view);
	}
	 protected XYMultipleSeriesDataset buildBarDataset(String[] titles, List<double[]> values) {
	        XYMultipleSeriesDataset dataset = new XYMultipleSeriesDataset();
	        int length = titles.length;
	        for (int i = 0; i < length; i++) {
	            CategorySeries series = new CategorySeries(titles[i]);
	            double[] v = values.get(i);
	            int seriesLength = v.length;
	            for (int k = 0; k < seriesLength; k++) {
	                series.add(v[k]);
	            }
	            dataset.addSeries(series.toXYSeries());
	        }
	        return dataset;
	    }

	    protected XYMultipleSeriesRenderer buildBarRenderer(int[] colors) {
	        XYMultipleSeriesRenderer renderer = new XYMultipleSeriesRenderer();
	        renderer.setAxisTitleTextSize(16);
	        renderer.setChartTitleTextSize(20);
	        renderer.setLabelsTextSize(15);
	        renderer.setLegendTextSize(15);
	        int length = colors.length;
	        for (int i = 0; i < length; i++) {
	            SimpleSeriesRenderer r = new SimpleSeriesRenderer();
	            r.setColor(colors[i]);
	            renderer.addSeriesRenderer(r);
	        }
	        return renderer;
	    }

	    protected void setChartSettings(XYMultipleSeriesRenderer renderer, String title, String xTitle, String yTitle, double xMin, double xMax, double yMin, double yMax, int axesColor, int labelsColor) {
	        renderer.setChartTitle(title);
	        renderer.setXTitle(xTitle);
	        renderer.setYTitle(yTitle);
	        renderer.setXAxisMin(xMin);
	        renderer.setXAxisMax(xMax);
	        renderer.setYAxisMin(yMin);
	        renderer.setYAxisMax(yMax);
	        renderer.setAxesColor(axesColor);
	        renderer.setLabelsColor(labelsColor);
	    }
	
}
4、分析demo。

①设置两组需要显示的数据（当然你可以写多组数据）。

②设置renderer的一些样式。当然这里的样式设置比pie chart的设置要复杂一些，除了设置数据本身的样式意外还需要对坐标轴也做设置（当然不设置就是默认的样式）。具体renderer样式的设置这里就不做过多的介绍了，在官方文档中都是有的，或者google一些很多解释。

 

5、总结。

stacked Chart 比pie chart稍微复杂一点：①可以包括多组数据；②renderer要设置要复杂点。

stacked Chart需要的dataset中需要一组或多组数据。总的来说根据demo来理解还是很容易的。


3)折线图
import java.util.ArrayList;
import java.util.List;

import org.achartengine.ChartFactory;
import org.achartengine.chart.PointStyle;
import org.achartengine.model.XYMultipleSeriesDataset;
import org.achartengine.model.XYSeries;
import org.achartengine.renderer.XYMultipleSeriesRenderer;
import org.achartengine.renderer.XYSeriesRenderer;

import android.app.Activity;
import android.graphics.Color;
import android.graphics.Paint.Align;
import android.os.Bundle;
import android.view.View;

public class Line extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		String[] titles = new String[] { "Crete", "Corfu", "Thassos", "Skiathos" };
        List<double[]> x = new ArrayList<double[]>();
        for (int i = 0; i < titles.length; i++) {
            x.add(new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 });
        }
        List<double[]> values = new ArrayList<double[]>();
        values.add(new double[] { 12.3, 12.5, 13.8, 16.8, 20.4, 24.4, 26.4, 26.1, 23.6, 20.3, 17.2, 13.9 });
        values.add(new double[] { 10, 10, 12, 15, 20, 24, 26, 26, 23, 18, 14, 11 });
        values.add(new double[] { 5, 5.3, 8, 12, 17, 22, 24.2, 24, 19, 15, 9, 6 });
        values.add(new double[] { 9, 10, 11, 15, 19, 23, 26, 25, 22, 18, 13, 10 });
        int[] colors = new int[] { Color.BLUE, Color.GREEN, Color.CYAN, Color.YELLOW };
        PointStyle[] styles = new PointStyle[] { PointStyle.CIRCLE, PointStyle.DIAMOND, PointStyle.TRIANGLE, PointStyle.SQUARE };
        XYMultipleSeriesRenderer renderer = buildRenderer(colors, styles);
        int length = renderer.getSeriesRendererCount();
        for (int i = 0; i < length; i++) {
            ((XYSeriesRenderer) renderer.getSeriesRendererAt(i)).setFillPoints(true);
        }
        setChartSettings(renderer, "Average temperature", "Month", "Temperature", 0.5, 12.5, -10, 40, Color.LTGRAY, Color.LTGRAY);
        renderer.setXLabels(12);
        renderer.setYLabels(10);
        renderer.setShowGrid(true);
        renderer.setXLabelsAlign(Align.RIGHT);
        renderer.setYLabelsAlign(Align.RIGHT);

        renderer.setZoomButtonsVisible(true);
        renderer.setPanLimits(new double[] { -10, 20, -10, 40 });
        renderer.setZoomLimits(new double[] { -10, 20, -10, 40 });

        View view = ChartFactory.getLineChartView(this, buildDataset(titles, x, values), renderer);
        view.setBackgroundColor(Color.BLACK);
        setContentView(view);
	}
	private XYMultipleSeriesRenderer buildRenderer(int[] colors, PointStyle[] styles) {
        XYMultipleSeriesRenderer renderer = new XYMultipleSeriesRenderer();
        setRenderer(renderer, colors, styles);
        return renderer;
    }

    private void setRenderer(XYMultipleSeriesRenderer renderer, int[] colors, PointStyle[] styles) {
        renderer.setAxisTitleTextSize(16);
        renderer.setChartTitleTextSize(20);
        renderer.setLabelsTextSize(15);
        renderer.setLegendTextSize(15);
        renderer.setPointSize(5f);
        renderer.setMargins(new int[] { 20, 30, 15, 20 });
        int length = colors.length;
        for (int i = 0; i < length; i++) {
            XYSeriesRenderer r = new XYSeriesRenderer();
            r.setColor(colors[i]);
            r.setPointStyle(styles[i]);
            renderer.addSeriesRenderer(r);
        }
    }

    private void setChartSettings(XYMultipleSeriesRenderer renderer, String title, String xTitle, String yTitle, double xMin, double xMax, double yMin, double yMax, int axesColor, int labelsColor) {
        renderer.setChartTitle(title);
        renderer.setXTitle(xTitle);
        renderer.setYTitle(yTitle);
        renderer.setXAxisMin(xMin);
        renderer.setXAxisMax(xMax);
        renderer.setYAxisMin(yMin);
        renderer.setYAxisMax(yMax);
        renderer.setAxesColor(axesColor);
        renderer.setLabelsColor(labelsColor);
    }

    private XYMultipleSeriesDataset buildDataset(String[] titles, List<double[]> xValues, List<double[]> yValues) {
        XYMultipleSeriesDataset dataset = new XYMultipleSeriesDataset();
        addXYSeries(dataset, titles, xValues, yValues, 0);
        return dataset;
    }

    private void addXYSeries(XYMultipleSeriesDataset dataset, String[] titles, List<double[]> xValues, List<double[]> yValues, int scale) {
        int length = titles.length;
        for (int i = 0; i < length; i++) {
            XYSeries series = new XYSeries(titles[i], scale);
            double[] xV = xValues.get(i);
            double[] yV = yValues.get(i);
            int seriesLength = xV.length;
            for (int k = 0; k < seriesLength; k++) {
                series.add(xV[k], yV[k]);
            }
            dataset.addSeries(series);
        }
    }
4、分析demo。

 首先代码看上去貌似很多，不过简单易懂。总结下来不外乎就几个方面：

①生成坐标数据。（当然你也可以根据自己的需要生成一组或多组数据，为了数据之间的对比所以文中写了多组数据）。

②生成渲染器。渲染器需要设置哪些可以根据需要而定，当然前提是你得知道它每个参数的意义，文中是比较全面的设置。

③设置数据和渲染器。

大概就只做了这些工作，至于具体的实现方法你可以自己阅读一下。	

*数据库
具体的请看书
Android数据库升级、降级、创建(onCreate() onUpgrade() onDowngrade()）的注意点
public abstract void onCreate(SQLiteDatabase db)

数据库被首次创建时，会调用这个方法。这时创建数据库表和表初始化的地方。

参数：

db：要创建的数据库。

 

public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion)

当数据库需要被降级时，调用这个方法。这个方法与onUpgrade(SQLiteDatabase, int, int)方法非常相似，但是它是在当前版本比请求的版本新的时候，才会被调用。但是这个方法不是抽象的，因此它不是强制要求客户实现它的。如果这个方法没有被重写，默认的实现会拒绝降级处理，并抛出SQLiteException异常。

这个方法是在事务中执行的。如果有异常被抛出，所有的改变都会被回滚。

参数：

db：指定要降级的数据库

oldVersion：旧的数据库版本

newVersion：新的数据库版本

 

public void onOpen(SQLiteDatabase db)

数据库被打开时，会调用这个方法。在升级数据库之前，这个方法的实现应该检查数据库是否是只读的（调用isReadOnly()方法）。

数据库连接被配置且数据库策略被创建、升级或必要的降级之后，这个方法会被调用。如果数据库连接必须在策略被创建、升级或降级前做某些设置，那么就要在onConfigure(SQLiteDatabase)方法中来做这些事情。

参数：

db：被打开的数据库。

 

public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)

当数据库需要升级时，会调用这个方法。应该使用这个方法来实现删除表、添加表或者做一些需要升级新的策略版本的事情。

SQLite ALTER TABLE的文档可以在以下网址中找到：

http://sqlite.org/lang_altertable.html

如果要重新创建表，调用oncreat的方法，只要在这里面添加这一行代码
onCreate(db);就可以了

如果要给表添加一个新列，那么使用使用ALTER TABLE能够把新列插入到表中。如果要重命名或删除列，那么你能够使用ALTER TABLE能够重命名旧表，然后，创建一个新表，并把旧表中内容复制到新表中。

这个方法是事务中执行的，如果有异常被抛出，所有的改变都会被自动的回滚。

参数：

db：指定要降级的数据库

oldVersion：旧的数据库版本

newVersion：新的数据库版本

*往页面里面添加多个布局文件
//这个是上面的柱状图布局文件
View view = ChartFactory.getBarChartView(this, buildBarDataset(titles, values), renderer, Type.DEFAULT); //Type.STACKED
view.setBackgroundColor(Color.BLACK);              

//新建一个布局文件  
final LinearLayout layout2 = new LinearLayout(this);
layout2.setOrientation(LinearLayout.VERTICAL);
Button bt1 = new Button(this);        
bt1.setText("按钮退出");  
layout2.addView(bt1); //添加按钮
layout2.addView(view);//添加柱状图

setContentView(layout2);
//按钮事件
bt1.setOnClickListener(new View.OnClickListener() {

@Override
public void onClick(View v) {
	// TODO Auto-generated method stub
	finish();
}
 		

*摄像头拍照：
SurfaceView提供了一个高速的刷新空间，作视频播放使用
Camera照相机类
1、添加权限和功能的支持AndroidManifest.xml
<activity
            android:name="com.example.camera.MainActivity"
            android:label="@string/app_name"
            android:screenOrientation="landscape" >
			
<uses-feature android:name="android.hardware.camera"/>
	<uses-feature android:name="android.hardware.camera.autofocus"/>
	<uses-permission android:name="android.permission.CAMERA"/>
	<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
	<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
	
2.	
import android.hardware.Camera;
public class MainActivity extends Activity {
	private SurfaceView sur=null;
	private Button but=null;
	private SurfaceHolder holder=null;
	private Camera cam=null;
	public boolean previewRunning;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		sur=(SurfaceView) findViewById(R.id.sur);
		holder=this.sur.getHolder();
		holder.addCallback(new surcallback());
		holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);//设置缓存处理
		holder.setFixedSize(500, 350);//设置分辨率
		
		but=(Button) findViewById(R.id.but);		
		but.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				if(cam!=null)
				{
					//自动对焦	
					cam.autoFocus(new AutoFocus());
				}
			}
		});
	}
	
	//预览摄像
	private class surcallback implements SurfaceHolder.Callback
	{

		@Override
		public void surfaceChanged(SurfaceHolder holder, int format, int width,
				int height) {
			// TODO Auto-generated method stub
			
		}

		@Override
		//预览摄像
		public void surfaceCreated(SurfaceHolder holder) {
			// TODO Auto-generated method stub
			//把摄像头的图片导入surfaceview中，0是后置的，1是前置的摄像头
			//MainActivity.this.cam=Camera.open(0);
			MainActivity.this.cam = Camera.open(1);   // 取得摄像头
			WindowManager manager=(WindowManager) MainActivity.this.getSystemService(Context.WINDOW_SERVICE);
			//WindowManager manager = (WindowManager)getSystemService(Context.WINDOW_SERVICE); // 取得窗口服务
			Display display=manager.getDefaultDisplay();
			Parameters param=MainActivity.this.cam.getParameters();
			param.setPreviewSize(display.getWidth(), display.getHeight());
			param.setPreviewFrameRate(15);//一秒显示5针
			param.setPictureFormat(PixelFormat.JPEG);//保存图片格式
			param.set("jpen-quality",95);//图片质量
			MainActivity.this.cam.setParameters(param);
			try {
				MainActivity.this.cam.setPreviewDisplay(MainActivity.this.holder);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			MainActivity.this.cam.startPreview();//进行预览
			MainActivity.this.previewRunning=true;
		}

		@Override
		//销毁摄像
		public void surfaceDestroyed(SurfaceHolder holder) {
			// TODO Auto-generated method stub
			if(MainActivity.this.cam!=null)
			{
				if(MainActivity.this.previewRunning==true)
				{
					MainActivity.this.cam.stopPreview();
					MainActivity.this.previewRunning=false;
				}
				MainActivity.this.cam.release();
			}
		}
		
	}
	
	//对焦
	private class AutoFocus implements AutoFocusCallback
	{

		@Override
		public void onAutoFocus(boolean success, Camera camera) {
			// TODO Auto-generated method stub
			if(success)//对焦成功
			{
				MainActivity.this.cam.takePicture(sc, pc, jpgcall);
			}
		}
		
	}
	//处理后得到的图像,保存图片
	private PictureCallback jpgcall=new PictureCallback()
	{

		@Override
		public void onPictureTaken(byte[] data, Camera camera) {
			// TODO Auto-generated method stub
			//所有捕获的图片，都保留在data数组中,将它变为bitmap
			Bitmap bmp=BitmapFactory.decodeByteArray(data, 0, data.length);
			//取得图片的sd卡路径和名称
			String filename=Environment.getExternalStorageDirectory().toString()+File.separator+"testphoto"
			       +File.separator+System.currentTimeMillis()+".jpg";
			File file=new File(filename);
			if(!file.getParentFile().exists())
			{
				file.getParentFile().mkdirs();
			}
			try {
				BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(file));
				//向bos缓存区压缩图片
				bmp.compress(Bitmap.CompressFormat.JPEG, 80, bos);
				bos.flush();
				bos.close();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			//重新开始预览
			cam.stopPreview();
			cam.startPreview();
		}
		
	};
	//按下快门后的操作
	private ShutterCallback sc=new ShutterCallback()
	{

		@Override
		public void onShutter() {
			// TODO Auto-generated method stub
			
		}		
		
	};
	//原始图像
	private PictureCallback pc=new PictureCallback()
	{

		@Override
		public void onPictureTaken(byte[] data, Camera camera) {
			// TODO Auto-generated method stub
			
		}
		
	};

}

*多点触控:但是只用于放大一张图片而已，用处不大
Activity窗体
@Override
//多点触控
public boolean onTouchEvent(MotionEvent event) {
	// TODO Auto-generated method stub
	event.getPointerCount();//放在屏幕上有几个手指
	x=event.getX(0);//第一个手指所在的x轴  event.getY(0)
	return super.onTouchEvent(event);	
}

*JNI开发:JNI是一个接口，把c,c++程序封装成jni，供android调用
1.环境安装:
1)下载android-ndk-r9d，这个是ndk插件，用来交叉编译
  eclipse->windows->preferences->Android->ndk->路径选择ndk的路径
  C:\android\android-ndk-r9d
2)下载cygwin，选择一个安装连接，点击Devel-Default，使之变成Devel-Install来安装配置包，展开后选择gcc,gdb,make,g++：
安装一个模拟Linux环境的虚拟机，并且安装交叉编译器，编译c语言和c++语言
为了使用gcc注意cygwin的必选安装包在devel目录下：binutils，gcc，make。
总之，安装完成以后，运行cygwin的快捷方式，在控制台输入命令 gcc和make，有合理的反馈即可（不是SB的command not found）

具体安装步骤：

    运行setup.exe程序，直接点击Next进入下一步。
    选择安装方式。第一次可以采用Direct Connection在线下载安装，如有现成的离线包，可以选择离线安装（Install from Local Directory）。
    选择安装目录。比如D:\Java\Cygwin，注意此目录是指Cygwin最终的安装目录，不是下载文件暂存目录。
    接下来是选择安装插件包了，下面这个奇怪的长串就是我们云盘里面解压出来的根目录。暂存目录默认是放到setup.exe的同级目录下。安装完成后把这个文件夹打包备份，以后再配置时不用重新下载。
    设置网络连接方式。这个目前河蟹没爬过来，选第一个即可。
    选择下载站点地址。据说国内163站点的速度不错，我也是用的这个。
    等待加载安装项载入，选择安装项。由于我们要进行编译，下面的两项需要点击Devel-Default，使之变成Devel-Install，展开后可以看到其下的子项被选中了，shells-Install。此界面其他设置都不用动。
    等待下载完成。下载完成时间决定于你选择的安装包数量及网络连接速度，安装我安装的版本，约983M，下载完成后会自动安装到上文设置的安装目录，安装也要时间的，总时间较长，去吃个饭没啥问题。

提醒：第四步的备份建议，尽量去做。如果有备份，第二步中选择离线安装。
验证:

运行安装目录下的“Cygwin.bat”，第一次运行时，它会自动创建用户信息，用户信息存放在“.\Cygwin\home”中。
在运行“Cygwin.bat”打开的命令行窗口输入：“cygcheck -c cygwin”命令，会打印出当前Cygwin的版本和运行状态，如果status是ok的话，则cygwin运行正常。
分别输入：“make Cv”和，“gcc Cv”命令如果检测成功，会有make和gcc相关版本信息打印出来。
3)配置环境变量
在windows的系统环境变量中添加NDK的路径。使用“/cygdrive/c/android/android-ndk-r9d”这种Linux风格路径，
如果使用Windows下的“D:\Android\ndk”，Cygwin在编译时会发出警告。
输入
java
ndk-build
分别看是否配置成功

2.使用cygwin自带的示例
1)使用NDK编译程序
现在我们用安装好的NDK来编译一个NDK提供的sample程序hello-jni（我的目录位于：D:\android\ndk\samples\hello-jni）。

第一步：运行Cygwin，
配置环境变量后可输入“cd $ndk/samples/hello-jni/”，
未配置则输入命令“cd /cygdrive/d/android/ndk/samples/hello-jni”，进入到“hello-jni”工程目录。

第二步：编译。输入命令“ndk-build”命令即可编译。ndk-build是调用ndk的编译程序。

2）导入NDK的hello-jni示例到Eclipse中
第一步：在Eclipse中新建一个Android工程HelloJni。在Create Android Project时勾选“Create project from existing source”，Location中填“D:\Java\android-ndk-r8\samples\hello-jni” （注意：在选择API level时需要选择1.5或更高的版本）。
第二步：直接以Android Aplication运行。这里要注意，你之前在使用NDK编译程序时要把这个hello-jni编译过并产生了.so文件，此处才能运行起来。
3)编译运行程序，下载到android中运行
4)修改hello-jni.c文件之后
源文件存放在hello-jni\jni\hello-jni.c中，so文件存放在\hello-jni\libs\armeabi\libhello-jni.so中
重新ndk-build,然后eclipse重新project->cliean,然后将原来手机上的程序删除，
再重新生成程序，下载到android中运行

2.新建JNI工程
1)使用Java编写HelloWorld 的Android应用程序
新建接口声明文件JNIinte.java
package com.example.testj3;

public class JNIinte {
	static
	{
		//2.加载JNI库文件
		System.loadLibrary("HelloJNI");
	}
	//3.声明JNI库函数 参数为String类型 返回类型为String
	static public native String printJNI(String str);
}

新建调用程序MainActivity.java
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		txtJNI=(TextView) findViewById(R.id.txtJNI);
		btnJNI=(Button) findViewById(R.id.btnJNI);
		btnJNI.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				//1.调用JNI接口函数
				txtJNI.setText(JNIinte.printJNI("Hello I'm JNI"));
			}
		});
	} 

2)生成共享库的头文件
　　进入到eclipse生成的Android Project中 ：/HelloWorld/bin/classes/com/example/testj3 下：
　　可以看到里面后很多后缀为.class的文件，就是eclipse为我们自动编译好了的java文件，其中就有：
　　　　JNIinte.class文件。
　　退回到classes一级目录：/HelloWorld/bin/classes/
执行如下命令：
　　 javah -classpath . com.example.testj3.JNIinte
　　在class目录旁边就会生成文件h:com_example_testj3_JNIinte.h

3)在eclipse实现这个h文件的JNI原生函数C源文件
（1）右击工程->Android Tools->Add Native Support->名称使用刚才调用的库名称
"HelloJNI"
（2）删除系统生成的HelloJNI.cpp文件，这个是c++文件，我们用不上     
（3）新建新的文件com_example_testj3_JNIinte.c	 
把.h文件中关于这个函数的声明拷贝过来，存放到/HelloWorld/jni/下并予以实现
#include <jni.h>
#include <string.h>
JNIEXPORT jstring JNICALL Java_com_example_testj3_JNIinte_printJNI
  (JNIEnv *env, jclass cls, jstring str)
{
	return (*env)->NewStringUTF(env, "easivend--->Hello !  ");
}


（4）Android.mk文件
LOCAL_MODULE    := HelloJNI
LOCAL_SRC_FILES := com_example_testj3_JNIinte.c

其中LOCAL_MODULE    := HelloJNI代表public class JNIinte ，
LOCAL_SRC_FILES := com_example_testj3_JNIinte.c是库文件路径，因为目前使用相对路径，
因此.c文件要放在/HelloWorld/jni/中，即与Android.mk文件同一个路径下

4） 使用NDK编译程序生成so库：
使用cygwin进入
$ cd /cygdrive/d/android/javaprj/HelloWorld
$ ndk-build
编译本工程
如果失败会弹出错误，如果成功，会生成.so库
Android NDK: WARNING: APP_PLATFORM android-18 is larger than android:minSdkVersion 8 in ./AndroidManifest.xml
[armeabi] Compile thumb  : JNIinteJNI <= com_example_jnit_JNIinte.c
[armeabi] SharedLibrary  : libJNIinteJNI.so
[armeabi] Install        : libJNIinteJNI.so => libs/armeabi/libJNIinteJNI.so

Helloworld的eclipse按下f5刷新一下，生成的so文件会放在\HelloWorld\libs\armeabi中

5）关闭C++的检查
Project->Properties->c++ General->Code Analysis:
选择Use project settings
取消勾选Syntax and semantic errors

6)貌似这个工程以后，直接修改.c文件后，编译器会自动编译，而不用cygwin,可以试一下

3.jni的核心API
其中将Java的String转为C的字符串
portName = (char *)(*env)->GetStringUTFChars(env,jportName, NULL);
在c/c++本地代码中访问java的String对象
.在java中，使用的字符串String对象是Unicode码，即每个字符不论是中文还是英文或是符号，一个字符总是占用两个字节。
在c/c++本地代码中创建java的String对象
.java通过JNI接口可以将java的字符串转换到c/c++中的宽字符串(wchar_t *),或是传回一个UTF-8的字符串（char *）到c/c++。反过来，c/c++可以通过一个宽字符串，或是一个UTF-8编码的字符串来创建一个java端的String对象。
GetStringChars/GetStringUTFChars
.这两个函数用来取得与某个jstring对象相关的java字符串。分别可以取得UTF-16编码的宽字符串（jchar*）跟UTF-8编码的字符串（char*）。
Const jchar* GetStringChars(jstring str, jboolean* copied)
Const char* GetStringUTFChars(jstring str, jboolean* copied)
第一个参数传入一个指向java中的String对象的jstring变量
第二个参数传入的是一个jboolean的指针。
这两个函数分别都会有两个不同的动作：
第一个参数：
1、 开新内存，然后把java中的String拷贝到这个内存中，然后返回这个内存地址的指针。
2、 直接返回指向java中string的内存的指针，这个时候千万不要改变这个内存的内容，这将破坏String在java中始终是常量这个原则。
第二个参数：是用来标示是否对java的string对象进行了拷贝的。
如果传入的这个jboolean指针不是null,则他会给该指针指向的内存传入JNI_TRUE或JNI_FALSE标示是否进行了拷贝。
传入null标示不关心是否拷贝字符串，它就不会给jboolean*指向的内存赋值。
使用这两个函数取得的字符串，在不使用的时候，要使用ReleaseStringChars/ReleaseStringUTFChars来释放拷贝的内存，或是释放对java的String对象的引用。
ReleaseStringChars(jstring jstr, const jchar* str);
ReleaseStringUTFChars(jstring jstr, const char* str);
第一个参数指定一个jstring变量，即是要释放的本地字符串的来源。
第二个参数就是要释放的本地字符串
GetStringCritical:是为了增加直接传回指向java字符串的指针的可能性（而不是拷贝），jdk1.2出来了新的函数：GetStringCritical/ReleaseStringCritical。
Const jchar* GetStringCritical(jstring str, jboolean* copied)
Void realeaseStringCritical(jstring jstr, const jchar* str);
在GetStringCritical/RealeaseStringCritical之间是一个关键区。在这关键区之中绝对不能呼叫JNI的其他函数和会造成当前线程中断或是会让当前线程等待的任何本地代码，否则将造成关键区代码执行区间垃圾回收器停止运作，任何触发垃圾回收器的线程也会暂停。其他的触发垃圾回收器的线程不能前进直到当前线程结束而激活垃圾回收器。
在关键区中千万不雅出现中断操作，或是在jvm中分配任何新对象。否则会造成jvm死锁。
虽说这个函数会增加直接传回指向java字符串的指针的可能性，不过还是会根据情况传回拷贝过的字符串。
不支持GetStringUTFCritical,没有这样的函数。由于java字符串用的是UTF16,要转成UTF8编码的字符串始终需要进行一个拷贝。所以没有这样的函数。
GetStringRegion/GetStringUTFRegion
.java1.2出来的函数，这个函数的动作，是把java字符串的内容直接拷贝到c/c++的字符数组中。在呼叫这个函数之前必须有一个c/c++分配出来的字符串，然后传入到这个函数中进行字符串的拷贝。
由于c/c++中分配内存开销相对小，而且java中的String内容拷贝的开销可以忽略，更好的一点是此函数不分配内存，不会抛出OutOfMemoeryError异常。
//拷贝java字符串并以UTF-8编码传入buffer.
GetStringUTFRegion(String str, jsize start, jsize len, char* buffer);
//拷贝java字符串并以UTF-16编码传入buffer
GetStringRegion(jstring str, jsize start, jsize len, jchar* buffer);


其他的字符串函数：
.jstring NewString(const jchar* str, jszie len); 宽字符串（c/c++中的普通的字符串）
.jstring NewStringUTF(const char* str);
.jsize GetStringLength(jstring str);
.jsize GetStringUTFLength(jstring str);
例如：红线圈住的是对应的方法应用。Message是定义在java类中，在此省略了代码




 
处理数组：数组分为两种（基本类型的数组、对象类型的数组）
一个能通用于两种不同类型数组的函数：GetArrayLength(jarray array)
处理--基本类型的数组：
.处理基本类型的数组跟处理字符串类似，也有很相似的函数。
.Get<TYPE>ArrayElements(<TYPE>Array arr, jboolean* isCopied);这类的函数可以把java基本类型的数组转换到c/c++中的数组。有两种处理方式,一是拷贝一份传回本地代码，另一个是把指向java数组的指针传回到本地代码。处理完本地化的数组后，通过Release<TYPE>ArrayElements来释放数组。
.Release<TYPE>ArrayElements(<TYPE>Array arr, <TYPE>* array, jint mode);用这个函数可以选择将如何处理java跟c++的数组。是提交，还是撤销等，内存释放还是不释放。mode可以去下面的值：0(对java的数组进行更新并释放c/c++的数组)
JNI_COMMIT（对java的数组进行更新但不释放c/c++的数组）
JNI_ABORT (对java的数组不进行更新，释放c/c++的数组)
.GetPrimitiveArrayCritical(jarray arr, jboolean* isCopied);
 ReleasePrimitiveArrayCritical(jarray arr, void* array, jint mode);它们也是jdk1.2出来的，为了增加直接传回指向java数组的指针而加入的函数。同样的，也会有同GetStringCritical的死锁的问题。
.Get<TYPE>ArrayRegion(<TYPE>Array arr, jsize start, jsize len,<TYPE>* buffer);在c/c++预先开辟一段内存，然后把java基本类型的数组拷贝到这段内存中。跟GetStringRegion原理类似。
.Set<TYPE>ArrayRegion(<TYPE>Array arr, jsize start, jsize len, const<TYPE>* buffer);把java基本类型的数组中的指定范围的元素用c/c++的数组中的元素来赋值。
.<TYPE>Array New<TYPE>Array(jsize size);指定一个长度然后返回相应的java基本类型的数组。
 
处理―对象类型的数组【Object[]】: 
JNI没有提供直接把java的对象类型数组（Object[]）直接转到c/c++中的jobject[]数组的函数;而是直接通过GetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index)/ SetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index, jobject val)这样的函数来对java的Object[]数组进行操作。
.使用上述的函数也不用释放任何资源。
.NewObjectArray(jsize len, jclass clazz, jobject init)可以通过指定长度跟初始值来创建某个类的数组。
int[] arrays = {1,2,3,4,5,6,7,8,9,0};
public native void callCppFunction();
public static void main(String[] args) {
MainTest obj = new MainTest();
obj.callCppFunction();//这里会去访问数组。
for(int each: obj.arrays) {
System.out.println(each);
}
}


全局引用/局部引用/弱全局引用
.从java虚拟机创建的对象传到本地c/c++代码时会产生引用。根据java的垃圾回收机制，只要引用存在就不会触发该引用指向的java对象的垃圾回收。
.这些引用在JNI中分为三种：
局部引用(Local Reference);最常见的引用类型。基本上通过JNI返回来的引用都是局部引用。
例如使用NewObject就会返回创建出来的实例的局部引用。局部引用只在该Native函数中有效。所有在该函数中产生的局部引用，都会在函数返回的时候自动释放。也可以使用deleteLocalRef函数手动释放该引用。
注意：既然局部引用能够在函数返回时自动释放，为什么还需要deleteRef()函数呢？
实际上局部引用存在，就会防止其指向的对象被垃圾回收。尤其是当一个局部引用指向一个庞大的对象，或是在一个循环中生成了局部引用，最好的做法就是在使用完该对象后，或在该循环尾部把这个引用释放掉，以确保在垃圾回收器被触发的时候被回收。
在局部引用的有效期中，可以传递到别的本地函数中，要强调的是它的有效期仍然只在一次的java本地函数调用中，所以千万不能用c++全局变量保存它或是把它定义为c++静态局部变量。
全局引用(Global Reference);
全局引用可以跨越当前线程，在多个native函数中有效，不过需要编程人员手动来释放该引用。全局引用存在期间会防止在java的垃圾回收器中回收。
与局部引用不同的是，全局引用过的创建不是由JNI自动创建的，全局引用是需要调用NewGlobalRef函数，而释放它需要使用ReleaseGlobalRef函数。
弱全局引用(Weak Global Reference);
其是jdk1.2出来的功能，与全局引用相似，创建跟删除都需要编程人员手动来进行。这种引用与全局引用一样可以在多个本地代码有效，也跨越多线程有效。不一样的是，这种夹棍不会阻止垃圾回收器回收这个引用所指向的对象。
使用NewWeakGlobalRef跟ReleaseGlobalRef来产生和接触引用。
关于的一些函数：jobject NewGlobalRef（jobject obj）;
   Jobject NewLocalRef(jobject obj);
   Jobject NewWeakGlobalRef(jobject obj);
   Void  DeleteGlobalRef(jobject obj);
Void  DeleteLocalRef(jobject obj);
Void  DeleteWeakGlobalRef(jobject obj);
Jboolean IsSameObject(jobject obj1, jobject obj2);这个函数对于弱全局引用还有一个特别的功能：把null传入要比较的对象中，就能够判断弱全局引用所指向的java对象是否被回收。《java native interface》
缓存JfieldID/jmethodID
 .取得jfieldID和jmethodID的时候会通过该属性/方法名称上签名来查询相应的jfieldID/jmethodID.这种查询相对来说开销较大。其实，可以将这些FieldID/MethodID缓存起来，这样只需查询一次，以后就是使用缓存起来的FieldID/MethodID了。
介绍两种缓存方式的实现：
1、 在用的时候缓存：
.在native code中使用static局部变量来保存已经查询过的id,这样就不会在每次的函数调用是查询，而只要第一次查询成功后就保存起来了。
.不过在这种情况下不得不考虑多线程同时呼叫此函数时可能会造成同时查询的情况。不过这种情况下没必要担心，所以是无害即是线程安全的。因为返回同一个ID值
    Static fieldID fieldID_string = null;
Jclass clazz = env->GetObjectClass(obj);
If(fieldID_string == null)
{fieldID_string = envo->GetFieldID(clazz, “string”, “Ljava/lang/String;”);
…
2、 在java类初始化是缓存
.更好的方法就是在任何native函数调用钱把id全部存起来。
.可以在第一次加载这个类的时候首先调用本地代码初始化所有的jfieldID/jmethodID,这样的话就可以省去多次得确定ID是否存在的语句，当然，这些jfieldID/jmethodID是定义在c/c++的全局。
.当java类卸载或重新加载的时候也会重新呼叫给本地代码来重新计算缓存的ID集。
（篇二完，后期篇是关于JNI异常处理/多线程/c/c++如何启动jvm(上面都没有涉及，在后期博客会更新，因为看英文的书籍，翻译和理解又慢点。）


*Android硬件抽象层（HAL）
1.adb
ADB的全称为Android Debug Bridge，就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作。
给出常用几个的说明：
1). 查看设备

adb devices

这个命令是查看当前连接的设备, 连接到计算机的android设备或者模拟器将会列出显示

Android系列教程(六) adb操作命令详解

2).安装软件

adb install

adb install :这个命令将指定的apk文件安装到设备上

Android系列教程(六) adb操作命令详解

3). 卸载软件

adb uninstall <软件名>

adb uninstall -k <软件名>

如果加 -k 参数,为卸载软件但是保留配置和缓存文件.

4). 进入设备或模拟器的shell：

adb shell

通过上面的命令，就可以进入设备或模拟器的shell环境中，在这个Linux Shell中，你可以执行各种Linux的命令，另外如果只想执行一条shell命令，可以采用以下的方式：

adb shell [command]

如：adb shell dmesg会打印出内核的调试信息。

5). 发布端口

可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如：

adb forward tcp:5555 tcp:8000

6). 从电脑上发送文件到设备

adb push <本地路径> <远程路径>

用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机)

7). 从设备上下载文件到电脑

adb pull <远程路径> <本地路径>

用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑

8)、查看bug报告

adb bugreport

9)、记录无线通讯日志

一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录：

adb shell

logcat -b radio

10)、获取设备的ID和序列号

adb get-product

adb get-serialno

adb shell

举一个最常用的例子：提取，并推送framework-res.apk。

提取系统上的framework-res.apk

进入“命令提示符”后，我们先执行一次"adb devices"，确认是否已经连上

然后，再执行"adb remount"

接着，我们就可以提取了，按照上面第七点的格式输入执行"adb pull /system/framework/framework-res.apk D:"

当然后面的路径，D:是随你自己喜欢的，但是要注意空格


adb devices adb remount adb pull /system/framework/framework-res.apk D: 复制代码即可

这样D:上就会多了framework-res.apk这文件了

从新推送"framework-res.apk"

我们用到推送的指令，仿照上面第六点输入执行 "adb push D:framework-res.apk /system/framework"

这里我们不要忘了还要修改权限，执行"adb shell chmod 644 /system/framework/framework-res.apk"

当然，我们还需要重启一下，执行"adb reboot"

如何使用adb工具详细教程？
adb devices adb remount adb adb push D:framework-res.apk /system/framework adb shell chmod 644 /system/framework/framework-res.apk 复制代码即可

好了!至于其他的adb指令大家可以模仿着这个来用!!

*蓝牙bluetooth  BluetoothAdapter类：代表了一个本地的蓝牙适配器。他是所有蓝牙交互的的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket（作为服务器端）来监听来自其他设备的连接。
BluetoothDevice类：代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态。（其信息是封装在bluetoothsocket中）。
Bluetoothsocket类：代表了一个蓝牙套接字的接口（类似于tcp中的套接字），他是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。
Blueboothserversocket类：代表打开服务连接来监听可能到来的连接请求（属于server端），为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，Blueboothserversocket类将会返回一个bluetoothsocket。
Bluetoothclass类：描述了一个蓝牙设备的一般特点和能力。他的只读属性集定义了设备的主、次设备类和一些相关服务。然而，他并没有准确的描述所有该设备所支持的蓝牙文件和服务，而是作为对设备种类来说的一个小小暗示。 

示例：
1.开启和搜索蓝牙
配置权限
<uses-permission android:name="android.permission.BLUETOOTH" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />  
<uses-permission android:name="android.permission.READ_CONTACTS"/>  
	
BluetoothMsg.java文件，用于蓝牙属性
public class BluetoothMsg {
	 /** 
     * 蓝牙连接类型 
     * @author Andy 
     * 
     */  
    public enum ServerOrCilent{  
        NONE,  
        SERVICE,  
        CILENT  
    };  
    //蓝牙连接方式  
    public static ServerOrCilent serviceOrCilent = ServerOrCilent.NONE;  
    //连接蓝牙地址  
    public static String BlueToothAddress = null,lastblueToothAddress=null;  
    //通信线程是否开启  
    public static boolean isOpen = false;  
}


public class MainActivity extends Activity  implements OnItemClickListener
{
	private BluetoothAdapter blueadapter=null;  
    private DeviceReceiver mydevice=new DeviceReceiver();  
    private List<String> deviceList=new ArrayList<String>();  
    private ListView deviceListview;  
    private Button btserch;  
    private ArrayAdapter<String> adapter;  
    private boolean hasregister=false; 
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		
		setView();//初始化控件  
        setBluetooth(); //打开蓝牙设备
	}
	
	private void setView(){  
	      
        deviceListview=(ListView)findViewById(R.id.devicelist);  
        adapter=new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, deviceList);  
        deviceListview.setAdapter(adapter);  
        deviceListview.setOnItemClickListener(this);  
        btserch=(Button)findViewById(R.id.start_seach);  
        btserch.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				if(blueadapter.isDiscovering()){  
	                blueadapter.cancelDiscovery();  
	                btserch.setText("repeat search1");  
	            }else{  
	                findAvalibleDevice(); //遍历已经存在的设备 
	                blueadapter.startDiscovery();//2.搜索蓝牙设备
	                btserch.setText("stop search1");  
	            }  
			}
		});  
          
    } 
	/** 
     * Setting Up Bluetooth 
     * //1.打开蓝牙设备
     */  
    private void setBluetooth(){  
         blueadapter=BluetoothAdapter.getDefaultAdapter();  
           首先通过调用静态方法getDefaultAdapter()获取蓝牙适配器bluetoothadapter，以后你就可以使用该对象了。如果返回为空，the story is over。
            if(blueadapter!=null){  //Device support Bluetooth  
                //确认开启蓝牙  
                if(!blueadapter.isEnabled()){  
                    //请求用户开启  
                    Intent intent=new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);  
                    startActivityForResult(intent, RESULT_FIRST_USER);  
                    //使蓝牙设备可见，方便配对  （默认打开120秒，可以将时间延长至最多300秒）
                    Intent in=new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);  
                    in.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);  
                    startActivity(in);  
                    //直接开启，不经过提示  
                    blueadapter.enable();  
                }  
            }  
            else{   //Device does not support Bluetooth  
                  
                AlertDialog.Builder dialog = new AlertDialog.Builder(this);  
                dialog.setTitle("No bluetooth devices");  
                dialog.setMessage("Your equipment does not support bluetooth, please change device");  
                  
                dialog.setNegativeButton("cancel",  
                        new DialogInterface.OnClickListener() {  
                            @Override  
                            public void onClick(DialogInterface dialog, int which) {  
                                  
                            }  
                        });  
                dialog.show();  
            }  
    }
    
	扫描的过程是一个很耗费资源的过程，一旦你找到你需要的设备之后，在发起连接请求之前，确保你的程序调用cancelDiscovery()方法停止扫描。显然，如果你已经连接上一个设备，启动扫描会减少你的通信带宽。
    //5.用于点击列表，弹出触发事件
    @Override  
    public void onItemClick(AdapterView<?> arg0, View arg1, int pos, long arg3) {  
          
        Log.e("msgParent", "Parent= "+arg0);  
        Log.e("msgView", "View= "+arg1);  
        Log.e("msgChildView", "ChildView= "+arg0.getChildAt(pos-arg0.getFirstVisiblePosition()));  
          
            final String msg = deviceList.get(pos);  
              
            if(blueadapter!=null&&blueadapter.isDiscovering()){  
                blueadapter.cancelDiscovery();  
                btserch.setText("repeat search2");  
            }  
              
            AlertDialog.Builder dialog = new AlertDialog.Builder(this);// 定义一个弹出框对象  
            dialog.setTitle("Confirmed connecting device");  
            dialog.setMessage(msg);  
            dialog.setPositiveButton("connect",  
                    new DialogInterface.OnClickListener() {  
                        @Override  
                        public void onClick(DialogInterface dialog, int which) {  
                            BluetoothMsg.BlueToothAddress=msg.substring(msg.length()-17);  
                              
                            if(BluetoothMsg.lastblueToothAddress!=BluetoothMsg.BlueToothAddress){  
                                BluetoothMsg.lastblueToothAddress=BluetoothMsg.BlueToothAddress;  
                            }  
                              
                            Intent in=new Intent(MainActivity.this,BluetoothActivity.class);  
                            startActivity(in);  
                          
                        }  
                    });  
            dialog.setNegativeButton("cancel",  
                    new DialogInterface.OnClickListener() {  
                        @Override  
                        public void onClick(DialogInterface dialog, int which) {  
                            BluetoothMsg.BlueToothAddress = null;  
                        }  
                    });  
            dialog.show();  
    }  
      
  
    在建立连接之前你必须先查询配对好了的蓝牙设备集（你周围的蓝牙设备可能不止一个），以便你选取哪一个设备进行通信，例如你可以你可以查询所有配对的蓝牙设备，并使用一个数组适配器将其打印显示出来：建立一个蓝牙连接只需要MAC地址就已经足够了。
    /** 
     * Finding Devices 
     */  
    private void findAvalibleDevice(){  
        //获取可配对蓝牙设备  
        Set<BluetoothDevice> device=blueadapter.getBondedDevices();  
          
        if(blueadapter!=null&&blueadapter.isDiscovering()){  
            deviceList.clear();  
            adapter.notifyDataSetChanged();  
        }  
        if(device.size()>0){ //存在已经配对过的蓝牙设备,遍历显示  
            for(Iterator<BluetoothDevice> it=device.iterator();it.hasNext();){  
                BluetoothDevice btd=it.next();  
                deviceList.add(btd.getName()+'\n'+btd.getAddress());  
                adapter.notifyDataSetChanged();  
            }  
        }else{  //不存在已经配对过的蓝牙设备,给出提示  
            deviceList.add("No can be matched to use bluetooth");  
            adapter.notifyDataSetChanged();  
        }  
    } 
    
    /** 
     * 3.蓝牙搜索状态广播监听 
     * @author Andy 
     * 
     */  
	 使用bluetoothadapter类里的方法，你可以查找远端设备（不过蓝牙查找的范围好像是在十米以内吧）或者查询在你手机上已经匹配（或者说绑定）的其他手机了。当然需要确定对方蓝牙设备已经开启或者已经开启了“被发现使能“功能（对方设备是可以被发现的是你能够发起连接的前提条件）。如果该设备是可以被发现的，会反馈回来一些对方的设备信息，比如名字、MAC地址等，利用这些信息，你的设备就可以选择去向对方初始化一个连接。
如果你是第一次与该设备连接，那么一个配对的请求就会自动的显示给用户。当设备配对好之后，他的一些基本信息（主要是名字和MAC）被保存下来并可以使用蓝牙的API来读取。使用已知的MAC地址就可以对远端的蓝牙设备发起连接请求。
  匹配好的设备和连接上的设备的不同点：匹配好只是说明对方设备发现了你的存在，并拥有一个共同的识别码，并且可以连接。连接上：表示当前设备共享一个RFCOMM信道并且两者之间可以交换数据。也就是是说蓝牙设备在建立RFCOMM信道之前，必须是已经配对好了的。
 怎么查询匹配好的设备：
 在建立连接之前你必须先查询配对好了的蓝牙设备集（你周围的蓝牙设备可能不止一个），以便你选取哪一个设备进行通信
 
 扫描设备，只需要简单的调用startDiscovery()方法，这个扫描的过程大概持续是12秒，应用程序为了ACTION_FOUND动作需要注册一个BroadcastReceiver来接受设备扫描到的信息。对于每一个设备，系统都会广播ACTION_FOUND动作。例如：
     
    private class DeviceReceiver extends BroadcastReceiver{  
  
        @Override  
        public void onReceive(Context context, Intent intent) {  
            String action =intent.getAction();  
            if(BluetoothDevice.ACTION_FOUND.equals(action)){    //搜索到新设备  
                BluetoothDevice btd=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);  
                //搜索没有配过对的蓝牙设备  
                 if (btd.getBondState() != BluetoothDevice.BOND_BONDED) {  
                     deviceList.add(btd.getName()+'\n'+btd.getAddress());  
                     adapter.notifyDataSetChanged();  
                 }  
            }  
             else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)){   //搜索结束  
                   
                    if (deviceListview.getCount() == 0) {  
                        deviceList.add("No can be matched to use bluetooth");  
                        adapter.notifyDataSetChanged();  
                    }  
                    btserch.setText("repeat search3");  
                }  
        }     
    } 
    //2.注册蓝牙接收广播  
	/*startDiscovery()方法是一个异步方法，调用后会立即返回。该方法会进行对其他蓝牙设备的搜索，该过程会持续12秒。该方法调用后，搜索过程实际上是在一个System Service中进行的，所以可以调用cancelDiscovery()方法来停止搜索（该方法可以在未执行discovery请求时调用）。
	请求Discovery后，系统开始搜索蓝牙设备，在这个过程中，系统会发送以下三个广播：
    ACTION_DISCOVERY_START：开始搜索
	ACTION_DISCOVERY_FINISHED：搜索结束
	ACTION_FOUND：找到设备，这个Intent中包含两个extra fields：EXTRA_DEVICE和EXTRA_CLASS，分别包含BluetooDevice和BluetoothClass。
	我们可以自己注册相应的BroadcastReceiver来接收响应的广播，以便实现某些功能
	*/
    @Override  
    protected void onStart() 
    { 
        if(!hasregister)
        {  
            hasregister=true;  
            IntentFilter filterStart=new IntentFilter(BluetoothDevice.ACTION_FOUND);      
            IntentFilter filterEnd=new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);      
            registerReceiver(mydevice, filterStart);  
            registerReceiver(mydevice, filterEnd);  
        }         
        super.onStart();  
    }  
    //4.之后解除绑定
    @Override  
    protected void onDestroy() 
    {  
        if(blueadapter!=null&&blueadapter.isDiscovering())
        {  
            blueadapter.cancelDiscovery();  
        }  
        if(hasregister)
        {  
            hasregister=false;  
            unregisterReceiver(mydevice);  
        }  
        //直接开启，不经过提示  
        blueadapter.disable();  
        super.onDestroy();  
    } 


}


2.连接设备：

  在你的应用程序中，想建立两个蓝牙设备之间的连接，你必须实现客户端和服务器端的代码（因为任何一个设备都必须可以作为服务端或者客户端）。一个开启服务来监听，一个发起连接请求（使用服务器端设备的MAC地址）。当他们都拥有一个蓝牙套接字在同一RFECOMM信道上的时候，可以认为他们之间已经连接上了。服务端和客户端通过不同的方式或其他们的蓝牙套接字。当一个连接监听到的时候，服务端获取到蓝牙套接字。当客户可打开一个FRCOMM信道给服务器端的时候，客户端获取到蓝牙套接字。

 注意：在此过程中，如果两个蓝牙设备还没有配对好的，android系统会通过一个通知或者对话框的形式来通知用户。RFCOMM连接请求会在用户选择之前阻塞。如下图：


1)服务端的连接：

 当你想要连接两台设备时，一个必须作为服务端（通过持有一个打开的bluetoothserversocket），目的是监听外来连接请求，当监听到以后提供一个连接上的bluetoothsocket给客户端，当客户端从bluetoothserversocket得到bluetoothsocket以后就可以销毁bluetoothserversocket，除非你还想监听更多的连接请求。
BluetoothActivity.java
public class BluetoothActivity extends Activity 
{
	/* 一些常量，代表服务器的名称 */  
    public static final String PROTOCOL_SCHEME_RFCOMM = "btspp";  
      
    private ListView mListView;  
    private Button sendButton;  
    private Button disconnectButton;  
    private EditText editMsgView;  
    private ArrayAdapter<String> mAdapter;  
    private List<String> msgList=new ArrayList<String>();  
    Context mContext;  
      
    private BluetoothServerSocket mserverSocket = null;  
    private ServerThread startServerThread = null;  
    private clientThread clientConnectThread = null;  
    private BluetoothSocket socket = null;  
    private BluetoothDevice device = null;  
    private readThread mreadThread = null;;   
    private BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 
    
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		setContentView(R.layout.chat);
		mContext = this;
		init();
	}
	
	//初始化
	private void init() {            
        
        mAdapter=new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, msgList);  
        mListView = (ListView) findViewById(R.id.list);  
        mListView.setAdapter(mAdapter);  
        mListView.setFastScrollEnabled(true);  
        editMsgView= (EditText)findViewById(R.id.MessageText);    
        editMsgView.clearFocus();  
        
        //发送数据
        sendButton= (Button)findViewById(R.id.btn_msg_send);  
        sendButton.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View arg0) {  
              
                String msgText =editMsgView.getText().toString();  
                if (msgText.length()>0) {  
                    sendMessageHandle(msgText);   
                    editMsgView.setText("");  
                    editMsgView.clearFocus();  
                    //close InputMethodManager  
                    InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);   
                    imm.hideSoftInputFromWindow(editMsgView.getWindowToken(), 0);  
                }else  
                Toast.makeText(mContext, "发送内容不能为空！", Toast.LENGTH_SHORT).show();  
            }  
        });  
          
        disconnectButton= (Button)findViewById(R.id.btn_disconnect);  
        disconnectButton.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View arg0) {  
                // TODO Auto-generated method stub  
                if (BluetoothMsg.serviceOrCilent == BluetoothMsg.ServerOrCilent.CILENT)   
                {  
                    shutdownClient();  
                }  
                else if (BluetoothMsg.serviceOrCilent == BluetoothMsg.ServerOrCilent.SERVICE)   
                {  
                    shutdownServer();  
                }  
                BluetoothMsg.isOpen = false;  
                BluetoothMsg.serviceOrCilent=BluetoothMsg.ServerOrCilent.NONE;  
                Toast.makeText(mContext, "已断开连接！", Toast.LENGTH_SHORT).show();  
            }  
        });       
    } 
	
	//加载页面时，自动启动服务端线程和客户端线程
	@Override  
    protected void onResume() {  
        //作为客户端使用  
        BluetoothMsg.serviceOrCilent=BluetoothMsg.ServerOrCilent.SERVICE;  
          
         if(BluetoothMsg.isOpen)  
            {  
                Toast.makeText(mContext, "连接已经打开，可以通信。如果要再建立连接，请先断开！", Toast.LENGTH_SHORT).show();  
                return;  
            }  
            if(BluetoothMsg.serviceOrCilent==BluetoothMsg.ServerOrCilent.CILENT)  
            {  
                String address = BluetoothMsg.BlueToothAddress;  
                if(!address.equals("null"))  
                {  
                    device = mBluetoothAdapter.getRemoteDevice(address);      
                    clientConnectThread = new clientThread();  
                    clientConnectThread.start();  
                    BluetoothMsg.isOpen = true;  
                }  
                else  
                {  
                    Toast.makeText(mContext, "address is null !", Toast.LENGTH_SHORT).show();  
                }  
            }  
            else if(BluetoothMsg.serviceOrCilent==BluetoothMsg.ServerOrCilent.SERVICE)  
            {                     
                startServerThread = new ServerThread();  
                startServerThread.start();  
                BluetoothMsg.isOpen = true;  
            }  
        super.onResume();  
    } 
	
	//主ui显示分线程发送来的提示信息
	private Handler LinkDetectedHandler = new Handler() {  
        @Override  
        public void handleMessage(Message msg) {  
            //Toast.makeText(mContext, (String)msg.obj, Toast.LENGTH_SHORT).show();  
            if(msg.what==1)  
            {  
                msgList.add((String)msg.obj);  
            }  
            else  
            {  
                msgList.add((String)msg.obj);  
            }  
            mAdapter.notifyDataSetChanged();  
            mListView.setSelection(msgList.size() - 1);  
        }  
    };  
	//1.开启服务器  
    private class ServerThread extends Thread {   
        @Override  
        public void run() {  
                      
            try {  
                /* 创建一个蓝牙服务器  
                 * 参数分别：服务器名称、UUID  
                 * 首先通过调用listenUsingRfcommWithServiceRecord(String, UUID)方法来获
                 * 取bluetoothserversocket对象，参数string代表了该服务的名称，UUID代
                 * 表了和客户端连接的一个标识（128位格式的字符串ID，相当于pin码），
                 * UUID必须双方匹配才可以建立连接。其次调用accept（）方法来监听可能
                 * 到来的连接请求，当监听到以后，返回一个连接上的蓝牙套接
                 * 字bluetoothsocket。 */   
                mserverSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(PROTOCOL_SCHEME_RFCOMM,  
                        UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));         
                  
                Log.d("server", "wait cilent connect...");  
                  
                Message msg = new Message();  
                msg.obj = "请稍候，正在等待客户端的连接...";  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg);  
                  
                /* 接受客户端的连接请求 */  
                socket = mserverSocket.accept();  
                Log.d("server", "accept success !");  
                  
                Message msg2 = new Message();  
                String info = "客户端已经连接上！可以发送信息。";  
                msg2.obj = info;  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg2);  
                //启动接受数据  
                mreadThread = new readThread();  
                mreadThread.start();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    };  
    /* 2.停止服务器 */  
    private void shutdownServer() {  
        new Thread() {  
            @Override  
            public void run() {  
                if(startServerThread != null)  
                {  
                    startServerThread.interrupt();  
                    startServerThread = null;  
                }  
                if(mreadThread != null)  
                {  
                    mreadThread.interrupt();  
                    mreadThread = null;  
                }                 
                try {                     
                    if(socket != null)  
                    {  
                        socket.close();  
                        socket = null;  
                    }  
                    if (mserverSocket != null)  
                    {  
                        mserverSocket.close();/* 关闭服务器 */  
                        mserverSocket = null;  
                    }  
                } catch (IOException e) {  
                    Log.e("server", "mserverSocket.close()", e);  
                }  
            };  
        }.start();  
    }
    
  //3.开启客户端  
    /*使用bluetoothdevice对象里的方法createRfcommSocketToServiceRecord(UUID)
     * 来获取bluetoothsocket。UUID就是匹配码。然后，调用connect（）方法来。
     * 如果远端设备接收了该连接，他们将在通信过程中共享RFFCOMM信道，并
     * 且connect（）方法返回。
     * */
    private class clientThread extends Thread {           
        @Override  
        public void run() {  
            try {  
                //创建一个Socket连接：只需要服务器在注册时的UUID号  
                // socket = device.createRfcommSocketToServiceRecord(BluetoothProtocols.OBEX_OBJECT_PUSH_PROTOCOL_UUID);  
                socket = device.createRfcommSocketToServiceRecord(UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));  
                //连接  
                Message msg2 = new Message();  
                msg2.obj = "请稍候，正在连接服务器:"+BluetoothMsg.BlueToothAddress;  
                msg2.what = 0;  
                LinkDetectedHandler.sendMessage(msg2);  
                  
                socket.connect();  
                  
                Message msg = new Message();  
                msg.obj = "已经连接上服务端！可以发送信息。";  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg);  
                //启动接受数据  
                mreadThread = new readThread();  
                mreadThread.start();  
            }   
            catch (IOException e)   
            {  
                Log.e("connect", "", e);  
                Message msg = new Message();  
                msg.obj = "连接服务端异常！断开连接重新试一试。";  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg);  
            }   
        }  
    };
    
    /* 4.停止客户端连接 */  
    private void shutdownClient() {  
        new Thread() {  
            @Override  
            public void run() {  
                if(clientConnectThread!=null)  
                {  
                    clientConnectThread.interrupt();  
                    clientConnectThread= null;  
                }  
                if(mreadThread != null)  
                {  
                    mreadThread.interrupt();  
                    mreadThread = null;  
                }  
                if (socket != null) {  
                    try {  
                        socket.close();  
                    } catch (IOException e) {  
                        // TODO Auto-generated catch block  
                        e.printStackTrace();  
                    }  
                    socket = null;  
                }  
            };  
        }.start();  
    }
    
    //5.ui线程发送数据  
    private void sendMessageHandle(String msg)   
    {         
        if (socket == null)   
        {  
            Toast.makeText(mContext, "没有连接", Toast.LENGTH_SHORT).show();  
            return;  
        }  
        try {                 
            OutputStream os = socket.getOutputStream();   
            os.write(msg.getBytes());  
        } catch (IOException e) {  
            e.printStackTrace();  
        }             
        msgList.add(msg);  
        mAdapter.notifyDataSetChanged();  
        mListView.setSelection(msgList.size() - 1);  
    }  
    //6.读取数据  
    private class readThread extends Thread {   
        @Override  
        public void run() {  
              
            byte[] buffer = new byte[1024];  
            int bytes;  
            InputStream mmInStream = null;  
              
            try {  
                mmInStream = socket.getInputStream();  
            } catch (IOException e1) {  
                // TODO Auto-generated catch block  
                e1.printStackTrace();  
            }     
            while (true) {  
                try {  
                    // Read from the InputStream  
                    if( (bytes = mmInStream.read(buffer)) > 0 )  
                    {  
                        byte[] buf_data = new byte[bytes];  
                        for(int i=0; i<bytes; i++)  
                        {  
                            buf_data[i] = buffer[i];  
                        }  
                        String s = new String(buf_data);  
                        Message msg = new Message();  
                        msg.obj = s;  
                        msg.what = 1;  
                        LinkDetectedHandler.sendMessage(msg);  
                    }  
                } catch (IOException e) {  
                    try {  
                        mmInStream.close();  
                    } catch (IOException e1) {  
                        // TODO Auto-generated catch block  
                        e1.printStackTrace();  
                    }  
                    break;  
                }  
            }  
        }  
    }  
    
}

2)客户端连接
BluetoothActivity.java
public class BluetoothActivity extends Activity 
{
	/* 一些常量，代表服务器的名称 */  
    public static final String PROTOCOL_SCHEME_RFCOMM = "btspp";  
      
    private ListView mListView;  
    private Button sendButton;  
    private Button disconnectButton;  
    private EditText editMsgView;  
    private ArrayAdapter<String> mAdapter;  
    private List<String> msgList=new ArrayList<String>();  
    Context mContext;  
      
    private BluetoothServerSocket mserverSocket = null;  
    private ServerThread startServerThread = null;  
    private clientThread clientConnectThread = null;  
    private BluetoothSocket socket = null;  
    private BluetoothDevice device = null;  
    private readThread mreadThread = null;;   
    private BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); 
    
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		setContentView(R.layout.chat);
		mContext = this;
		init();
	}
	
	//初始化
	private void init() {            
        
        mAdapter=new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, msgList);  
        mListView = (ListView) findViewById(R.id.list);  
        mListView.setAdapter(mAdapter);  
        mListView.setFastScrollEnabled(true);  
        editMsgView= (EditText)findViewById(R.id.MessageText);    
        editMsgView.clearFocus();  
        
        //发送数据
        sendButton= (Button)findViewById(R.id.btn_msg_send);  
        sendButton.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View arg0) {  
              
                String msgText =editMsgView.getText().toString();  
                if (msgText.length()>0) {  
                    sendMessageHandle(msgText);   
                    editMsgView.setText("");  
                    editMsgView.clearFocus();  
                    //close InputMethodManager  
                    InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);   
                    imm.hideSoftInputFromWindow(editMsgView.getWindowToken(), 0);  
                }else  
                Toast.makeText(mContext, "发送内容不能为空！", Toast.LENGTH_SHORT).show();  
            }  
        });  
          
        disconnectButton= (Button)findViewById(R.id.btn_disconnect);  
        disconnectButton.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View arg0) {  
                // TODO Auto-generated method stub  
                if (BluetoothMsg.serviceOrCilent == BluetoothMsg.ServerOrCilent.CILENT)   
                {  
                    shutdownClient();  
                }  
                else if (BluetoothMsg.serviceOrCilent == BluetoothMsg.ServerOrCilent.SERVICE)   
                {  
                    shutdownServer();  
                }  
                BluetoothMsg.isOpen = false;  
                BluetoothMsg.serviceOrCilent=BluetoothMsg.ServerOrCilent.NONE;  
                Toast.makeText(mContext, "已断开连接！", Toast.LENGTH_SHORT).show();  
            }  
        });       
    } 
	
	//加载页面时，自动启动服务端线程和客户端线程
	@Override  
    protected void onResume() {  
        //作为客户端使用  
        BluetoothMsg.serviceOrCilent=BluetoothMsg.ServerOrCilent.CLIENT;  
          
         if(BluetoothMsg.isOpen)  
            {  
                Toast.makeText(mContext, "连接已经打开，可以通信。如果要再建立连接，请先断开！", Toast.LENGTH_SHORT).show();  
                return;  
            }  
            if(BluetoothMsg.serviceOrCilent==BluetoothMsg.ServerOrCilent.CILENT)  
            {  
                String address = BluetoothMsg.BlueToothAddress;  
                if(!address.equals("null"))  
                {  
                    device = mBluetoothAdapter.getRemoteDevice(address);      
                    clientConnectThread = new clientThread();  
                    clientConnectThread.start();  
                    BluetoothMsg.isOpen = true;  
                }  
                else  
                {  
                    Toast.makeText(mContext, "address is null !", Toast.LENGTH_SHORT).show();  
                }  
            }  
            else if(BluetoothMsg.serviceOrCilent==BluetoothMsg.ServerOrCilent.SERVICE)  
            {                     
                startServerThread = new ServerThread();  
                startServerThread.start();  
                BluetoothMsg.isOpen = true;  
            }  
        super.onResume();  
    } 
	
	//主ui显示分线程发送来的提示信息
	private Handler LinkDetectedHandler = new Handler() {  
        @Override  
        public void handleMessage(Message msg) {  
            //Toast.makeText(mContext, (String)msg.obj, Toast.LENGTH_SHORT).show();  
            if(msg.what==1)  
            {  
                msgList.add((String)msg.obj);  
            }  
            else  
            {  
                msgList.add((String)msg.obj);  
            }  
            mAdapter.notifyDataSetChanged();  
            mListView.setSelection(msgList.size() - 1);  
        }  
    };  
	//1.开启服务器  
    private class ServerThread extends Thread {   
        @Override  
        public void run() {  
                      
            try {  
                /* 创建一个蓝牙服务器  
                 * 参数分别：服务器名称、UUID  
                 * 首先通过调用listenUsingRfcommWithServiceRecord(String, UUID)方法来获
                 * 取bluetoothserversocket对象，参数string代表了该服务的名称，UUID代
                 * 表了和客户端连接的一个标识（128位格式的字符串ID，相当于pin码），
                 * UUID必须双方匹配才可以建立连接。其次调用accept（）方法来监听可能
                 * 到来的连接请求，当监听到以后，返回一个连接上的蓝牙套接
                 * 字bluetoothsocket。 */   
                mserverSocket = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(PROTOCOL_SCHEME_RFCOMM,  
                        UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));         
                  
                Log.d("server", "wait cilent connect...");  
                  
                Message msg = new Message();  
                msg.obj = "请稍候，正在等待客户端的连接...";  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg);  
                  
                /* 接受客户端的连接请求 */  
                socket = mserverSocket.accept();  
                Log.d("server", "accept success !");  
                  
                Message msg2 = new Message();  
                String info = "客户端已经连接上！可以发送信息。";  
                msg2.obj = info;  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg2);  
                //启动接受数据  
                mreadThread = new readThread();  
                mreadThread.start();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    };  
    /* 2.停止服务器 */  
    private void shutdownServer() {  
        new Thread() {  
            @Override  
            public void run() {  
                if(startServerThread != null)  
                {  
                    startServerThread.interrupt();  
                    startServerThread = null;  
                }  
                if(mreadThread != null)  
                {  
                    mreadThread.interrupt();  
                    mreadThread = null;  
                }                 
                try {                     
                    if(socket != null)  
                    {  
                        socket.close();  
                        socket = null;  
                    }  
                    if (mserverSocket != null)  
                    {  
                        mserverSocket.close();/* 关闭服务器 */  
                        mserverSocket = null;  
                    }  
                } catch (IOException e) {  
                    Log.e("server", "mserverSocket.close()", e);  
                }  
            };  
        }.start();  
    }
    
  //3.开启客户端  
    /*使用bluetoothdevice对象里的方法createRfcommSocketToServiceRecord(UUID)
     * 来获取bluetoothsocket。UUID就是匹配码。然后，调用connect（）方法来。
     * 如果远端设备接收了该连接，他们将在通信过程中共享RFFCOMM信道，并
     * 且connect（）方法返回。
     * */
    private class clientThread extends Thread {           
        @Override  
        public void run() {  
            try {  
                //创建一个Socket连接：只需要服务器在注册时的UUID号  
                // socket = device.createRfcommSocketToServiceRecord(BluetoothProtocols.OBEX_OBJECT_PUSH_PROTOCOL_UUID);  
                socket = device.createRfcommSocketToServiceRecord(UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));  
                //连接  
                Message msg2 = new Message();  
                msg2.obj = "请稍候，正在连接服务器:"+BluetoothMsg.BlueToothAddress;  
                msg2.what = 0;  
                LinkDetectedHandler.sendMessage(msg2);  
                  
                socket.connect();  
                  
                Message msg = new Message();  
                msg.obj = "已经连接上服务端！可以发送信息。";  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg);  
                //启动接受数据  
                mreadThread = new readThread();  
                mreadThread.start();  
            }   
            catch (IOException e)   
            {  
                Log.e("connect", "", e);  
                Message msg = new Message();  
                msg.obj = "连接服务端异常！断开连接重新试一试。";  
                msg.what = 0;  
                LinkDetectedHandler.sendMessage(msg);  
            }   
        }  
    };
    
    /* 4.停止客户端连接 */  
    private void shutdownClient() {  
        new Thread() {  
            @Override  
            public void run() {  
                if(clientConnectThread!=null)  
                {  
                    clientConnectThread.interrupt();  
                    clientConnectThread= null;  
                }  
                if(mreadThread != null)  
                {  
                    mreadThread.interrupt();  
                    mreadThread = null;  
                }  
                if (socket != null) {  
                    try {  
                        socket.close();  
                    } catch (IOException e) {  
                        // TODO Auto-generated catch block  
                        e.printStackTrace();  
                    }  
                    socket = null;  
                }  
            };  
        }.start();  
    }
    
    //5.ui线程发送数据  
    private void sendMessageHandle(String msg)   
    {         
        if (socket == null)   
        {  
            Toast.makeText(mContext, "没有连接", Toast.LENGTH_SHORT).show();  
            return;  
        }  
        try {                 
            OutputStream os = socket.getOutputStream();   
            os.write(msg.getBytes());  
        } catch (IOException e) {  
            e.printStackTrace();  
        }             
        msgList.add(msg);  
        mAdapter.notifyDataSetChanged();  
        mListView.setSelection(msgList.size() - 1);  
    }  
    //6.读取数据  
    private class readThread extends Thread {   
        @Override  
        public void run() {  
              
            byte[] buffer = new byte[1024];  
            int bytes;  
            InputStream mmInStream = null;  
              
            try {  
                mmInStream = socket.getInputStream();  
            } catch (IOException e1) {  
                // TODO Auto-generated catch block  
                e1.printStackTrace();  
            }     
            while (true) {  
                try {  
                    // Read from the InputStream  
                    if( (bytes = mmInStream.read(buffer)) > 0 )  
                    {  
                        byte[] buf_data = new byte[bytes];  
                        for(int i=0; i<bytes; i++)  
                        {  
                            buf_data[i] = buffer[i];  
                        }  
                        String s = new String(buf_data);  
                        Message msg = new Message();  
                        msg.obj = s;  
                        msg.what = 1;  
                        LinkDetectedHandler.sendMessage(msg);  
                    }  
                } catch (IOException e) {  
                    try {  
                        mmInStream.close();  
                    } catch (IOException e1) {  
                        // TODO Auto-generated catch block  
                        e1.printStackTrace();  
                    }  
                    break;  
                }  
            }  
        }  
    }  
    
}


3.发送文件
1)单文件发送，调用系统组件
  //单个
  File f = new File(msg);
  //调用android分享窗口
  Intent intent = new Intent();
  intent.setAction(Intent.ACTION_SEND);
  intent.setType("application/octet-stream");
  intent.setClassName("com.android.bluetooth" , "com.android.bluetooth.opp.BluetoothOppLauncherActivity");
  intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(f));				          
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  startActivity(intent);
2)多文件发送，调用系统组件
    private void listFiles() 
	{  
		//遍历这个文件夹里的所有文件
		File file = new File(ReadAdsFile());
		File[] files = file.listFiles();
		if (files.length > 0) 
		{  
			uris=new ArrayList<Uri>();
			for (int i = 0; i < files.length; i++) 
			{
			  if(!files[i].isDirectory())
			  {		
				  deviceList.add(files[i].toString());				  	
				  uris.add(Uri.fromFile(new File(files[i].toString())));
			  }
			}
			Intent intent = new Intent();
			intent.setAction(Intent.ACTION_SEND_MULTIPLE);
			intent.setType("application/octet-stream");
			intent.setClassName("com.android.bluetooth" , "com.android.bluetooth.opp.BluetoothOppLauncherActivity");
			intent.putExtra(Intent.EXTRA_STREAM, uris);
			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			startActivity(intent);			
		}
		
		
	}

*压缩和解压缩zip文件
public class XZip 
{
	 public XZip(){   
		  
	    }   
	       
	    /**  
	     * 取得压缩包中的 文件列表(文件夹,文件自选)  
	     * @param zipFileString     压缩包名字  
	     * @param bContainFolder    是否包括 文件夹  
	     * @param bContainFile      是否包括 文件  
	     * @return  
	     * @throws Exception  
	     */  
	    public static java.util.List<java.io.File> GetFileList(String zipFileString, boolean bContainFolder, boolean bContainFile)throws Exception {   
	           
	        android.util.Log.v("XZip", "GetFileList(String)");   
	           
	        java.util.List<java.io.File> fileList = new java.util.ArrayList<java.io.File>();   
	        java.util.zip.ZipInputStream inZip = new java.util.zip.ZipInputStream(new java.io.FileInputStream(zipFileString));   
	        java.util.zip.ZipEntry zipEntry;   
	        String szName = "";   
	           
	        while ((zipEntry = inZip.getNextEntry()) != null) {   
	            szName = zipEntry.getName();   
	           
	            if (zipEntry.isDirectory()) {   
	           
	                // get the folder name of the widget   
	                szName = szName.substring(0, szName.length() - 1);   
	                java.io.File folder = new java.io.File(szName);   
	                if (bContainFolder) {   
	                    fileList.add(folder);   
	                }   
	           
	            } else {   
	                java.io.File file = new java.io.File(szName);   
	                if (bContainFile) {   
	                    fileList.add(file);   
	                }   
	            }   
	        }//end of while   
	           
	        inZip.close();   
	           
	        return fileList;   
	    }   
	  
	    /**  
	     * 返回压缩包中的文件InputStream  
	     * @param zipFileString     压缩文件的名字  
	     * @param fileString    解压文件的名字  
	     * @return InputStream  
	     * @throws Exception  
	     */  
	    public static java.io.InputStream UpZip(String zipFileString, String fileString)throws Exception {   
	        android.util.Log.v("XZip", "UpZip(String, String)");   
	        java.util.zip.ZipFile zipFile = new java.util.zip.ZipFile(zipFileString);   
	        java.util.zip.ZipEntry zipEntry = zipFile.getEntry(fileString);   
	           
	        return zipFile.getInputStream(zipEntry);   
	  
	    }   
	       
	       
	    /**  
	     * 解压一个压缩文档 到指定位置  
	     * @param zipFileString 压缩包的名字  
	     * @param outPathString 指定的路径  
	     * @throws Exception  
	     */  
	    public static void UnZipFolder(String zipFileString, String outPathString)throws Exception {   
	        android.util.Log.v("XZip", "UnZipFolder(String, String)");   
	        java.util.zip.ZipInputStream inZip = new java.util.zip.ZipInputStream(new java.io.FileInputStream(zipFileString));   
	        java.util.zip.ZipEntry zipEntry;   
	        String szName = "";   
	           
	        while ((zipEntry = inZip.getNextEntry()) != null) {   
	            szName = zipEntry.getName();   
	           
	            if (zipEntry.isDirectory()) {   
	           
	                // get the folder name of the widget   
	                szName = szName.substring(0, szName.length() - 1);   
	                java.io.File folder = new java.io.File(outPathString + java.io.File.separator + szName);   
	                folder.mkdirs();   
	           
	            } else {   
	           
	                java.io.File file = new java.io.File(outPathString + java.io.File.separator + szName);   
	                file.createNewFile();   
	                // get the output stream of the file   
	                java.io.FileOutputStream out = new java.io.FileOutputStream(file);   
	                int len;   
	                byte[] buffer = new byte[1024];   
	                // read (len) bytes into buffer   
	                while ((len = inZip.read(buffer)) != -1) {   
	                    // write (len) byte from buffer at the position 0   
	                    out.write(buffer, 0, len);   
	                    out.flush();   
	                }   
	                out.close();   
	            }   
	        }//end of while   
	           
	        inZip.close();   
	       
	    }//end of func   
	       
	  
	    /**  
	     * 压缩文件,文件夹  
	     * @param srcFileString 要压缩的文件/文件夹名字  
	     * @param zipFileString 指定压缩的目的和名字  
	     * @throws Exception  
	     */  
	    public static void ZipFolder(String srcFileString, String zipFileString)throws Exception {   
	        android.util.Log.v("XZip", "ZipFolder(String, String)");   
	           
	        //创建Zip包   
	        java.util.zip.ZipOutputStream outZip = new java.util.zip.ZipOutputStream(new java.io.FileOutputStream(zipFileString));   
	           
	        //打开要输出的文件   
	        java.io.File file = new java.io.File(srcFileString);   
	  
	        //压缩   
	        ZipFiles(file.getParent()+java.io.File.separator, file.getName(), outZip);   
	           
	        //完成,关闭   
	        outZip.finish();   
	        outZip.close(); 
	       
	    }//end of func   
	       
	    /**  
	     * 压缩文件  
	     * @param folderString  
	     * @param fileString  
	     * @param zipOutputSteam  
	     * @throws Exception  
	     */  
	    private static void ZipFiles(String folderString, String fileString, java.util.zip.ZipOutputStream zipOutputSteam)throws Exception{   
	        android.util.Log.v("XZip", "ZipFiles(String, String, ZipOutputStream)");   
	           
	        if(zipOutputSteam == null)   
	            return;   
	           
	        java.io.File file = new java.io.File(folderString+fileString);   
	           
	        //判断是不是文件   
	        if (file.isFile()) {   
	  
	            java.util.zip.ZipEntry zipEntry =  new java.util.zip.ZipEntry(fileString);   
	            java.io.FileInputStream inputStream = new java.io.FileInputStream(file);   
	            zipOutputSteam.putNextEntry(zipEntry);   
	               
	            int len;   
	            byte[] buffer = new byte[4096];   
	               
	            while((len=inputStream.read(buffer)) != -1)   
	            {   
	                zipOutputSteam.write(buffer, 0, len);   
	            }   
	               
	            zipOutputSteam.closeEntry();   
	        }   
	        else {   
	               
	            //文件夹的方式,获取文件夹下的子文件   
	            String fileList[] = file.list();   
	               
	            //如果没有子文件, 则添加进去即可   
	            if (fileList.length <= 0) {   
	                java.util.zip.ZipEntry zipEntry =  new java.util.zip.ZipEntry(fileString+java.io.File.separator);   
	                zipOutputSteam.putNextEntry(zipEntry);   
	                zipOutputSteam.closeEntry();                   
	            }   
	               
	            //如果有子文件, 遍历子文件   
	            for (int i = 0; i < fileList.length; i++) {   
	                ZipFiles(folderString, fileString+java.io.File.separator+fileList[i], zipOutputSteam);   
	            }//end of for   
	       
	        }//end of if   
	           
	    }//end of func   
	       
	    public void finalize() throws Throwable {   
	           
	    } 
}
	
*Baidu地图
1.下载和配置
1)
注册百度开发者账户，得到key,下载开发包，放在E:\VMCSource\android\百度地图中
可以依据百度提供的开发示例指引
第一步：在工程里新建libs文件夹，将开发包里的baidumapapi_vX_X_X.jar，locSDK_3.1.jar拷贝到libs根目录下，
将libBaiduMapSDK_vX_X_X.so，liblocSDK3.so拷贝到libs\armeabi目录下（官网demo里已有这两个文件，如果要集成到自己的工程里，就需要自己添加），拷贝完成后的工程目录如下图所示；

注：liblocSDK3.so和locSDK_3.1.jar为百度定位SDK所使用资源，开发者可根据实际需求自行添加。 2.定位服务

第二步：在右击工程Properties属性->Java Build Path->Libraries中选择“Add External JARs”，选定baidumapapi_vX_X_X.jar，确定后返回。

通过以上两步操作后，您就可以正常使用百度地图SDK为您提供的全部功能了。

注意：由于adt插件升级，若您使用Eclipse adt 22的话，需要对开发环境进行相应的设置，方法如下：

1. 在Eclipse 中选中工程，右键选 Properties->Java Build Path->Order and Export 使 Android Private Libraries处于勾选状态；

2. Project -> clean-> clean all . 

2)
百度地图SDK为开发者提供了便捷的显示百度地图数据的接口，通过以下几步操作，即可在您的应用中使用百度地图数据：

第一步：在AndroidManifest中添加开发密钥、所需权限等信息；

（1）在application中添加开发密钥

<application>  
    <meta-data  
        android:name="com.baidu.lbsapi.API_KEY"  
        android:value="开发者 key" />  
</application>
（2）添加所需权限 
例如：
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.junpeng.easivend"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="8"
        android:targetSdkVersion="18" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <meta-data
            android:name="com.baidu.lbsapi.API_KEY"
            android:value="CH1WGKQtEv11EvjPAsdCjSRt" />
        <activity
            android:name="com.junpeng.easivend.MainActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
    
    <!-- 添加地图的授权信息 -->
	<uses-permission android:name="android.permission.BAIDU_LOCATION_SERVICE" >
    </uses-permission>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" >
    </uses-permission>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" >
    </uses-permission>
    <uses-permission android:name="android.permission.INTERNET" >
    </uses-permission>
    <uses-permission android:name="android.permission.ACCESS_MOCK_LOCATION" >
    </uses-permission>
    <!-- <uses-permission android:name="android.permission.WRITE_APN_SETTINGS"></uses-permission> -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" >
    </uses-permission>
    <uses-permission android:name="com.android.launcher.permission.READ_SETTINGS" />
    <uses-permission android:name="android.permission.WAKE_LOCK" >
    </uses-permission>
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.ACCESS_GPS" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.READ_CONTACTS" />
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.SEND_SMS" />
    <!-- SDK1.5需要android.permission.GET_TASKS权限判断本程序是否为当前运行的应用? -->
    <uses-permission android:name="android.permission.GET_TASKS" />
    <uses-permission android:name="android.permission.CAMERA" >
    </uses-permission>
    <uses-permission android:name="android.permission.RECORD_AUDIO" >
    </uses-permission>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" >
    </uses-permission>
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.BROADCAST_STICKY" />
    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
    <!-- 来电消音 -->
    <uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" >
    </uses-permission>
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <!--添加对屏幕的支持-->
    <supports-screens
        android:anyDensity="true"
        android:largeScreens="true"
        android:normalScreens="false"
        android:resizeable="true"
        android:smallScreens="true" />
</manifest>

3)第三步，在布局xml文件中添加地图控件；

<com.baidu.mapapi.map.MapView  
    android:id="@+id/bmapView"  
    android:layout_width="fill_parent"  
    android:layout_height="fill_parent"  
    android:clickable="true" />

第四步，在应用程序创建时初始化 SDK引用的Context 全局变量：

public class MainActivity extends Activity {  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);   
        //在使用SDK各组件之前初始化context信息，传入ApplicationContext  
        //注意该方法要再setContentView方法之前实现  
        SDKInitializer.initialize(getApplicationContext());  
        setContentView(R.layout.activity_main);  
    }  
}

注意：在SDK各功能组件使用之前都需要调用

SDKInitializer.initialize(getApplicationContext());，因此我们建议该方法放在Application的初始化方法中

第五步，创建地图Activity，管理地图生命周期；

import com.baidu.mapapi.SDKInitializer;
import com.baidu.mapapi.map.MapView;

import android.os.Bundle;
import android.app.Activity;
import android.view.Menu;

public class MainActivity extends Activity {
	MapView mMapView=null;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		//在使用SDK各组件之前初始化context信息，传入ApplicationContext  
        //注意该方法要再setContentView方法之前实现  
        SDKInitializer.initialize(getApplicationContext());  
		setContentView(R.layout.activity_main);
		//获取地图控件引用  
		mMapView = (MapView) findViewById(R.id.bmapView);  
	}
	 @Override  
    protected void onDestroy() {  
        super.onDestroy();  
        //在activity执行onDestroy时执行mMapView.onDestroy()，实现地图生命周期管理  
        MainActivity.this.mMapView.onDestroy();  
    }  
    @Override  
    protected void onResume() {  
        super.onResume();  
        //在activity执行onResume时执行mMapView. onResume ()，实现地图生命周期管理  
        MainActivity.this.mMapView.onResume();  
        }  
    @Override  
    protected void onPause() {  
        super.onPause();  
        //在activity执行onPause时执行mMapView. onPause ()，实现地图生命周期管理  
        MainActivity.this.mMapView.onPause();  
        } 
	
}
2.地图的所有变更可以看百度文档(查看百度地图APP开发日志)


*App工程结构搭建查看附录
架构思想都差不多的,个人觉得android的XML+Activity就类似ASP.NET那个控件跟代码分离的View层，业务处理和数据访问层常常会根据android的特点细分为adapter适配器层、或者网络访问层net、后台处理层、逻辑控制层、自定义组件层等,公司那边这样做的,仅供讨论，呵呵！

*其他问题点
1.android开发中, 关闭另一个activity
public class BusgoodsSelect extends Activity 
{
	public static BusgoodsSelect BusgoodsSelectAct=null;
	protected void onCreate(Bundle savedInstanceState) 
	{
		BusgoodsSelectAct = this;
	}
}	
public class BusHuo extends Activity 
{
	protected void onCreate(Bundle savedInstanceState) 
	{
		if(BusgoodsSelect.BusgoodsSelectAct!=null)
			BusgoodsSelect.BusgoodsSelectAct.finish(); 
	}
}

2.界面延时退出页面
private final int SPLASH_DISPLAY_LENGHT = 10000; // 延迟10秒

if(tempx>=count)
{
	new Handler().postDelayed(new Runnable() 
	{
		@Override
		public void run() 
		{
			   finish();
		}

	}, SPLASH_DISPLAY_LENGHT);
}

3.Android控件显示和隐藏
一、在XML配置文件设置

可见：
android:visibility="visible"
不可见：
android:visibility="invisible"
隐藏：
android:visibility="gone"
这三种显示方式区别： visible就是正常可见状态，invisible是不可见状态，但其实还在占用排列空间，而gone则为隐藏状态，控件不再占用空间。
二、在Java代码中设置

mlistview1.setVisibility(View.GONE);//mlistview1处于隐藏状态
mlistview1.setVisibility(View.INVISIBLE);//mlistview1处于不可见状态
mlistview1.setVisibility(View.VISIBLE);//mlistview1处于可见状态

4.判断应用是否在运行 
ActivityManager activityManager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
List<RunningTaskInfo> list = activityManager.getRunningTasks(100);
String MY_PKG_NAME = "com.example.evconsole";
int isopen=0;//1代表正在运行，0代表没在运行
for (RunningTaskInfo info : list) 
{	        			 
	 Log.i("EV_JNI","appName:"+info.topActivity.getClassName()+"-->pack:"+info.topActivity.getPackageName());
	 if (info.topActivity.getPackageName().equals(MY_PKG_NAME)||info.baseActivity.getPackageName().equals(MY_PKG_NAME)) 
	 {	        				  
		  isopen=1;
		  break;
	 }
}
if(isopen==1)s
{
	Log.i("EV_JNI", "applicationrun");
}
else
{
	Log.i("EV_JNI", "applicationstop");
	//1.开启应用程序
	Intent intent=new Intent(DogService.this,MaintainActivity.class);
	intent.setAction(Intent.ACTION_MAIN);  
	intent.addCategory(Intent.CATEGORY_LAUNCHER);  
	intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);  
	intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);  
	DogService.this.startActivity(intent);	
}

检测Service是否已启动

 public static boolean isServiceRunning(String serviceClassName){ 
        final ActivityManager activityManager = (ActivityManager)Application.getContext().getSystemService(Context.ACTIVITY_SERVICE); 
        final List<RunningServiceInfo> services = activityManager.getRunningServices(Integer.MAX_VALUE); 

        for (RunningServiceInfo runningServiceInfo : services) { 
            if (runningServiceInfo.service.getClassName().equals(serviceClassName)){ 
                return true; 
            } 
        } 
        return false; 
     }
检测应用程序是否已开启

权限

<uses-permission android:name="android.permission.GET_TASKS"/>

代码----判断Activity是否正在运行

ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
List<RunningTaskInfo> list = am.getRunningTasks(100);
boolean isAppRunning = false;
String MY_PKG_NAME = "com.cyberblue.iitag";
for (RunningTaskInfo info : list) {
	if (info.topActivity.getPackageName().equals(MY_PKG_NAME) || info.baseActivity.getPackageName().equals(MY_PKG_NAME)) {
		isAppRunning = true;
		Log.i(TAG,info.topActivity.getPackageName() + " info.baseActivity.getPackageName()="+info.baseActivity.getPackageName());
		break;
	}
}
/**
* 检测某Activity是否在当前Task的栈顶
*/
public boolean isTopActivy(String cmdName){
        ActivityManager manager = (ActivityManager) context.getSystemService(ACTIVITY_SERVICE);
        List<RunningTaskInfo> runningTaskInfos = manager.getRunningTasks(1);
        String cmpNameTemp = null;
        if(null != runningTaskInfos){
                cmpNameTemp=(runningTaskInfos.get(0).topActivity).toString);
                Log.e("cmpname","cmpname:"+cmpName);
        }
       if(null == cmpNameTemp)return false;
       return cmpNameTemp.equals(cmdName);
}
下面代码检测当前Activity是不是栏启动器

private  boolean isLauncherRunnig(Context context) {  
		boolean result = false ;  
		List<String> names = getAllTheLauncher();  
		ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE) ;  
		List<ActivityManager.RunningAppProcessInfo> appList = mActivityManager.getRunningAppProcesses() ;  
		for (RunningAppProcessInfo running : appList) {  
				if (running.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {  
						for (int i = 0; i < names.size(); i++) {  
								if (names.get(i).equals(running.processName)) {  
										result = true ;  
										break;  
								}  
						}  
				}  
		}  
		return result ;  
}
----------------判断App是否正在运行---------------------

/**
 * 判断app是否正在运行
 * @param ctx
 * @param packageName
 * @return
 */
public boolean appIsRunning(Context ctx,String packageName)
{
	ActivityManager am = (ActivityManager) ctx.getSystemService(ACTIVITY_SERVICE);
	
	List<RunningAppProcessInfo> runningAppProcesses = am.getRunningAppProcesses();
	
	if(runningAppProcesses!=null)
	{
		for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) {
			
			if(runningAppProcessInfo.processName.startsWith(packageName))
			{
				return true;
			}
		}
	}
	
	return false;
}
/**
 * app 是否在后台运行
 * @param ctx
 * @param packageName
 * @return
 */
public boolean appIsBackgroundRunning(Context ctx,String packageName)
{
	ActivityManager am = (ActivityManager) ctx.getSystemService(ACTIVITY_SERVICE);
	
	List<RunningAppProcessInfo> runningAppProcesses = am.getRunningAppProcesses();
	
	if(runningAppProcesses!=null)
	{
		for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) {
			
			if(runningAppProcessInfo.processName.startsWith(packageName))
			{
				return runningAppProcessInfo.importance!=RunningAppProcessInfo.IMPORTANCE_FOREGROUND && runningAppProcessInfo.importance!=RunningAppProcessInfo.IMPORTANCE_VISIBLE; //排除无界面的app
			}
		}
	}
	
	return false;
}

5.Android系统中标准Intent的使用
一 Android系统用于Activity的标准Intent

1 根据联系人ID显示联系人信息
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_VIEW);   //显示联系人信息  
intent.setData(Uri.parse("content://contacts/people/492"));  
startActivity(intent);  

2 根据联系人ID显示拨号面板
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_DIAL);  //显示拨号面板  
intent.setData(Uri.parse("content://contacts/people/492"));  
startActivity(intent);  

3 显示拨号面板， 并在拨号面板上将号码显示出来
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_VIEW);     
intent.setData(Uri.parse("tel://15216448315"));  
startActivity(intent);  

4 显示拨号面板， 并在拨号面板上将号码显示出来
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_DIAL);   //显示拨号面板, 并在拨号面板上将号码显示出来  
intent.setData(Uri.parse("tel://15216448315"));  
startActivity(intent);  

5 根据联系人的ID编辑联系人
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_EDIT);   //编辑联系人  
intent.setData(Uri.parse("content://contacts/people/492"));  
startActivity(intent);  

6 显示通讯录联系人和其他账号联系人的列表
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_VIEW);     
intent.setData(Uri.parse("content://contacts/people/"));  
startActivity(intent);  

7 启动HomeScreen
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_MAIN);     //启动HomeScreen  
intent.addCategory(Intent.CATEGORY_HOME);  
startActivity(intent);  

8 选择某个联系人的号码，返回一个代表这个号码的uri，如:content://contacts/phones/982
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_GET_CONTENT);       
intent.setType("vnd.android.cursor.item/phone");  
startActivityForResult(intent, 1);  

9  打开多个应用选取各种类型的数据,以uri返回。返回的uri可使用ContentResolver.openInputStream(Uri)打开
    该功能可用在邮件中附件的选取
    举例如下:
    选取一张图片, 返回的uri为 content://media/external/images/media/47
    选取一首歌, 返回的uri为 content://media/external/audio/media/51
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_GET_CONTENT);       
intent.setType("*/*");  
intent.addCategory(Intent.CATEGORY_OPENABLE);  
startActivityForResult(intent, 2);  

10 自定义一个chooser，不使用系统的chooser
     该chooser可以有自己的标题(Title)
     并且不必让用户指定偏好
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_CHOOSER);   
intent.putExtra(Intent.EXTRA_TITLE, "my chooser");  
intent.putExtra(Intent.EXTRA_INTENT,   
        new Intent(Intent.ACTION_GET_CONTENT)  
        .setType("*/*")  
        .addCategory(Intent.CATEGORY_OPENABLE)  
        );  
  
startActivityForResult(intent, 2);  

11 选取activity，返回的activity可在返回的intent.getComponent()中得到
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_PICK_ACTIVITY);   
intent.putExtra( Intent.EXTRA_INTENT,   
        new Intent(Intent.ACTION_GET_CONTENT)  
        .setType("*/*")  
        .addCategory(Intent.CATEGORY_OPENABLE)  
        );  
startActivityForResult(intent, 3);  

12 启动搜索，在以下示例代码中，"ANDROID"为要搜索的字符串
     当执行这段代码后, 会在系统的Chooser中显示可以用于搜索的程序列表
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_SEARCH);     //启动搜索  
intent.putExtra(SearchManager.QUERY, "ANDROID");  
startActivity(intent);  

13 启动WEB搜索，在以下示例代码中，"ANDROID"为要搜索的字符串
     当执行这段代码后, 会在系统的Chooser中显示可以用于搜索的程序列表，一般情况下系统中安装的浏览器都会显示出来
[java] view plain copy
Intent intent = new Intent();  
intent.setAction(Intent.ACTION_WEB_SEARCH);     //启动搜索  
intent.putExtra(SearchManager.QUERY, "ANDROID");  
startActivity(intent);  


二  Android系统用于BroadcastReceiver的标准Intent

1 ACTION_TIME_TICK，系统时钟广播，系统每分钟都会发送一个这样的广播，
   如果在应用开发中，有些逻辑依赖于系统时钟，可以注册一个广播接收者
   这是一个受保护的action，只有系统才能发送这个广播
   并且，在manifest文件中注册的广播接收者不能接收到该广播，若要接收该广播，必须在代码中注册广播接收者
[java] view plain copy
registerReceiver(new BroadcastReceiver(){  
  
    @Override  
    public void onReceive(Context context, Intent intent) {  
        Log.i("xxxx", "TIME_TICK");  
    }  
      
},   
new IntentFilter(Intent.ACTION_TIME_TICK));  

2 在官方文档中，列出了以下标准的广播action
ACTION_TIME_TICK               系统时钟广播
ACTION_TIME_CHANGED            时间被重新设置
ACTION_TIMEZONE_CHANGED        时区改变
ACTION_BOOT_COMPLETED          系统启动完成
ACTION_PACKAGE_ADDED           系统中安装了新的应用
ACTION_PACKAGE_CHANGED         系统中已存在的app包被更改
ACTION_PACKAGE_REMOVED         系统中已存在的app被移除
ACTION_PACKAGE_RESTARTED       用户重启了一个app，这个app的所有进程被杀死
ACTION_PACKAGE_DATA_CLEARED    用户清除了一个app的数据
ACTION_UID_REMOVED             系统中的一个user ID被移除
ACTION_BATTERY_CHANGED         电池状态改变，这是一个sticky广播
ACTION_POWER_CONNECTED         设备连接了外部电源
ACTION_POWER_DISCONNECTED      外部电源被移除
ACTION_SHUTDOWN                设备正在关机

三  Android中的标准类别（category）

类别（category）一般配合action使用，以下为系统中的标准类别，由于数量过多，只能在使用到时再详细研究
CATEGORY_DEFAULT
CATEGORY_BROWSABLE
CATEGORY_TAB
CATEGORY_ALTERNATIVE
CATEGORY_SELECTED_ALTERNATIVE
CATEGORY_LAUNCHER
CATEGORY_INFO
CATEGORY_HOME
CATEGORY_PREFERENCE
CATEGORY_TEST
CATEGORY_CAR_DOCK
CATEGORY_DESK_DOCK
CATEGORY_LE_DESK_DOCK
CATEGORY_HE_DESK_DOCK
CATEGORY_CAR_MODE
CATEGORY_APP_MARKET

四  Android中的标准Extra键值

这些常量用于在调用Intent.putExtra(String, Bundle)时作为键值传递数据，同样由于数量较多，在此只列出索引
EXTRA_ALARM_COUNT
EXTRA_BCC
EXTRA_CC
EXTRA_CHANGED_COMPONENT_NAME
EXTRA_DATA_REMOVED
EXTRA_DOCK_STATE
EXTRA_DOCK_STATE_HE_DESK
EXTRA_DOCK_STATE_LE_DESK
EXTRA_DOCK_STATE_CAR
EXTRA_DOCK_STATE_DESK
EXTRA_DOCK_STATE_UNDOCKED
EXTRA_DONT_KILL_APP
EXTRA_EMAIL
EXTRA_INITIAL_INTENTS
EXTRA_INTENT
EXTRA_KEY_EVENT
EXTRA_ORIGINATING_URI
EXTRA_PHONE_NUMBER
EXTRA_REFERRER
EXTRA_REMOTE_INTENT_TOKEN
EXTRA_REPLACING
EXTRA_SHORTCUT_ICON
EXTRA_SHORTCUT_ICON_RESOURCE
EXTRA_SHORTCUT_INTENT
EXTRA_STREAM
EXTRA_SHORTCUT_NAME
EXTRA_SUBJECT
EXTRA_TEMPLATE
EXTRA_TEXT
EXTRA_TITLE
EXTRA_UID

五  Intent中的标志（FLAG）

Intent类中定义了一些以FLAG_开头的标志位，这些标志位中有的非常重要，会影响app中Activity和BroadcastReceiver等的行为。
以下为这些标志位的索引，是从官方文档上的截图。之后会对重要的标志加以详细分析


6.Android性能调优
1）
本文主要分享自己在appstore项目中的性能调优点，包括同步改异步、缓存、Layout优化、数据库优化、算法优化、延迟执行等。
 
目前性能优化专题已完成以下部分：
性能优化总纲――性能问题及性能调优方式
性能优化第四篇――移动网络优化
性能优化第三篇――Java(Android)代码优化
性能优化第二篇――布局优化
性能优化第一篇――数据库性能优化
性能优化实例
 
一、性能瓶颈点
整个页面主要由6个Page的ViewPager，每个Page为一个GridView，GridView一屏大概显示4*4的item信息(本文最后有附图)。由于网络数据获取较多且随时需要保持页面内app下载进度及状态，所以出现以下性能问题
a.  ViewPager左右滑动明显卡顿
b.  GridView上下滚动明显卡顿
c.  其他Activity返回ViewPager Activity较慢
d.  网络获取到展现速度较慢
 
二、性能调试及定位
打开DDMS调试工具，打开devices窗口，选择某个进程，点击右上角的start method profilingddms trace
运行app一段时间后，再点击已变成stop method profiling的该按钮。eclipse会自动弹出debug的标签（可通过菜单File->save as保存数据）。界面同上面。
这种方式不需要修改代码，所以对于没有源码的程序同样可以进行排查。同时可以方便的进行全局性能排查。

TraceView界面信息介绍
TraceView界面包括时间面板和方法面板
(1) 时间面板(Timeline Panel)
时间面板展示了每个线程的执行情况，其中的[1]main即为ui主线程。
移动到某个位置可以查看该点对应的方法的执行信息，点击方法面板则会选中相应的方法。
可以左键按住不放选中区域放大局部精细查看，不同方法用不同颜色标注
 
(2) 方法面板(Profile Panel)
方法面板展示了所有方法的执行情况，点击某个方法可以查看在对应线程上的执行时间区域，并会显示其父方法及子方法。
每个方法包括如下信息列，可点击某列进行排序，从而确定产生性能问题的函数：
Incl Cpu Time, Excl Cpu Time, Incl Real Time, Excl Real Time, Incl Cpu Time%, Excl Cpu Time%, Incl Real Time%, Excl Real Time%, Calls+RecurCalls/Total, Cpu Time/Call, Real Time/Call
所有的Time都是以毫秒计算。每列具体含义及作用如下：
a. Incl表示将所有子函数耗时也计算在内，Excl则表示不包括子函数的调用时间。对比可以确定耗时操作发生是自身还是子函数中。
b. Cpu Time表示占用cpu执行的时间，Real Time包括Cpu Time以及等待、切换的时间等，所以一般都大于Cpu Time。对比可以判断耗时操作是否在cpu执行段内。
c. 上面四个指标对应的%表示函数在总时间的占比。方便查看某个函数的时间占比。
d. Calls+RecurCalls/Total表示被外部调用次数+递归次数/总次数。可以查看调用次数是否符合自己预期。
e. Cpu Time/Call, Real Time/Call表示总的Cpu Time及Real Time与总调用次数的比例。查看每次调用的耗时，一般可通过简单此项确定每个函数的性能。
 
三、性能调优点
主要包括同步改异步、缓存、Layout优化、数据库优化、算法优化、延迟执行。
1. 同步改异步
这个就不用多讲了，耗时操作放在线程中执行防止占用主线程，一定程度上解决anr。
但需要注意线程和service结合（防止activity被回收后线程也被回收）以及线程的数量
线程池使用可见java的线程池
 
2. 缓存
java的对象创建需要分配资源较耗费时间，加上创建的对象越多会造成越频繁的gc影响系统响应。主要使用单例模式、缓存(图片缓存、线程池、View缓存、IO缓存、消息缓存、通知栏notification缓存)及其他方式减少对象创建。
(1). 单例模式
对于创建开销较大的类可使用此方法，保证全局一个实例，在程序运行过程中该类不会因新建额外对象产生开销。示例代码如下：
单例模式Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
public class Singleton {
 
    private static Object    obj      = new Object();
    private static Singleton instance = null;
 
    private Singleton(){
    }
 
    public static Singleton getInstance() {
        // if already inited, no need to get lock everytime
        if (instance == null) {
            synchronized (obj) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
 
        return instance;
    }
}
 
(2). 缓存
程序中用到了图片缓存、线程池、View缓存、IO缓存、消息缓存、通知栏notification缓存等。
a. 图片缓存：见ImageCache和ImageSdCache
 
b. 线程池：使用Java的Executors类，通过newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool提供四种不同类型的线程池
 
c. View缓存：
可见ListView缓存机制
listView的getView缓存
通过convertView是否为null减少layout inflate次数，通过静态的ViewHolder减少findViewById的次数，这两个函数尤其是inflate是相当费时间的
 
d. IO缓存：
使用具有缓存策略的输入流，BufferedInputStream替代InputStream，BufferedReader替代Reader，BufferedReader替代BufferedInputStream.对文件、网络IO皆适用。
 
e. 消息缓存：通过 Handler 的 obtainMessage 回收 Message 对象，减少 Message 对象的创建开销
handler.sendMessage(handler.obtainMessage(1));
 
f. 通知栏notification缓存：下载中需要不断改变通知栏进度条状态，如果不断新建Notification会导致通知栏很卡。这里我们可以使用最简单的缓存
Map<String, Notification> notificationMap = new HashMap<String, Notification>();如果notificationMap中不存在，则新建notification并且put into map.
 
(3). 其他
能创建基类解决问题就不用具体子类：除需要设置优先级的线程使用new Thread创建外，其余线程创建使用new Runnable。因为子类会有自己的属性创建需要更多开销。
控制最大并发数量：使用Java的Executors类，通过Executors.newFixedThreadPool(nThreads)控制线程池最大线程并发
对于http请求增加timeout
 
3. Layout优化
使用抽象布局标签(include, viewstub, merge)、去除不必要的嵌套和View节点、减少不必要的infalte及其他Layout方面可调优点，顺带提及布局调优相关工具(hierarchy viewer和lint)。具体可见性能优化之布局优化
TextView属性优化：TextView的android:ellipsize=”marquee”跑马灯效果极耗性能，具体原因还在深入源码中
 
4. 数据库优化
主要包括索引和事务及针对Sqlite的优化。具体可见性能优化之数据库优化
 
5. 算法优化
这个就是个博大精深的话题了，只介绍本应用中使用的。
使用hashMap代替arrayList，时间复杂度降低一个数量级
 
6. 延迟执行
对于很多耗时逻辑没必要立即执行，这时候我们可以将其延迟执行。
线程延迟执行 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);
消息延迟发送 handler.sendMessageDelayed(handler.obtainMessage(0), 1000);
 
四、本程序性能调优结果
1. ViewPager左右滑动明显卡顿
2. GridView上下滚动明显卡顿
(1). 去掉TextView的android:ellipsize=”marquee”
(2). 修改图片缓存的最大线程数，增加http timeout
(3). 修改设置app是否已安装的状态，具体代码修改如下：
Java

1
2
3
4
5
6
7
List<PackageInfo> installedPackageList = getPackageManager().getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);
List<App> installedAppList = function(installedAppList)
for (App app : appList) {
	for (App installedApp : installedAppList) {
 
	}
}
修改为
Java

1
2
3
4
5
6
7
8
for (App app : appList) {
	Pair<Integer, String> versionInfo = INSTALLED_APP_MAP.get(app.getPackageName());
	if (versionInfo != null) {
 
	} else {
 
	}
}
从每次获取List<PackageInfo> installedAppList = getPackageManager().getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);修改为只在有应用安装或卸载广播时获取应用列表，并且用hashMap代替installedAppList减少查询时间。
将平均执行时间从201ms降低到1ms。
 
3. 其他Activity返回ViewPager Activity较慢
定位：在onStart函数
解决：使用延迟策略，具体代码修改如下：
Java

1
2
3
4
5
@Override
public void onStart() {
	super.onStart();
	appUpdateListAdapter.notifyDataSetChanged();
}
改为
优化后代码
 
4. 网络获取到展现速度较慢
定位：在HttpURLConnection.getInputStream()之后的处理
解决：使用BufferedReader替代BufferedInputStream获取时间从100ms降低到3ms，具体代码修改如下：
Java

1
2
3
4
5
HttpURLConnection con = (HttpURLConnection)url.openConnection();
InputStream input = con.getInputStream();
while (input.read(buffer, 0, 1024) != -1) {
 
}
改为
Java

1
2
3
4
5
6
HttpURLConnection con = (HttpURLConnection)url.openConnection();
BufferedReader input = new BufferedReader(new InputStreamReader(con.getInputStream()));
String s;
while ((s = input.readLine()) != null) {
 
}


2）性能优化之布局优化
本文为Android性能优化的第二篇――布局优化，主要介绍使用抽象布局标签(include, viewstub, merge)、去除不必要的嵌套和View节点、减少不必要的infalte及其他Layout方面可调优点，顺带提及布局调优相关工具(hierarchy viewer和lint)。
 
目前性能优化专题已完成以下部分：
性能优化总纲――性能问题及性能调优方式
性能优化第四篇――移动网络优化
性能优化第三篇――Java(Android)代码优化
性能优化第二篇――布局优化
性能优化第一篇――数据库性能优化
性能优化实例
 
1、抽象布局标签
(1) <include>标签
include标签常用于将布局中的公共部分提取出来供其他layout共用，以实现布局模块化，这在布局编写方便提供了大大的便利。
下面以在一个布局main.xml中用include引入另一个布局foot.xml为例。main.mxl代码如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
 
    <ListView
        android:id="@+id/simple_list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginBottom="@dimen/dp_80" />
 
    <include layout="@layout/foot.xml" />
 
</RelativeLayout>
其中include引入的foot.xml为公用的页面底部，代码如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
 
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="@dimen/dp_40"
        android:layout_above="@+id/text"/>
 
    <TextView
        android:id="@+id/text"
        android:layout_width="match_parent"
        android:layout_height="@dimen/dp_40"
        android:layout_alignParentBottom="true"
        android:text="@string/app_name" />
 
</RelativeLayout>
<include>标签唯一需要的属性是layout属性，指定需要包含的布局文件。可以定义android:id和android:layout_*属性来覆盖被引入布局根节点的对应属性值。注意重新定义android:id后，子布局的顶结点i就变化了。
 
(2) <viewstub>标签
viewstub标签同include标签一样可以用来引入一个外部布局，不同的是，viewstub引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析layout时节省cpu和内存。
viewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。
下面以在一个布局main.xml中加入网络错误时的提示页面network_error.xml为例。main.mxl代码如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
 
	……
    <ViewStub
        android:id="@+id/network_error_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout="@layout/network_error" />
 
</RelativeLayout>
其中network_error.xml为只有在网络错误时才需要显示的布局，默认不会被解析，示例代码如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
 
    <Button
        android:id="@+id/network_setting"
        android:layout_width="@dimen/dp_160"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:text="@string/network_setting" />
 
    <Button
        android:id="@+id/network_refresh"
        android:layout_width="@dimen/dp_160"
        android:layout_height="wrap_content"
        android:layout_below="@+id/network_setting"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="@dimen/dp_10"
        android:text="@string/network_refresh" />
 
</RelativeLayout>
在java中通过(ViewStub)findViewById(id)找到ViewStub，通过stub.inflate()展开ViewStub，然后得到子View，如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
private View networkErrorView;
 
private void showNetError() {
	// 如果已经存在了，就显示出来就可以了
	if (networkErrorView != null) {
		networkErrorView.setVisibility(View.VISIBLE);
		return;
	}
	//不存在，重新创建一个
	ViewStub stub = (ViewStub)findViewById(R.id.network_error_layout);
	networkErrorView = stub.inflate();
	Button networkSetting = (Button)networkErrorView.findViewById(R.id.network_setting);
	Button refresh = (Button)findViewById(R.id.network_refresh);
}
 
private void showNormal() {
	if (networkErrorView != null) {
		networkErrorView.setVisibility(View.GONE);
	}
}
在上面showNetError()中展开了ViewStub，同时我们对networkErrorView进行了保存，这样下次不用继续inflate。这就是后面第三部分提到的减少不必要的infalte。
viewstub标签大部分属性同include标签类似。
 
上面展开ViewStub部分代码
Java

1
2
ViewStub stub = (ViewStub)findViewById(R.id.network_error_layout);
networkErrorView = stub.inflate();
也可以写成下面的形式
Java

1
2
3
View viewStub = findViewById(R.id.network_error_layout);
viewStub.setVisibility(View.VISIBLE);   // ViewStub被展开后的布局所替换
networkErrorView =  findViewById(R.id.network_error_layout); // 获取展开后的布局
效果一致，只是不用显示的转换为ViewStub。通过viewstub的原理我们可以知道将一个view设置为GONE不会被解析，从而提高layout解析速度，而VISIBLE和INVISIBLE这两个可见性属性会被正常解析。
 
(3) <merge>标签
在使用了include后可能导致布局嵌套过多，多余不必要的layout节点，从而导致解析变慢，不必要的节点和嵌套可通过hierarchy viewer(下面布局调优工具中有具体介绍)或设置->开发者选项->显示布局边界查看。
 
merge标签可用于两种典型情况：
a.  布局顶结点是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity内容试图的parent view就是个FrameLayout，所以可以用merge消除只剩一个。
b.  某布局作为子布局被其他布局include时，使用merge当作该布局的顶节点，这样在被引入时顶结点会自动被忽略，而将其子节点全部合并到主布局中。
以(1) <include>标签的示例为例，用hierarchy viewer查看main.xml布局如下图：
android include
可以发现多了一层没必要的RelativeLayout，将foot.xml中RelativeLayout改为merge，如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
<?xml version="1.0" encoding="utf-8"?>
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
 
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="@dimen/dp_40"
        android:layout_above="@+id/text"/>
 
    <TextView
        android:id="@+id/text"
        android:layout_width="match_parent"
        android:layout_height="@dimen/dp_40"
        android:layout_alignParentBottom="true"
        android:text="@string/app_name" />
 
</merge>
运行后再次用hierarchy viewer查看main.xml布局如下图：
android include2
这样就不会有多余的RelativeLayout节点了。
 
2、去除不必要的嵌套和View节点
(1) 首次不需要使用的节点设置为GONE或使用viewstub
(2) 使用RelativeLayout代替LinearLayout
大约在Android4.0之前，新建工程的默认main.xml中顶节点是LinearLayout，而在之后已经改为RelativeLayout，因为RelativeLayout性能更优，且可以简单实现LinearLayout嵌套才能实现的布局。
4.0及以上Android版本可通过设置->开发者选项->显示布局边界打开页面布局显示，看看是否有不必要的节点和嵌套。4.0以下版本可通过hierarchy viewer查看。
 
3、减少不必要的infalte
(1) 对于inflate的布局可以直接缓存，用全部变量代替局部变量，避免下次需再次inflate
如上面ViewStub示例中的
Java

1
2
3
4
if (networkErrorView != null) {
	networkErrorView.setVisibility(View.VISIBLE);
	return;
}
 
(2) ListView提供了item缓存，adapter getView的标准写法，如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
@Override
public View getView(int position, View convertView, ViewGroup parent) {
	ViewHolder holder;
	if (convertView == null) {
		convertView = inflater.inflate(R.layout.list_item, null);
		holder = new ViewHolder();
		……
		convertView.setTag(holder);
	} else {
		holder = (ViewHolder)convertView.getTag();
	}
}
 
/**
 * ViewHolder
 * 
 * @author trinea@trinea.cn 2013-08-01
 */
private static class ViewHolder {
 
	ImageView appIcon;
	TextView  appName;
	TextView  appInfo;
}
关于ListView缓存原理可见Android ListView缓存机制。
 
4、其他点
(1) 用SurfaceView或TextureView代替普通View
SurfaceView或TextureView可以通过将绘图操作移动到另一个单独线程上提高性能。
普通View的绘制过程都是在主线程(UI线程)中完成，如果某些绘图操作影响性能就不好优化了，这时我们可以考虑使用SurfaceView和TextureView，他们的绘图操作发生在UI线程之外的另一个线程上。
因为SurfaceView在常规视图系统之外，所以无法像常规试图一样移动、缩放或旋转一个SurfaceView。TextureView是Android4.0引入的，除了与SurfaceView一样在单独线程绘制外，还可以像常规视图一样被改变。
 
(2) 使用RenderJavascript
RenderScript是Adnroid3.0引进的用来在Android上写高性能代码的一种语言，语法给予C语言的C99标准，他的结构是独立的，所以不需要为不同的CPU或者GPU定制代码代码。
 
(3) 使用OpenGL绘图
Android支持使用OpenGL API的高性能绘图，这是Android可用的最高级的绘图机制，在游戏类对性能要求较高的应用中得到广泛使用。
Android 4.3最大的改变，就是支持OpenGL ES 3.0。相比2.0，3.0有更多的缓冲区对象、增加了新的着色语言、增加多纹理支持等等，将为Android游戏带来更出色的视觉体验。
 
(4) 尽量为所有分辨率创建资源
减少不必要的硬件缩放，这会降低UI的绘制速度，可借助Android asset studio


3）
本文为性能优化的第一篇――数据库性能优化，原理适用于大部分数据库包括Sqlite、Mysql、Oracle、Sql server，详细介绍了索引(优缺点、分类、场景、规则)和事务，最后介绍了部分单独针对Sqlite的优化。
 
目前性能优化专题已完成以下部分：
性能优化总纲――性能问题及性能调优方式
性能优化第四篇――移动网络优化
性能优化第三篇――Java(Android)代码优化
性能优化第二篇――布局优化
性能优化第一篇――数据库性能优化
性能优化实例
 
1、索引
简单的说，索引就像书本的目录，目录可以快速找到所在页数，数据库中索引可以帮助快速找到数据，而不用全表扫描，合适的索引可以大大提高数据库查询的效率。
(1). 优点
大大加快了数据库检索的速度，包括对单表查询、连表查询、分组查询、排序查询。经常是一到两个数量级的性能提升，且随着数据数量级增长。
 
(2). 缺点
索引的创建和维护存在消耗，索引会占用物理空间，且随着数据量的增加而增加。
在对数据库进行增删改时需要维护索引，所以会对增删改的性能存在影响。
 
(3). 分类
a. 直接创建索引和间接创建索引
直接创建: 使用sql语句创建，Android中可以在SQLiteOpenHelper的onCreate或是onUpgrade中直接excuSql创建语句，语句如

1
CREATE INDEX mycolumn_index ON mytable (myclumn)
间接创建: 定义主键约束或者唯一性键约束，可以间接创建索引，主键默认为唯一索引。
 
b. 普通索引和唯一性索引
普通索引：

1
CREATE INDEX mycolumn_index ON mytable (myclumn)
唯一性索引：保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用，语句为

1
CREATE UNIQUE COUSTERED INDEX myclumn_cindex ON mytable(mycolumn)
 
c. 单个索引和复合索引
单个索引：索引建立语句中仅包含单个字段，如上面的普通索引和唯一性索引创建示例。
复合索引：又叫组合索引，在索引建立语句中同时包含多个字段，语句如：

1
CREATE INDEX name_index ON username(firstname, lastname)
其中firstname为前导列。
 
d. 聚簇索引和非聚簇索引(聚集索引，群集索引)
聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列，语句为：

1
CREATE CLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn) WITH ALLOW_DUP_ROW
其中WITH ALLOW_DUP_ROW表示允许有重复记录的聚簇索引
非聚簇索引：

1
CREATE UNCLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn)
索引默认为非聚簇索引
 
(4). 使用场景
在上面讲到了优缺点，那么肯定会对何时使用索引既有点明白又有点糊涂吧，那么下面总结下：
a.  当某字段数据更新频率较低，查询频率较高，经常有范围查询(>, <, =, >=, <=)或order by、group by发生时建议使用索引。并且选择度越大，建索引越有优势，这里选择度指一个字段中唯一值的数量/总的数量。
b.  经常同时存取多列，且每列都含有重复值可考虑建立复合索引
 
(5). 索引使用规则
a.  对于复合索引，把使用最频繁的列做为前导列(索引中第一个字段)。如果查询时前导列不在查询条件中则该复合索引不会被使用。
如create unique index PK_GRADE_CLASS on student (grade, class)
select * from student where class = 2未使用到索引
select * from dept where grade = 3使用到了索引
 
b.  避免对索引列进行计算，对where子句列的任何计算如果不能被编译优化，都会导致查询时索引失效
select * from student where tochar(grade)=’2′
c.  比较值避免使用NULL
d.  多表查询时要注意是选择合适的表做为内表。连接条件要充份考虑带有索引的表、行数多的表，内外表的选择可由公式：外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳方案。实际多表操作在被实际执行前，查询优化器会根据连接条件，列出几组可能的连接方案并从中找出系统开销最小的最佳方案。
 
e.  查询列与索引列次序一致
f.  用多表连接代替EXISTS子句
g.  把过滤记录数最多的条件放在最前面
h.  善于使用存储过程，它使sql变得更加灵活和高效(Sqlite不支持存储过程::>_<:: )
 
(6)索引检验
建立了索引，对于某条sql语句是否使用到了索引可以通过执行计划查看是否用到了索引。
 
2、使用事务
使用事务的两大好处是原子提交和更优性能。
(1) 原子提交
原则提交意味着同一事务内的所有修改要么都完成要么都不做，如果某个修改失败，会自动回滚使得所有修改不生效。
 
(2) 更优性能
Sqlite默认会为每个插入、更新操作创建一个事务，并且在每次插入、更新后立即提交。
这样如果连续插入100次数据实际是创建事务->执行语句->提交这个过程被重复执行了100次。如果我们显示的创建事务->执行100条语句->提交会使得这个创建事务和提交这个过程只做一次，通过这种一次性事务可以使得性能大幅提升。尤其当数据库位于sd卡时，时间上能节省两个数量级左右。
Sqlte显示使用事务，示例代码如下：
Java

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
public void insertWithOneTransaction() {
    SQLiteDatabase db = sqliteOpenHelper.getWritableDatabase();
    // Begins a transaction
    db.beginTransaction();
    try {
        // your sqls
        for (int i = 0; i < 100; i++) {
            db.insert(yourTableName, null, value);
        }
 
        // marks the current transaction as successful
        db.setTransactionSuccessful();
    } catch (Exception e) {
        // process it
        e.printStackTrace();
    } finally {
        // end a transaction
        db.endTransaction();
    }
}
其中sqliteOpenHelper.getWritableDatabase()表示得到写表权限。
 
3、其他针对Sqlite的优化
(1) 语句的拼接使用StringBuilder代替String
这个就不多说了，简单的string相加会导致创建多个临时对象消耗性能。StringBuilder的空间预分配性能好得多。如果你对字符串的长度有大致了解，如100字符左右，可以直接new StringBuilder(128)指定初始大小，减少空间不够时的再次分配。
 
(2) 查询时返回更少的结果集及更少的字段。
查询时只取需要的字段和结果集，更多的结果集会消耗更多的时间及内存，更多的字段会导致更多的内存消耗。
 
(3) 少用cursor.getColumnIndex
根据性能调优过程中的观察cursor.getColumnIndex的时间消耗跟cursor.getInt相差无几。可以在建表的时候用static变量记住某列的index，直接调用相应index而不是每次查询。
Java

1
2
3
4
5
6
7
public static final String       HTTP_RESPONSE_TABLE_ID                  = android.provider.BaseColumns._ID;
public static final String       HTTP_RESPONSE_TABLE_RESPONSE            = "response";
public List<Object> getData() {
	……
	cursor.getString(cursor.getColumnIndex(HTTP_RESPONSE_TABLE_RESPONSE));
	……
}
优化为
Java

1
2
3
4
5
6
7
8
9
public static final String       HTTP_RESPONSE_TABLE_ID                  = android.provider.BaseColumns._ID;
public static final String       HTTP_RESPONSE_TABLE_RESPONSE            = "response";
public static final int          HTTP_RESPONSE_TABLE_ID_INDEX            = 0;
public static final int          HTTP_RESPONSE_TABLE_URL_INDEX           = 1;
public List<Object> getData() {
	……
	cursor.getString(HTTP_RESPONSE_TABLE_RESPONSE_INDEX);
	……
}
 
4、异步线程
Sqlite是常用于嵌入式开发中的关系型数据库，完全开源。
与Web常用的数据库Mysql、Oracle db、sql server不同，Sqlite是一个内嵌式的数据库，数据库服务器就在你的程序中，无需网络配置和管理，数据库服务器端和客户端运行在同一进程内，减少了网络访问的消耗，简化了数据库管理。不过Sqlite在并发、数据库大小、网络方面存在局限性，并且为表级锁，所以也没必要多线程操作。
 
Android中数据不多时表查询可能耗时不多，不会导致anr，不过大于100ms时同样会让用户感觉到延时和卡顿，可以放在线程中运行，但sqlite在并发方面存在局限，多线程控制较麻烦，这时候可使用单线程池，在任务中执行db操作，通过handler返回结果和ui线程交互，既不会影响UI线程，同时也能防止并发带来的异常。
可使用Android提供的AsyncQueryHandler(感谢@内网无法登陆账号 反馈)或类似如下代码完成：
Java

1
2
3
4
5
6
7
8
9
10
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
singleThreadExecutor.execute(new Runnable() {
 
	@Override
	public void run() {
		// db operetions, u can use handler to send message after
		db.insert(yourTableName, null, value);
		handler.sendEmptyMessage(xx);
	}
});
,或者直接用AsyncTask，
例如查询记录：
//查询报表
private void loggrid()
{
	ToolClass.Log(ToolClass.INFO,"EV_JNI","APP<<start:"+ToolClass.getDayOfMonth(mYear, mMon, mDay)+"end:"+ToolClass.getDayOfMonth(eYear, eMon, eDay)+"时间大小="+ToolClass.dateCompare(ToolClass.getDayOfMonth(mYear, mMon, mDay),ToolClass.getDayOfMonth(eYear, eMon, eDay)),"log.txt");
	if(
			(!edtloggridstart.getText().toString().isEmpty())
		  &&(!edtloggridend.getText().toString().isEmpty())
		  &&(ToolClass.dateCompare(ToolClass.getDayOfMonth(mYear, mMon, mDay),ToolClass.getDayOfMonth(eYear, eMon, eDay))<0)
	  )
	{
		LoggridQueryThread logquery=new LoggridQueryThread();
		logquery.execute();
	}
	else
	{
		Toast.makeText(LogOpt.this, "请输入正确查询时间！", Toast.LENGTH_SHORT).show();
	}
}
//****************
//异步线程，用于查询记录
//****************
private class LoggridQueryThread extends AsyncTask<Void,Void,List<Tb_vmc_log>>
{

	@Override
	protected List<Tb_vmc_log> doInBackground(Void... params) {
		// TODO Auto-generated method stub
		String mYearStr=null,mMonthStr=null,mDayStr=null;
		String eYearStr=null,eMonthStr=null,eDayStr=null;
		
		mYearStr=((mYear<10)?("0"+String.valueOf(mYear)):String.valueOf(mYear));
		mMonthStr=((mMon<10)?("0"+String.valueOf(mMon)):String.valueOf(mMon));
		mDayStr=((mDay<10)?("0"+String.valueOf(mDay)):String.valueOf(mDay));
		eYearStr=((eYear<10)?("0"+String.valueOf(eYear)):String.valueOf(eYear));
		eMonthStr=((eMon<10)?("0"+String.valueOf(eMon)):String.valueOf(eMon));
		eDayStr=((eDay<10)?("0"+String.valueOf(eDay)):String.valueOf(eDay));
		// 创建InaccountDAO对象
		vmc_logDAO logDAO = new vmc_logDAO(LogOpt.this);
		String start=mYearStr+"-"+mMonthStr+"-"+mDayStr;
		String end=eYearStr+"-"+eMonthStr+"-"+eDayStr;
		List<Tb_vmc_log> listinfos=logDAO.getScrollPay(start,end);
		return listinfos;
	}

	@Override
	protected void onPostExecute(List<Tb_vmc_log> listinfos) {
		// TODO Auto-generated method stub
		String[] strInfos = new String[listinfos.size()];
		logID = new String[listinfos.size()];
		logType = new String[listinfos.size()];
		logDesc = new String[listinfos.size()];
		logTime = new String[listinfos.size()];
		int m=0;
		// 遍历List泛型集合
		for (Tb_vmc_log tb_inaccount : listinfos) 
		{
			//总支付订单
			logID[m]= tb_inaccount.getLogID();
			logType[m] = ToolClass.typestr(3,tb_inaccount.getLogType());
			logDesc[m] = tb_inaccount.getLogDesc();
			logTime[m] = tb_inaccount.getLogTime();			
			m++;// 标识加1
		}
		
		int x=0;
		LogOpt.this.listMap.clear();
		for(x=0;x<listinfos.size();x++)
		{
			Map<String,String> map = new HashMap<String,String>();//定义Map集合，保存每一行数据
			map.put("logID", logID[x]);
			map.put("logType", logType[x]);
			map.put("logDesc", logDesc[x]);
			map.put("logTime", logTime[x]);
			LogOpt.this.listMap.add(map);//保存数据行
		}
		//将这个构架加载到data_list中
		LogOpt.this.simpleada = new SimpleAdapter(LogOpt.this,LogOpt.this.listMap,R.layout.loglist,
					new String[]{"logID","logType","logDesc","logTime"},//Map中的key名称
					new int[]{R.id.txtlogID,R.id.txtlogType,R.id.txtlogDesc,R.id.txtlogTime});
		LogOpt.this.lvlog.setAdapter(LogOpt.this.simpleada);
	}
			
}


4）性能优化之Java(Android)代码优化
(2). 数据存储优化
包括数据类型、数据结构的选择。
a. 数据类型选择
字符串拼接用StringBuilder代替String，在非并发情况下用StringBuilder代替StringBuffer。如果你对字符串的长度有大致了解，如100字符左右，可以直接new StringBuilder(128)指定初始大小，减少空间不够时的再次分配。
对于三者使用的总结：
1.如果要操作少量的数据用 = String
2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer
 
64位类型如long double的处理比32位如int慢
使用SoftReference、WeakReference相对正常的强应用来说更有利于系统垃圾回收
final类型存储在常量区中读取效率更高
LocalBroadcastManager代替普通BroadcastReceiver，效率和安全性都更高
 
b. 数据结构选择
常见的数据结构选择如：
ArrayList和LinkedList的选择，ArrayList根据index取值更快，LinkedList更占内存、随机插入删除更快速、扩容效率更高。一般推荐ArrayList。
ArrayList、HashMap、LinkedHashMap、HashSet的选择，hash系列数据结构查询速度更优，ArrayList存储有序元素，HashMap为键值对数据结构，LinkedHashMap可以记住加入次序的hashMap，HashSet不允许重复元素。
HashMap、WeakHashMap选择，WeakHashMap中元素可在适当时候被系统垃圾回收器自动回收，所以适合在内存紧张型中使用。
Collections.synchronizedMap和ConcurrentHashMap的选择，ConcurrentHashMap为细分锁，锁粒度更小，并发性能更优。Collections.synchronizedMap为对象锁，自己添加函数进行锁控制更方便。
 
Android也提供了一些性能更优的数据类型，如SparseArray、SparseBooleanArray、SparseIntArray、Pair。
Sparse系列的数据结构是为key为int情况的特殊处理，采用二分查找及简单的数组存储，加上不需要泛型转换的开销，相对Map来说性能更优。不过我不太明白为啥默认的容量大小是10，是做过数据统计吗，还是说现在的内存优化不需要考虑这些东西，写16会死吗，还是建议大家根据自己可能的容量设置初始值。
 
(3). 算法优化
这个主题比较大，需要具体问题具体分析，尽量不用O(n*n)时间复杂度以上的算法，必要时候可用空间换时间。
查询考虑hash和二分，尽量不用递归。可以从结构之法 算法之道或微软、Google等面试题学习。
 
(4). JNI
Android应用程序大都通过Java开发，需要Dalvik的JIT编译器将Java字节码转换成本地代码运行，而本地代码可以直接由设备管理器直接执行，节省了中间步骤，所以执行速度更快。不过需要注意从Java空间切换到本地空间需要开销，同时JIT编译器也能生成优化的本地代码，所以糟糕的本地代码不一定性能更优。
这个优化点会在后面单独用一片博客介绍。
 
(5). 逻辑优化
这个不同于算法，主要是理清程序逻辑，减少不必要的操作。
 
(6). 需求优化
这个就不说了，对于sb的需求可能带来的性能问题，只能说做为一个合格的程序员不能只是执行者，要学会说NO。不过不能拿这种接口敷衍产品经理哦。
 
2、异步，利用多线程提高TPS
充分利用多核Cpu优势，利用线程解决密集型计算、IO、网络等操作。
关于多线程可参考：Java线程池
在Android应用程序中由于系统ANR的限制，将可能造成主线程超时操作放入另外的工作线程中。在工作线程中可以通过handler和主线程交互。
 
3、提前或延迟操作，错开时间段提高TPS
(1) 延迟操作
不在Activity、Service、BroadcastReceiver的生命周期等对响应时间敏感函数中执行耗时操作，可适当delay。
Java中延迟操作可使用ScheduledExecutorService，不推荐使用Timer.schedule;
Android中除了支持ScheduledExecutorService之外，还有一些delay操作，如
handler.postDelayed，handler.postAtTime，handler.sendMessageDelayed，View.postDelayed，AlarmManager定时等。
 
(2) 提前操作
对于第一次调用较耗时操作，可统一放到初始化中，将耗时提前。如得到壁纸wallpaperManager.getDrawable();


5）移动端网络优化
一个网络请求可以简单分为连接服务器 -> 获取数据两个部分。
其中连接服务器前还包括 DNS 解析的过程；获取数据后可能会对数据进行缓存。
 
一、连接服务器优化策略
1. 不用域名，用 IP 直连
省去 DNS 解析过程，DNS 全名 Domain Name System，解析意指根据域名得到其对应的 IP 地址。 如 http://www.codekk.com 的域名解析结果就是 104.236.147.76。
3. 减小请求数据大小
(1) 对于 POST 请求，Body 可以做 Gzip 压缩，如日志。
 (2) 精简数据格式
如 JSON 代替 XML，WebP 代替其他图片格式。关注公众号 codekk，回复 20 查看关于 WebP 的介绍。
 (5) 大文件下载
支持断点续传，并缓存 Http Resonse 的 ETag 标识，下次请求时带上，从而确定是否数据改变过，未改变则直接返回 304。




*自动升级和安装程序
Button btn=(Button)findViewById(R.id.btn);
        btn.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				final String SDCARD_DIR=File.separator+"sdcard"+File.separator+"ev";
		    	final String NOSDCARD_DIR=File.separator+"ev";
		    	File fileName=null;
		    	String  sDir =null,str=null;
		    	Map<String, String> list=null;
		    	    	
		        try {
		        	  //首先判断sdcard是否插入
		        	  String status = Environment.getExternalStorageState();
		        	  if (status.equals(Environment.MEDIA_MOUNTED)) 
		        	  {
		        		 sDir = SDCARD_DIR;;
		        	  } 
		        	  else
		        	  {
		        		  sDir = NOSDCARD_DIR;
		        	  }
		        	 
		        	  
		        	             
		        } catch (Exception e) {
		            e.printStackTrace();
		        }
		        fileName=new File(sDir+File.separator+"EVConsole0419.apk");  
		        //如果不存在，则创建文件
	        	if(!fileName.exists())
	        	{  
	        		Log.v("EV_JNI","file not exists");
	    	    } 
	        	else
	        	{
	        		Log.v("EV_JNI",fileName.toString());
	        	}
		        
	        	//1.有提示的安装
//		        Intent intent = new Intent();  
//		        //执行动作  
//		        intent.setAction(Intent.ACTION_VIEW); 
//		        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 
//		        //执行的数据类型  
//		        intent.setDataAndType(Uri.fromFile(fileName), "application/vnd.android.package-archive");  
//		        startActivity(intent); 
//		        
	        	//1.静默安装
	        	Process process = null;  
	            OutputStream out = null;
	            boolean result = false;  
	            try {  
	                process = Runtime.getRuntime().exec("su");  
	                out = process.getOutputStream();  
	                DataOutputStream dataOutputStream = new DataOutputStream(out);  
	                dataOutputStream.writeBytes("chmod 777 " + fileName.getPath() + "\n");  
	                dataOutputStream.writeBytes("LD_LIBRARY_PATH=/vendor/lib:/system/lib pm install -r " +  
	                		fileName.getPath());  
	                // 提交命令  
	                dataOutputStream.flush();  
	                // 关闭流操作  
	                dataOutputStream.close();  
	                out.close();  
	                int value = process.waitFor();  
	                  
	                // 代表成功  
	                if (value == 0) {  
	                    result = true;  
	                } else if (value == 1) { // 失败  
	                    result = false;  
	                } else { // 未知情况  
	                    result = false;  
	                }  
	            } catch (IOException e) {  
	                e.printStackTrace();  
	            } catch (InterruptedException e) {  
	                e.printStackTrace();  
	            }
	            
	            //2.杀死本进程
	            android.os.Process.killProcess(android.os.Process.myPid());
	            
	            //3.打开已安装的程序
	            
	            
			}
		});
		
		
*上传交易日志：
1.base64格式的转换
在项目中需要用到文件传输入，为了传输方便最好的办法是将文件转成base64字串，再将base64字串转成字节流保存在文件了。
不过这种做法的虽然简单，但还是要根据实际需要进行选择；弊端是不能转太大的文件，文件太大会造成效率上的问题。具体多大，笔者没有做深入研究和实际测试。如有兴趣，可以自己深入研究测试。

需要导入 import android.util.Base64;
/**
* encodeBase64File:(将文件转成base64 字符串). <br/>
* @author guhaizhou@126.com
* @param path 文件路径
* @return
* @throws Exception
* @since JDK 1.6
*/
public static String encodeBase64File(String path) throws Exception {
File  file = new File(path);
FileInputStream inputFile = new FileInputStream(file);
byte[] buffer = new byte[(int)file.length()];
inputFile.read(buffer);
        inputFile.close();
        return Base64.encodeToString(buffer,Base64.DEFAULT);
}
－－－－－－－－－－－－－－－－－－－－－－－－－－可以加我微信号：googlecao 进行交流－－－－－－－－－－－－－－－－－－－－－－－－
/**
* decoderBase64File:(将base64字符解码保存文件). <br/>
* @author guhaizhou@126.com
* @param base64Code 编码后的字串
* @param savePath  文件保存路径
* @throws Exception
* @since JDK 1.6
*/
public static void decoderBase64File(String base64Code,String savePath) throws Exception {
//byte[] buffer = new BASE64Decoder().decodeBuffer(base64Code);
byte[] buffer =Base64.decode(base64Code, Base64.DEFAULT);
FileOutputStream out = new FileOutputStream(savePath);
out.write(buffer);
out.close();
}


2.例子：		
/**
 * 上传文件线程
 * 
 * @author coolszy
 *@date 2012-4-26
 *@blog http://blog.92coding.com
 */
private class uploadLogThread extends Thread
{
	@Override
	public void run()
	{
		String target = httpStr+"/api/uploadClientLog";	//要提交的目标地址
		HttpClient httpclient = new DefaultHttpClient();	//创建HttpClient对象
		httpclient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 10000);//请求超时
		httpclient.getParams().setParameter(CoreConnectionPNames.SO_TIMEOUT, 10000);//读取超时
		HttpPost httppost = new HttpPost(target);	//创建HttpPost对象
		//1.添加params
		List<NameValuePair> params = new ArrayList<NameValuePair>();
		params.add(new BasicNameValuePair("LAST_EDIT_TIME", ToolClass.getLasttime()));
		params.add(new BasicNameValuePair("Token", Tok));			
		params.add(new BasicNameValuePair("CLIENT_LOG_ID", LOG_IDS));
		ByteArrayOutputStream output =null;
		String bal=null;
		try {
				//输入文件流
				FileInputStream inputFile = new FileInputStream(file);
				//抓为byte字节
				byte[] buffer = new byte[(int)file.length()];
				inputFile.read(buffer);
				inputFile.close();
				//压缩为Base64格式
				bal= Base64.encodeToString(buffer,Base64.DEFAULT);
			} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		params.add(new BasicNameValuePair("FILE_CONTENT", bal));
		//ToolClass.Log(ToolClass.INFO,"EV_SERVER","Send3="+params.toString(),"server.txt");
		try {
			httppost.setEntity(new UrlEncodedFormEntity(params, "utf-8")); //设置编码方式
			HttpResponse httpResponse = httpclient.execute(httppost);	//执行HttpClient请求
			//向主线程返回信息
			Message tomain=mainhand.obtainMessage();
			if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK){	//如果请求成功
				//如果请求成功
				result = EntityUtils.toString(httpResponse.getEntity());	//获取返回的字符串
				ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec1="+result,"server.txt");
//					JSONObject object=new JSONObject(result);
//					int errType =  object.getInt("Error");
//					//返回有故障
//					if(errType>0)
//					{
//						tomain.what=SETERRFAILMAIN;
//						tomain.obj=object.getString("Message");
//						ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec1=[fail1]SETERRFAILMAIN","server.txt");
//					}
//					else
//					{
//						tomain.what=SETMAIN;
//						Tok=object.getString("Token");
//						ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec1=[ok1]","server.txt");
//					}			    	    
//		    	    mainhand.sendMessage(tomain); // 发送消息
			}else{
				result = "请求失败！";
				tomain.what=SETFAILMAIN;
				mainhand.sendMessage(tomain); // 发送消息
				ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec1=[fail1]SETFAILMAIN"+result,"server.txt");
			}
			
			
		} 
	   catch (Exception e) 
	   {  
		   //e.printStackTrace();  
		   //向主线程返回网络失败信息
			Message tomain=mainhand.obtainMessage();
			tomain.what=SETFAILMAIN;
			mainhand.sendMessage(tomain); // 发送消息
			ToolClass.Log(ToolClass.INFO,"EV_SERVER","rec1=Net[fail1]SETFAILMAIN","server.txt");
	   }
	}
};


*图片的变换
1.在商品图片上面覆盖一个已售罄的图片
1)保存已售罄的图标
//加载售罄水印图片		
Bitmap mark = BitmapFactory.decodeResource(this.getResources(), R.drawable.ysq);  
ToolClass.setMark(mark);

2)导入已售罄的图标
Bitmap mark=ToolClass.getMark();
			            //ToolClass.Log(ToolClass.INFO,"EV_JNI","APP<<proID="+pictures.get(arg0).getProID()+"overproImage="+pictures.get(arg0).getProImage(),"log.txt");
			            Bitmap photoMark = Bitmap.createBitmap(photo.getWidth(), photo.getHeight(), Config.ARGB_8888);  
			            Canvas canvas = new Canvas(photoMark);  
			            canvas.drawBitmap(photo, 0, 0, null);  
			            canvas.drawBitmap(mark, 0, 0, null);  
			            canvas.save(Canvas.ALL_SAVE_FLAG);  
			            canvas.restore();
			            viewHolder.image.setImageBitmap(photoMark);// 设置图像的二进制值

2.设置滤镜，将商品图片变暗
//这三个负数的值越大，图片就会越暗
final float[] BT_SELECTED = new float[]{ 1, 0, 0, 0, -170, 0, 1,
		        				0, 0, -170, 0, 0, 1, 0, -170, 0, 0, 0, 1, 0 };
viewHolder.image.setDrawingCacheEnabled(true);
viewHolder.image.setColorFilter( new ColorMatrixColorFilter(BT_SELECTED) ) ; 
viewHolder.image.setImageBitmap(photo);// 设置图像的二进制值						


完整示例：
public class AnimationUtils {
	
	/**
	 * 给试图添加点击效果,让背景变暗
	 * */
	public static void addTouchDrak(View view , boolean isClick){
		view.setOnTouchListener( VIEW_TOUCH_DARK ) ; 
		
		if(!isClick){
			view.setOnClickListener(new View.OnClickListener() {
				
				@Override
				public void onClick(View v) {
				}
			});
		}
	}
	
	/**
	 * 给试图添加点击效果,让背景变浅
	 * */
	public static void addTouchLight(View view , boolean isClick){
		view.setOnTouchListener( VIEW_TOUCH_LIGHT ) ; 
		
		if(!isClick){
			view.setOnClickListener(new View.OnClickListener() {
				
				@Override
				public void onClick(View v) {
				}
			});
		}
	}
	
	
	/**
	 * 让控件点击时，颜色变暗
	 * */
	public static final OnTouchListener VIEW_TOUCH_DARK = new OnTouchListener() {

		public final float[] BT_SELECTED = new float[] { 1, 0, 0, 0, -50, 0, 1,
				0, 0, -50, 0, 0, 1, 0, -50, 0, 0, 0, 1, 0 };
		public final float[] BT_NOT_SELECTED = new float[] { 1, 0, 0, 0, 0, 0,
				1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0 };

		@Override
		public boolean onTouch(View v, MotionEvent event) {
			if (event.getAction() == MotionEvent.ACTION_DOWN) {
				if(v instanceof ImageView){
					ImageView iv = (ImageView) v;
					iv.setColorFilter( new ColorMatrixColorFilter(BT_SELECTED) ) ; 
				}else{
					v.getBackground().setColorFilter( new ColorMatrixColorFilter(BT_SELECTED) );
					v.setBackgroundDrawable(v.getBackground());
				}
			} else if (event.getAction() == MotionEvent.ACTION_UP) {
				if(v instanceof ImageView){
					ImageView iv = (ImageView) v;
					iv.setColorFilter( new ColorMatrixColorFilter(BT_NOT_SELECTED) ) ; 
				}else{
					v.getBackground().setColorFilter(
							new ColorMatrixColorFilter(BT_NOT_SELECTED));
					v.setBackgroundDrawable(v.getBackground());
				}
			}
			return false;
		}
	};
	
	/**
	 * 让控件点击时，颜色变浅
	 * */
	public static final OnTouchListener VIEW_TOUCH_LIGHT = new OnTouchListener(){

		public final float[] BT_SELECTED = new float[] { 1, 0, 0, 0, 50, 0, 1,
				0, 0, 50, 0, 0, 1, 0, 50, 0, 0, 0, 1, 0 };
		public final float[] BT_NOT_SELECTED = new float[] { 1, 0, 0, 0, 0, 0,
				1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0 };
		
		@Override
		public boolean onTouch(View v, MotionEvent event) {
			if (event.getAction() == MotionEvent.ACTION_DOWN) {
				if(v instanceof ImageView){
					ImageView iv = (ImageView) v;
					iv.setDrawingCacheEnabled(true); 
					
					iv.setColorFilter( new ColorMatrixColorFilter(BT_SELECTED) ) ; 
				}else{
					v.getBackground().setColorFilter( new ColorMatrixColorFilter(BT_SELECTED) );
					v.setBackgroundDrawable(v.getBackground());
				}
			} else if (event.getAction() == MotionEvent.ACTION_UP) {
				if(v instanceof ImageView){
					ImageView iv = (ImageView) v; 
					iv.setColorFilter( new ColorMatrixColorFilter(BT_NOT_SELECTED) ) ; 
					System.out.println( "变回来" ); 
				}else{
					v.getBackground().setColorFilter(
							new ColorMatrixColorFilter(BT_NOT_SELECTED));
					v.setBackgroundDrawable(v.getBackground());
				}
			}
			return false;
		}
	};
}